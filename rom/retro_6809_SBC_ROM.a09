
; SBC system hardware version 1.0, clock 8.0 MHz
; for AS09 Assembler for M6809 [1.42]

;{ --------------------------------------------------- CPU Memory Mapping -------------------------------------
;-----------------------CSRAM-------------------------------------------
RAM_ORG				equ		$0000
RAM_END				equ		$7FFF 	; max 32KB size

;-----------------------CS0_1-------------------------------------------
ROM1_ORG			equ		$8000 	; second SBC ROM, 16K section begin

;-----------------------CS2---------------------------------------------
USB_COM_RD			equ		$c000
USB_COM_WR			equ		$c800
UART				equ		$d000
PORTA				equ		$d800
CRA					equ		$d801
PORTB				equ		$d802
CRB					equ		$d803

;-----------------------CS3---------------------------------
ROM0_ORG  			equ		$e000  	; first SBC ROM, 8K section begin
ROM_Integrity		equ		$fff0 	; SBC ROM0 checksum data check (16-bit value)
INT_VECTOR			equ		$fff2
;}


************************************************************************
;
; Microsoft Color Computer Basic

		  direct 0			  ; assembler parameter for optimization (DP is considered as always 0)
		  
BS        equ  $8             ; BACKSPACE CODE
LF        equ  $A             ; LINE FEED CODE
CR        equ  $D             ; ENTER CODE
ESC       equ  $1B            ; ESCAPE CODE
SPACE     equ  $20            ; SPACE (BLANK) CODE
STKBUF    equ  58             ; STACK BUFFER ROOM
LBUFMX    equ  250            ; MAX NUMBER OF CHARS IN A BASIC LINE
MAXLIN    equ  $FA            ; MAXIMUM MS BYTE OF LINE NUMBER
* PSEUDO OPS
SKP1      equ  $21            ; OP CODE OF BRN - SKIP ONE BYTE
SKP2      equ  $8C            ; OP CODE OF CMPX # - SKIP TWO BYTES
SKP1LD    equ  $86            ; OP CODE OF LDA # - SKIP THE NEXT BYTE
*                             ; AND LOAD THE VALUE OF THAT BYTE INTO ACCA - THIS
*                             ; IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE
          org  0
ENDFLG    rmb  1              ; STOP/END FLAG: POSITIVE=STOP, NEG=END
CHARAC    rmb  1              ; TERMINATOR FLAG 1
ENDCHR    rmb  1              ; TERMINATOR FLAG 2
TMPLOC    rmb  1              ; SCRATCH VARIABLE
IFCTR     rmb  1              ; IF COUNTER - HOW MANY IF STATEMENTS IN A LINE
DIMFLG    rmb  1              ; *DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING
VALTYP    rmb  1              ; *DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING
GARBFL    rmb  1              ; *TV STRING SPACE HOUSEKEEPING FLAG
ARYDIS    rmb  1              ; DISABLE ARRAY SEARCH: 00=ALLOW SEARCH
INPFLG    rmb  1              ; *TV INPUT FLAG: READ=0, INPUT<>0
RELFLG    rmb  1              ; *TV RELATIONAL OPERATOR FLAG
TEMPPT    rmb  2              ; *PV TEMPORARY STRING STACK POINTER
LASTPT    rmb  2              ; *PV ADDR OF LAST USED STRING STACK ADDRESS
TEMPTR    rmb  2              ; TEMPORARY POINTER
TMPTR1    rmb  2              ; TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH)
FPA2      rmb  4              ; FLOATING POINT ACCUMULATOR #2 MANTISSA
BOTSTK    rmb  2              ; BOTTOM OF STACK AT LAST CHECK
TXTTAB    rmb  2              ; *PV BEGINNING OF BASIC PROGRAM
VARTAB    rmb  2              ; *PV START OF VARIABLES
ARYTAB    rmb  2              ; *PV START OF ARRAYS
ARYEND    rmb  2              ; *PV END OF ARRAYS (+1)
FRETOP    rmb  2              ; *PV START OF STRING STORAGE (TOP OF FREE RAM)
STRTAB    rmb  2              ; *PV START OF STRING VARIABLES
FRESPC    rmb  2              ; UTILITY STRING POINTER
MEMSIZ    rmb  2              ; *PV TOP OF STRING SPACE
OLDTXT    rmb  2              ; SAVED LINE NUMBER DURING A "STOP"
BINVAL    rmb  2              ; BINARY VALUE OF A CONVERTED LINE NUMBER
OLDPTR    rmb  2              ; SAVED INPUT PTR DURING A "STOP"
TINPTR    rmb  2              ; TEMPORARY INPUT POINTER STORAGE
DATTXT    rmb  2              ; *PV 'DATA' STATEMENT LINE NUMBER POINTER
DATPTR    rmb  2              ; *PV 'DATA' STATEMENT ADDRESS POINTER
DATTMP    rmb  2              ; DATA POINTER FOR 'INPUT' & 'READ'
VARNAM    rmb  2              ; *TV TEMP STORAGE FOR A VARIABLE NAME
VARPTR    rmb  2              ; *TV POINTER TO A VARIABLE DESCRIPTOR
VARDES    rmb  2              ; TEMP POINTER TO A VARIABLE DESCRIPTOR
RELPTR    rmb  2              ; POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE
TRELFL    rmb  1              ; TEMPORARY RELATIONAL OPERATOR FLAG BYTE
* FLOATING POINT ACCUMULATORS #3,4 & 5 ARE MOSTLY
* USED AS SCRATCH PAD VARIABLES.
** FLOATING POINT ACCUMULATOR #3 :PACKED: ($40-$44)
V40       rmb  1
V41       rmb  1
V42       rmb  1
V43       rmb  1
V44       rmb  1
** FLOATING POINT ACCUMULATOR #4 :PACKED: ($45-$49)
V45       rmb  1
V46       rmb  1
V47       rmb  1
V48       rmb  2
** FLOATING POINT ACCUMULATOR #5 :PACKED: ($4A-$4E)
V4A       rmb  1
V4B       rmb  2
V4D       rmb  2
** FLOATING POINT ACCUMULATOR #0
FP0EXP    rmb  1              ; *PV FLOATING POINT ACCUMULATOR #0 EXPONENT
FPA0      rmb  4              ; *PV FLOATING POINT ACCUMULATOR #0 MANTISSA
FP0SGN    rmb  1              ; *PV FLOATING POINT ACCUMULATOR #0 SIGN
COEFCT    rmb  1              ; POLYNOMIAL COEFFICIENT COUNTER
STRDES    rmb  5              ; TEMPORARY STRING DESCRIPTOR
FPCARY    rmb  1              ; FLOATING POINT CARRY BYTE
** FLOATING POINT ACCUMULATOR #1
FP1EXP    rmb  1              ; *PV FLOATING POINT ACCUMULATOR #1 EXPONENT
FPA1      rmb  4              ; *PV FLOATING POINT ACCUMULATOR #1 MANTISSA
FP1SGN    rmb  1              ; *PV FLOATING POINT ACCUMULATOR #1 SIGN
RESSGN    rmb  1              ; SIGN OF RESULT OF FLOATING POINT OPERATION
FPSBYT    rmb  1              ; FLOATING POINT SUB BYTE (FIFTH BYTE)
COEFPT    rmb  2              ; POLYNOMIAL COEFFICIENT POINTER
LSTTXT    rmb  2              ; CURRENT LINE POINTER DURING LIST
CURLIN    rmb  2              ; *PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT
DEVCFW    rmb  1              ; *TV TAB FIELD WIDTH
DEVLCF    rmb  1              ; *TV TAB ZONE
DEVPOS    rmb  1              ; *TV PRINT POSITION
DEVWID    rmb  1              ; *TV PRINT WIDTH
DEVNUM 	  rmb  1			  ; *PV DEVICE NUMBER: -3=DLOAD, -2=PRINTER, -1=CASSETTE, 0=SCREEN, 1-15=DISK
BasicSavReg_S rmb 2
TOPRAM    rmb  2              ; *PV TOP OF RAM
IKEYIM    rmb  1              ; *TV INKEY$ RAM IMAGE
ZERO      rmb  2              ; *PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO
* THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM
LPTCFW    rmb  1              ; 16
LPTLCF    rmb  1              ; 112
LPTWID    rmb  1              ; 132
LPTPOS    rmb  1              ; 0
EXECJP    rmb  2              ; LB4AA

* THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM
* BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE
* INTERPRETED IS STORED AT CHARAD.
GETNCH    inc  <CHARAD+1      ; *PV INCREMENT LS BYTE OF INPUT POINTER
          bne  GETCCH         ; *PV BRANCH IF NOT ZERO (NO CARRY)
          inc  <CHARAD        ; *PV INCREMENT MS BYTE OF INPUT POINTER
GETCCH    fcb  $B6            ; *PV OP CODE OF lda EXTENDED
CHARAD    rmb  2              ; *PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT
*         *    CHARACTER WHICH THE BASIC INTERPRETER IS
*         *    PROCESSING
          jmp  BROMHK         ; JUMP BACK INTO THE BASIC RUM

VAB       rmb  1              ; = LOW ORDER FOUR BYTES OF THE PRODUCT
VAC       rmb  1              ; = OF A FLOATING POINT MULTIPLICATION
VAD       rmb  1              ; = THESE BYTES ARE USE AS RANDOM DATA
VAE       rmb  1              ; = BY THE RND STATEMENT

* EXTENDED BASIC VARIABLES
TRCFLG    rmb  1              ; *PV TRACE FLAG 0=OFF ELSE=ON
USRADR    rmb  2              ; *PV ADDRESS OF THE START OF USR VECTORS

* EXTENDED BASIC SCRATCH PAD VARIABLES
VCF       rmb  2
VD1       rmb  2
VD3       rmb  2
VD5       rmb  2
VD7       rmb  1
VD8       rmb  1
VD9       rmb  1
VDA       rmb  1
USRJMP    rmb  3              ; JUMP ADDRESS FOR BASIC'S USR FUNCTION
RVSEED    rmb  1              ; * FLOATING POINT RANDOM NUMBER SEED EXPONENT
          rmb  4              ; * MANTISSA: INITIALLY SET TO $804FC75259

**** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)
USR0      rmb  2              ; USR 0 VECTOR
          rmb  2              ; USR 1
          rmb  2              ; USR 2
          rmb  2              ; USR 3
          rmb  2              ; USR 4
          rmb  2              ; USR 5
          rmb  2              ; USR 6
          rmb  2              ; USR 7
          rmb  2              ; USR 8
          rmb  2              ; USR 9

STRSTK    rmb  8*5            ; STRING DESCRIPTOR STACK
LINHDR    rmb  2              ; LINE INPUT BUFFER HEADER
LINBUF    rmb  LBUFMX+1       ; BASIC LINE INPUT BUFFER
STRBUF    rmb  41             ; STRING BUFFER
F_PTR     rmb  2              ; POINTER TO THE FILE STRUCTURE
PROGST    rmb  1              ; START OF PROGRAM SPACE

BasicRAMend			equ	$7cff ; RAM section reserved for BASIC 0-$7cff
CSum16_ROM1			equ $f1f5 ; BASIC ROM CheckSum16

          org  ROM1_ORG
		  dw	CSum16_ROM1

BASIC_ORG
* JUMP TO BASIC COLD START AT START OF ROM FOR CONVENIENCE          
		  orcc #%01010000	  ; ensure init in case of software reset (no interrupt)
		  clra
		  tfr  a,dp
		  lbra RESVEC

; context switching to let run BASIC in parallel
EXITBAS	  pshs d,x,y,u,cc,dp
		  sts  BasicSavReg_S
		  ldx  BasicCallBack
		  ldd  #ENTRYBAS
		  std  BasicCallBack
		  jmp  ,x			  ; EXIT BASIC
ENTRYBAS  lds  BasicSavReg_S  ; ENTRY BASIC
		  puls d,x,y,u,cc,dp,pc

* CONSOLE IN
LA171     ldd  F_PTR		  ; check if file reading open		  
		  beq  LA173
		  
  		  pshs x,y		  ; Note for generated asm from C: the D, X and Y registers need to be preserved. Set Y to GV stack.  		  
*		returnStatus = FILE_GetCh(srcFilePtr);
		  pshs	d
		  lbsr	FILE_Get
		  leas	2,s
		  
* 		if(returnStatus == EOF) {
		  cmpb	#$1a
		  bne	LA172  		  
* 			FILE_Close(srcFilePtr);
		  ldd	F_PTR
		  pshs	d
		  lbsr	FILE_Clo
		  leas	2,s
		  clr   F_PTR		
		  clr   F_PTR+2
		  clrb
*		}
LA172	  puls	x,y
		  tfr  b,a
		  anda #$7F
		  bne  LA174

LA173	  bsr  KEYIN          ; GET A CHARACTER FROM CONSOLE IN          
		  beq  LA173          ; LOOP IF NO KEY DOWN
LA174     rts

*
* THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY
* IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.
*
*
LA1C1
KEYIN     bsr  EXITBAS
		  pshs b
		  jsr  APLgetChar
		  tfr  b,a
		  anda #$7F
          puls b,pc
		  

* CONSOLE OUT
PUTCHR    pshs d              ; PRESERVE ACCD		
		  tst  DEVNUM		  ; CHECK DEVICE NUMBER		  
		  beq  TOSCRN		  ; BRANCH IF SCREEN				  
		  
		  pshs d,x,y		  
		  tfr  a,b	  		  ; char in ACCB
		  pshs d		
		  ldd  F_PTR
		  pshs d
		  lbsr FILE_Put	  	  ; Note for BASIC ASM -> C : the U, X and Y registers needs to be preserved. Set Y to GV stack.
		  leas 4,s
		  puls d,x,y
		  bra  PUTEXIT

TOSCRN	  jsr  APLsendChar          
PUTEXIT	  cmpa #CR            ; IS IT CARRIAGE RETURN?
          beq  NEWLINE        ; YES
          inc  LPTPOS         ; INCREMENT CHARACTER COUNTER
          lda  LPTPOS         ; CHECK FOR END OF LINE PRINTER LINE
          cmpa LPTWID         ; AT END OF LINE PRINTER LINE?
          blo  PUTEND         ; NO
NEWLINE   clr  LPTPOS         ; RESET CHARACTER COUNTER          
PUTEND    bsr  EXITBAS
		  puls d,pc           ; RESTORE ACCD
          

*
RESVEC

* COLD START ENTRY

		  ldu  BasicCallBack  ; preserve the BasicCallBack before earasing RAM
		  ldx  #PROGST+1      ; POINT X TO CLEAR 1ST 1K OF RAM
LA077     clr  ,--x           ; MOVE POINTER DOWN TWO-CLEAR BYTE
		  leax 1,x            ; ADVANCE POINTER ONE
          bne  LA077          ; KEEP GOING IF NOT AT BOTTOM OF PAGE 0
          ldx  #PROGST        ; SET TO START OF PROGRAM SPACE
          clr  ,x+            ; CLEAR 1ST BYTE OF BASIC PROGRAM
          stx  TXTTAB         ; BEGINNING OF BASIC PROGRAM
		  ldx  #BasicRAMend   ; end of BASIC allocated memory		
		  stu  BasicCallBack  ; restore the BasicCallBack
		  stx  TOPRAM         ; SAVE ABSOLUTE TOP OF RAM
          stx  MEMSIZ         ; SAVE TOP OF STRING SPACE
          stx  STRTAB         ; SAVE START OF STRING VARIABLES
          leax -200,x         ; CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES
          stx  FRETOP         ; SAVE START OF STRING SPACE
          tfr  x,s            ; PUT STACK THERE
          ldx  #LA10D         ; POINT X TO ROM SOURCE DATA
          ldu  #LPTCFW        ; POINT U TO RAM DESTINATION
          ldb  #18            ; MOVE 18 BYTES
          jsr  LA59A          ; MOVE 18 BYTES FROM ROM TO RAM
          lda  #$39
          sta  LINHDR-1       ; PUT rts IN LINHDR-1
          jsr  LAD19          ; G0 DO A 'NEW'
* EXTENDED BASIC INITIALISATION
          ldx  #USR0          ; INITIALIZE ADDRESS OF START OF
          stx  USRADR         ; USR JUMP TABLE
* DISK BASIC INITIALISATION
		  clr  DEVNUM		  ; DEFAULT SCREEN
		  clr  F_PTR
		  clr  F_PTR+2
* INITIALIZE THE USR CALLS TO 'FC ERROR'
          ldu  #LB44A         ; ADDRESS OF 'FC ERROR' ROUTINE
          ldb  #10            ; 10 USR CALLS IN EX BASIC
L8031     stu  ,x++           ; STORE 'FC' ERROR AT USR ADDRESSES
          decb                ; FINISHED ALL 10?
          bne  L8031          ; NO
		  		  
          ldx  #LA147-1       ; POINT X TO COLOR BASIC COPYRIGHT MESSAGE
          jsr  LB99C          ; PRINT 'COLOR BASIC'
LA0F3     jmp  LAC73          ; GO TO MAIN LOOP OF BASIC

*
* THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIRECT PAGE
LA10D     fcb  16             ; TAB FIELD WIDTH
          fcb  64             ; LAST TAB ZONE
          fcb  80             ; PRINTER WIDTH
          fcb  0              ; LINE PRINTER POSITION
          fdb  LB44A          ; ARGUMENT OF EXEC COMMAND - SET TO 'FC' ERROR
* LINE INPUT ROUTINE
          inc  CHARAD+1
          bne  LA123
          inc  CHARAD
LA123     lda  >0000
          jmp  BROMHK
*
* THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1
          jmp  LB44A          ; USR ADDRESS FOR 8K BASIC (INITIALIZED TO 'FC' ERROR)
          fcb  $80            ; *RANDOM SEED
          fdb  $4FC7          ; *RANDON SEED OF MANTISSA
          fdb  $5259          ; *.811635157
* BASIC COMMAND INTERPRETATION TABLE ROM IMAGE
COMVEC    fcb  59             ; 59 BASIC COMMANDS
          fdb  LAA66          ; POINTS TO RESERVED WORDS
          fdb  LAB67          ; POINTS TO JUMP TABLE FOR COMMANDS
          fcb  29             ; 29 BASIC SECONDARY COMMANDS
          fdb  LAB1A          ; POINTS TO SECONDARY FUNCTION RESERVED WORDS
          fdb  LAA29          ; POINTS TO SECONDARY FUNCTION JUMP TABLE
          fdb  0              ; NO MORE TABLES (RES WORDS=0)
          fdb  0              ; NO MORE TABLES
          fdb  0              ; NO MORE TABLES
          fdb  0              ; NO MORE TABLES
          fdb  0              ; NO MORE TABLES
          fdb  0              ; NO MORE TABLES (SECONDARY FNS =0)

* COPYRIGHT MESSAGES
LA147     fcc  "6809 DISK EXT COLOR BASIC"
          fcb  CR
          fcc  "(C) 1982 BY MICROSOFT"
LA156     fcb  CR,CR
LA165     fcb  $00


LA35F     pshs x,b,a          ; SAVE REGISTERS
          ldx  LPTCFW         ; TAB FIELD WIDTH AND TAB ZONE
          ldd  LPTWID         ; PRINTER WIDTH AND POSITION
LA37C     stx  DEVCFW         ; SAVE TAB FIELD WIDTH AND ZONE
          stb  DEVPOS         ; SAVE PRINT POSITION
          sta  DEVWID         ; SAVE PRINT WIDTH
          puls a,b,x,pc       ; RESTORE REGISTERS

* THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC
* EXIT WITH BREAK KEY: CARRY = 1
* EXIT WITH ENTER KEY: CARRY = 0
LA38D
LA390     clr  IKEYIM         ; RESET BREAK CHECK KEY TEMP KEY STORAGE
          ldx  #LINBUF+1      ; INPUT LINE BUFFER
          ldb  #1             ; ACCB CHAR COUNTER: SET TO 1 TO ALLOW A BACKSPACE AS FIRST CHARACTER
LA39A     jsr  LA171          ; GO GET A CHARACTER FROM CONSOLE IN
          cmpa #BS            ; BACKSPACE
          bne  LA3B4          ; NO
          decb                ; YES - DECREMENT CHAR COUNTER
          beq  LA390          ; BRANCH IF BACK AT START OF LINE AGAIN
          leax -1,x           ; DECREMENT BUFFER POINTER
          bra  LA3E8          ; ECHO CHAR TO SCREEN
LA3B4     cmpa #$15           ; SHIFT RIGHT ARROW?
          bne  LA3C2          ; NO
* YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE
LA3B8     decb                ; DEC CHAR CTR
          beq  LA390          ; GO BACK TO START IF CHAR CTR = 0
          lda  #BS            ; BACKSPACE?
          jsr  PUTCHR         ; SEND TO CONSOLE OUT (SCREEN)
          bra  LA3B8          ; KEEP GOING
LA3C2     cmpa #3             ; BREAK KEY?
          orcc #1             ; SET CARRY FLAG
          beq  LA3CD          ; BRANCH IF BREAK KEY DOWN
LA3C8     cmpa #CR            ; ENTER KEY?
          bne  LA3D9          ; NO
LA3CC     clra                ; CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY
LA3CD     pshs cc             ; SAVE CARRY FLAG
          jsr  LB958          ; SEND CR TO SCREEN
          clr  ,x             ; MAKE LAST BYTE IN INPUT BUFFER = 0
          ldx  #LINBUF        ; RESET INPUT BUFFER POINTER
		  puls cc,pc          ; RESTORE CARRY FLAG

* INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER
LA3D9     cmpa #$20           ; IS IT CONTROL CHAR?
          blo  LA39A          ; BRANCH IF CONTROL CHARACTER
          cmpa #'z'+1         ; *
          bcc  LA39A          ; * IGNORE IF > LOWER CASE Z
          cmpb #LBUFMX        ; HAVE 250 OR MORE CHARACTERS BEEN ENTERED?
          bcc  LA39A          ; YES, IGNORE ANY MORE
          sta  ,x+            ; PUT IT IN INPUT BUFFER
          incb                ; INCREMENT CHARACTER COUNTER
LA3E8     jsr  PUTCHR         ; ECHO IT TO SCREEN
          bra  LA39A          ; GO SET SOME MORE


* EXEC
EXEC      beq  LA545          ; BRANCH IF NO ARGUMENT
          jsr  LB73D          ; EVALUATE ARGUMENT - ARGUMENT RETURNED IN X
          stx  EXECJP         ; STORE X TO EXEC JUMP ADDRESS
LA545     jmp  [EXECJP]       ; GO DO IT

* BREAK CHECK
LA549     jmp  LADEB          ; GO DO BREAK KEY CHECK

* THIS ROUTINE EVALUATES AN ARGUMENT
* AND MAKES SURE IT IS WITHIN LIMITS OF VIDEO DISPLAY RAM
LA554	  jsr  LB3E4		  ; EVALUATE EXPRESSION AND RETURN VALUE IN ACCD
		  cmpd #639			  ; ONLY 512 VIDEO DISPLAY LOCATIONS (32 COL BY 20 LINES)
		  lbhi LB44A		  ; BRANCH IF > 511 TO ‘ILLEGAL FUNCTION CALL’
		  pshs b  			  ; SAVE LOWER PART 0-31 (5-BIT)
		  lslb				  ; SHIFT 3-BIT VER VALUE TO ACCA
		  rola
		  lslb
		  rola
		  lslb
		  rola				  ; VER VALUE IN ACCA
		  puls b
		  andb #$1F			  ; KEEP HOR VALUE
		  jsr APLsetXY 		  ; GET CHARACTER LOCATION (VER IN ACCA, HOR IN ACCB)
		  rts
		
* INKEY$
INKEY     lda  IKEYIM         ; WAS A KEY DOWN IN THE BREAK CHECK?
          bne  LA56B          ; YES
          jsr  KEYIN          ; GO GET A KEY
LA56B     clr  IKEYIM         ; CLEAR INKEY RAM IMAGE
          sta  FPA0+3         ; STORE THE KEY IN FPA0
          lbne LB68F          ; CONVERT FPA0+3 TO A STRING
          sta  STRDES         ; SET LENGTH OF STRING = 0 IF NO KEY DOWN
          jmp  LB69B          ; PUT A NULL STRING ONTO THE STRING STACK

* MOVE ACCB BYTES FROM (X) TO (U)
LA59A     lda  ,x+            ; GET BYTE FROM X
          sta  ,u+            ; STORE IT AT U
          decb                ; MOVED ALL BYTES?
          bne  LA59A          ; NO
LA5A1     rts

** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BASIC LINE
** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS
** FOLLOWING THE END OF THE NAME
LA5C7     jsr  GETCCH         ; GET CURRENT INPUT CHAR FROM BASIC LINE
LA5C9     beq  LA5A1          ; RETURN IF END OF LINE
          jmp  LB277          ; SYNTAX ERROR IF ANY MORE CHARACTERS

* SET  ; SET(x,y,col)
SET       bsr LA8C1			; GET ABSOLUTE SCREEN POSITION OF GRAPHICS BLOCK
		  pshs d 			; SAVE CHARACTER LOCATION
		  jsr LB738			; SYNTAX CHECK FOR COMMA - RETURN EXPR VALUE IN ACCB		  
		  tstb				; VALID ARGUMENT?
		  beq LA6C6			; IF ARGUMENT <1, USE DEFAULT
		  cmpb #7			; VALID ARGUMENT?
		  bls LA6C7			; ILLEGAL COLOR - ‘ILLEGAL FUNCTION CALL’
LA6C6	  ldb #2			; GREEN DEFAULT VALUE
LA6C7	  					; THE COLOR IN ACCB IS IGNORED
		  jsr LB267		    ; SYNTAX CHECK FOR ‘)‘
		  puls b			; REGET CHARACTER LOCATION (HOR IN ACCB)
		  puls a			; REGET CHARACTER LOCATION (VER IN ACCA)
		  jsr APLsetXY
		  rts

*** THIS ROUTINE WILL CHECK SYNTAX AND CHECK FOR LEGAL VALUES
*** OF SET,RESET & POINT HORIZONTAL AND VERTICAL PARAMETERS
*** AND RETURN THEIR ABSOLUTE SCREEN ADDRESS IN THE X REGISTER
*** WHICH OF THE FOUR PIXELS OF THE GRAPHIC BLOCK SELECTED
*** IS RETURNED IN GRBLOK.
LA8C1 	  jsr LB26A			; SYNTAX CHECK FOR "("
		  jsr LB70B			; EVALUATE EXPRESSION - RETURN VALUE IN ACCB
		  ;cmpb #63			; ONLY 64 HORIZONTAL GRAPHIC BLOCKS
		  ;bhi LA948		; ‘ILLEGAL FUNCTION CALL’
		  pshs b			; SAVE HOR COORD
		  jsr LB738			; SYNTAX CHECK FOR COMMA AND EVALUATE EXPR
		  puls a			; KEEP VERT COORD IN ACCB, GET HOR COORD IN ACCA
		  ;cmpb #31
LA8D5 	  ;bhi LA948		; ‘ILLEGAL FUNCTION CALL’		  
		  rts
		  
* CLS  ; CLS "color" [the color values are: 1 red, 2 green, 3 yellow, 4 blue, 5 magenta, 6 cyan, 7 white]
CLS		  beq LA928			; BRANCH IF NO ARGUMENT
		  jsr LB70B			; CALCULATE ARGUMENT, RETURN VALUE IN ACCB
		  tstb				; VALID ARGUMENT?
		  beq LA928			; IF ARGUMENT <1, USE DEFAULT
		  cmpb #7			; VALID ARGUMENT?
		  bls LA937			; IF ARGUMENT >7, USE DEFAULT
LA928	  ldb #2			; GREEN DEFAULT VALUE
LA937	  jsr APLclearscreen
          rts

LA93F 	  jsr LB26D			; SYNTAX CHECK FOR A COMMA
LA942 	  jsr LB70B			; EVALUATE EXPRESSION, RETURN VALUE IN ACCB
		  tstb				; SET FLAGS
		  bne LA950			; RETURN IF NON ZERO
		  leas 1,s			; CLEAR PUSHED VALUE
LA948	  jmp LB44A			; ‘ILLEGAL FUNCTION CALL’ IF ZERO

* SOUND  ; SOUND tone,duration [tone and duration are each between 0-255]
SOUND     bsr LA942			; EVALUATE EXPRESSION (FREQUENCY), RETURN VALUE IN ACCB
		  pshs b			; SAVE IT
		  lbsr LA93F		; EVALUATE EXPRESSION (SOUND LENGTH), RETURN VALUE IN ACCB
		  puls a			; SAVE FREQuENCY IN ACCA, LENGTH OF SOUND IN ACCB
		  jsr  APLsound
LA950	  rts  

* DATE  ; DATE YY,MM,DD [each between 0-255]
DATE      tfr  ccr,a		; preserve Z flag
		  ldb  #'d'			; date command
		  bra  TIME_01
		  
* TIME  ; TIME HH,MM,SS [each between 0-255]
TIME      tfr  ccr,a		; preserve Z flag
		  ldb  #'t'		  		  
TIME_01	  pshs b			; memorize the intial cmd (t or d)
		  bsr  TIME_02		; 
		  puls a			; memorized the intial cmd (i or d)
		  cmpx #0
		  lbeq LA970		  
		  bra  LA964		  

TIME_02	  tfr  a,ccr		; restore Z flag
		  beq  LA960		; BRANCH IF NO ARGUMENT		  
		  pshs b			; cmd param 1
		  cmpb #'d'
		  beq  TIME_03  
		  lbsr LB70B		; EVALUATE EXPRESSION (HH), RETURN VALUE IN ACCB
		  bra  TIME_04
TIME_03	  lbsr LB73D		; EVALUATE EXPRESSION (YYYY), RETURN VALUE IN ACCB
		  tfr x,d		  
		  subd #1980		; validate
		  bpl TIME_04
		  clrb	  
TIME_04	  pshs b			; param 2
		  lbsr LB26D		; SYNTAX CHECK FOR A COMMA
		  lbsr LB70B		; EVALUATE EXPRESSION (MM or MM), RETURN VALUE IN ACCB
		  pshs b			; param 3
		  lbsr LB26D		; SYNTAX CHECK FOR A COMMA
		  lbsr LB70B		; EVALUATE EXPRESSION (DD or SS), RETURN VALUE IN ACCB
		  pshs b			; param 4		  
		  bra  LA961	  
LA960	  ldb  #'d'			; override with d when no params
		  clra
		  pshs d			; date command with 0 0 0 to trigger the timestamp
		  clrb		  
		  pshs d
LA961	  jsr  setDateTime	; launch the date command
		  leas 4,s			; clear pushed params
		  clr  APLdate+1	; reset last timestamp lower byte
		  ldx  #500			; repeat until max 500 reception tentatives
LA962	  lbsr EXITBAS		; process the income string (timestamp msg)
		  leax -1,x
		  beq  LA963		; abort
		  tst  APLdate+1
		  beq  LA962		; wait until timestamp received		  
LA963	  rts
		  
LA964	  cmpa #'t'
		  beq  LA966		; extract the time instead
		  clra
		  ldb  APLdate		; year is bit 15-9
		  lsrb		  
		  addd #1980
		  pshs u
		  lbsr LBDCC		; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN	
		  puls u
		  lda  #'/'
		  lbsr PUTCHR       ; SEND TO CONSOLE OUT (SCREEN)
		  ldd  APLdate		; month is bit 8-5
		  anda #$1
		  ldx  #5
LA965	  lsra
		  rorb
		  leax -1,x
		  bne  LA965
		  pshs u
		  lbsr LBDCC		; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN	
		  puls u
		  lda  #'/'
		  lbsr PUTCHR       ; SEND TO CONSOLE OUT (SCREEN)
		  clra
		  ldb  APLdate+1	; day is bit 4-0
		  andb #$1f
		  bra  LA968
LA966	  clra
		  ldb  APLtime		; hour is bit 15-11
		  lsrb
		  lsrb
		  lsrb
		  pshs u
		  lbsr LBDCC		; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN	
		  puls u
		  lda  #':'
		  lbsr PUTCHR       ; SEND TO CONSOLE OUT (SCREEN)
		  ldd  APLtime		; minute is bit 10-5
		  anda #$7
		  ldx  #5
LA967	  lsra
		  rorb
		  leax -1,x
		  bne  LA967		  		  
		  pshs u
		  lbsr LBDCC		; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN	
		  puls u
		  lda  #':'
		  lbsr PUTCHR       ; SEND TO CONSOLE OUT (SCREEN)
		  ldb  APLtime+1	; seconde is bit 4-0
		  andb #$1f
		  lslb
LA968	  clra
		  pshs u
		  lbsr LBDCC		; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN	
		  puls u
LA970	  rts

* SET CARRY IF NUMERIC - RETURN WITH
* ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END
* OF BASIC LINE OR SUB LINE
BROMHK    cmpa #'9'+1         ; IS THIS CHARACTER >=(ASCII 9)+1?
          bhs  LAA28          ; BRANCH IF > 9; Z SET IF = COLON
          cmpa #SPACE         ; SPACE?
          bne  LAA24          ; NO - SET CARRY IF NUMERIC
          jmp  GETNCH         ; IF SPACE, GET NECT CHAR (IGNORE SPACES)
LAA24     suba #'0'           ; * SET CARRY IF
          suba #-'0'          ; * CHARACTER > ASCII 0
LAA28     rts

* DISPATCH TABLE FOR SECONDARY FUNCTIONS
* TOKENS ARE PRECEEDED BY $FF
* FIRST SET ALWAYS HAS ONE PARAMETER
FUNC_TAB
LAA29     fdb  SGN            ; SGN
          fdb  INT            ; INT
          fdb  ABS            ; ABS
          fdb  USRJMP         ; USR
TOK_USR   equ  $83			  ; (LL01-FUNC_TAB)/2+$7F
TOK_FF_USR equ  $ff83		  ; (LL01-FUNC_TAB)/2+$FF7F
LL01      fdb  RND            ; RND
          fdb  SIN            ; SIN
          fdb  PEEK           ; PEEK
          fdb  LEN            ; LEN
          fdb  STR            ; STR$
          fdb  VAL            ; VAL
          fdb  ASC            ; ASC
          fdb  CHR            ; CHR$
          fdb  ATN            ; ATN
          fdb  COS            ; COS
          fdb  TAN            ; TAN
          fdb  EXP            ; EXP
          fdb  FIX            ; FIX
          fdb  LOG            ; LOG
          fdb  POS            ; POS
          fdb  SQR            ; SQR
          fdb  HEXDOL         ; HEX$
* LEFT, RIGHT AND MID ARE TREATED SEPARATELY
          fdb  LEFT           ; LEFT$
TOK_LEFT  equ  $95 			  ; ((LL02-FUNC_TAB)/2)+$7F
LL02      fdb  RIGHT          ; RIGHT$
          fdb  MID            ; MID$
TOK_MID   equ  $97			  ; (LL03-FUNC_TAB)/2+$7F
* REMAINING FUNCTIONS
LL03      fdb  INKEY          ; INKEY$
TOK_INKEY equ  $98			  ;(LL04-FUNC_TAB)/2+$7F
LL04      fdb  MEM            ; MEM
          fdb  VARPT          ; VARPTR
          fdb  INSTR          ; INSTR
          fdb  STRING         ; STRING$
NUM_SEC_FNS equ  $1d	      ; (LL05-FUNC_TAB)/2
LL05

* THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESSES FOR ARITHMETIC
* AND LOGICAL OPERATORS - THE NEGATION OPERATORS DO NOT ACT ON TWO OPERANDS
* S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREATED SEPARATELY IN THE
* EXPRESSION EVALUATION ROUTINE. THEY ARE:
* UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGATION (NOT), PRECEDENCE $5A
* THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, PRECEDENCE $64.
* A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSION OR PARENTHESES
*
LAA51     fcb  $79
          fdb  LB9C5          ; +
          fcb  $79
          fdb  LB9BC          ; -
          fcb  $7B
          fdb  LBACC          ; *
          fcb  $7B
          fdb  LBB91          ; /
          fcb  $7F
          fdb  L8489          ; EXPONENTIATION
          fcb  $50
          fdb  LB2D5          ; AND
          fcb  $46
          fdb  LB2D4          ; OR

* THIS IS THE RESERVED WORD TABLE
* FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS
LAA66     fcc  "FO"           ; 80
          fcb  $80+'R'
          fcc  "G"            ; 81
          fcb  $80+'O'
TOK_GO    equ  $81
          fcc  "RE"           ; 82
          fcb  $80+'M'
          fcb  $80+$27        ; 83 + '''
          fcc  "ELS"          ; 84
          fcb  $80+'E'
          fcc  "I"            ; 85
          fcb  $80+'F'
          fcc  "DAT"          ; 86
          fcb  $80+'A'
          fcc  "PRIN"         ; 87
          fcb  $80+'T'
          fcc  "O"            ; 88
          fcb  $80+'N'
          fcc  "INPU"         ; 89
          fcb  $80+'T'
          fcc  "EN"           ; 8A
          fcb  $80+'D'
          fcc  "NEX"          ; 8B
          fcb  $80+'T'
          fcc  "DI"           ; 8C
          fcb  $80+'M'
          fcc  "REA"          ; 8D
          fcb  $80+'D'
          fcc  "RU"           ; 8E
          fcb  $80+'N'
          fcc  "RESTOR"       ; 8F
          fcb  $80+'E'
          fcc  "RETUR"        ; 90
          fcb  $80+'N'
          fcc  "STO"          ; 91
          fcb  $80+'P'
          fcc  "POK"          ; 92
          fcb  $80+'E'
          fcc  "CON"          ; 93
          fcb  $80+'T'
          fcc  "LIS"          ; 94
          fcb  $80+'T'
          fcc  "CLEA"         ; 95
          fcb  $80+'R'
          fcc  "NE"           ; 96
          fcb  $80+'W'
          fcc  "SE"           ; 97
          fcb  $80+'T'
		  fcc  "CL"           ; 98
          fcb  $80+'S'
		  fcc  "SOUN"         ; 99
          fcb  $80+'D'
		  fcc  "EXE"          ; 9A
          fcb  $80+'C'
          fcc  "DE"           ; 9B
          fcb  $80+'L'
          fcc  "EDI"          ; 9C
          fcb  $80+'T'
          fcc  "TRO"          ; 9D
          fcb  $80+'N'
          fcc  "TROF"         ; 9E
          fcb  $80+'F'
          fcc  "DE"           ; 9F
          fcb  $80+'F'
          fcc  "LIN"          ; A0
          fcb  $80+'E'
          fcc  "RENU"         ; A1
          fcb  $80+'M'          
          fcc  "DI"           ; A2
          fcb  $80+'R'
          fcc  "KIL"          ; A3
          fcb  $80+'L'
          fcc  "LOA"          ; A4
          fcb  $80+'D'
          fcc  "SAV"          ; A5
          fcb  $80+'E'          
          fcc  "DAT"          ; A6
          fcb  $80+'E'
          fcc  "TIM"          ; A7
          fcb  $80+'E'          
* END OF EXECUTABLE COMMANDS. THE REMAINDER OF THE TABLE ARE NON-EXECUTABLE TOKENS
          fcc  "TAB"          ; A8
          fcb  $80+'('
TOK_TAB   equ  $A8
          fcc  "T"            ; A9
          fcb  $80+'O'
TOK_TO    equ  $A9
          fcc  "SU"           ; AA
          fcb  $80+'B'
TOK_SUB   equ  $AA
          fcc  "THE"          ; AB
          fcb  $80+'N'
TOK_THEN  equ  $AB
          fcc  "NO"           ; AC
          fcb  $80+'T'
TOK_NOT   equ  $AC
          fcc  "STE"          ; AD
          fcb  $80+'P'
TOK_STEP  equ  $AD
          fcc  "OF"           ; AE
          fcb  $80+'F'
          fcb  '+'+$80        ; AF
TOK_PLUS  equ  $AF
          fcb  $80+'-'        ; B0
TOK_MINUS equ  $B0
          fcb  $80+'*'        ; B1
          fcb  $80+'/'        ; B2
          fcb  $80+'^'        ; B3
          fcc  "AN"           ; B4
          fcb  $80+'D'
          fcc  "O"            ; B5
          fcb  $80+'R'
          fcb  $80+'>'        ; B6
TOK_GREATER equ  $B6
          fcb  $80+'='        ; B7
TOK_EQUALS equ  $B7
          fcb  $80+'<'        ; B8
          fcc  "F"            ; B9
          fcb  $80+'N'
TOK_FN    equ  $B9
          fcc  "USIN"         ; BA
          fcb  $80+'G'
TOK_USING equ  $BA
*

* FIRST SET ALWAYS HAS ONE PARAMETER
LAB1A     fcc  "SG"           ; 80
          fcb  $80+'N'
          fcc  "IN"           ; 81
          fcb  $80+'T'
          fcc  "AB"           ; 82
          fcb  $80+'S'
          fcc  "US"           ; 83
          fcb  $80+'R'
          fcc  "RN"           ; 84
          fcb  $80+'D'
          fcc  "SI"           ; 85
          fcb  $80+'N'
          fcc  "PEE"          ; 86
          fcb  $80+'K'
          fcc  "LE"           ; 87
          fcb  $80+'N'
          fcc  "STR"          ; 88
          fcb  $80+'$'
          fcc  "VA"           ; 89
          fcb  $80+'L'
          fcc  "AS"           ; 8A
          fcb  $80+'C'
          fcc  "CHR"          ; 8B
          fcb  $80+'$'
          fcc  "AT"           ; 8C
          fcb  $80+'N'
          fcc  "CO"           ; 8D
          fcb  $80+'S'
          fcc  "TA"           ; 8E
          fcb  $80+'N'
          fcc  "EX"           ; 8F
          fcb  $80+'P'
          fcc  "FI"           ; 90
          fcb  $80+'X'
          fcc  "LO"           ; 91
          fcb  $80+'G'
          fcc  "PO"           ; 92
          fcb  $80+'S'
          fcc  "SQ"           ; 93
          fcb  $80+'R'
          fcc  "HEX"          ; 94
          fcb  $80+'$'
* LEFT, RIGHT AND MID ARE TREATED SEPARATELY
          fcc  "LEFT"         ; 95
          fcb  $80+'$'
          fcc  "RIGHT"        ; 96
          fcb  $80+'$'
          fcc  "MID"          ; 97
          fcb  $80+'$'
* REMAINING FUNCTIONS
          fcc  "INKEY"        ; 98
          fcb  $80+'$'
          fcc  "ME"           ; 99
          fcb  $80+'M'
          fcc  "VARPT"        ; 9A
          fcb  $80+'R'
          fcc  "INST"         ; 9B
          fcb  $80+'R'
          fcc  "STRING"       ; 9C
          fcb  $80+'$'

*
* DISPATCH TABLE FOR COMMANDS TOKEN #
CMD_TAB
LAB67     fdb  FOR            ; 80
          fdb  GO             ; 81
          fdb  REM            ; 82
TOK_REM   equ  $82			  ; (LL06-CMD_TAB)/2+$7F
LL06      fdb  REM            ; 83 (')
TOK_SNGL_Q equ $83			  ; (LL07-CMD_TAB)/2+$7F
LL07      fdb  REM            ; 84 (ELSE)
TOK_ELSE  equ  $84			  ; (LL08-CMD_TAB)/2+$7F
LL08	  fdb  IF             ; 85
TOK_IF    equ  $85			  ; (LL09-CMD_TAB)/2+$7F
LL09      fdb  DATA           ; 86
TOK_DATA  equ  $86			  ; (LL10-CMD_TAB)/2+$7F
LL10      fdb  PRINT          ; 87
TOK_PRINT equ  $87			  ; (LL11-CMD_TAB)/2+$7F
LL11      fdb  ON             ; 88
          fdb  INPUT          ; 89
TOK_INPUT equ  $89			  ; (LL12-CMD_TAB)/2+$7F
LL12      fdb  END            ; 8A
          fdb  NEXT           ; 8B
          fdb  DIM            ; 8C
          fdb  READ           ; 8D
          fdb  RUN            ; 8E
          fdb  RESTOR         ; 8F
          fdb  RETURN         ; 90
          fdb  STOP           ; 91
          fdb  POKE           ; 92
          fdb  CONT           ; 93
          fdb  LIST           ; 94
          fdb  CLEAR          ; 95
          fdb  NEW            ; 96
          fdb  SET            ; 97
		  fdb  CLS            ; 98
		  fdb  SOUND          ; 99
		  fdb  EXEC           ; 9A
          fdb  DEL            ; 9B
          fdb  EDIT           ; 9C
		  fdb  TRON           ; 9D
          fdb  TROFF          ; 9E
          fdb  DEF            ; 9F
          fdb  LINE           ; A0
          fdb  RENUM          ; A1    
          fdb  DIR            ; A2
          fdb  KILL           ; A3
          fdb  LOAD           ; A4
          fdb  SAVE           ; A5		  
          fdb  DATE           ; A6
          fdb  TIME           ; A7
TOK_HIGH_EXEC equ  $a7 ; (LABAF-CMD_TAB)/2+$7F

* ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY
LABAF     fcc  "NF"           ; 0 NEXT WITHOUT FOR
          fcc  "SN"           ; 1 SYNTAX ERROR
          fcc  "RG"           ; 2 RETURN WITHOUT GOSUB
          fcc  "OD"           ; 3 OUT OF DATA
          fcc  "FC"           ; 4 ILLEGAL FUNCTION CALL
          fcc  "OV"           ; 5 OVERFLOW
          fcc  "OM"           ; 6 OUT OF MEMORY
          fcc  "UL"           ; 7 UNDEFINED LINE NUMBER
          fcc  "BS"           ; 8 BAD SUBSCRIPT
          fcc  "DD"           ; 9 REDIMENSIONED ARRAY
          fcc  "/0"           ; 10 DIVISION BY ZERO
          fcc  "ID"           ; 11 ILLEGAL DIRECT STATEMENT
          fcc  "TM"           ; 12 TYPE MISMATCH
          fcc  "OS"           ; 13 OUT OF STRING SPACE
          fcc  "LS"           ; 14 STRING TOO LONG
          fcc  "ST"           ; 15 STRING FORMULA TOO COMPLEX
          fcc  "CN"           ; 16 CAN'T CONTINUE
          fcc  "FD"           ; 17 BAD FILE DATA
          fcc  "AO"           ; 18 FILE ALREADY OPEN
          fcc  "DN"           ; 19 DEVICE NUMBER ERROR
          fcc  "IO"           ; 20 I/O ERROR
          fcc  "FM"           ; 21 BAD FILE MODE
          fcc  "NO"           ; 22 FILE NOT OPEN
          fcc  "IE"           ; 23 INPUT PAST END OF FILE
          fcc  "DS"           ; 24 DIRECT STATEMENT IN FILE
* ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC
L890B     fcc  "UF"           ; 25 UNDEFINED FUNCTION (FN) CALL
L890D     fcc  "NE"           ; 26 FILE NOT FOUND

LABE1     fcc  " ERROR"
          fcb  $00
LABE8     fcc  " IN "
          fcb  $00
LABED     fcb  CR
LABEE     fcc  "OK"
          fcb  CR,$00
LABF2     fcb  CR
          fcc  "BREAK"
          fcb  $00

* SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DATA.
* THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEING
* SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT DATA IS 18
* BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES
* WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA
* IS CONSIDERED 'GOSUB/RETURN'
LABF9     leax 4,s            ; POINT X TO 3RD ADDRESS ON STACK - IGNORE THE
*         FIRST TWO RETURN ADDRESSES ON THE STACK
LABFB     ldb  #18            ; 18 BYTES SAVED ON STACK FOR EACH 'FOR' LOOP
          stx  TEMPTR         ; SAVE POINTER
          lda  ,x             ; GET 1ST BYTE
          suba #$80           ; * CHECK FOR TYPE OF STACK JUMP FOUND
          bne  LAC1A          ; * BRANCH IF NOT 'FOR/NEXT'
          ldx  1,x            ; = GET INDEX VARIABLE DESCRIPTOR
          stx  TMPTR1         ; = POINTER AND SAVE IT IN TMPTR1
          ldx  VARDES         ; GET INDEX VARIABLE BEING SEARCHED FOR
          beq  LAC16          ; BRANCH IF DEFAULT INDEX VARIABLE - USE THE
*                             ; FIRST 'FOR/NEXT' DATA FOUND ON STACK
*                             ; IF NO INDEX VARIABLE AFTER 'NEXT'
          cmpx TMPTR1         ; DOES THE STACK INDEX MATCH THE ONE
*                             ; BEING SEARCHED FOR?
          beq  LAC1A          ; YES
          ldx  TEMPTR         ; * RESTORE INITIAL POINTER, ADD
          abx                 ; * 18 TO IT AND LOOK FOR
          bra  LABFB          ; * NEXT BLOCK OF DATA
LAC16     ldx  TMPTR1         ; = GET 1ST INDEX VARIABLE FOUND AND
          stx  VARDES         ; = SAVE AS 'NEXT' INDEX
LAC1A     ldx  TEMPTR         ; POINT X TO START OF 'FOR/NEXT' DATA
          tsta                ; SET ZERO FLAG IF 'FOR/NEXT' DATA
          rts
* CHECK FOR MEMORY SPACE FOR NEW TOP OF
* ARRAYS AND MOVE ARRAYS TO NEW LOCATION
LAC1E     bsr  LAC37          ; ACCD = NEW BOTTOM OF FREE RAM - IS THERE
*                             ; ROOM FOR THE STACK?
* MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND
* SAVE FINAL VALUE OF U IN V45
LAC20     ldu  V41            ; POINT U TO DESTINATION ADDRESS (V41)
          leau 1,u            ; ADD ONE TO U - COMPENSATE FOR FIRST pshu
          ldx  V43            ; POINT X TO SOURCE ADDRESS (V43)
          leax 1,x            ; ADD ONE - COMPENSATE FOR FIRST lda ,x
LAC28     lda  ,-x            ; GRAB A BYTE FROM SOURCE
          pshu a              ; MOVE IT TO DESTINATION
          cmpx V47            ; DONE?
          bne  LAC28          ; NO - KEEP MOVING BYTES
          stu  V45            ; SAVE FINAL DESTINATION ADDRESS
LAC32     rts
* CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB
* BYTES IN FREE RAM - OM ERROR IF NOT
LAC33     clra                ; * ACCD CONTAINS NUMBER OF EXTRA
          aslb                ; * BYTES TO PUT ON STACK
          addd ARYEND         ; END OF PROGRAM AND VARIABLES
LAC37     addd #STKBUF        ; ADD STACK BUFFER - ROOM FOR STACK?
          bcs  LAC44          ; BRANCH IF GREATER THAN $FFFF
          sts  BOTSTK         ; CURRENT NEW BOTTOM OF STACK STACK POINTER
          cmpd BOTSTK         ; ARE WE GOING TO BE BELOW STACK?
          bcs  LAC32          ; YES - NO ERROR
LAC44     ldb  #6*2           ; OUT OF MEMORY ERROR

* ERROR SERVICING ROUTINE
LAC46     jsr  LAD33          ; RESET STACK, STRING STACK, CONTINUE POINTER
          jsr  LB95C          ; SEND A CR TO SCREEN
          jsr  LB9AF          ; SEND A '?' TO SCREEN
          ldx  #LABAF         ; POINT TO ERROR TABLE
LAC60     abx                 ; ADD MESSAGE NUMBER OFFSET
          bsr  LACA0          ; * GET TWO CHARACTERS FROM X AND
          bsr  LACA0          ; * SEND TO CONSOLE OUT (SCREEN)
          ldx  #LABE1-1       ; POINT TO "ERROR" MESSAGE
LAC68     jsr  LB99C          ; PRINT MESSAGE POINTED TO BY X
          lda  CURLIN         ; GET CURRENT LINE NUMBER (CURL IN)
          inca                ; TEST FOR DIRECT MODE
          beq  LAC73          ; BRANCH IF DIRECT MODE
          jsr  LBDC5          ; PRINT 'IN ****'

* THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE
LAC73     jsr  LB95C          ; MOVE CURSOR TO START OF LINE
          jsr  APLcurBlinking ; SET THE BLINKING CURSOR
		  ldx  #LABED         ; POINT X TO 'OK', CR MESSAGE
          jsr  LB99C          ; PRINT 'OK', CR
LAC7C     jsr  LA390          ; GO GET AN INPUT LINE
          ldu  #$FFFF         ; THE LINE NUMBER FOR DIRECT MODE IS $FFFF
          stu  CURLIN         ; SAVE IT IN CURLIN
          bcs  LAC7C          ; BRANCH IF LINE INPUT TERMINATED BY BREAK
          stx  CHARAD         ; SAVE (X) AS CURRENT INPUT POINTER - THIS WILL
*         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. THE
*         LINE JUST ENTERED WILL BE INTERPRETED
          jsr  GETNCH         ; GET NEXT CHARACTER FROM BASIC
          beq  LAC7C          ; NO LINE INPUT - GET ANOTHER LINE
          bcs  LACA5          ; BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE
*         THE  STATEMENT ENTEREd, SO THIS STATEMENT
*         WILL BE MERGED INTO THE BASIC PROGRAM
          jsr  APLcurOff	  ; STOP THE BLINKING CURSOR		  
		  jsr  LB821          ; GO CRUNCH LINE
          jmp  LADC0          ; GO EXECUTE THE STATEMENT (LIVE KEYBOARD)
*
LACA0     lda  ,x+            ; GET A CHARACTER
          jmp  LB9B1          ; SEND TO CONSOLE OUT
* TAKE A LINE FROM THE LINE INPUT BUFFER
* AND INSERT IT INTO THE BASIC PROGRAM
LACA5     jsr  LAF67          ; CONVERT LINE NUMBER TO BINARY
LACA8     ldx  BINVAL         ; GET CONVERTED LINE NUMBER
          stx  LINHDR         ; STORE IT IN LINE INPUT HEADER
          jsr  LB821          ; GO CRUNCH THE LINE
          stb  TMPLOC         ; SAVE LINE LENGTH
          bsr  LAD01          ; FIND OUT WHERE TO INSERT LINE
          bcs  LACC8          ; RANCH IF LINE NUMBER DOES NOT ALREADY EXIST
          ldd  V47            ; GET ABSOLUTE ADDRESS OF LINE NUMBER
          subd ,x             ; SUBTRACT ADDRESS OF NEXT LINE NUMBER
          addd VARTAB         ; * ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE
          std  VARTAB         ; * THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM
          ldu  ,x             ; POINT U TO ADDRESS OF NEXT LINE NUMBER
* DELETE OLD LINE FROM BASIC PROGRAM
LACC0     pulu a              ; GET A BYTE FROM WHAT'S LEFT OF PROGRAM
          sta  ,x+            ; MOVE IT DOWN
          cmpx VARTAB         ; COMPARE TO END OF BASIC PROGRAM
          bne  LACC0          ; BRANCH IF NOT AT END
LACC8     lda  LINBUF         ; * CHECK TO SEE IF THERE IS A LINE IN
          beq  LACE9          ; * THE BUFFER AND BRANCH IF NONE
          ldd  VARTAB         ; = SAVE CURRENT END OF
          std  V43            ; = PROGRAM IN V43
          addb TMPLOC         ; * ADD LENGTH OF CRUNCHED LINE,
          adca #0             ; * PROPOGATE CARRY AND SAVE NEW END
          std  V41            ; * OF PROGRAM IN V41
          jsr  LAC1E          ; = MAKE SURE THERE'S ENOUGH RAM FOR THIS LINE & MAKE A HOLE IN BASIC FOR NEW LINE
          ldu  #LINHDR-2      ; POINT U TO LINE TO BE INSERTED
LACDD     pulu a              ; GET A BYTE FROM NEW LINE
          sta  ,x+            ; INSERT IT IN PROGRAM
          cmpx V45            ; * COMPARE TO ADDRESS OF END OF INSERTED
          bne  LACDD          ; * LINE AND BRANCH IF NOT DONE
          ldx  V41            ; = GET AND SAVE
          stx  VARTAB         ; = END OF PROGRAM
LACE9     bsr  LAD21          ; RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE
          bsr  LACEF          ; ADJUST START OF NEXT LINE ADDRESSES
          bra  LAC7C          ; EENTER BASIC'S INPUT LOOP
* COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM
LACEF     ldx  TXTTAB         ; POINT X TO START OF PROGRAM
LACF1     ldd  ,x             ; GET ADDRESS OF NEXT LINE
          beq  LAD16          ; RETURN IF END OF PROGRAM
          leau 4,x            ; POINT U TO START OF BASIC TEXT IN LINE
LACF7     lda  ,u+            ; * SKIP THROUGH THE LINE UNTIL A
          bne  LACF7          ; * ZERO (END OF LINE) IS FOUND
          stu  ,x             ; SAVE THE NEW START OF NEXT LINE ADDRESS
          ldx  ,x             ; POINT X TO START OF NEXT LINE
          bra  LACF1          ; KEEP GOING
*
* FIND A LINE NUMBER IN THE BASIC PROGRAM
* RETURN WITH CARRY SET IF NO MATCH FOUND
LAD01     ldd  BINVAL         ; GET THE LINE NUMBER TO FIND
          ldx  TXTTAB         ; BEGINNING OF PROGRAM
LAD05     ldu  ,x             ; GET ADDRESS OF NEXT LINE NUMBER
          beq  LAD12          ; BRANCH IF END OF PROG
          cmpd 2,x            ; IS IT A MATCH?
          bls  LAD14          ; CARRY SET IF LOWER; CARRY CLEAR IF MATCH
          ldx  ,x             ; X = ADDRESS OF NEXT LINE
          bra  LAD05          ; KEEP LOOPING FOR LINE NUMBER
LAD12     orcc #1             ; SET CARRY FLAG
LAD14     stx  V47            ; SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER
*                             ; WHERE IT SHOULD HAVE BEEN
LAD16     rts

* NEW
NEW       bne  LAD14          ; BRANCH IF ARGUMENT GIVEN
LAD19     ldx  TXTTAB         ; GET START OF BASIC
          clr  ,x+            ; * PUT 2 ZERO BYTES THERE - ERASE
          clr  ,x+            ; * THE BASIC PROGRAM
          stx  VARTAB         ; AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM
LAD21     ldx  TXTTAB         ; GET START OF BASIC
          jsr  LAEBB          ; PUT INPUT POINTER ONE BEFORE START OF BASIC
* ERASE ALL VARIABLES
LAD26     ldx  MEMSIZ         ; * RESET START OF STRING VARIABLES
          stx  STRTAB         ; * TO TOP OF STRING SPACE
          jsr  RESTOR         ; RESET 'DATA' POINTER TO START OF BASIC
          ldx  VARTAB         ; * GET START OF VARIABLES AND USE IT
          stx  ARYTAB         ; * TO RESET START OF ARRAYS
          stx  ARYEND         ; RESET END OF ARRAYS
LAD33     ldx  #STRSTK        ; * RESET STRING STACK POINTER TO
          stx  TEMPPT         ; * BOTTOM OF STRING STACK
          ldx  ,s             ; GET RETURN ADDRESS OFF STACK
          lds  FRETOP         ; RESTORE STACK POINTER
          clr  ,-s            ; PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF
*                             ; FOR/NEXT DATA FROM THE STACK
          clr  OLDPTR         ; RESET 'CONT' ADDRESS SO YOU
          clr  OLDPTR+1       ; 'CAN'T CONTINUE'
          clr  ARYDIS         ; CLEAR THE ARRAY DISABLE FLAG
          jmp  ,x             ; RETURN TO CALLING ROUTINE - THIS IS NECESSARY
*                             ; SINCE THE STACK WAS RESET
*
* FOR
*
* THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR
* EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE
* BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);
*         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;
*         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;
* 9-13=FP VALUE OF 'TO' PARAMETER;
* 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END
*         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
FOR       lda  #$80           ; * SAVE THE DISABLE ARRAY FLAG IN VO8
          sta  ARYDIS         ; * DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY
          jsr  LET            ; SET INDEX VARIABLE TO INITIAL VALUE
          jsr  LABF9          ; SEARCH THE STACK FOR 'FOR/NEXT' DATA
          leas 2,s            ; PURGE RETURN ADDRESS OFF OF THE STACK
          bne  LAD59          ; BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED
          ldx  TEMPTR         ; GET (ADDRESS + 18) OF MATCHED 'FOR/NEXT' DATA
          leas b,x            ; MOVE THE STACK POINTER TO THE BEGINNING OF THE
* MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
* OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY
* ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
* THIS POINT ON THE STACK
LAD59     ldb  #$09           ; * CHECK FOR ROOM FOR 18 BYTES
          jsr  LAC33          ; * IN FREE RAM
          jsr  LAEE8          ; GET ADDR OF END OF SUBLINE IN X
          ldd  CURLIN         ; GET CURRENT LINE NUMBER
          pshs x,b,a          ; SAVE LINE ADDR AND LINE NUMBER ON STACK
          ldb  #TOK_TO        ; TOKEN FOR 'TO'
          jsr  LB26F          ; SYNTAX CHECK FOR 'TO'
          jsr  LB143          ; 'TM' ERROR IF INDEX VARIABLE SET TO STRING
          jsr  LB141          ; EVALUATE EXPRESSION
*
          ldb  FP0SGN         ; GET FPA0 MANTISSA SIGN
          orb  #$7F           ; FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA
          andb FPA0           ; PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA
          stb  FPA0           ; SAVE THE PACKED HIGH ORDER MANTISSA
          ldy  #LAD7F         ; LOAD FOLLOWING ADDRESS INTO Y AS A RETURN
          jmp  LB1EA          ; ADDRESS - PUSH FPA0 ONTO THE STACK
LAD7F     ldx  #LBAC5         ; POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE)
          jsr  LBC14          ; MOVE (X) TO FPA0
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          cmpa #TOK_STEP      ; STEP TOKEN
          bne  LAD90          ; BRANCH IF NO 'STEP' VALUE
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          jsr  LB141          ; EVALUATE NUMERIC EXPRESSION
LAD90     jsr  LBC6D          ; CHECK STATUS OF FPA0
          jsr  LB1E6          ; SAVE STATUS AND FPA0 ON THE STACK
          ldd  VARDES         ; * GET DESCRIPTOR POINTER FOR THE 'STEP'
          pshs b,a            ; * VARIABLE AND SAVE IT ON THE STACK
          lda  #$80           ; = GET THE 'FOR' FLAG AND
          pshs a              ; = SAVE IT ON THE STACK
*
* MAIN COMMAND INTERPRETATION LOOP
LAD9E     bsr  LADEB          ; CHECK FOR KEYBOARD BREAK
          ldx  CHARAD         ; GET BASIC'S INPUT POINTER
          stx  TINPTR         ; SAVE IT
          lda  ,x+            ; GET CURRENT INPUT CHAR & MOVE POINTER
          beq  LADB4          ; BRANCH IF END OF LINE
          cmpa #':'            ; CHECK FOR LINE SEPARATOR
          beq  LADC0          ; BRANCH IF COLON
LADB1     jmp  LB277          ; 'SYNTAX ERROR'-IF NOT LINE SEPARATOR
LADB4     lda  ,x++           ; GET MS BYTE OF ADDRESS OF NEXT BASIC LINE
          sta  ENDFLG         ; SAVE IN STOP/END FLAG - CAUSE A STOP IF
*                             ; NEXT LINE ADDRESS IS < $8000; CAUSE
*                             ; AN END IF ADDRESS > $8000
          beq LAE15           ; BRANCH TO 'STOP' - END OF PROGRAM
          ldd  ,x+            ; GET CURRENT LINE NUMBER
          std  CURLIN         ; SAVE IN CURLIN
          stx  CHARAD         ; SAVE ADDRESS OF FIRST BYTE OF LINE
* EXTENDED BASIC TRACE
          lda  TRCFLG         ; TEST THE TRACE FLAG
          beq  LADC0          ; BRANCH IF TRACE OFF
          lda  #$5B           ; <LEFT HAND MARKER FOR TRON LINE NUMBER
          jsr  PUTCHR         ; OUTPUT A CHARACTER
          lda  CURLIN         ; GET MS BYTE OF LINE NUMBER
          jsr  LBDCC          ; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN
          lda  #$5D           ; > RIGHT HAND MARKER FOR TRON LINE NUMBER
          jsr  PUTCHR         ; OUTPUT A CHARACTER
* END OF EXTENDED BASIC TRACE
LADC0     jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          bsr  LADC6          ; GO PROCESS COMMAND
          bra  LAD9E          ; GO BACK TO MAIN LOOP
LADC6     beq  LADEA          ; RETURN IF END OF LINE (rts - was beq LAE40)
          tsta                ; CHECK FOR TOKEN - BIT 7 SET (NEGATIVE)
          lbpl LET            ; BRANCH IF NOT A TOKEN - GO DO A 'LET' WHICH
* 
          cmpa #$FF           ; SECONDARY TOKEN
          beq  SECTOK
          cmpa #TOK_HIGH_EXEC ; SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC
          bhi  LADB1          ; 'SYNTAX ERROR' IF NON-EXECUTABLE TOKEN
          ldx  COMVEC+3       ; GET ADDRESS OF BASIC'S COMMAND TABLE
LADD4     asla                ; X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7
          tfr  a,b            ; SAVE COMMAND OFFSET IN ACCB
          abx                 ; NON X POINTS TO COMMAND JUMP ADDR
          jsr  GETNCH         ; GET AN INPUT CHAR
*
* HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
          jmp  [,x]           ; GO DO A COMMAND
SECTOK
* THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTABLE IS
* THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHECK DONE HERE
          jsr  GETNCH         ; GET AN INPUT CHAR
          cmpa #TOK_MID       ; TOKEN FOR "MID$"
          lbeq L86D6          ; PROCESS MID$ REPLACEMENT
          jmp  LB277          ; SYNTAX ERROR

*
* RESTORE
RESTOR    ldx  TXTTAB         ; BEGINNING OF PROGRAM ADDRESS
          leax -1,x           ; MOVE TO ONE BYTE BEFORE PROGRAM
LADE8     stx  DATPTR         ; SAVE NEW DATA POINTER
LADEA     rts
*
* BREAK CHECK
LADEB     jsr  LA1C1          ; GET A KEYSTROKE ENTRY
          beq  LADFA          ; RETURN IF NO INPUT
LADF0     cmpa #3             ; CONTROL C? (BREAK)
          beq  STOP           ; YES
          cmpa #$13           ; CONTROL S? (PAUSE)
          beq  LADFB          ; YES
          sta  IKEYIM         ; SAVE KEYSTROKE IN INKEY IMAGE
LADFA     rts
LADFB     jsr  KEYIN          ; GET A KEY
          beq  LADFB          ; BRANCH IF NO KEY DOWN
          bra  LADF0          ; CONTINUE - DO A BREAK CHECK
*
* END
END       jsr  GETCCH         ; GET CURRENT INPUT CHAR
          bra  LAE0B
*
* STOP
STOP      orcc #$01           ; SET CARRY FLAG
LAE0B     bne  LAE40          ; BRANCH IF ARGUMENT EXISTS
          ldx  CHARAD         ; * SAVE CURRENT POSITION OF
          stx  TINPTR         ; * BASIC'S INPUT POINTER
LAE11     ror  ENDFLG         ; ROTATE CARRY INTO BIT 7 OF STOP/END FLAG
          leas 2,s            ; PURGE RETURN ADDRESS OFF STACK
LAE15     ldx  CURLIN         ; GET CURRENT LINE NUMBER
          cmpx #$FFFF         ; DIRECT MODE?
          beq  LAE22          ; YES
          stx  OLDTXT         ; SAVE CURRENT LINE NUMBER
          ldx  TINPTR         ; * GET AND SAVE CURRENT POSITION
          stx  OLDPTR         ; * OF BASIC'S INPUT POINTER
LAE22
          ldx  #LABF2-1       ; POINT TO CR, 'BREAK' MESSAGE
          tst  ENDFLG         ; CHECK STOP/END FLAG
          lbpl LAC73          ; BRANCH TO MAIN LOOP OF BASIC IF END
          jmp  LAC68          ; PRINT 'BREAK AT ####' AND GO TO
*                             ; BASIC'S MAIN LOOP IF 'STOP'

* CONT
CONT      bne  LAE40          ; RETURN IF ARGUMENT GIVEN
          ldb  #2*16          ; 'CAN'T CONTINUE' ERROR
          ldx  OLDPTR         ; GET CONTINUE ADDRESS (INPUT POINTER)
          lbeq LAC46          ; 'CN' ERROR IF CONTINUE ADDRESS = 0
          stx  CHARAD         ; RESET BASIC'S INPUT POINTER
          ldx  OLDTXT         ; GET LINE NUMBER
          stx  CURLIN         ; RESET CURRENT LINE NUMBER
LAE40     rts
*
* CLEAR
CLEAR     beq  LAE6F          ; BRANCH IF NO ARGUMENT
          jsr  LB3E6          ; EVALUATE ARGUMENT
          pshs b,a            ; SAVE AMOUNT OF STRING SPACE ON STACK
          ldx  MEMSIZ         ; GET CURRENT TOP OF CLEARED SPACE
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          beq  LAE5A          ; BRANCH IF NO NEW TOP OF CLEARED SPACE
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          jsr  LB73D          ; EVALUATE EXPRESSlON; RETURN VALUE IN X
          leax -1,x           ; X = TOP OF CLEARED SPACE
          cmpx TOPRAM         ; COMPARE TO TOP OF RAM
          bhi  LAE72          ; 'OM' ERROR IF > TOP OF RAM
LAE5A     tfr  x,d            ; ACCD = TOP OF CLEARED SPACE
          subd ,s++           ; SUBTRACT OUT AMOUNT OF CLEARED SPACE
          bcs  LAE72          ; 'OM' ERROR IF FREE MEM < 0
          tfr  d,u            ; U = BOTTOM OF CLEARED SPACE
          subd #STKBUF        ; SUBTRACT OUT STACK BUFFER
          bcs  LAE72          ; 'OM' ERROR IF FREE MEM < 0
          subd VARTAB         ; SUBTRACT OUT START OF VARIABLES
          bcs  LAE72          ; 'OM' ERROR IF FREE MEM < 0
          stu  FRETOP         ; SAVE NEW BOTTOM OF CLEARED SPACE
          stx  MEMSIZ         ; SAVE NEW TOP OF CLEARED SPACE
LAE6F     jmp  LAD26          ; ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC
LAE72     jmp  LAC44          ; 'OM' ERROR
*
* RUN
RUN       jsr  GETCCH         ; * GET CURRENT INPUT CHARACTER
          lbeq LAD21          ; * IF NO LINE NUMBER
          jsr  LAD26          ; ERASE ALL VARIABLES
          bra  LAE9F          ; 'GOTO' THE RUN ADDRESS
*
* GO
GO        tfr  a,b            ; SAVE INPUT CHARACTER IN ACCB
LAE88     jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          cmpb #TOK_TO        ; 'TO' TOKEN
          beq  LAEA4          ; BRANCH IF GOTO
          cmpb #TOK_SUB       ; 'SUB' TOKEN
          bne  LAED7          ; 'SYNTAX ERROR' IF NEITHER
          ldb  #3             ; =ROOM FOR 6
          jsr  LAC33          ; =BYTES ON STACK?
          ldu  CHARAD         ; * SAVE CURRENT BASIC INPUT POINTER, LINE
          ldx  CURLIN         ; * NUMBER AND SUB TOKEN ON STACK
          lda  #TOK_SUB       ; *
          pshs u,x,a          ; *
LAE9F     bsr  LAEA4          ; GO DO A 'GOTO'
          jmp  LAD9E          ; JUMP BACK TO BASIC'S MAIN LOOP
* GOTO
LAEA4     jsr  GETCCH         ; GET CURRENT INPUT CHAR
          jsr  LAF67          ; GET LINE NUMBER TO BINARY IN BINVAL
          bsr  LAEEB          ; ADVANCE BASIC'S POINTER TO END OF LINE
          leax $01,x          ; POINT TO START OF NEXT LINE
          ldd  BINVAL         ; GET THE LINE NUMBER TO RUN
          cmpd CURLIN         ; COMPARE TO CURRENT LINE NUMBER
          bhi  LAEB6          ; IF REO'D LINE NUMBER IS > CURRENT LINE NUMBER,
*              ; DON'T START LOOKING FROM
*              ; START OF PROGRAM
          ldx  TXTTAB         ; BEGINNING OF PROGRAM
LAEB6     jsr  LAD05          ; GO FIND A LINE NUMBER
          bcs  LAED2          ; 'UNDEFINED LINE NUMBER'
LAEBB     leax -1,x           ; MOVE BACK TO JUST BEFORE START OF LINE
          stx  CHARAD         ; RESET BASIC'S INPUT POINTER
LAEBF     rts
*
* RETURN
RETURN    bne  LAEBF          ; EXIT ROUTINE IF ARGUMENT GIVEN
          lda  #$FF           ; * PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF
          sta  VARDES         ; * VARDES WHICH WILL CAUSE 'FOR/NEXT' DATA ON THE
*              ; STACK TO BE IGNORED
          jsr  LABF9          ; CHECK FOR RETURN DATA ON THE STACK
          tfr  x,s            ; RESET STACK POINTER - PURGE TWO RETURN ADDRESSES
*              ; FROM THE STACK
          cmpa #TOK_SUB-$80   ; SUB TOKEN - $80
          beq  LAEDA          ; BRANCH IF 'RETURN' FROM SUBROUTINE
          ldb  #2*2           ; ERROR #2 'RETURN WITHOUT GOSUB'
          fcb  SKP2           ; SKIP TWO BYTES
LAED2     ldb  #7*2           ; ERROR #7 'UNDEFINED LINE NUMBER'
          jmp  LAC46          ; JUMP TO ERROR HANDLER
LAED7     jmp  LB277          ; 'SYNTAX ERROR'
LAEDA     puls a,x,u          ; * RESTORE VALUES OF CURRENT LINE NUMBER AND
          stx  CURLIN         ; * BASIC'S INPUT POINTER FOR THIS SUBROUTINE
          stu  CHARAD         ; * AND LOAD ACCA WITH SUB TOKEN ($A6)
*
* DATA
DATA      bsr  LAEE8          ; MOVE INPUT POINTER TO END OF SUBLINE OR LINE
          fcb  SKP2           ; SKIP 2 BYTES

* REM, ELSE
ELSE
REM       bsr  LAEEB          ; MOVE INPUT POINTER TO END OF LINE
          stx  CHARAD         ; RESET BASIC'S INPUT POINTER
LAEE7     rts
* ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE
LAEE8     ldb  #':'            ; COLON = SUBLINE TERMINATOR CHARACTER
LAEEA     fcb  SKP1LD         ; SKPILD SKIP ONE BYTE; lda #$5F
* ADVANCE BASIC'S INPUT POINTER TO END OF
* LINE - RETURN ADDRESS OF END OF LINE+1 IN X
LAEEB     clrb                ; 0 = LINE TERMINATOR CHARACTER
          stb  CHARAC         ; TEMP STORE PRIMARY TERMINATOR CHARACTER
          clrb                ; 0 (END OF LINE) = ALTERNATE TERM. CHAR.
          ldx  CHARAD         ; LOAD X W/BASIC'S INPUT POINTER
LAEF1     tfr  b,a            ; * CHANGE TERMINATOR CHARACTER
          ldb  CHARAC         ; * FROM ACCB TO CHARAC - SAVE OLD TERMINATOR
*         IN   CHARAC
          sta  CHARAC         ; SWAP PRIMARY AND SECONDARY TERMINATORS
LAEF7     lda  ,x             ; GET NEXT INPUT CHARACTER
          beq  LAEE7          ; RETURN IF 0 (END OF LINE)
          pshs b              ; SAVE TERMINATOR ON STACK
          cmpa ,s+            ; COMPARE TO INPUT CHARACTER
          beq  LAEE7          ; RETURN IF EQUAL
          leax 1,x            ; MOVE POINTER UP ONE
          cmpa #'"'            ; CHECK FOR DOUBLE QUOTES
          beq  LAEF1          ; BRANCH IF " - TOGGLE TERMINATOR CHARACTERS
          inca                ; * CHECK FOR $FF AND BRANCH IF
          bne  LAF0C          ; * NOT SECONDARY TOKEN
          leax 1,x            ; MOVE INPUT POINTER 1 MORE IF SECONDARY
LAF0C     cmpa #TOK_IF+1      ; TOKEN FOR IF?
          bne  LAEF7          ; NO - GET ANOTHER INPUT CHARACTER
          inc  IFCTR          ; INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY
*                             ; 'IF' STATEMENTS ARE NESTED IN ONE LINE
          bra  LAEF7          ; GET ANOTHER INPUT CHARACTER

* IF
IF        jsr  LB141          ; EVALUATE NUMERIC EXPRESSION
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          cmpa #TOK_GO        ; TOKEN FOR GO
          beq  LAF22          ; TREAT 'GO' THE SAME AS 'THEN'
          ldb  #TOK_THEN      ; TOKEN FOR THEN
          jsr  LB26F          ; DO A SYNTAX CHECK ON ACCB
LAF22     lda  FP0EXP         ; CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO
          bne  LAF39          ; BRANCH IF CONDITION TRUE
          clr  IFCTR          ; CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT
*                             ; TO SEARCH FOR IN NESTED 'IF' LOOPS
LAF28     bsr  DATA           ; MOVE BASIC'S POINTER TO END OF SUBLINE
          tsta                ; * CHECK TO SEE IF END OF LINE OR SUBLINE
          beq  LAEE7          ; * AND RETURN IF END OF LINE
          jsr  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
          cmpa #TOK_ELSE      ; TOKEN FOR ELSE
          bne  LAF28          ; IGNORE ALL DATA EXCEPT 'ELSE' UNTIL
*                             ; END OF LINE (ZERO BYTE)
          dec  IFCTR          ; CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE
          bpl  LAF28          ; BRANCH TO SEARCH ANOTHER SUBLINE FOR 'ELSE'
          jsr  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
LAF39     jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          lbcs LAEA4          ; BRANCH TO 'GOTO' IF NUMERIC CHARACTER
          jmp  LADC6          ; RETURN TO MAIN INTERPRETATION LOOP

* ON
ON        jsr  LB70B          ; EVALUATE EXPRESSION
          ldb  #TOK_GO        ; TOKEN FOR GO
          jsr  LB26F          ; SYNTAX CHECK FOR GO
          pshs a              ; SAVE NEW TOKEN (TO,sUB)
          cmpa #TOK_SUB       ; TOKEN FOR SUB?
          beq  LAF54          ; YES
          cmpa #TOK_TO        ; TOKEN FOR TO?
LAF52     lbne LAED7          ; 'SYNTAX' ERROR IF NOT 'SUB' OR 'TO'
LAF54     dec  FPA0+3         ; DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS
*                             ; IS THE ARGUMENT OF THE 'ON' STATEMENT
          bne  LAF5D          ; BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER
          puls b              ; GET BACK THE TOKEN FOLLOWING 'GO'
          jmp  LAE88          ; GO DO A 'GOTO' OR 'GOSUB'
LAF5D     jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          bsr  LAF67          ; CONVERT BASIC LINE NUMBER TO BINARY
          cmpa #','           ; IS CHARACTER FOLLOWING LINE NUMBER A COMMA?
          beq  LAF54          ; YES
          puls b,pc           ; IF NOT, FALL THROUGH TO NEXT COMMAND
LAF67     ldx  ZERO           ; DEFAULT LINE NUMBER OF ZERO
          stx  BINVAL         ; SAVE IT IN BINVAL
*
* CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL
*
LAF6B     bcc  LAFCE          ; RETURN IF NOT NUMERIC CHARACTER
          suba #'0'            ; MASK OFF ASCII
          sta  CHARAC         ; SAVE DIGIT IN VO1
          ldd  BINVAL         ; GET ACCUMULATED LINE NUMBER VALUE
          cmpa #24            ; LARGEST LINE NUMBER IS $F9FF (63999) -
*         (24*256+255)*10+9
          bhi  LAF52          ; 'SYNTAX' ERROR IF TOO BIG
* MULT ACCD X 10
          aslb                ; *
          rola                ; * TIMES 2
          aslb                ; =
          rola                ; = TIMES 4
          addd BINVAL         ; ADD 1 = TIMES 5
          aslb                ; *
          rola                ; * TIMES 10
          addb CHARAC         ; ADD NEXT DIGIT
          adca #0             ; PROPAGATE CARRY
          std  BINVAL         ; SAVE NEW ACCUMULATED LINE NUMBER
          jsr  GETNCH         ; GET NEXT CHARACTER FROM BASIC
          bra  LAF6B          ; LOOP- PROCESS NEXT DIGIT
*
* LET (EXBAS)
* EVALUATE A NON-TOKEN EXPRESSION
* TARGET = REPLACEMENT
LET       jsr  LB357          ; FIND TARGET VARIABLE DESCRIPTOR
          stx  VARDES         ; SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION
          ldb  #TOK_EQUALS    ; TOKEN FOR "="
          jsr  LB26F          ; DO A SYNTAX CHECK FOR '='
          lda  VALTYP         ; * GET VARIABLE TYPE AND
          pshs a              ; * SAVE ON THE STACK
          jsr  LB156          ; EVALUATE EXPRESSION
          puls a              ; * REGET VARIABLE TYPE OF 1ST EXPRESSION AND
          rora                ; * SET CARRY IF STRING
          jsr  LB148          ; TYPE CHECK-TM ERROR IF VARIABLE TYPES ON
*                             ; BOTH SIDES OF EQUALS SIGN NOT THE SAME
          lbeq LBC33          ; GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC
* MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT
* FPA0+2 INTO THE STRING SPACE. TRANSFER THE
* DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES
* DON'T MOVE THE STRING IF IT IS ALREADY IN THE
* STRING SPACE. REMOVE DESCRIPTOR FROM STRING
* STACK IF IT IS LAST ONE ON THE STACK
LAFA4     ldx  FPA0+2         ; POINT X TO DESCRIPTOR OF REPLACEMENT STRING
          ldd  FRETOP         ; LOAD ACCD WITH START OF STRING SPACE
          cmpd 2,x            ; IS THE STRING IN STRING SPACE?
          bcc  LAFBE          ; BRANCH IF IT'S NOT IN THE STRING SPACE
          cmpx VARTAB         ; COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES
          bcs  LAFBE          ; BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES
LAFB1     ldb  ,x             ; GET LENGTH OF REPLACEMENT STRING
          jsr  LB50D          ; RESERVE ACCB BYTES OF STRING SPACE
          ldx  V4D            ; GET DESCRIPTOR ADDRESS BACK
          jsr  LB643          ; MOVE STRING INTO STRING SPACE
          ldx  #STRDES        ; POINT X TO TEMP STRING DESCRIPTOR ADDRESS
LAFBE     stx  V4D            ; SAVE STRING DESCRIPTOR ADDRESS IN V4D
          jsr  LB675          ; REMOVE STRING DESCRIPTOR IF LAST ONE
*              ; ON STRING STACK
          ldu  V4D            ; POINT U TO REPLACEMENT DESCRIPTOR ADDRESS
          ldx  VARDES         ; GET TARGET DESCRIPTOR ADDRESS
          pulu a,b,y          ; GET LENGTH AND START OF REPLACEMENT STRING
          sta  ,x             ; * SAVE STRING LENGTH AND START IN
          sty  2,x            ; * TARGET DESCRIPTOR LOCATION
LAFCE     rts

LAFCF     fcc  "?REDO"        ; ?REDO MESSAGE
          fcb  CR,$00

LAFD6
LAFDC     jmp  LAC46          ; jmp TO ERROR HANDLER
LAFDF     lda  INPFLG         ; = GET THE INPUT FLAG AND BRANCH
          beq  LAFEA          ; = IF 'INPUT'
          ldx  DATTXT         ; * GET LINE NUMBER WHERE THE ERROR OCCURRED
          stx  CURLIN         ; * AND USE IT AS THE CURRENT LINE NUMBER
          jmp  LB277          ; 'SYNTAX ERROR'
LAFEA     ldx  #LAFCF-1       ; * POINT X TO '?REDO' AND PRINT
          jsr  LB99C          ; * IT ON THE SCREEN
          ldx  TINPTR         ; = GET THE SAVED ABSOLUTE ADDRESS OF
          stx  CHARAD         ; = INPUT POINTER AND RESTORE IT
          rts
*
* INPUT
INPUT     ldb  #11*2          ; 'ID' ERROR
          ldx  CURLIN         ; GET CURRENT LINE NUMBER
          leax 1,x            ; ADD ONE
          beq  LAFDC          ; 'ID' ERROR BRANCH IF DIRECT MODE
          bsr  LB00F          ; GET SOME INPUT DATA - WAS LB002
          rts
LB00F     cmpa #'"'           ; CHECK FOR PROMPT STRING DELIMITER
          bne  LB01E          ; BRANCH IF NO PROMPT STRING
          jsr  LB244          ; PUT PROMPT STRING ON STRING STACK
          ldb  #';'           ; *
          jsr  LB26F          ; * DO A SYNTAX CHECK FOR SEMICOLON
          jsr  LB99F          ; PRINT MESSAGE TO CONSOLE OUT
LB01E     ldx  #LINBUF        ; POINT TO BASIC'S LINE BUFFER
          clr  ,x             ; CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA
*              ; IN LINE BUFFER
          bsr  LB02F          ; INPUT A STRING TO LINE BUFFER
          ldb  #','           ; * INSERT A COMMA AT THE END
          stb  ,x             ; * OF THE LINE INPUT BUFFER
          bra  LB049
* FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
LB02F     jsr  LB9AF          ; SEND A "?" TO CONSOLE OUT
          jsr  LB9AC          ; SEND A 'SPACE' TO CONSOLE OUT
LB035     jsr  LA390          ; GO READ IN A BASIC LINE
          bcc  LB03F          ; BRANCH IF ENTER KEY ENDED ENTRY
          leas 4,s            ; PURGE TWO RETURN ADDRESSES OFF THE STACK
          jmp  LAE11          ; GO DO A 'STOP' IF BREAK KEY ENDED LINE ENTRY
LB03F     ldb  #2*23          ; 'INPUT PAST END OF FILE' ERROR
          rts
*
* READ
READ      ldx  DATPTR         ; GET 'READ' START ADDRESS
          fcb  SKP1LD         ; SKIP ONE BYTE - lda #*$4F
LB049     clra                ; 'INPUT' ENTRY POINT: INPUT FLAG = 0
          sta  INPFLG         ; SET INPUT FLAG; 0 = INPUT: <> 0 = READ
          stx  DATTMP         ; SAVE 'READ' START ADDRESS/'INPUT' BUFFER START
LB04E     jsr  LB357          ; EVALUATE A VARIABLE
          stx  VARDES         ; SAVE DESCRIPTOR ADDRESS
          ldx  CHARAD         ; * GET BASIC'S INPUT POINTER
          stx  BINVAL         ; * AND SAVE IT
          ldx  DATTMP         ; GET 'READ' ADDRESS START/'INPUT' BUFFER POINTER
          lda  ,x             ; GET A CHARACTER FROM THE BASIC PROGRAM
          bne  LB069          ; BRANCH IF NOT END OF LINE
          lda  INPFLG         ; * CHECK INPUT FLAG AND BRANCH
          bne  LB0B9          ; * IF LOOKING FOR DATA (READ)
* NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
* NOT COMING FROM SCREEN
          jsr  LB9AF          ; SEND A '?' TO CONSOLE OUT
          bsr  LB02F          ; FILL INPUT BUFFER FROM CONSOLE IN
LB069     stx  CHARAD         ; RESET BASIC'S INPUT POINTER
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          ldb  VALTYP         ; * CHECK VARIABLE TYPE AND
          beq  LB098          ; * BRANCH IF NUMERIC
* READ/INPUT A STRING VARIABLE
          ldx  CHARAD         ; LOAD X WITH CURRENT BASIC INPUT POINTER
          sta  CHARAC         ; SAVE CURRENT INPUT CHARACTER
          cmpa #'"'           ; CHECK FOR STRING DELIMITER
          beq  LB08B          ; BRANCH IF STRING DELIMITER
          leax -1,x           ; BACK UP POINTER
          clra                ; * ZERO = END OF LINE CHARACTER
          sta  CHARAC         ; * SAVE AS TERMINATOR
          jsr  LA35F          ; SET UP PRINT PARAMETERS
          lda  #':'           ; END OF SUBLINE CHARACTER
          sta  CHARAC         ; SAVE AS TERMINATOR I
          lda  #','           ; COMMA
LB08B     sta  ENDCHR         ; SAVE AS TERMINATOR 2
          jsr  LB51E          ; STRIP A STRING FROM THE INPUT BUFFER
          jsr  LB249          ; MOVE INPUT POINTER TO END OF STRING
          jsr  LAFA4          ; PUT A STRING INTO THE STRING SPACE IF NECESSARY
          bra  LB09E          ; CHECK FOR ANOTHER DATA ITEM
* SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM
LB098     jsr  LBD12          ; CONVERT AN ASCII STRING TO FP NUMBER
          jsr  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS IN VARDES -
*                             ; INPUT OR READ DATA ITEM
LB09E     jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          beq  LB0A8          ; BRANCH IF END OF LINE
          cmpa #','            ; CHECK FOR A COMMA
          lbne LAFD6          ; BAD FILE DATA' ERROR OR RETRY
LB0A8     ldx  CHARAD         ; * GET CURRENT INPUT
          stx  DATTMP         ; * POINTER (USED AS A DATA POINTER) AND SAVE IT
          ldx  BINVAL         ; * RESET INPUT POINTER TO INPUT OR
          stx  CHARAD         ; * READ STATEMENT
          jsr  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
          beq  LB0D5          ; BRANCH IF END OF LINE - EXIT COMMAND
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          bra  LB04E          ; GET ANOTHER INPUT OR READ ITEM
* SEARCH FROM ADDRESS IN X FOR
* 1ST OCCURENCE OF THE TOKEN FOR DATA
LB0B9     stx  CHARAD         ; RESET BASIC'S INPUT POINTER
          jsr  LAEE8          ; SEARCH FOR END OF CURRENT LINE OR SUBLINE
          leax 1,x            ; MOVE X ONE PAST END OF LINE
          tsta                ; CHECK FOR END OF LINE
          bne  LB0CD          ; BRANCH IF END OF SUBLINE
          ldb  #2*3           ; 'OUT OF DATA' ERROR
          ldu  ,x++           ; GET NEXT 2 CHARACTERS
          beq  LB10A          ; 'OD' ERROR IF END OF PROGRAM
          ldd  ,x++           ; GET BASIC LINE NUMBER AND
          std  DATTXT         ; SAVE IT IN DATTXT
LB0CD     lda  ,x             ; GET AN INPUT CHARACTER
          cmpa #TOK_DATA      ; DATA TOKEN?
          bne  LB0B9          ; NO - KEEP LOOKING
          bra  LB069          ; YES
* EXIT READ AND INPUT COMMANDS
LB0D5     ldx  DATTMP         ; GET DATA POINTER
          ldb  INPFLG         ; * CHECK INPUT FLAG
          lbne LADE8          ; * SAVE NEW DATA POINTER IF READ
          lda  ,x             ; = CHECK NEXT CHARACTER IN 'INPUT' BUFFER
          beq  LB0E7          ; =
          ldx  #LB0E8-1       ; POINT X TO '?EXTRA IGNORED'
          jmp  LB99C          ; PRINT THE MESSAGE
LB0E7     rts

LB0E8     fcc  "?EXTRA IGNORED" ; ?EXTRA IGNORED MESSAGE


          fcb  CR,$00

* NEXT
NEXT      bne  LB0FE          ; BRANCH IF ARGUMENT GIVEN
          ldx  ZERO           ; X = 0: DEFAULT FOR NO ARGUMENT
          bra  LB101
LB0FE     jsr  LB357          ; EVALUATE AN ALPHA EXPRESSION
LB101     stx  VARDES         ; SAVE VARIABLE DESCRIPTOR POINTER
          jsr  LABF9          ; GO SCAN FOR 'FOR/NEXT' DATA ON STACK
          beq  LB10C          ; BRANCH IF DATA FOUND
          ldb  #0             ; 'NEXT WITHOUT FOR' ERROR (SHOULD BE clrb)
LB10A     bra  LB153          ; PROCESS ERROR
LB10C     tfr  x,s            ; POINT S TO START OF 'FOR/NEXT' DATA
          leax 3,x            ; POINT X TO FP VALUE OF STEP
          jsr  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
          lda  8,s            ; GET THE DIRECTION OF STEP
          sta  FP0SGN         ; SAVE IT AS THE SIGN OF FPA0
          ldx  VARDES         ; POINT (X) TO INDEX VARIABLE DESCRIPTOR
          jsr  LB9C2          ; ADD (X) TO FPA0 (STEP TO INDEX)
          jsr  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS
*                             ; CONTAINED IN VARDES
          leax 9,s            ; POINT (X) TO TERMINAL VALUE OF INDEX
          jsr  LBC96          ; COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX
          subb 8,s            ; ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF
*                             ; STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR
*                             ; STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE
          beq  LB134          ; BRANCH IF 'FOR/NEXT' LOOP DONE
          ldx  14,s           ; * GET LINE NUMBER AND
          stx  CURLIN         ; * BASIC POINTER OF
          ldx  16,s           ; * STATEMENT FOLLOWING THE
          stx  CHARAD         ; * PROPER FOR STATEMENT
LB131     jmp  LAD9E          ; JUMP BACK TO COMMAND INTEPR. LOOP
LB134     leas 18,s           ; PULL THE 'FOR-NEXT' DATA OFF THE STACK
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          cmpa #','            ; CHECK FOR ANOTHER ARGUMENT
          bne  LB131          ; RETURN IF NONE
          jsr  GETNCH         ; GET NEXT CHARACTER FROM BASIC
          bsr  LB0FE          ; bsr SIMULATES A CALL TO 'NEXT' FROM COMMAND LOOP


LB141     bsr  LB156          ; EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC
LB143     andcc #$FE          ; CLEAR CARRY FLAG
LB145     fcb  $7D            ; OP CODE OF tst $1A01 - SKIP TWO BYTES (DO
*              ; NOT CHANGE CARRY FLAG)
LB146     orcc #1             ; SET CARRY

* STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR
* NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR
* IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP
* IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC
* IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.
LB148     tst  VALTYP         ; TEST TYPE FLAG; DO NOT CHANGE CARRY
          bcs  LB14F          ; BRANCH IF STRING
          bpl  LB0E7          ; RETURN ON PLUS
          fcb  SKP2           ; SKIP 2 BYTES - 'TM' ERROR
LB14F     bmi  LB0E7          ; RETURN ON MINUS
          ldb  #12*2          ; 'TYPE M1SMATCH' ERROR
LB153     jmp  LAC46          ; PROCESS ERROR
* EVALUATE EXPRESSION
LB156     bsr  LB1C6          ; BACK UP INPUT POINTER
LB158     clra                ; END OF OPERATION PRECEDENCE FLAG
          fcb  SKP2           ; SKIP TWO BYTES
LB15A     pshs b              ; SAVE FLAG (RELATIONAL OPERATOR FLAG)
          pshs a              ; SAVE FLAG (PRECEDENCE FLAG)
          ldb  #1             ; *
          jsr  LAC33          ; * SEE IF ROOM IN FREE RAM FOR (B) WORDS
          jsr  LB223          ; GO EVALUATE AN EXPRESSION
          clr  TRELFL         ; RESET RELATIONAL OPERATOR FLAG
LB168     jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
* CHECK FOR RELATIONAL OPERATORS
LB16A     suba #TOK_GREATER   ; TOKEN FOR >
          bcs  LB181          ; BRANCH IF LESS THAN RELATIONAL OPERATORS
          cmpa #3             ; *
          bcc  LB181          ; * BRANCH IF GREATER THAN RELATIONAL OPERATORS
          cmpa #1             ; SET CARRY IF '>'
          rola                ; CARRY TO BIT 0
          eora TRELFL         ; * CARRY SET IF
          cmpa TRELFL         ; * TRELFL = ACCA
          bcs  LB1DF          ; BRANCH IF SYNTAX ERROR : == << OR >>
          sta  TRELFL         ; BIT 0: >, BIT 1 =, BIT 2: <
          jsr  GETNCH         ; GET AN INPUT CHARACTER
          bra  LB16A          ; CHECK FOR ANOTHER RELATIONAL OPERATOR
*
LB181     ldb  TRELFL         ; GET RELATIONAL OPERATOR FLAG
          bne  LB1B8          ; BRANCH IF RELATIONAL COMPARISON
          lbcc LB1F4          ; BRANCH IF > RELATIONAL OPERATOR
          adda #7             ; SEVEN ARITHMETIC/LOGICAL OPERATORS
          bcc  LB1F4          ; BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR
          adca VALTYP         ; ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER
          lbeq LB60F          ; BRANCH IF VALTYP = FF, AND ACCA = '+' TOKEN -
*                             ; CONCATENATE TWO STRINGS
          adca #-1            ; RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER
          pshs a              ; * STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2
          asla                ; * THEN ADD THE STORED STACK DATA = MULTIPLY
          adda ,s+            ; * X 3; 3 BYTE/TABLE ENTRY
          ldx  #LAA51         ; JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS
          leax a,x            ; POINT X TO PROPER TABLE
LB19F     puls a              ; GET PRECEDENCE FLAG FROM STACK
          cmpa ,x             ; COMPARE TO CURRENT OPERATOR
          bcc  LB1FA          ; BRANCH IF STACK OPERATOR > CURRENT OPERATOR
          bsr  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING

* OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.
LB1A7     pshs a              ; SAVE PRECEDENCE FLAG
          bsr  LB1D4          ; PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK
          ldx  RELPTR         ; GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR
*                             ; LAST CALCULATED OPERATION
          puls a              ; GET PRECEDENCE FLAG OF PREVIOUS OPERATION
          bne  LB1CE          ; BRANCH IF NOT END OF OPERATION
          tsta                ; CHECK TYPE OF PRECEDENCE FLAG
          lbeq LB220          ; BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION
          bra  LB203          ; EVALUATE AN OPERATION

LB1B8     asl  VALTYP         ; BIT 7 OF TYPE FLAG TO CARRY
          rolb                ; SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0
          bsr  LB1C6          ; MOVE THE INPUT POINTER BACK ONE
          ldx  #LB1CB         ; POINT X TO RELATIONAL COMPARISON JUMP TABLE
          stb  TRELFL         ; SAVE RELATIONAL COMPARISON DATA
          clr  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
          bra  LB19F          ; PERFORM OPERATION OR SAVE ON STACK

LB1C6     ldx  CHARAD         ; * GET BASIC'S INPUT POINTER AND
          jmp  LAEBB          ; * MOVE IT BACK ONE
* RELATIONAL COMPARISON JUMP TABLE
LB1CB     fcb  $64            ; RELATIONAL COMPARISON FLAG
LB1CC     fdb  LB2F4          ; JUMP ADDRESS

LB1CE     cmpa ,x             ; COMPARE PRECEDENCE OF LAST DONE OPERATION TO
*         NEXT TO BE DONE OPERATION
          bcc  LB203          ; EVALUATE OPERATION IF LOWER PRECEDENCE
          bra  LB1A7          ; PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE

* PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR
LB1D4     ldd  1,x            ; GET ADDRESS OF OPERATOR ROUTINE
          pshs b,a            ; SAVE IT ON THE STACK
          bsr  LB1E2          ; PUSH FPA0 ONTO STACK
          ldb  TRELFL         ; GET BACK RELATIONAL OPERATOR FLAG
          jmp  LB15A          ; EVALUATE ANOTHER EXPRESSION
LB1DF     jmp  LB277          ; 'SYNTAX ERROR'
* PUSH FPA0 ONTO THE STACK. ,s   = EXPONENT
* 1-2,s =HIGH ORDER MANTISSA 3-4,s = LOW ORDER MANTISSA
* 5,s = SIGN RETURN WITH PRECEDENCE CODE IN ACCA
LB1E2     ldb  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
          lda  ,x             ; GET PRECEDENCE CODE TO ACCA
LB1E6     puls y              ; GET RETURN ADDRESS FROM STACK & PUT IT IN Y
          pshs b              ; SAVE ACCB ON STACK
LB1EA     ldb  FP0EXP         ; * PUSH FPA0 ONTO THE STACK
          ldx  FPA0           ; *
          ldu  FPA0+2         ; *
          pshs u,x,b          ; *
          jmp  ,y             ; JUMP TO ADDRESS IN Y

* BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALLY ')' OR END OF LINE
LB1F4     ldx  ZERO           ; POINT X TO DUMMY VALUE (ZERO)
          lda  ,s+            ; GET PRECEDENCE FLAG FROM STACK
          beq  LB220          ; BRANCH IF END OF EXPRESSION
LB1FA     cmpa #$64           ; * CHECK FOR RELATIONAL COMPARISON FLAG
          beq  LB201          ; * AND BRANCH IF RELATIONAL COMPARISON
          jsr  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
LB201     stx  RELPTR         ; SAVE POINTER TO OPERATOR ROUTINE
LB203     puls b              ; GET RELATIONAL OPERATOR FLAG FROM STACK
          cmpa #$5A           ; CHECK FOR 'NOT' OPERATOR
          beq  LB222          ; RETURN IF 'NOT' - NO RELATIONAL COMPARISON
          cmpa #$7D           ; CHECK FOR NEGATION (UNARY) FLAG
          beq  LB222          ; RETURN IF NEGATION - NO RELATIONAL COMPARISON

* EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES
* ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH
* WILL EVALUATE THE OPERATION. THE rts AT END OF ROUTINE WILL VECTOR
* TO EVALUATING ROUTINE.
          lsrb                ; = ROTATE VALTYP BIT INTO CARRY
          stb  RELFLG         ; = FLAG AND SAVE NEW RELFLG
          puls a,x,u          ; * PULL A FP VALUE OFF OF THE STACK
          sta  FP1EXP         ; * AND SAVE IT IN FPA1
          stx  FPA1           ; *
          stu  FPA1+2         ; *
          puls b              ; = GET MANTISSA SIGN AND
          stb  FP1SGN         ; = SAVE IT IN FPA1
          eorb FP0SGN         ; EOR IT WITH FPA1 MANTISSA SIGN
          stb  RESSGN         ; SAVE IT IN RESULT SIGN BYTE
LB220     ldb  FP0EXP         ; GET EXPONENT OF FPA0
LB222     rts

LB223     jsr  XVEC15         ; CALL EXTENDED BASIC ADD-IN
          clr  VALTYP         ; INITIALIZE TYPE FLAG TO NUMERIC
          jsr  GETNCH         ; GET AN INPUT CHAR
          bcc  LB22F          ; BRANCH IF NOT NUMERIC
LB22C     jmp  LBD12          ; CONVERT ASCII STRING TO FLOATING POINT -
*         RETURN RESULT IN FPA0
* PROCESS A NON NUMERIC FIRST CHARACTER
LB22F     jsr  LB3A2          ; SET CARRY IF NOT ALPHA
          bcc  LB284          ; BRANCH IF ALPHA CHARACTER
          cmpa #'.'           ; IS IT '.' (DECIMAL POINT)?
          beq  LB22C          ; CONVERT ASCII STRING TO FLOATING POINT
          cmpa #TOK_MINUS     ; MINUS TOKEN
          beq  LB27C          ; YES - GO PROCESS THE MINUS OPERATOR
          cmpa #TOK_PLUS      ; PLUS TOKEN
          beq  LB223          ; YES - GET ANOTHER CHARACTER
          cmpa #'"'           ; STRING DELIMITER?
          bne  LB24E          ; NO
LB244     ldx  CHARAD         ; CURRENT BASIC POINTER TO X
          jsr  LB518          ; SAVE STRING ON STRING STACK
LB249     ldx  COEFPT         ; * GET ADDRESS OF END OF STRING AND
          stx  CHARAD         ; * PUT BASIC'S INPUT POINTER THERE
          rts
LB24E     cmpa #TOK_NOT       ; NOT TOKEN?
          bne  LB25F          ; NO
* PROCESS THE NOT OPERATOR
          lda  #$5A           ; 'NOT' PRECEDENCE FLAG
          jsr  LB15A          ; PROCESS OPERATION FOLLOWING 'NOT'
          jsr  INTCNV         ; CONVERT FPA0 TO INTEGER IN ACCD
          coma                ; * 'NOT' THE INTEGER
          comb                ; *
          jmp  GIVABF         ; CONVERT ACCD TO FLOATING POINT (FPA0)
LB25F     inca                ; CHECK FOR TOKENS PRECEEDED BY $FF
          beq  LB290          ; IT WAS PRECEEDED BY $FF
LB262     bsr  LB26A          ; SYNTAX CHECK FOR A '('
          jsr  LB156          ; EVALUATE EXPRESSIONS WITHIN PARENTHESES AT
*         HIGHEST PRECEDENCE
LB267     ldb  #')'           ; SYNTAX CHECK FOR ')'
          fcb  SKP2           ; SKIP 2 BYTES
LB26A     ldb  #'('           ; SYNTAX CHECK FOR '('
          fcb  SKP2           ; SKIP 2 BYTES
LB26D     ldb  #','            ; SYNTAX CHECK FOR COMMA
LB26F     cmpb [CHARAD]       ; * COMPARE ACCB TO CURRENT INPUT
          bne  LB277          ; * CHARACTER - SYNTAX ERROR IF NO MATCH
          jmp  GETNCH         ; GET A CHARACTER FROM BASIC
LB277     ldb  #2*1           ; SYNTAX ERROR
          jmp  LAC46          ; JUMP TO ERROR HANDLER

* PROCESS THE MINUS (UNARY) OPERATOR
LB27C     lda  #$7D           ; MINUS (UNARY) PRECEDENCE FLAG
          jsr  LB15A          ; PROCESS OPERATION FOLLOWING 'UNARY' NEGATION
          jmp  LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA

* EVALUATE ALPHA EXPRESSION
LB284     jsr  LB357          ; FIND THE DESCRIPTOR ADDRESS OF A VARIABLE
LB287     stx  FPA0+2         ; SAVE DESCRIPTOR ADDRESS IN FPA0
          lda  VALTYP         ; TEST VARIABLE TYPE
          bne  LB222          ; RETURN IF STRING
          jmp  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0

* EVALUATING A SECONDARY TOKEN
LB290     jsr  GETNCH         ; GET AN INPUT CHARACTER (SECONDARY TOKEN)
          tfr  a,b            ; SAVE IT IN ACCB
          aslb                ; X2 & BET RID OF BIT 7
          jsr  GETNCH         ; GET ANOTHER INPUT CHARACTER
          cmpb #(NUM_SEC_FNS-1)*2 ; 29 SECONDARY FUNCTIONS - 1
          bls  LB29F          ; BRANCH IF COLOR BASIC TOKEN
          bra  LB277          ; SYNTAX ERROR
LB29F     pshs b              ; SAVE TOKEN OFFSET ON STACK
		  cmpb #(TOK_LEFT-$80)*2 ; CHECK FOR TOKEN WITH AN ARGUMENT
		  bcs  LB2C7          ; DO SECONDARIES STRING$ OR LESS
          cmpb #(TOK_INKEY-$80)*2 ; *
          bcc  LB2C9          ; * DO SECONDARIES $92 (INKEY$) OR >
          bsr  LB26A          ; SYNTAX CHECK FOR A '('
          lda  ,s             ; GET TOKEN NUMBER
* DO SECONDARIES (LEFT$, RIGHT$, MID$)
          jsr  LB156          ; EVALUATE FIRST STRING IN ARGUMENT
          bsr  LB26D          ; SYNTAX CHECK FOR A COMMA
          jsr  LB146          ; 'TM' ERROR IF NUMERIC VARiABLE
          puls a              ; GET TOKEN OFFSET FROM STACK
          ldu  FPA0+2         ; POINT U TO STRING DESCRIPTOR
          pshs u,a            ; SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS
          jsr  LB70B          ; EVALUATE FIRST NUMERIC ARGUMENT
          puls a              ; GET TOKEN OFFSET FROM STACK
          pshs b,a            ; SAVE TOKEN OFFSET AND NUMERIC ARGUMENT
          fcb  $8E            ; OP CODE OF ldx# - SKlP 2 BYTES
LB2C7     bsr  LB262          ; SYNTAX CHECK FOR A '('
LB2C9     puls b              ; GET TOKEN OFFSET
          ldx  COMVEC+8       ; GET SECONDARY FUNCTION JUMP TABLE ADDRESS
LB2CE     abx                 ; ADD IN COMMAND OFFSET
*
* HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION
          jsr  [,x]           ; GO DO AN SECONDARY FUNCTION
          jmp  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING

* LOGICAL OPERATOR 'OR' JUMPS HERE
LB2D4     fcb  SKP1LD         ; SKIP ONE BYTE - 'OR' FLAG = $4F

* LOGICAL OPERATOR 'AND' JUMPS HERE
LB2D5     clra                ; AND FLAG = 0
          sta  TMPLOC         ; AND/OR FLAG
          jsr  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
          std  CHARAC         ; TEMP SAVE ACCD
          jsr  LBC4A          ; MOVE FPA1 TO FPA0
          jsr  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
          tst  TMPLOC         ; CHECK AND/OR FLAG
          bne  LB2ED          ; BRANCH IF OR
          anda CHARAC         ; * 'AND' ACCD WITH FPA0 INTEGER
          andb ENDCHR         ; * STORED IN ENDCHR
          bra  LB2F1          ; CONVERT TO FP
LB2ED     ora  CHARAC         ; * 'OR' ACCD WITH FPA0 INTEGER
          orb  ENDCHR         ; * STORED IN CHARAC
LB2F1     jmp  GIVABF         ; CONVERT THE VALUE IN ACCD INTO A FP NUMBER

* RELATIONAL COMPARISON PROCESS HANDLER
LB2F4     jsr  LB148          ; 'TM' ERROR IF TYPE MISMATCH
          bne  LB309          ; BRANCH IF STRING VARIABLE
          lda  FP1SGN         ; * 'PACK' THE MANTISSA
          ora  #$7F           ; * SIGN OF FPA1 INTO
          anda FPA1           ; * BIT 7 OF THE
          sta  FPA1           ; * MANTISSA MS BYTE
          ldx  #FP1EXP        ; POINT X TO FPA1
          jsr  LBC96          ; COMPARE FPA0 TO FPA1
          bra  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON

* RELATIONAL COMPARISON OF STRINGS
LB309     clr  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
          dec  TRELFL         ; REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE
*                             ; DESIRED RELATIONAL COMPARISON DATA
          jsr  LB657          ; GET LENGTH AND ADDRESS OF STRING WHOSE
*                             ; DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0
          stb  STRDES         ; * SAVE LENGTH AND ADDRESS IN TEMPORARY
          stx  STRDES+2       ; * DESCRIPTOR (STRING B)
          ldx  FPA1+2         ; = RETURN LENGTH AND ADDRESS OF STRING
          jsr  LB659          ; = WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2
          lda  STRDES         ; LOAD ACCA WITH LENGTH OF STRING B
          pshs b              ; SAVE LENGTH A ON STACK
          suba ,s+            ; SUBTRACT LENGTH A FROM LENGTH B
          beq  LB328          ; BRANCH IF STRINGS OF EQUAL LENGTH
          lda  #1             ; ; TRUE FLAG
          bcc  LB328          ; TRUE IF LENGTH B > LENGTH A
          ldb  STRDES         ; LOAD ACCB WITH LENGTH B
          nega                ; SET FLAG = FALSE (1FF)
LB328     sta  FP0SGN         ; SAVE TRUE/FALSE FLAG
          ldu  STRDES+2       ; POINT U TO START OF STRING
          incb                ; COMPENSATE FOR THE DECB BELOW
* ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING
LB32D     decb                ; DECREMENT SHORTER STRING LENGTH
          bne  LB334          ; BRANCH IF ALL OF STRING NOT COMPARED
          ldb  FP0SGN         ; GET TRUE/FALSE FLAB
          bra  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
LB334     lda  ,x+            ; GET A BYTE FROM STRING A
          cmpa ,u+            ; COMPARE TO STRING B
          beq  LB32D          ; CHECK ANOTHER CHARACTER IF =
          ldb  #$FF           ; FALSE FLAG IF STRING A > B
          bcc  LB33F          ; BRANCH IF STRING A > STRING B
          negb                ; SET FLAG = TRUE

* DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0
LB33F     addb #1             ; CONVERT $FF,0,1 TO 0,1,2
          rolb                ; NOW IT'S 1,2,4 FOR > = <
          andb RELFLG         ; 'AND' THE ACTUAL COMPARISON WITH THE DESIRED -
COMPARISON
          beq  LB348          ; BRANCH IF FALSE (NO MATCHING BITS)
          ldb  #$FF           ; TRUE FLAG
LB348     jmp  LBC7C          ; CONVERT ACCB INTO FP NUMBER IN FPA0

* DIM
LB34B     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
DIM       ldb  #1             ; DIMENSION FLAG
          bsr  LB35A          ; SAVE ARRAY SPACE FOR THIS VARIABLE
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          bne  LB34B          ; KEEP DIMENSIONING IF NOT END OF LINE
          rts
* EVALUATE A VARIABLE - RETURN X AND
* VARPTR POINTING TO VARIABLE DESCRIPTOR
* EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO
* BYTES ARE THE VARIABLE NAME AND THE NEXT 5
* BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE
* FIRST BYTE OF VARlABLE NAME IS SET, THE
* VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF
* THE SECOND BYTE OF VARIABLE NAME IS SET, THE
* VARIABLE IS A STRING, OTHERWISE THE VARIABLE
* IS NUMERIC.
* IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS
* INSERTED INTO THE VARIABLE SPACE
LB357     clrb                ; DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
LB35A     stb  DIMFLG         ; SAVE ARRAY FLAG
* ENTRY POINT FOR DEF FN VARIABLE SEARCH
LB35C     sta  VARNAM         ; SAVE INPUT CHARACTER
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          bsr  LB3A2          ; SET CARRY IF NOT ALPHA
          lbcs LB277          ; SYNTAX ERROR IF NOT ALPHA
          clrb                ; DEFAULT 2ND VARIABLE CHARACTER TO ZERO
          stb  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
          jsr  GETNCH         ; GET ANOTHER CHARACTER FROM BASIC
          bcs  LB371          ; BRANCH IF NUMERIC (2ND CHARACTER IN
*                             ; VARIABLE MAY BE NUMERIC)
          bsr  LB3A2          ; SET CARRY IF NOT ALPHA
          bcs  LB37B          ; BRANCH IF NOT ALPHA
LB371     tfr  a,b            ; SAVE 2ND CHARACTER IN ACCB
* READ INPUT CHARACTERS UNTIL A NON ALPHA OR
* NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS
* IN VARIABLE NAME AFTER THE 1ST TWO
LB373     jsr  GETNCH         ; GET AN INPUT CHARACTER
          bcs  LB373          ; BRANCH IF NUMERIC
          bsr  LB3A2          ; SET CARRY IF NOT ALPHA
          bcc  LB373          ; BRANCH IF ALPHA
LB37B     cmpa #'$'           ; CHECK FOR A STRING VARIABLE
          bne  LB385          ; BRANCH IF IT IS NOT A STRING
          com  VALTYP         ; SET VARIABLE TYPE TO STRING
          addb #$80           ; SET BIT 7 OF 2ND CHARACTER (STRING)
          jsr  GETNCH         ; GET AN INPUT CHARACTER
LB385     stb  VARNAM+1       ; SAVE 2ND CHARACTER IN VARNAM+1
          ora  ARYDIS         ; OR IN THE ARRAY DISABLE FLAG - IF = $80,
*              ; DON'T SEARCH FOR VARIABLES IN THE ARRAYS
          suba #'('           ; IS THIS AN ARRAY VARIABLE?
          lbeq LB404          ; BRANCH IF IT IS
          clr  ARYDIS         ; RESET THE ARRAY DISABLE FLAG
          ldx  VARTAB         ; POINT X TO THE START OF VARIABLES
          ldd  VARNAM         ; GET VARIABLE IN QUESTION
LB395     cmpx ARYTAB         ; COMPARE X TO THE END OF VARIABLES
          beq  LB3AB          ; BRANCH IF END OF VARIABLES
          cmpd ,x++           ; * COMPARE VARIABLE IN QUESTION TO CURRENT
          beq  LB3DC          ; * VARIABLE AND BRANCH IF MATCH
          leax 5,x            ; = MOVE POINTER TO NEXT VARIABLE AND
          bra  LB395          ; = KEEP LOOKING

* SET CARRY IF NOT UPPER CASE ALPHA
LB3A2     cmpa #'A'           ; * CARRY SET IF < 'A'
          bcs  LB3AA          ; *
          suba #'Z'+1         ; =
*         suba #-('Z'+1)      ; = CARRY CLEAR IF <= 'Z'
          fcb  $80,$A5
LB3AA     rts
* PUT A NEW VARIABLE IN TABLE OF VARIABLES
LB3AB     ldx  #ZERO          ; POINT X TO ZERO LOCATION
          ldu  ,s             ; GET CURRENT RETURN ADDRESS
          cmpu #LB287         ; DID WE COME FROM 'EVALUATE ALPHA EXPR'?
          beq  LB3DE          ; YES - RETURN A ZERO VALUE
          ldd  ARYEND         ; * GET END OF ARRAYS ADDRESS AND
          std  V43            ; * SAVE IT AT V43
          addd #7             ; = ADD 7 TO END OF ARRAYS (EACH
          std  V41            ; = VARIABLE = 7 BYTES) AND SAVE AT V41
          ldx  ARYTAB         ; * GET END OF VARIABLES AND SAVE AT V47
          stx  V47            ; *
          jsr  LAC1E          ; MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT
*         TOP  OF VARIABLES
          ldx  V41            ; = GET NEW END OF ARRAYS AND SAVE IT
          stx  ARYEND         ; =
          ldx  V45            ; * GET NEW END OF VARIABLES AND SAVE IT
          stx  ARYTAB         ; *
          ldx  V47            ; GET OLD END OF VARIABLES
          ldd  VARNAM         ; GET NEW VARIABLE NAME
          std  ,x++           ; SAVE VARIABLE NAME
          clra                ; * ZERO OUT THE FP VALUE OF THE NUMERIC
          clrb                ; * VARIABLE OR THE LENGTH AND ADDRESS
          std  ,x             ; * OF A STRING VARIABLE
          std  2,x            ; *
          sta  4,x            ; *
LB3DC     stx  VARPTR         ; STORE ADDRESS OF VARIABLE VALUE
LB3DE     rts
*
LB3DF     fcb  $90,$80,$00,$00,$00 ; * FLOATING POINT -32768
*                             ; SMALLEST SIGNED TWO BYTE INTEGER
*
LB3E4     jsr  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
LB3E6     jsr  LB141          ; GO EVALUATE NUMERIC EXPRESSION
LB3E9     lda  FP0SGN         ; GET FPA0 MANTISSA SIGN
          bmi  LB44A          ; 'FC' ERROR IF NEGATIVE NUMBER


INTCNV    jsr  LB143          ; 'TM' ERROR IF STRING VARIABLE
          lda  FP0EXP         ; GET FPA0 EXPONENT
          cmpa #$90           ; * COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND
          bcs  LB3FE          ; * BRANCH IF FPA0 < 32768
          ldx  #LB3DF         ; POINT X TO FP VALUE OF -32768
          jsr  LBC96          ; COMPARE -32768 TO FPA0
          bne  LB44A          ; 'FC' ERROR IF NOT =
LB3FE     jsr  LBCC8          ; CONVERT FPA0 TO A TWO BYTE INTEGER
          ldd  FPA0+2         ; GET THE INTEGER
          rts
* EVALUATE AN ARRAY VARIABLE
LB404     ldd  DIMFLG         ; GET ARRAY FLAG AND VARIABLE TYPE
          pshs b,a            ; SAVE THEM ON STACK
          nop                 ; DEAD SPACE CAUSED BY 1.2 REVISION
          clrb                ; RESET DIMENSION COUNTER
LB40A     ldx  VARNAM         ; GET VARIABLE NAME
          pshs x,b            ; SAVE VARIABLE NAME AND DIMENSION COUNTER
          bsr  LB3E4          ; EVALUATE EXPRESSION (DIMENSlON LENGTH)
          puls b,x,y          ; PULL OFF VARIABLE NAME, DIMENSlON COUNTER,
*                             ; ARRAY FLAG
          stx  VARNAM         ; SAVE VARIABLE NAME AND VARIABLE TYPE
          ldu  FPA0+2         ; GET DIMENSION LENGTH
          pshs u,y            ; SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE
          incb                ; INCREASE DIMENSION COUNTER
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          cmpa #','           ; CHECK FOR ANOTHER DIMENSION
          beq  LB40A          ; BRANCH IF MORE
          stb  TMPLOC         ; SAVE DIMENSION COUNTER
          jsr  LB267          ; SYNTAX CHECK FOR A ')'
          puls a,b            ; * RESTORE VARIABLE TYPE AND ARRAY
          std  DIMFLG         ; * FLAG - LEAVE DIMENSION LENGTH ON STACK
          ldx  ARYTAB         ; GET START OF ARRAYS
LB42A     cmpx ARYEND         ; COMPARE TO END OF ARRAYS
          beq  LB44F          ; BRANCH IF NO MATCH FOUND
          ldd  VARNAM         ; GET VARIABLE IN QUESTION
          cmpd ,x             ; COMPARE TO CURRENT VARIABLE
          beq  LB43B          ; BRANCH IF =
          ldd  2,x            ; GET OFFSET TO NEXT ARRAY VARIABLE
          leax d,x            ; ADD TO CURRENT POINTER
          bra  LB42A          ; KEEP SEARCHING
LB43B     ldb  #2*9           ; 'REDIMENSIONED ARRAY' ERROR
          lda  DIMFLG         ; * TEST ARRAY FLAG - IF <>0 YOU ARE TRYING
          bne  LB44C          ; * TO REDIMENSION AN ARRAY
          ldb  TMPLOC         ; GET NUMBER OF DIMENSIONS IN ARRAY
          cmpb 4,x            ; COMPARE TO THIS ARRAYS DIMENSIONS
          beq  LB4A0          ; BRANCH IF =
LB447     ldb  #8*2           ; 'BAD SUBSCRIPT'
          fcb  SKP2           ; SKIP TWO BYTES
LB44A     ldb  #4*2           ; 'ILLEGAL FUNCTION CALL'
LB44C     jmp  LAC46          ; JUMP TO ERROR SERVICING ROUTINE

* INSERT A NEW ARRAY INTO ARRAY VARIABLES
* EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-
* SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE
* NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFINED
* AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LENGTH
* OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-
* ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-
* SION 2;... 4+N,5+N:LENGTH OF DIMENSION N.

LB44F     ldd  #5             ; * 5 BYTES/ARRAY ENTRY SAVE AT COEFPT
          std  COEFPT         ; *
          ldd  VARNAM         ; = GET NAME OF ARRAY AND SAVE IN
          std  ,x             ; = FIRST 2 BYTES OF DESCRIPTOR
          ldb  TMPLOC         ; GET NUMBER OF DIMENSIONS AND SAVE IN
          stb  4,x            ; * 5TH BYTE OF DESCRIPTOR
          jsr  LAC33          ; CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM
          stx  V41            ; TEMPoraRILY SAVE DESCRIPTOR ADDRESS
LB461     ldb  #11            ; * DEFAULT DIMENSION VALUE:X(10)
          clra                ; *
          tst  DIMFLG         ; = CHECK ARRAY FLAG AND BRANCH IF
          beq  LB46D          ; = NOT DIMENSIONING AN ARRAY
          puls a,b            ; GET DIMENSION LENGTH
          addd #1             ; ADD ONE (X(0) HAS A LENGTH OF ONE)
LB46D     std  5,x            ; SAVE LENGTH OF ARRAY DIMENSION
          bsr  LB4CE          ; MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH
*                             ; OF NEW DIMENSION
          std  COEFPT         ; TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE
          leax 2,x            ; BUMP POINTER UP TWO
          dec  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND BRANCH IF
          bne  LB461          ; * NOT DONE WITH ALL DIMENSIONS
          stx  TEMPTR         ; SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5)
          addd TEMPTR         ; ADD TOTAL SIZE OF NEW ARRAY
          lbcs LAC44          ; 'OM' ERROR IF > $FFFF
          tfr  d,x            ; SAVE END OF ARRAY IN X
          jsr  LAC37          ; MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY
          subd #STKBUF-5      ; SUBTRACT OUT THE (STACK BUFFER - 5)
          std  ARYEND         ; SAVE NEW END OF ARRAYS
          clra                ; ZERO = TERMINATOR BYTE
LB48C     leax -1,x           ; * STORE TWO TERMINATOR BYTES AT
          sta  5,x            ; * THE END OF THE ARRAY DESCRIPTOR
          cmpx TEMPTR         ; *
          bne  LB48C          ; *
          ldx  V41            ; GET ADDRESS OF START OF DESCRIPTOR
          lda  ARYEND         ; GET MSB OF END OF ARRAYS; LSB ALREADY THERE
          subd V41            ; SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR
          std  2,x            ; SAVE LENGTH OF (ARRAY AND DESCRIPTOR)
          lda  DIMFLG         ; * GET ARRAY FLAG AND BRANCH
          bne  LB4CD          ; * BACK IF DIMENSIONING
* CALCULATE POINTER TO CORRECT ELEMENT
LB4A0     ldb  4,x            ; GET THE NUMBER OF DIMENSIONS
          stb  TMPLOC         ; TEMPoraRILY SAVE
          clra                ; * INITIALIZE POINTER
          clrb                ; * TO ZERO
LB4A6     std  COEFPT         ; SAVE ACCUMULATED POINTER
          puls a,b            ; * PULL DIMENSION ARGUMENT OFF THE
          std  FPA0+2         ; * STACK AND SAVE IT
          cmpd 5,x            ; COMPARE TO STORED 'DIM' ARGUMENT
          bcc  LB4EB          ; 'BS' ERROR IF > = "DIM" ARGUMENT
          ldu  COEFPT         ; * GET ACCUMULATED POINTER AND
          beq  LB4B9          ; * BRANCH IF 1ST DIMENSION
          bsr  LB4CE          ; = MULTIPLY ACCUMULATED POINTER AND DIMENSION
          addd FPA0+2         ; = LENGTH AND ADD TO CURRENT ARGUMENT
LB4B9     leax 2,x            ; MOVE POINTER TO NEXT DIMENSION
          dec  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND
          bne  LB4A6          ; * BRANCH IF ANY DIMENSIONS LEFT
* MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE
          std  ,--s
          aslb
          rola                ; TIMES 2
          aslb
          rola                ; TIMES 4
          addd ,s++           ; TIMES 5
          leax d,x            ; ADD OFFSET TO START OF ARRAY
          leax 5,x            ; ADJUST POINTER FOR SIZE OF DESCRIPTOR
          stx  VARPTR         ; SAVE POINTER TO ARRAY VALUE
LB4CD     rts
* MULTIPLY 2 BYTE NUMBER IN 5,x BY THE 2 BYTE NUMBER
* IN COEFPT. RETURN RESULT IN ACCd, BS ERROR IF > $FFFF
LB4CE     lda  #16            ; 16 SHIFTS TO DO A MULTIPLY
          sta  V45            ; SHIFT COUNTER
          ldd  5,x            ; * GET SIZE OF DIMENSION
          std  BOTSTK         ; * AND SAVE IT
          clra                ; * ZERO
          clrb                ; * ACCD
LB4D8     aslb                ; = SHIFT ACCB LEFT
          rola                ; = ONE BIT
          bcs  LB4EB          ; 'BS' ERROR IF CARRY
          asl  COEFPT+1       ; * SHIFT MULTIPLICAND LEFT ONE
          rol  COEFPT         ; * BIT - ADD MULTIPLIER TO ACCUMULATOR
          bcc  LB4E6          ; * IF CARRY <> 0
          addd BOTSTK         ; ADD MULTIPLIER TO ACCD
          bcs  LB4EB          ; 'BS' ERROR IF CARRY (>$FFFF)
LB4E6     dec  V45            ; * DECREMENT SHIFT COUNTER
          bne  LB4D8          ; * IF NOT DONE
          rts
LB4EB     jmp  LB447          ; 'BS' ERROR
*
* MEM
* THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE
* BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK
* FOR WHICH MEM DOES NOT ALLOW.
*
MEM       tfr  s,d            ; PUT STACK POINTER INTO ACCD
          subd ARYEND         ; SUBTRACT END OF ARRAYS
          fcb  SKP1           ; SKIP ONE BYTE
*CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0
LB4F3     clra                ; CLEAR MS BYTE OF ACCD
* CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0
GIVABF    clr  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
          std  FPA0           ; SAVE ACCD IN TOP OF FACA
          ldb  #$90           ; EXPONENT REQUIRED IF THE TOP TWO BYTES
*         OF   FPA0 ARE TO BE TREATED AS AN INTEGER IN FPA0
          jmp  LBC82          ; CONVERT THE REST OF FPA0 TO AN INTEGER

* STR$
STR       jsr  LB143          ; 'TM' ERROR IF STRING VARIABLE
          ldu  #STRBUF+2      ; *CONVERT FP NUMBER TO ASCII STRING IN
          jsr  LBDDC          ; *THE STRING BUFFER
          leas 2,s            ; PURGE THE RETURN ADDRESS FROM THE STACK
          ldx  #STRBUF+1      ; *POINT X TO STRING BUFFER AND SAVE
          bra  LB518          ; *THE STRING IN THE STRING SPACE
* RESERVE ACCB BYTES OF STRING SPACE. RETURN START
* ADDRESS IN (X) AND FRESPC
LB50D     stx  V4D            ; SAVE X IN V4D
LB50F     bsr  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
LB511     stx  STRDES+2       ; SAVE NEW STRING ADDRESS
          stb  STRDES         ; SAVE LENGTH OF RESERVED BLOCK
          rts
LB516     leax -1,x           ; MOVE POINTER BACK ONE
* SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR
* EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.
* THE RESULTING STRING IS STORED IN THE STRING SPACE
* ONLY IF THE START OF THE STRING IS <= STRBUF+2
LB518     lda  #'"'           ; * INITIALIZE
          sta  CHARAC         ; * TERMINATORS
LB51A     sta  ENDCHR         ; * TO "
LB51E     leax 1,x            ; MOVE POINTER UP ONE
          stx  RESSGN         ; TEMPORARILY SAVE START OF STRING
          stx  STRDES+2       ; SAVE START OF STRING IN TEMP DESCRIPTOR
          ldb  #-1            ; INITIALIZE CHARACTER COUNTER TO - 1
LB526     incb                ; INCREMENT CHARACTER COUNTER
          lda  ,x+            ; GET CHARACTER
          beq  LB537          ; BRANCH IF END OF LINE
          cmpa CHARAC         ; * CHECK FOR TERMINATORS
          beq  LB533          ; * IN CHARAC AND ENDCHR
          cmpa ENDCHR         ; * DON'T MOVE POINTER BACK
          bne  LB526          ; * ONE IF TERMINATOR IS "MATCHED"
LB533     cmpa #'"'           ; = COMPARE CHARACTER TO STRING DELIMITER
          beq  LB539          ; = & DON'T MOVE POINTER BACK IF SO
LB537     leax -1,x           ; MOVE POINTER BACK ONE
LB539     stx  COEFPT         ; SAVE END OF STRING ADDRESS
          stb  STRDES         ; SAVE STRING LENGTH IN TEMP DESCRIPTOR
          ldu  RESSGN         ; GET INITlAL STRING START
          cmpu #STRBUF+2      ; COMPARE TO START OF STRING BUFFER
LB543     bhi  LB54C          ; BRANCH IF > START OF STRING BUFFER
          bsr  LB50D          ; GO RESERVE SPACE FOR THE STRING
          ldx  RESSGN         ; POINT X TO THE BEGINNING OF THE STRING
          jsr  LB645          ; MOVE (B) BYTES FROM (X) TO
*                             [FRESPC] - MOVE STRING DATA
* PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA
* ON THE STRING STACK. SET VARIABLE TYPE TO STRING
LB54C     ldx  TEMPPT         ; GET NEXT AVAILABLE STRING STACK DESCRIPTOR
          cmpx #LINHDR        ; COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF
          bne  LB558          ; FORMULA O.K.
          ldb  #15*2          ; STRING FORMULA TOO COMPLEX' ERROR
LB555     jmp  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
LB558     lda  STRDES         ; * GET LENGTH OF STRING AND SAVE IT
*         sta  ,x             ; * IN BYTE 0 OF DESCRIPTOR
          fcb  $A7,$00
          ldd  STRDES+2       ; = GET START ADDRESS OF ACTUAL STRING
          std  2,x            ; = AND SAVE IN BYTES 2,3 OF DESCRIPTOR
          lda  #$FF           ; * VARIABLE TYPE = STRING
          sta  VALTYP         ; * SAVE IN VARIABLE TYPE FLAG
          stx  LASTPT         ; = SAVE START OF DESCRIPTOR
          stx  FPA0+2         ; = ADDRESS IN LASTPT AND FPA0
          leax 5,x            ; 5 BYTES/STRING DESCRIPTOR
          stx  TEMPPT         ; NEXT AVAILABLE STRING VARIABLE DESCRIPTOR
          rts
* RESERVE ACCB BYTES IN STRING STORAGE SPACE
* RETURN WITH THE STARTING ADDRESS OF THE
* RESERVED STRING SPACE IN (X) AND FRESPC
LB56D     clr  GARBFL         ; CLEAR STRING REORGANIZATION FLAG
LB56F     clra                ; * PUSH THE LENGTH OF THE
          pshs b,a            ; * STRING ONTO THE STACK
          ldd  STRTAB         ; GET START OF STRING VARIABLES
          subd ,s+            ; SUBTRACT STRING LENGTH
          cmpd FRETOP         ; COMPARE TO START OF STRING STORAGE
          bcs  LB585          ; IF BELOW START, THEN REORGANIZE
          std  STRTAB         ; SAVE NEW START OF STRING VARIABLES
          ldx  STRTAB         ; GET START OF STRING VARIABLES
          leax 1,x            ; ADD ONE
          stx  FRESPC         ; SAVE START ADDRESS OF NEWLY RESERVED SPACE
          puls b,pc           ; RESTORE NUMBER OF BYTES RESERVED AND RETURN
LB585     ldb  #2*13          ; OUT OF STRING SPACE' ERROR
          com  GARBFL         ; TOGGLE REORGANIZATiON FLAG
          beq  LB555          ; ERROR IF FRESHLY REORGANIZED
          bsr  LB591          ; GO REORGANIZE STRING SPACE
          puls b              ; GET BACK THE NUMBER OF BYTES TO RESERVE
          bra  LB56F          ; TRY TO RESERVE ACCB BYTES AGAIN
* REORGANIZE THE STRING SPACE
LB591     ldx  MEMSIZ         ; GET THE TOP OF STRING SPACE
LB593     stx  STRTAB         ; SAVE TOP OF UNORGANIZED STRING SPACE
          clra                ; * ZERO OUT ACCD
          clrb                ; * AND RESET VARIABLE
          std  V4B            ; * POINTER TO 0
          ldx  FRETOP         ; POINT X TO START OF STRING SPACE
          stx  V47            ; SAVE POINTER IN V47
          ldx  #STRSTK        ; POINT X TO START OF STRING DESCRIPTOR STACK
LB5A0     cmpx TEMPPT         ; COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR
          beq  LB5A8          ; BRANCH IF TOP OF STRING STACK
          bsr  LB5D8          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
          bra  LB5A0          ; KEEP CHECKING
LB5A8     ldx  VARTAB         ; GET THE END OF BASIC PROGRAM
LB5AA     cmpx ARYTAB         ; COMPARE TO END OF VARIABLES
          beq  LB5B2          ; BRANCH IF AT TOP OF VARIABLES
          bsr  LB5D2          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
          bra  LB5AA          ; KEEP CHECKING VARIABLES
LB5B2     stx  V41            ; SAVE ADDRESS OF THE END OF VARIABLES
LB5B4     ldx  V41            ; GET CURRENT ARRAY POINTER
LB5B6     cmpx ARYEND         ; COMPARE TO THE END OF ARRAYS
          beq  LB5EF          ; BRANCH IF AT END OF ARRAYS
          ldd  2,x            ; GET LENGTH OF ARRAY AND DESCRIPTOR
          addd V41            ; * ADD TO CURRENT ARRAY POINTER
          std  V41            ; * AND SAVE IT
          lda  1,x            ; GET 1ST CHARACTER OF VARIABLE NAME
          bpl  LB5B4          ; BRANCH IF NUMERIC ARRAY
          ldb  4,x            ; GET THE NUMBER OF DIMENSIONS IN THIS ARRAY
          aslb                ; MULTIPLY BY 2
          addb #5             ; ADD FIVE BYTES (VARIABLE NAME, ARRAY
*                             ; LENGTH, NUMBER DIMENSIONS)
          abx                 ; X NOW POINTS TO START OF ARRAY ELEMENTS
LB5CA     cmpx V41            ; AT END OF THIS ARRAY?
          beq  LB5B6          ; YES - CHECK FOR ANOTHER
          bsr  LB5D8          ; CHECK FOR STRING LOCATED IN
*                             ; UNORGANIZED STRING SPACE
          bra  LB5CA          ; KEEP CHECKING ELEMENTS IN THIS ARRAY
LB5D2     lda  1,x            ; GET F1RST BYTE OF VARIABLE NAME
          leax 2,x            ; MOVE POINTER TO DESCRIPTOR
          bpl  LB5EC          ; BRANCH IF VARIABLE IS NUMERIC
* SEARCH FOR STRING - ENTER WITH X POINTING TO
* THE STRING DESCRIPTOR. IF STRING IS STORED
* BETWEEN V47 AND STRTAb, SAVE DESCRIPTOR POINTER
* IN V4B AND RESET V47 TO STRING ADDRESS
LB5D8     ldb  ,x             ; GET THE LENGTH OF THE STRING
          beq  LB5EC          ; BRANCH IF NULL - NO STRING
          ldd  2,x            ; GET STARTING ADDRESS OF THE STRING
          cmpd STRTAB         ; COMPARE TO THE START OF STRING VARIABLES
          bhi  LB5EC          ; BRANCH IF THIS STRING IS STORED IN
*              ; THE STRING VARIABLES
          cmpd V47            ; COMPARE TO START OF STRING SPACE
          bls  LB5EC          ; BRANCH IF NOT STORED IN THE STRING SPACE
          stx  V4B            ; SAVE VARIABLE POINTER IF STORED IN STRING SPACE
          std  V47            ; SAVE STRING STARTING ADDRESS
LB5EC     leax 5,x            ; MOVE TO NEXT VARIABLE DESCRIPTOR
LB5EE     rts
LB5EF     ldx  V4B            ; GET ADDRESS OF THE DESCRIPTOR FOR THE
*              ; STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN
*              ; THE UNORGANIZED STRING SPACE
          beq  LB5EE          ; BRANCH IF NONE FOUND AND REORGANIZATION DONE
          clra                ; CLEAR MS BYTE OF LENGTH
          ldb  ,x             ; GET LENGTH OF STRING
          decb                ; SUBTRACT ONE
          addd V47            ; ADD LENGTH OF STRING TO ITS STARTING ADDRESS
          std  V43            ; SAVE AS MOVE STARTING ADDRESS
          ldx  STRTAB         ; POINT X TO THE START OF orgANIZED STRING VARIABLES
          stx  V41            ; SAVE AS MOVE ENDING ADDRESS
          jsr  LAC20          ; MOVE STRING FROM CURRENT POSITION TO THE
*              ; TOP OF UNORGANIZED STRING SPACE
          ldx  V4B            ; POINT X TO STRING DESCRIPTOR
          ldd  V45            ; * GET NEW STARTING ADDRESS OF STRING AND
          std  2,x            ; * SAVE IT IN DESCRIPTOR
          ldx  V45            ; GET NEW TOP OF UNORGANIZED STRING SPACE
          leax -1,x           ; MOVE POINTER BACK ONE
          jmp  LB593          ; JUMP BACK AND REORGANIZE SOME MORE


LB60F     ldd  FPA0+2         ; * GET DESCRIPTOR ADDRESS OF STRING A
          pshs b,a            ; * AND SAVE IT ON THE STACK
          jsr  LB223          ; GET DESCRIPTOR ADDRESS OF STRING B
          jsr  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
          puls x              ; * POINT X TO STRING A DESCRIPTOR
          stx  RESSGN         ; * ADDRESS AND SAVE IT IN RESSGN
          ldb  ,x             ; GET LENGTH OF STRING A
          ldx  FPA0+2         ; POINT X TO DESCRIPTOR OF STRING B
          addb ,x             ; ADD LENGTH OF STRING B TO STR1NG A
          bcc  LB62A          ; BRANCH IF LENGTH < 256
          ldb  #2*14          ; 'STRING TOO LONG' ERROR IF LENGTH > 255
          jmp  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
LB62A     jsr  LB50D          ; RESERVE ROOM IN STRING SPACE FOR NEW STRING
          ldx  RESSGN         ; GET DESCRIPTOR ADDRESS OF STRING A
          ldb  ,x             ; GET LENGTH OF STRING A
          bsr  LB643          ; MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE
          ldx  V4D            ; GET DESCRIPTOR ADDRESS OF STRING B
          bsr  LB659          ; GET LENGTH AND ADDRESS OF STRING B
          bsr  LB645          ; MOVE STRING B INTO REST OF RESERVED BUFFER
          ldx  RESSGN         ; POINT X TO DESCRIPTOR OF STRING A
          bsr  LB659          ; DELETE STRING A IF LAST STRING ON STRING STACK
          jsr  LB54C          ; PUT STRING DESCRIPTOR ON THE STRING STACK
          jmp  LB168          ; BRANCH BACK TO EXPRESSION EVALUATION

* MOVE (B) BYTES FROM 2,x TO FRESPC
LB643     ldx  2,x            ; POINT X TO SOURCE ADDRESS
LB645     ldu  FRESPC         ; POINT U TO DESTINATION ADDRESS
          incb                ; COMPENSATION FOR THE DECB BELOW
          bra  LB64E          ; GO MOVE THE BYTES
* MOVE B BYTES FROM (X) TO (U)
LB64A     lda  ,x+            ; * GET A SOURCE BYTE AND MOVE IT
          sta  ,u+            ; * TO THE DESTINATION
LB64E     decb                ; DECREMENT BYTE COUNTER
          bne  LB64A          ; BRANCH IF ALL BYTES NOT MOVED
          stu  FRESPC         ; SAVE ENDING ADDRESS IN FRESPC
          rts
* RETURN LENGTH (ACCB) AND ADDRESS (X) OF
* STRING WHOSE DESCRIPTOR IS IN FPA0+2
* DELETE THE STRING IF IT IS THE LAST ONE
* PUT ON THE STRING STACK. REMOVE STRING FROM STRING
* SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.
LB654     jsr  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
LB657     ldx  FPA0+2         ; GET ADDRESS OF SELECTED STRING DESCRIPTOR
LB659     ldb  ,x             ; GET LENGTH OF STRING
          bsr  LB675          ; * CHECK TO SEE IF THIS STRING DESCRIPTOR WAS
          bne  LB672          ; * THE LAST ONE PUT ON THE STRING STACK AND
*                             ; * BRANCH IF NOT
          ldx  5+2,x          ; GET START ADDRESS OF STRING JUST REMOVED
          leax -1,x           ; MOVE POINTER DOWN ONE
          cmpx STRTAB         ; COMPARE TO START OF STRING VARIABLES
          bne  LB66F          ; BRANCH IF THIS STRING IS NOT AT THE BOTTOM
*                             ; OF STRING VARIABLES
          pshs b              ; SAVE LENGTH; ACCA WAS CLEARED
          addd STRTAB         ; * ADD THE LENGTH OF THE JUST REMOVED STRING
          std  STRTAB         ; * TO THE START OF STRING VARIABLES - THIS WILL
*                             ; * REMOVE THE STRING FROM THE STRING SPACE
          puls b              ; RESTORE LENGTH
LB66F     leax 1,x            ; ADD ONE TO POINTER
          rts
LB672     ldx  2,x            ; *POINT X TO ADDRESS OF STRING NOT
          rts                 ; *ON THE STRING STACK
* REMOVE STRING FROM STRING STACK. ENTER WITH X
* POINTING TO A STRING DESCRIPTOR - DELETE THE
* STRING FROM STACK IF IT IS ON TOP OF THE
* STACK. IF THE STRING IS DELETEd, SET THE ZERO FLAG
LB675     cmpx LASTPT         ; *COMPARE TO LAST USED DESCRIPTOR ADDRESS
          bne  LB680          ; *ON THE STRING STACK, RETURN IF DESCRIPTOR
*                             ; *ADDRESS NOT ON THE STRING STACK
          stx  TEMPPT         ; SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE
          leax -5,x           ; * MOVE LAST USED DESCRIPTOR BACK 5 BYTES
          stx  LASTPT         ; * AND SAVE AS THE LAST USED DESCRIPTOR ADDR
          clra                ; SET ZERO FLAG
LB680     rts

* LEN
LEN       bsr  LB686          ; POINT X TO PROPER STRING AND GET LENGTH
LB683     jmp  LB4F3          ; CONVERT ACCB TO FP NUMBER IN FPA0
* POINT X TO STRING ADDRESS LOAD LENGTH INTO
* ACCB. ENTER WITH THE STRING DESCRIPTOR IN
* BOTTOM TWO BYTES OF FPA0
LB686     bsr  LB654          ; GET LENGTH AND ADDRESS OF STRING
          clr  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
          tstb                ; SET FLAGS ACCORDING TO LENGTH
          rts

* CHR$
CHR       jsr  LB70E          ; CONVERT FPA0 TO AN INTEGER IN ACCD
LB68F     ldb  #1             ; * RESERVE ONE BYTE IN
          jsr  LB56D          ; * THE STRING SPACE
          lda  FPA0+3         ; GET ASCII STRING VALUE
          jsr  LB511          ; SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR
          sta  ,x             ; SAVE THE STRING (IT'S ONLY ONE BYTE)
LB69B     leas 2,s            ; PURGE THE RETURN ADDRESS OFF OF THE STACK
LB69D     jmp  LB54C          ; PUT TEMP DESCRIPTOR DATA ONTO STRING STACK


ASC       bsr  LB6A4          ; PUT 1ST CHARACTER OF STRING INTO ACCB
          bra  LB683          ; CONVERT ACCB INTO FP NUMBER IN FPA0
LB6A4     bsr  LB686          ; POINT X TO STRING DESCRIPTOR
          beq  LB706          ; 'FC' ERROR IF NULL STRING
          ldb  ,x             ; GET FIRST BYTE OF STRING
          rts


LEFT      bsr  LB6F5          ; GET ARGUMENTS FROM STACK
LB6AD     clra                ; CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$
LB6AE     cmpb ,x             ; * COMPARE LENGTH PARAMETER TO LENGTH OF
          bls  LB6B5          ; * STRING AND BRANCH IF LENGTH OF STRING
*                             ; >= LENGTH PARAMETER
          ldb  ,x             ; USE LENGTH OF STRING OTHERWISE
          clra                ; CLEAR STRING POINTER OFFSET (0 FOR LEFT$)
LB6B5     pshs b,a            ; PUSH PARAMETERS ONTO STACK
          jsr  LB50F          ; RESERVE ACCB BYTES IN THE STRING SPACE
          ldx  V4D            ; POINT X TO STRING DESCRIPTOR
          bsr  LB659          ; GET ADDRESS OF OLD STRING (X=ADDRESS)
          puls b              ; * PULL STRING POINTER OFFSET OFF OF THE STACK
          abx                 ; * AND ADD IT TO STRING ADDRESS
          puls b              ; PULL LENGTH PARAMETER OFF OF THE STACK
          jsr  LB645          ; MOVE ACCB BYTES FROM (X) TO [FRESPC]
          bra  LB69D          ; PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK

* RIGHT$
RIGHT     bsr  LB6F5          ; GET ARGUMENTS FROM STACK
          suba ,x             ; ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING
          nega                ; NOW ACCA = LENGTH OF OLD STRING
          bra  LB6AE          ; PUT NEW STRING IN THE STRING SPACE

* MID$
MID       ldb  #$FF           ; * GET DEFAULT VALUE OF LENGTH AND
          stb  FPA0+3         ; * SAVE IT IN FPA0
          jsr  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
          cmpa #')'           ; ARGUMENT DELIMITER?
          beq  LB6DE          ; YES - NO LENGTH PARAMETER GIVEN
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          bsr  LB70B          ; EVALUATE NUMERIC EXPRESSION (LENGTH)
LB6DE     bsr  LB6F5          ; GET ARGUMENTS FROM STACK
          beq  LB706          ; 'FC' ERROR IF NULL STRING
          clrb                ; CLEAR LENGTH COUNTER (DEFAULT VALUE)
          deca                ; *SUOTRACT ONE FROM POSITION PARAMETER (THESE
          cmpa ,x             ; *ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE)
*                             ; *AND COMPARE IT TO LENGTH OF OLD STRING
          bcc  LB6B5          ; IF POSITION > LENGTH OF OLD STRING, THEN NEW
*                             ; STRING WILL BE A NULL STRING
          tfr  a,b            ; SAVE ABSOLUTE POSITION PARAMETER IN ACCB
          subb ,x             ; ACCB=POSITION-LENGTH OF OLD STRING
          negb                ; NOW ACCB=LENGTH OF OLDSTRING-POSITION
          cmpb FPA0+3         ; *IF THE AMOUNT OF OLD STRING TO THE RIGHT OF
          bls  LB6B5          ; *POSITION IS <= THE LENGTH PARAMETER, BRANCH AND
* USE ALL OF THE STRING TO THE RIGHT OF THE POSITION
* INSTEAD OF THE LENGTH PARAMETER
          ldb  FPA0+3         ; GET LENGTH OF NEW STRING
          bra  LB6B5          ; PUT NEW STRING IN STRING SPACE
* DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC
* ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK
LB6F5     jsr  LB267          ; SYNTAX CHECK FOR A ")"
          ldu  ,s             ; LOAD THE RETURN ADDRESS INTO U REGISTER
          ldx  5,s            ; * GET ADDRESS OF STRING AND
          stx  V4D            ; * SAVE IT IN V4D
          lda  4,s            ; = PUT LENGTH OF STRING IN
          ldb  4,s            ; = BOTH ACCA AND ACCB
          leas 7,s            ; REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK
          tfr  u,pc           ; JUMP TO ADDRESS IN U REGISTER
LB706     jmp  LB44A          ; 'ILLEGAL FUNCTION CALL'
* EVALUATE AN EXPRESSION - RETURN AN INTEGER IN
* ACCB - 'FC' ERROR IF EXPRESSION > 255
LB709     jsr  GETNCH         ; GET NEXT BASIC INPUT CHARACTER
LB70B     jsr  LB141          ; EVALUATE A NUMERIC EXPRESSION
LB70E     jsr  LB3E9          ; CONVERT FPA0 TO INTEGER IN ACCD
          tsta                ; TEST MS BYTE OF INTEGER
          bne  LB706          ; 'FC' ERROR IF EXPRESSION > 255
          jmp  GETCCH         ; GET CURRENT INPUT CHARACTER FROM BASIC

* VAL
VAL       jsr  LB686          ; POINT X TO STRING ADDRESS
          lbeq LBA39          ; IF NULL STRING SET FPA0
          ldu  CHARAD         ; SAVE INPUT POINTER IN REGISTER U
          stx  CHARAD         ; POINT INPUT POINTER TO ADDRESS OF STRING
          abx                 ; MOVE POINTER TO END OF STRING TERMINATOR
          lda  ,x             ; GET LAST BYTE OF STRING
          pshs u,x,a          ; SAVE INPUT POINTER, STRING TERMINATOR
*         ADDRESS AND CHARACTER
          clr  ,x             ; CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION
          jsr  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
          jsr  LBD12          ; CONVERT AN ASCII STRING TO FLOATING POINT
          puls a,x,u          ; RESTORE CHARACTERS AND POINTERS
          sta  ,x             ; REPLACE STRING TERMINATOR
          stu  CHARAD         ; RESTORE INPUT CHARACTER
          rts

LB734     bsr  LB73D          ; * EVALUATE AN EXPRESSION, RETURN
          stx  BINVAL         ; * THE VALUE IN X; STORE IT IN BINVAL
LB738     jsr  LB26D          ; SYNTAX CHECK FOR A COMMA
          bra  LB70B          ; EVALUATE EXPRESSION IN RANGE 0 <= X < 256
* EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF

LB73D     jsr  LB141          ; EVALUATE NUMERIC EXPRESSION
LB740     lda  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
          bmi  LB706          ; ILLEGAL FUNCTION CALL' IF NEGATIVE
          lda  FP0EXP         ; GET EXPONENT OF FPA0
          cmpa #$90           ; COMPARE TO LARGEST POSITIVE INTEGER
          bhi  LB706          ; ILLEGAL FUNCTION CALL' IF TOO LARGE
          jsr  LBCC8          ; SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0
          ldx  FPA0+2         ; LOAD X WITH LOWER TWO BYTES OF FPA0
          rts

* PEEK
PEEK      bsr  LB740          ; CONVERT FPA0 TO INTEGER IN REGISTER X
          ldb  ,x             ; GET THE VALUE BEING 'PEEK'ED
          jmp  LB4F3          ; CONVERT ACCB INTO A FP NUMBER

* POKE
POKE      bsr  LB734          ; EVALUATE 2 EXPRESSIONS
          ldx  BINVAL         ; GET THE ADDRESS TO BE 'POKE'ED
          stb  ,x             ; STORE THE DATA IN THAT ADDRESS
          rts

* LIST
LIST      pshs cc             ; SAVE ZERO FLAG ON STACK
          jsr  LAF67          ; CONVERT DECIMAL LINE NUMBER TO BINARY
          jsr  LAD01          ; * FIND RAM ADDRESS OF THAT LINE NUMBER AND
          stx  LSTTXT         ; * SAVE IT IN LSTTXT
          puls cc             ; GET ZERO FLAG FROM STACK
          beq  LB784          ; BRANCH IF END OF LINE
          jsr  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
          beq  LB789          ; BRANCH IF END OF LINE
          cmpa #TOK_MINUS     ; MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?)
          bne  LB783          ; NO - RETURN
          jsr  GETNCH         ; GET NEXT CHARACTER FROM BASIC
          beq  LB784          ; BRANCH IF END OF LINE
          jsr  LAF67          ; GET ENDING LINE NUMBER
          beq  LB789          ; BRANCH IF LEGAL LINE NUMBER
LB783     rts
* LIST THE ENTIRE PROGRAM
LB784     ldu  #$FFFF         ; * SET THE DEFAULT ENDING LINE NUMBER
          stu  BINVAL         ; * TO $FFFF
LB789     ldx  LSTTXT         ; POINT X TO STARTING LINE ADDRESS
LB78D     jsr  LB95C          ; MOVE CURSOR TO START OF A NEW LINE
          jsr  LA549          ; CHECK FOR A BREAK OR PAUSE
          ldd  ,x             ; GET ADDRESS OF NEXT BASIC LINE
          bne  LB79F          ; BRANCH IF NOT END OF PROGRAM
LB797
          tst  DEVNUM		  ; null value when screen as output
		  bne  LB783          ; return from call for disk following code execution
		  leas 2,s            ; PURGE RETURN ADDRESS FROM THE STACK		  
		  jmp  LAC73          ; RETURN TO BASIC'S MAIN INPUT LOOP
LB79F     stx  LSTTXT         ; SAVE NEW STARTING LINE ADDRESS
          ldd  2,x            ; * GET THE LINE NUMBER OF THIS LINE AND
          cmpd BINVAL         ; * COMPARE IT TO ENDING LINE NUMBER
          bhi  LB797          ; EXIT IF LINE NUMBER > ENDING LINE NUMBER
          jsr  LBDCC          ; PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL
          jsr  LB9AC          ; SEND A SPACE TO CONSOLE OUT
          ldx  LSTTXT         ; GET RAM ADDRESS OF THIS LINE
          bsr  LB7C2          ; UNCRUNCH A LINE
          ldx  [LSTTXT]       ; POINT X TO START OF NEXT LINE
          ldu  #LINBUF+1      ; POINT U TO BUFFER FULL OF UNCRUNCHED LINE
LB7B9     lda  ,u+            ; GET A BYTE FROM THE BUFFER
          beq  LB78D          ; BRANCH IF END OF BUFFER
          jsr  LB9B1          ; SEND CHARACTER TO CONSOLE OUT
          bra  LB7B9          ; GET ANOTHER CHARACTER

* UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
LB7C2     leax 4,x            ; MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER
          ldy  #LINBUF+1      ; UNCRUNCH LINE INTO LINE INPUT BUFFER
LB7CB     lda  ,x+            ; GET A CHARACTER
          beq  LB820          ; BRANCH IF END OF LINE
          bmi  LB7E6          ; BRANCH IF IT'S A TOKEN
          cmpa #':'           ; CHECK FOR END OF SUB LINE
          bne  LB7E2          ; BRNCH IF NOT END OF SUB LINE
          ldb  ,x             ; GET CHARACTER FOLLOWING COLON
          cmpb #TOK_ELSE      ; TOKEN FOR ELSE?
          beq  LB7CB          ; YES - DON'T PUT IT IN BUFFER
          cmpb #TOK_SNGL_Q    ; TOKEN FOR REMARK?
          beq  LB7CB          ; YES - DON'T PUT IT IN BUFFER
          fcb  SKP2           ; SKIP TWO BYTES
LB7E0     lda  #'!'           ; EXCLAMATION POINT
LB7E2     bsr  LB814          ; PUT CHARACTER IN BUFFER
          bra  LB7CB          ; GET ANOTHER CHARACTER

LB7E6     ldu  #COMVEC-10     ; FIRST DO COMMANDS
          cmpa #$FF           ; CHECK FOR SECONDARY TOKEN
          bne  LB7F1          ; BRANCH IF NON SECONDARY TOKEN
          lda  ,x+            ; GET SECONDARY TOKEN
          leau 5,u            ; BUMP IT UP TO SECONDARY FUNCTIONS
LB7F1     anda #$7F           ; MASK OFF BIT 7 OF TOKEN
LB7F3     leau 10,u           ; MOVE TO NEXT COMMAND TABLE
          tst  ,u             ; IS THIS TABLE ENABLED?
          beq  LB7E0          ; NO - ILLEGAL TOKEN
          suba ,u             ; SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER
          bpl  LB7F3          ; BRANCH IF TOKEN NOT IN THIS TABLE
          adda ,u             ; RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE
          ldu  1,u            ; POINT U TO COMMAND DICTIONARY TABLE
LB801     deca                ; DECREMENT TOKEN NUMBER
          bmi  LB80A          ; BRANCH IF THIS IS THE CORRECT TOKEN
* SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN
LB804     tst  ,u+            ; GRAB A BYTE
          bpl  LB804          ; BRANCH IF BIT 7 NOT SET
          bra  LB801          ; GO SEE IF THIS IS THE CORRECT TOKEN
LB80A     lda  ,u             ; GET A CHARACTER FROM DICTIONARY TABLE
          bsr  LB814          ; PUT CHARACTER IN BUFFER
          tst  ,u+            ; CHECK FOR START OF NEXT TOKEN
          bpl  LB80A          ; BRANCH IF NOT DONE WITH THIS TOKEN
          bra  LB7CB          ; GO GET ANOTHER CHARACTER
LB814     cmpy #LINBUF+LBUFMX ; TEST FOR END OF LINE INPUT BUFFER
          bcc  LB820          ; BRANCH IF AT END OF BUFFER
          anda #$7F           ; MASK OFF BIT 7
          sta  ,y+            ; * SAVE CHARACTER IN BUFFER AND
          clr  ,y             ; * CLEAR NEXT CHARACTER SLOT IN BUFFER
LB820     rts
*
* CRUNCH THE LINE THAT THE INPUT POINTER IS
* POINTING TO INTO THE LINE INPUT BUFFER
* RETURN LENGTH OF CRUNCHED LINE IN ACCD
*
LB821     ldx  CHARAD         ; GET BASIC'S INPUT POINTER ADDRESS
          ldu  #LINBUF        ; POINT X TO LINE INPUT BUFFER
LB829     clr  V43            ; CLEAR ILLEGAL TOKEN FLAG
          clr  V44            ; CLEAR DATA FLAG
LB82D     lda  ,x+            ; GET INPUT CHAR
          beq  LB852          ; BRANCH IF END OF LINE
          tst  V43            ; * CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT
          beq  LB844          ; * PROCESSING AN ILLEGAL TOKEN
          jsr  LB3A2          ; SET CARRY IF NOT UPPER CASE ALPHA
          bcc  LB852          ; BRANCH IF UPPER CASE ALPHA
          cmpa #'0'            ; * DON'T CRUNCH ASCII NUMERIC CHARACTERS
          blo  LB842          ; * BRANCH IF NOT NUMERIC
          cmpa #'9'           ; *
          bls  LB852          ; * BRANCH IF NUMERIC
* END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC
LB842     clr  V43            ; CLEAR ILLEGAL TOKEN FLAG
LB844     cmpa #SPACE         ; SPACE?
          beq  LB852          ; DO NOT REMOVE SPACES
          sta  V42            ; SAVE INPUT CHARACTER AS SCAN DELIMITER
          cmpa #'"'           ; CHECK FOR STRING DELIMITER
          beq  LB886          ; BRANCH IF STRING
          tst  V44            ; * CHECK DATA FLAG AND BRANCH IF CLEAR
          beq  LB86B          ; * DO NOT CRUNCH DATA
LB852     sta  ,u+            ; SAVE CHARACTER IN BUFFER
          beq  LB85C          ; BRANCH IF END OF LINE
          cmpa #':'           ; * CHECK FOR END OF SUBLINE
          beq  LB829          ; * AND RESET FLAGS IF END OF SUBLINE
LB85A     bra  LB82D          ; GO GET ANOTHER CHARACTER
LB85C     clr  ,u+            ; * DOUBLE ZERO AT END OF LINE
          clr  ,u+            ; *
          tfr  u,d            ; SAVE ADDRESS OF END OF LINE IN ACCD
          subd #LINHDR        ; LENGTH OF LINE IN ACCD
          ldx  #LINBUF-1      ; * SET THE INPUT POINTER TO ONE BEFORE
          stx  CHARAD         ; * THE START OF THE CRUNCHED LINE
          rts                 ; EXIT 'CRUNCH'
LB86B     cmpa #'?'           ; CHECK FOR "?" - PRINT ABBREVIATION
          bne  LB873          ; BRANCH IF NOT PRINT ABBREVIATION
          lda  #TOK_PRINT     ; * GET THE PRINT TOKEN AND SAVE IT
          bra  LB852          ; * IN BUFFER
LB873     cmpa #$27           ; #''' APOSTROPHE IS SAME AS REM
          bne  LB88A          ; BRANCH IF NOT REMARK
          ldd  #$3A00+TOK_SNGL_Q ; COLON, REM TOKEN
          std  ,u++           ; SAVE IN BUFFER
LB87C     clr  V42            ; SET DELIMITER = 0 (END OF LINE)
LB87E     lda  ,x+            ; SCAN TILL WE MATCH [V42]
          beq  LB852          ; BRANCH IF END OF LINE
          cmpa V42            ; DELIMITER?
          beq  LB852          ; BRANCH OUT IF SO
LB886     sta  ,u+            ; DON'T CRUNCH REMARKS OR STRINGS
          bra  LB87E          ; GO GET MORE STRING OR REMARK
LB88A     cmpa #'0'            ; * LESS THAN ASCII ZERO?
          bcs  LB892          ; * BRANCH IF SO
          cmpa #';'+1         ; = CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON
          bcs  LB852          ; = AND INSERT IN BUFFER IF SO
LB892     leax -1,x           ; MOVE INPUT POINTER BACK ONE
          pshs u,x            ; SAVE POINTERS TO INPUT STRING, OUTPUT STRING
          clr  V41            ; TOKEN FLAG 0 = COMMANd, FF = SECONDARY
          ldu  #COMVEC-10     ; POINT U TO COMMAND INTERPRETATION
*                             ; TABLE FOR BASIC - 10
LB89B     clr  V42            ; INITIALIZE V42 AS TOKEN COUNTER
LB89D     leau 10,u           ; MOVE TO NEXT COMMAND INTERPRETATION TABLE
          lda  ,u             ; GET NUMBER OF COMMANDS
          beq  LB8D4          ; GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE
          ldy  1,u            ; POINT Y TO COMMAND DICTIONARY TABLE
LB8A6     ldx  ,s             ; GET POINTER TO INPUT STRING
LB8A8     ldb  ,y+            ; GET A BYTE FROM DICTIONARY TABLE
          subb ,x+            ; SUBTRACT INPUT CHARACTER
          beq  LB8A8          ; LOOP IF SAME
          cmpb #$80           ; LAST CHAR IN RESERVED WORD TABLE HAD
*                             ; BIT 7 SET, SO IF WE HAVE $80 HERE
*                             ; THEN IT IS A GOOD COMPARE
          bne  LB8EA          ; BRANCH IF NO MATCH - CHECK ANOTHER COMMAND
          leas 2,s            ; DELETE OLD INPUT POINTER FROM STACK
          puls u              ; GET POINTER TO OUTPUT STRING
          orb  V42            ; OR IN THE TABLE POSITION TO MAKE THE TOKEN
*                             ; - NOTE THAT B ALREADY HAD $80 IN IT -
          lda  V41            ; * CHECK TOKEN FLAG AND BRANCH
          bne  LB8C2          ; * IF SECONDARY
          cmpb #TOK_ELSE      ; IS IT ELSE TOKEN?
          bne  LB8C6          ; NO
          lda  #':'           ; PUT A COLON (SUBLINE) BEFORE ELSE TOKEN
LB8C2     std  ,u++           ; SECONDARY TOKENS PRECEEDED BY $FF
          bra  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
LB8C6     stb  ,u+            ; SAVE THIS TOKEN
          cmpb #TOK_DATA      ; DATA TOKEN?
          bne  LB8CE          ; NO
          inc  V44            ; SET DATA FLAG
LB8CE     cmpb #TOK_REM       ; REM TOKEN?
          beq  LB87C          ; YES
LB8D2     lbra LB85A          ; GO PROCESS MORE INPUT CHARACTERS
* CHECK FOR A SECONDARY TOKEN
LB8D4     ldu  #COMVEC-5      ; NOW DO SECONDARY FUNCTIONS
          com  V41            ; TOGGLE THE TOKEN FLAG
          bne  LB89B          ; BRANCH IF NOW CHECKING SECONDARY COMMANDS

* THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO
* IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN
          puls x,u            ; RESTORE INPUT AND OUTPUT POINTERS
          lda  ,x+            ; * MOVE THE FIRST CHARACTER OF AN
          sta  ,u+            ; * ILLEGAL TOKEN
          jsr  LB3A2          ; SET CARRY IF NOT ALPHA
          bcs  LB8D2          ; BRANCH IF NOT ALPHA
          com  V43            ; SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA
          bra  LB8D2          ; PROCESS MORE INPUT CHARACTERS
LB8EA     inc  V42            ; INCREMENT TOKEN COUNTER
          deca                ; DECR COMMAND COUNTER
          beq  LB89D          ; GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE
          leay -1,y           ; MOVE POINTER BACK ONE
LB8F1     ldb  ,y+            ; * GET TO NEXT
          bpl  LB8F1          ; * RESERVED WORD
          bra  LB8A6          ; GO SEE IF THIS WORD IS A MATCH

* PRINT
PRINT     beq  LB958          ; BRANCH IF NO ARGUMENT
          bsr  LB8FE          ; CHECK FOR ALL PRINT OPTIONS
          rts

LB8FE	cmpa #'@'	; CHECK FOR PRINT @
		bne	LB907	; NOT PRINT @
LB902	jsr	LA554	; MOVE CURSOR TO PROPER PRINT LOCATION
LB905	bra	LB911	; GO PRINT THE DATA
LB907	cmpa #'#'	; CHECK FOR PRINT NUMBER
		bne	LB918	; NOT PRINT#
		;jsr	LA5A5	; CHECK FOR A VALID DEVICE NUMBER
		;jsr	LA406	; CHECK FOR A VALID OUTPUT FILE
LB911	jsr	GETCCH	; GET CURRENT INPUT CHARACTER
		beq	LB958	; BRANCH IF END OF LINE
		jsr	LB26D	; SYNTAX CHECK FOR COMMA

LB918     jsr  XVEC9          ; CALL EXTENDED BASIC ADD-IN
LB91B     beq  LB965          ; RETURN IF END OF LINE
LB91D     cmpa #TOK_TAB       ; TOKEN FOR TAB( ?
          beq  LB97E          ; YES
          cmpa #','           ; COMMA?
          beq  LB966          ; YES - ADVANCE TO NEXT TAB FIELD
          cmpa #';'           ; SEMICOLON?
          beq  LB997          ; YES - DO NOT ADVANCE CURSOR
          jsr  LB156          ; EVALUATE EXPRESSION
          lda  VALTYP         ; * GET VARIABLE TYPE AND
          pshs a              ; * SAVE IT ON THE STACK
          bne  LB938          ; BRANCH IF STRING VARIABLE
          jsr  LBDD9          ; CONVERT FP NUMBER TO AN ASCII STRING
          jsr  LB516          ; PARSE A STRING FROM (X-1) AND PUT
*                             ; DESCRIPTOR ON STRING STACK
LB938     bsr  LB99F          ; PRINT STRING POINTED TO BY X
          puls b              ; GET VARIABLE TYPE BACK
          jsr  LA35F          ; SET UP TAB WIDTH ZONE, ETC
LB949     tstb                ; CHECK CURRENT PRINT POSITION
          bne  LB954          ; BRANCH IF NOT AT START OF LINE
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          cmpa #','            ; COMMA?
          beq  LB966          ; SKIP TO NEXT TAB FIELD
          bsr  LB9AC          ; SEND A SPACE TO CONSOLE OUT
LB954     jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          bne  LB91D          ; BRANCH IF NOT END OF LINE
LB958     lda  #CR            ; * SEND A CR TO
          bra  LB9B1          ; * CONSOLE OUT
LB95C     jsr  LA35F          ; SET UP TAB WIDTH, ZONE ETC
          beq  LB958          ; BRANCH IF WIDTH = ZERO
          lda  DEVPOS         ; GET PRINT POSITION
          bne  LB958          ; BRANCH IF NOT AT START OF LINE
LB965     rts
* SKIP TO NEXT TAB FIELD
LB966     jsr  LA35F          ; SET UP TAB WIDTH, ZONE ETC
          beq  LB975          ; BRANCH IF LINE WIDTH = 0 (CASSETTE)
          ldb  DEVPOS         ; GET CURRENT POSITION
          cmpb DEVLCF         ; COMPARE TO LAST TAB ZONE
          bcs  LB977          ; BRANCH IF < LAST TAB ZONE
          bsr  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
          bra  LB997          ; GET MORE DATA
LB975     ldb  DEVPOS         ; *
LB977     subb DEVCFW         ; * SUBTRACT TAB FIELD WIDTH FROM CURRENT
          bcc  LB977          ; * POSITION UNTIL CARRY SET - NEGATING THE
          negb                ; * REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT
*              ; * TAB ZONE IN ACCB
          bra  LB98E          ; GO ADVANCE TO NEXT TAB ZONE

* PRINT TAB(
LB97E     jsr  LB709          ; EVALUATE EXPRESSION - RETURN VALUE IN B
          cmpa #')'           ; * 'SYNTAX' ERROR IF NOT ')'
          lbne LB277          ; *
          jsr  LA35F          ; SET UP TAB WIDTH, ZONE ETC
          subb DEVPOS         ; GET DIFFERENCE OF PRINT POSITION & TAB POSITION
          bls  LB997          ; BRANCH IF TAB POSITION < CURRENT POSITION
LB98E
LB992     bsr  LB9AC          ; SEND A SPACE TO CONSOLE OUT
          decb                ; DECREMENT DIFFERENCE COUNT
          bne  LB992          ; BRANCH UNTIL CURRENT POSITION = TAB POSITION
LB997     jsr  GETNCH         ; GET NEXT CHARACTER FROM BASIC
          jmp  LB91B          ; LOOK FOR MORE PRINT DATA
* COPY A STRING FROM (X) TO CONSOLE OUT
LB99C     jsr  LB518          ; PARSE A STRING FROM X AND PUT DESCRIPTOR ON STRING STACK
LB99F     jsr  LB657          ; GET LENGTH OF STRING AND REMOVE DESCRIPTOR FROM STRING STACK
          incb                ; COMPENSATE FOR DECB BELOW
LB9A3     decb                ; DECREMENT COUNTER
          beq  LB965          ; EXIT ROUTINE
          lda  ,x+            ; GET A CHARACTER FROM X
          bsr  LB9B1          ; SEND TO CONSOLE OUT
          bra  LB9A3          ; KEEP LOOPING
LB9AC     lda  #SPACE         ; SPACE TO CONSOLE OUT
          fcb  SKP2           ; SKIP NEXT TWO BYTES
LB9AF     lda  #'?'           ; QUESTION MARK TO CONSOLE OUT
LB9B1     jmp  PUTCHR         ; JUMP TO CONSOLE OUT

* FLOATING POINT MATH PACKAGE

* ADD .5 TO FPA0
LB9B4     ldx  #LBEC0         ; FLOATING POINT CONstaNT (.5)
          bra  LB9C2          ; ADD .5 TO FPA0
* SUBTRACT FPA0 FROM FP NUMBER POINTED
* TO BY (X), LEAVE RESULT IN FPA0
LB9B9     jsr  LBB2F          ; COPY PACKED FP DATA FROM (X) TO FPA1

* ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER
* WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)
LB9BC     com  FP0SGN         ; CHANGE MANTISSA SIGN OF FPA0
          com  RESSGN         ; REVERSE RESULT SIGN FLAG
          bra  LB9C5          ; GO ADD FPA1 AND FPA0
* ADD FP NUMBER POINTED TO BY
* (X) TO FPA0 - LEAVE RESULT IN FPA0
LB9C2     jsr  LBB2F          ; UNPACK PACKED FP DATA FROM (X) TO
*         FPA1; RETURN EXPONENT OF FPA1 IN ACCA

* ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO

LB9C5     tstb                ; CHECK EXPONENT OF FPA0
          lbeq LBC4A          ; COPY FPA1 TO FPA0 IF FPA0 =
          ldx  #FP1EXP        ; POINT X TO FPA1
LB9CD     tfr  a,b            ; PUT EXPONENT OF FPA1 INTO ACCB
          tstb                ; CHECK EXPONENT
          beq LBA3E           ; RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0)
          subb FP0EXP         ; SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1
          beq LBA3F           ; BRANCH IF EXPONENTS ARE EQUAL
          bcs  LB9E2          ; BRANCH IF EXPONENT FPA0 > FPA1
          sta  FP0EXP         ; REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT
          lda  FP1SGN         ; * REPLACE FPA0 MANTISSA SIGN
          sta  FP0SGN         ; * WITH FPA1 MANTISSA SIGN
          ldx  #FP0EXP        ; POINT X TO FPA0
          negb                ; NEGATE DIFFERENCE OF EXPONENTS
LB9E2     cmpb #-8            ; TEST DIFFERENCE OF EXPONENTS
          ble  LBA3F          ; BRANCH IF DIFFERENCE OF EXPONENTS <= 8
          clra                ; CLEAR OVERFLOW BYTE
          lsr  1,x            ; SHIFT MS BYTE OF MANTISSA; BIT 7 = 0
          jsr  LBABA          ; GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES
LB9EC     ldb  RESSGN         ; GET SIGN FLAG
          bpl  LB9FB          ; BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME
          com  1,x            ; * COMPLEMENT MANTISSA POINTED
          com  2,x            ; * TO BY (X) THE
          com  3,x            ; * adca BELOW WILL
          com  4,x            ; * CONVERT THIS OPERATION
          coma                ; * INTO A NEG (MANTISSA)
          adca #0             ; ADD ONE TO ACCA - coma ALWAYS SETS THE CARRY FLAG
* THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA
*
* ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0
LB9FB     sta  FPSBYT         ; SAVE FPA SUB BYTE
          lda  FPA0+3         ; * ADD LS BYTE
          adca FPA1+3         ; * OF MANTISSA
          sta  FPA0+3         ; SAVE IN FPA0 LSB
          lda  FPA0+2         ; * ADD NEXT BYTE
          adca FPA1+2         ; * OF MANTISSA
          sta  FPA0+2         ; SAVE IN FPA0
          lda  FPA0+1         ; * ADD NEXT BYTE
          adca FPA1+1         ; * OF MANTISSA
          sta  FPA0+1         ; SAVE IN FPA0
          lda  FPA0           ; * ADD MS BYTE
          adca FPA1           ; * OF MANTISSA
          sta  FPA0           ; SAVE IN FPA0
          tstb                ; TEST SIGN FLAG
          bpl  LBA5C          ; BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE
LBA18     bcs  LBA1C          ; BRANCH IF POSITIVE MANTISSA
          bsr  LBA79          ; NEGATE FPA0 MANTISSA

* NORMALIZE FPA0
LBA1C     clrb                ; CLEAR TEMPORARY EXPONENT ACCUMULATOR
LBA1D     lda  FPA0           ; TEST MSB OF MANTISSA
          bne  LBA4F          ; BRANCH IF <> 0
          lda  FPA0+1         ; * IF THE MSB IS
          sta  FPA0           ; * 0, THEN SHIFT THE
          lda  FPA0+2         ; * MANTISSA A WHOLE BYTE
          sta  FPA0+1         ; * AT A TIME. THIS
          lda  FPA0+3         ; * IS FASTER THAN ONE
          sta  FPA0+2         ; * BIT AT A TIME
          lda  FPSBYT         ; * BUT USES MORE MEMORY.
          sta  FPA0+3         ; * FPSBYT, THE CARRY IN
          clr  FPSBYT         ; * BYTE, REPLACES THE MATISSA LSB.
          addb #8             ; SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT
          cmpb #5*8           ; CHECK FOR 5 SHIFTS
          blt  LBA1D          ; BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0
LBA39     clra                ; A ZERO EXPONENT = 0 FLOATING POINT
LBA3A     sta  FP0EXP         ; ZERO OUT THE EXPONENT
          sta  FP0SGN         ; ZERO OUT THE MANTISSA SIGN
LBA3E     rts
LBA3F     bsr LBAAE           ; SHIFT FPA0 MANTISSA TO RIGHT
          clrb                ; CLEAR CARRY FLAG
          bra  LB9EC
* SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7
* OF MATISSA MS BYTE = 1
LBA44     incb                ; ADD ONE TO EXPONENT ACCUMULATOR
          asl  FPSBYT         ; SHIFT SUB BYTE ONE LEFT
          rol  FPA0+3         ; SHIFT LS BYTE
          rol  FPA0+2         ; SHIFT NS BYTE
          rol  FPA0+1         ; SHIFT NS BYTE
          rol  FPA0           ; SHIFT MS BYTE
LBA4F     bpl  LBA44          ; BRANCH IF NOT YET NORMALIZED
          lda  FP0EXP         ; GET CURRENT EXPONENT
          pshs b              ; SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION
          suba ,s+            ; SUBTRACT ACCUMULATED EXPONENT MODIFIER
          sta  FP0EXP         ; SAVE AS NEW EXPONENT
          bls  LBA39          ; SET FPA0 = 0 IF THE NORMALIZATION CAUSED
*         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE
*         SIZE OF THE EXPONENT
          fcb  SKP2           ; SKIP 2 BYTES
LBA5C     bcs  LBA66          ; BRANCH IF MANTISSA OVERFLOW
          asl  FPSBYT         ; SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF
*                             ; FLAG (TRUNCATE THE REST OF SUB BYTE)
          lda  #0             ; clra, BUT DO NOT CHANGE CARRY FLAG
          sta  FPSBYT         ; CLEAR THE SUB BYTE
          bra  LBA72          ; GO ROUND-OFF RESULT
LBA66     inc  FP0EXP         ; INCREMENT EXPONENT - MULTIPLY BY 2
          beq  LBA92          ; OVERFLOW ERROR IF CARRY PAST $FF
          ror  FPA0           ; * SHIFT MANTISSA
          ror  FPA0+1         ; * ONE TO
          ror  FPA0+2         ; * THE RIGHT -
          ror  FPA0+3         ; * DIVIDE BY TWO
LBA72     bcc  LBA78          ; BRANCH IF NO ROUND-OFF NEEDED
          bsr  LBA83          ; ADD ONE TO MANTISSA - ROUND OFF
          beq  LBA66          ; BRANCH iF OVERFLOW - MANTISSA = 0
LBA78     rts
* NEGATE FPA0 MANTISSA
LBA79     com  FP0SGN         ; TOGGLE SIGN OF MANTISSA
LBA7B     com  FPA0           ; * COMPLEMENT ALL 4 MANTISSA BYTES
          com  FPA0+1         ; *
          com  FPA0+2         ; *
          com  FPA0+3         ; *
* ADD ONE TO FPA0 MANTISSA
LBA83     ldx  FPA0+2         ; * GET BOTTOM 2 MANTISSA
          leax 1,x            ; * BYTES, ADD ONE TO
          stx  FPA0+2         ; * THEM AND SAVE THEM
          bne  LBA91          ; BRANCH IF NO OVERFLOW
          ldx  FPA0           ; * IF OVERFLOW ADD ONE
          leax 1,x            ; * TO TOP 2 MANTISSA
          stx  FPA0           ; * BYTES AND SAVE THEM
LBA91     rts
LBA92     ldb  #2*5           ; OV' OVERFLOW ERROR
          jmp  LAC46          ; PROCESS AN ERROR
LBA97     ldx  #FPA2-1        ; POINT X TO FPA2
* SHIFT FPA POINTED TO BY (X) TO
* THE RIGHT -(B) TIMES. EXIT WITH
* ACCA CONTAINING DATA SHIFTED OUT
* TO THE RIGHT (SUB BYTE) AND THE DATA
* SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY
LBA9A     lda  4,x            ; GET LS BYTE OF MANTISSA (X)
          sta  FPSBYT         ; SAVE IN FPA SUB BYTE
          lda  3,x            ; * SHIFT THE NEXT THREE BYTES OF THE
          sta  4,x            ; * MANTISSA RIGHT ONE COMPLETE BYTE.
          lda  2,x            ; *
          sta  3,x            ; *
          lda  1,x            ; *
          sta  2,x            ; *
          lda  FPCARY         ; GET THE CARRY IN BYTE
          sta  1,x            ; STORE AS THE MS MANTISSA BYTE OF (X)
LBAAE     addb #8             ; ADD 8 TO DIFFERENCE OF EXPONENTS
          ble  LBA9A          ; BRANCH IF EXPONENT DIFFERENCE < -8
          lda  FPSBYT         ; GET FPA SUB BYTE
          subb #8             ; CAST OUT THE 8 ADDED IN ABOVE
          beq  LBAC4          ; BRANCH IF EXPONENT DIFFERENCE = 0


LBAB8     asr  1,x            ; * SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT
LBABA     ror  2,x            ; *
          ror  3,x            ; *
          ror  4,x            ; *
          rora                ; *
          incb                ; ADD ONE TO EXPONENT DIFFERENCE
          bne  LBAB8          ; BRANCH IF EXPONENTS NOT =
LBAC4     rts
LBAC5     fcb  $81,$00,$00,$00,$00 ; FLOATING POINT CONSTANT 1.0

* ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY
* FPA0 BY (X) - RETURN PRODUCT IN FPA0
LBACA     bsr  LBB2F          ; MOVE PACKED FPA FROM (X) TO FPA1
LBACC     beq  LBB2E          ; BRANCH IF EXPONENT OF FPA0 = 0
          bsr  LBB48          ; CALCULATE EXPONENT OF PRODUCT
* MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE
* HIGH ORDER BYTES OF PRODUCT IN FPA0. THE
* LOW ORDER FOUR BYTES OF THE PRODUCT WILL
* BE STORED IN VAB-VAE.
LBAD0     lda  #0             ; * ZERO OUT MANTISSA OF FPA2
          sta  FPA2           ; *
          sta  FPA2+1         ; *
          sta  FPA2+2         ; *
          sta  FPA2+3         ; *
          ldb  FPA0+3         ; GET LS BYTE OF FPA0
          bsr  LBB00          ; MULTIPLY BY FPA1
          ldb  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 4
          stb  VAE            ; *
          ldb  FPA0+2         ; GET NUMBER 3 MANTISSA BYTE OF FPA0
          bsr  LBB00          ; MULTIPLY BY FPA1
          ldb  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 3
          stb  VAD            ; *
          ldb  FPA0+1         ; GET NUMBER 2 MANTISSA BYTE OF FPA0
          bsr  LBB00          ; MULTIPLY BY FPA1
          ldb  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 2
          stb  VAC            ; *
          ldb  FPA0           ; GET MS BYTE OF FPA0 MANTISSA
          bsr  LBB02          ; MULTIPLY BY FPA1
          ldb  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 1
          stb  VAB            ; *
          jsr  LBC0B          ; COPY MANTISSA FROM FPA2 TO FPA0
          jmp  LBA1C          ; NORMALIZE FPA0
LBB00     lbeq LBA97          ; SHIFT FPA2 ONE BYTE TO RIGHT
LBB02     coma                ; SET CARRY FLAG
* MULTIPLY FPA1 MANTISSA BY ACCB AND
* ADD PRODUCT TO FPA2 MANTISSA
LBB03     lda  FPA2           ; GET FPA2 MS BYTE
          rorb                ; ROTATE CARRY FLAG INTO SHIFT COUNTER;
*         DATA BIT INTO CARRY
          beq  LBB2E          ; BRANCH WHEN 8 SHIFTS DONE
          bcc  LBB20          ; DO NOT ADD FPA1 IF DATA BIT = 0
          lda  FPA2+3         ; * ADD MANTISSA LS BYTE
          adda FPA1+3         ; *
          sta  FPA2+3         ; *
          lda  FPA2+2         ; = ADD MANTISSA NUMBER 3 BYTE
          adca FPA1+2         ; =
          sta  FPA2+2         ; =
          lda  FPA2+1         ; * ADD MANTISSA NUMBER 2 BYTE
          adca FPA1+1         ; *
          sta  FPA2+1         ; *
          lda  FPA2           ; = ADD MANTISSA MS BYTE
          adca FPA1           ; =
LBB20     rora                ; * ROTATE CARRY INTO MS BYTE
          sta  FPA2           ; *
          ror  FPA2+1         ; = ROTATE FPA2 ONE BIT TO THE RIGHT
          ror  FPA2+2         ; =
          ror  FPA2+3         ; =
          ror  FPSBYT         ; =
          clra                ; CLEAR CARRY FLAG
          bra  LBB03          ; KEEP LOOPING
LBB2E     rts
* UNPACK A FP NUMBER FROM (X) TO FPA1
LBB2F     ldd  1,x            ; GET TWO MSB BYTES OF MANTISSA FROM
*         FPA  POINTED TO BY X
          sta  FP1SGN         ; SAVE PACKED MANTISSA SIGN BYTE
          ora  #$80           ; FORCE BIT 7 OF MSB MANTISSA = 1
          std  FPA1           ; SAVE 2 MSB BYTES IN FPA1
          ldb  FP1SGN         ; * GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0
          eorb FP0SGN         ; * SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE,
          stb  RESSGN         ; * NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED
*                             ; * MANTISSA SIGN BYTE
          ldd  3,x            ; = GET 2 LSB BYTES OF MANTISSA
          std  FPA1+2         ; = AND PUT IN FPA1
          lda  ,x             ; * GET EXPONENT FROM (X) AND
          sta  FP1EXP         ; * PUT IN EXPONENT OF FPA1
          ldb  FP0EXP         ; GET EXPONENT OF FPA0
          rts
* CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1
* ENTER WITH EXPONENT OF FPA1 IN ACCA
LBB48     tsta                ; TEST EXPONENT OF FPA1
          beq  LBB61          ; PURGE RETURN ADDRESS & SET FPA0 = 0
          adda FP0EXP         ; ADD FPA1 EXPONENT TO FPA0 EXPONENT
          rora                ; ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY
          rola                ; SET OVERFLOW FLAG
          bvc  LBB61          ; BRANCH IF EXPONENT TOO LARGE OR SMALL
          adda #$80           ; ADD $80 BIAS TO EXPONENT
          sta  FP0EXP         ; SAVE NEW EXPONENT
          beq  LBB63          ; SET FPA0
          lda  RESSGN         ; GET MANTISSA SIGN
          sta  FP0SGN         ; SAVE AS MANTISSA SIGN OF FPA0
          rts
* IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0
* = IS NEGATIVE THEN FPA0 = 0
LBB5C     lda  FP0SGN         ; GET MANTISSA SIGN OF FPA0
          coma                ; CHANGE SIGN OF FPA0 MANTISSA
          bra  LBB63
LBB61     leas 2,s            ; PURGE RETURN ADDRESS FROM STACK
LBB63     lbpl LBA39          ; ZERO FPA0 MANTISSA SIGN & EXPONENT
LBB67     jmp  LBA92          ; 'OV' OVERFLOW ERROR
* FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0
LBB6A     jsr  LBC5F          ; TRANSFER FPA0 TO FPA1
          beq  LBB7C          ; BRANCH IF EXPONENT = 0
          adda #2             ; ADD 2 TO EXPONENT (TIMES 4)
          bcs  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
          clr  RESSGN         ; CLEAR RESULT SIGN BYTE
          jsr  LB9CD          ; ADD FPA1 TO FPA0 (TIMES 5)
          inc  FP0EXP         ; ADD ONE TO EXPONENT (TIMES 10)
          beq  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
LBB7C     rts
LBB7D     fcb  $84,$20,$00,$00,$00 ; FLOATING POINT CONSTANT 10
* DIVIDE FPA0 BY 10
LBB82     jsr  LBC5F          ; MOVE FPA0 TO FPA1
          ldx  #LBB7D         ; POINT TO FLOATING POINT CONSTANT 10
          clrb                ; ZERO MANTISSA SIGN BYTE
LBB89     stb  RESSGN         ; STORE THE QUOTIENT MANTISSA SIGN BYTE
          jsr  LBC14          ; UNPACK AN FP NUMBER FROM (X) INTO FPA0
          fcb  SKP2           ; SKIP TWO BYTES
* DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0
LBB8F     bsr  LBB2F          ; GET FP NUMBER FROM (X) TO FPA1

* ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH
* EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY tsta)

* DIVIDE FPA1 BY FPA0
LBB91     beq  LBC06          ; '/0' DIVIDE BY ZERO ERROR
          neg  FP0EXP         ; GET EXPONENT OF RECIPROCAL OF DIVISOR
          bsr  LBB48          ; CALCULATE EXPONENT OF QUOTIENT
          inc  FP0EXP         ; INCREMENT EXPONENT
          beq  LBB67          ; 'OV' OVERFLOW ERROR
          ldx  #FPA2          ; POINT X TO MANTISSA OF FPA2 - HOLD
*                             ; TEMPORARY QUOTIENT IN FPA2
          ldb  #4             ; 5 BYTE DIVIDE
          stb  TMPLOC         ; SAVE BYTE COUNTER
          ldb  #1             ; SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE
* COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -
* SET CARRY FLAG IF FPA1 >= FPA0
LBBA4     lda  FPA0           ; * COMPARE THE TWO MS BYTES
          cmpa FPA1           ; * OF FPA0 AND FPA1 AND
          bne  LBBBD          ; * BRANCH IF <>
          lda  FPA0+1         ; = COMPARE THE NUMBER 2
          cmpa FPA1+1         ; = BYTES AND
          bne  LBBBD          ; = BRANCH IF <>
          lda  FPA0+2         ; * COMPARE THE NUMBER 3
          cmpa FPA1+2         ; * BYTES AND
          bne  LBBBD          ; * BRANCH IF <>
          lda  FPA0+3         ; = COMPARE THE LS BYTES
          cmpa FPA1+3         ; = AND BRANCH
          bne  LBBBD          ; = IF <>
          coma                ; SET CARRY FLAG IF FPA0 = FPA1
LBBBD     tfr  cc,a           ; SAVE CARRY FLAG STATUS IN ACCA; CARRY
*         CLEAR IF FPA0 > FPA1
          rolb                ; ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE
          bcc  LBbcc          ; CARRY WILL BE SET AFTER 8 SHIFTS
          stb  ,x+            ; SAVE TEMPORARY QUOTIENT
          dec  TMPLOC         ; DECREMENT BYTE COUNTER
          bmi  LBBFC          ; BRANCH IF DONE
          beq  LBBF8          ; BRANCH IF LAST BYTE
          ldb  #1             ; RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE
LBbcc     tfr  a,cc           ; RESTORE CARRY FLAG AND
          bcs  LBBDE          ; BRANCH IF FPA0 =< FPA1
LBBD0     asl  FPA1+3         ; * SHIFT FPA1 MANTISSA 1 BIT TO LEFT
          rol  FPA1+2         ; *
          rol  FPA1+1         ; *
          rol  FPA1           ; *
          bcs  LBBBD          ; BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT
          bmi  LBBA4          ; IF MSB OF HIGH ORDER MANTISSA BYTE IS
*         SET, CHECK THE MAGNITUDES OF FPA0, FPA1
          bra  LBBBD          ; CARRY IS CLEAR, CHECK ANOTHER BIT
* SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1
LBBDE     lda  FPA1+3         ; * SUBTRACT THE LS BYTES OF MANTISSA
          suba FPA0+3         ; *
          sta  FPA1+3         ; *
          lda  FPA1+2         ; = THEN THE NEXT BYTE
          sbca FPA0+2         ; =
          sta  FPA1+2         ; =
          lda  FPA1+1         ; * AND THE NEXT
          sbca FPA0+1         ; *
          sta  FPA1+1         ; *
          lda  FPA1           ; = AND FINALLY, THE MS BYTE OF MANTISSA
          sbca FPA0           ; =
          sta  FPA1           ; =
          bra  LBBD0          ; GO SHIFT FPA1
LBBF8     ldb  #$40           ; USE ONLY TWO BITS OF THE LAST BYTE (FIFTH)
          bra  LBbcc          ; GO SHIFT THE LAST BYTE
LBBFC     rorb                ; * SHIFT CARRY (ALWAYS SET HERE) INTO
          rorb                ; * BIT 5 AND MOVE
          rorb                ; * BITS 1,0 TO BITS 7,6
          stb  FPSBYT         ; SAVE SUB BYTE
          bsr  LBC0B          ; MOVE MANTISSA OF FPA2 TO FPA0
          jmp  LBA1C          ; NORMALIZE FPA0
LBC06     ldb  #2*10          ; /0' ERROR
          jmp  LAC46          ; PROCESS THE ERROR
* COPY MANTISSA FROM FPA2 TO FPA0
LBC0B     ldx  FPA2           ; * MOVE TOP 2 BYTES
          stx  FPA0           ; *
          ldx  FPA2+2         ; = MOVE BOTTOM 2 BYTES
          stx  FPA0+2         ; =
          rts
* COPY A PACKED FP NUMBER FROM (X) TO FPA0
LBC14     pshs a              ; SAVE ACCA
          ldd  1,x            ; GET TOP TWO MANTISSA BYTES
          sta  FP0SGN         ; SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN
          ora  #$80           ; UNPACK MS BYTE
          std  FPA0           ; SAVE UNPACKED TOP 2 MANTISSA BYTES
          clr  FPSBYT         ; CLEAR MANTISSA SUB BYTE
          ldb  ,x             ; GET EXPONENT TO ACCB
          ldx  3,x            ; * MOVE LAST 2
          stx  FPA0+2         ; * MANTISSA BYTES
          stb  FP0EXP         ; SAVE EXPONENT
          puls a,pc           ; RESTORE ACCA AND RETURN

LBC2A     ldx  #V45           ; POINT X TO MANTISSA OF FPA4
          bra  LBC35          ; MOVE FPA0 TO FPA4
LBC2F     ldx  #V40           ; POINT X TO MANTISSA OF FPA3
          fcb  SKP2           ; SKIP TWO BYTES
LBC33     ldx  VARDES         ; POINT X TO VARIABLE DESCRIPTOR IN VARDES
* PACK FPA0 AND MOVE IT TO ADDRESS IN X
LBC35     lda  FP0EXP         ; * COPY EXPONENT
          sta  ,x             ; *
          lda  FP0SGN         ; GET MANTISSA SIGN BIT
          ora  #$7F           ; MASK THE BOTTOM 7 BITS
          anda FPA0           ; AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE
          sta  1,x            ; SAVE MS BYTE
          lda  FPA0+1         ; * MOVE 2ND MANTISSA BYTE
          sta  2,x            ; *
          ldu  FPA0+2         ; = MOVE BOTTOM 2 MANTISSA BYTES
          stu  3,x            ; =
          rts
* MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA
LBC4A     lda  FP1SGN         ; * COPY MANTISSA SIGN FROM
LBC4C     sta  FP0SGN         ; * FPA1 TO FPA0
          ldx  FP1EXP         ; = COPY EXPONENT + MS BYTE FROM
          stx  FP0EXP         ; = FPA1 TO FPA0
          clr  FPSBYT         ; CLEAR MANTISSA SUB BYTE
          lda  FPA1+1         ; * COPY 2ND MANTISSA BYTE
          sta  FPA0+1         ; * FROM FPA1 TO FPA0
          lda  FP0SGN         ; GET MANTISSA SIGN
          ldx  FPA1+2         ; * COPY 3RD AND 4TH MANTISSA BYTE
          stx  FPA0+2         ; * FROM FPA1 TO FPA0
          rts
* TRANSFER FPA0 TO FPA1
LBC5F     ldd  FP0EXP         ; * TRANSFER EXPONENT & MS BYTE
          std  FP1EXP         ; *
          ldx  FPA0+1         ; = TRANSFER MIDDLE TWO BYTES
          stx  FPA1+1         ; =
          ldx  FPA0+3         ; * TRANSFER BOTTOM TWO BYTES
          stx  FPA1+3         ; *
          tsta                ; SET FLAGS ACCORDING TO EXPONENT
          rts
* CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,
* ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE
LBC6D     ldb  FP0EXP         ; GET EXPONENT
          beq  LBC79          ; BRANCH IF FPA0 = 0
LBC71     ldb  FP0SGN         ; GET SIGN OF MANTISSA
LBC73     rolb                ; BIT 7 TO CARRY
          ldb  #$FF           ; NEGATIVE FLAG
          bcs  LBC79          ; BRANCH IF NEGATIVE MANTISSA
          negb                ; ACCB = 1 IF POSITIVE MANTISSA
LBC79     rts

* SGN
SGN       bsr  LBC6D          ; SET ACCB ACCORDING TO SIGN OF FPA0
* CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER
LBC7C     stb  FPA0           ; SAVE ACCB IN FPA0
          clr  FPA0+1         ; CLEAR NUMBER 2 MANTISSA BYTE OF FPA0
          ldb  #$88           ; EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER
LBC82     lda  FPA0           ; GET MS BYTE OF MANTISSA
          suba #$80           ; SET CARRY IF POSITIVE MANTISSA
LBC86     stb  FP0EXP         ; SAVE EXPONENT
          ldd  ZERO           ; * ZERO OUT ACCD AND
          std  FPA0+2         ; * BOTTOM HALF OF FPA0
          sta  FPSBYT         ; CLEAR SUB BYTE
          sta  FP0SGN         ; CLEAR SIGN OF FPA0 MANTISSA
          jmp  LBA18          ; GO NORMALIZE FPA0

* ABS
ABS       clr  FP0SGN         ; FORCE MANTISSA SIGN OF FPA0 POSITIVE
          rts
* COMPARE A PACKED FLOATING POINT NUMBER POINTED TO
* BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN
* ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF
* FPA0 > (X); ACCB = $FF IF FPA0 < (X)
LBC96     ldb  ,x             ; CHECK EXPONENT OF (X)
          beq  LBC6D          ; BRANCH IF FPA = 0
          ldb  1,x            ; GET MS BYTE OF MANTISSA OF (X)
          eorb FP0SGN         ; EOR WITH SIGN OF FPA0
          bmi  LBC71          ; BRANCH IF SIGNS NOT =
* COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).
* FPA0 IS NORMALIZEd, (X) IS PACKED.
LBCA0     ldb  FP0EXP         ; * GET EXPONENT OF
          cmpb ,x             ; * FPA0, COMPARE TO EXPONENT OF
          bne  LBCC3          ; * (X) AND BRANCH IF <>.
          ldb  1,x            ; * GET MS BYTE OF (X), KEEP ONLY
          orb  #$7F           ; * THE SIGN BIT - 'AND' THE BOTTOM 7
          andb FPA0           ; * BITS OF FPA0 INTO ACCB
          cmpb 1,x            ; = COMPARE THE BOTTOM 7 BITS OF THE MANTISSA
          bne  LBCC3          ; = MS BYTE AND BRANCH IF <>
          ldb  FPA0+1         ; * COMPARE 2ND BYTE
          cmpb 2,x            ; * OF MANTISSa,
          bne  LBCC3          ; * BRANCH IF <>
          ldb  FPA0+2         ; = COMPARE 3RD BYTE
          cmpb 3,x            ; = OF MANTISSa,
          bne  LBCC3          ; = BRANCH IF <>
          ldb  FPA0+3         ; * SUBTRACT LS BYTE
          subb 4,x            ; * OF (X) FROM LS BYTE OF
          bne  LBCC3          ; * FPA0, BRANCH IF <>
          rts                 ; RETURN IF FP (X) = FPA0
LBCC3     rorb                ; SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X)
          eorb FP0SGN         ; TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE
          bra  LBC73          ; GO SET ACCB ACCORDING TO COMPARISON
* DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT
* OF THE leasT SIGNIFICANT BYTE OF THE MANTISSA
LBCC8     ldb  FP0EXP         ; GET EXPONENT OF FPA0
          beq  LBD09          ; ZERO MANTISSA IF FPA0 = 0
          subb #$A0           ; SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD
*                             ; THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN
*                             ; THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT
*                             ; WILL BE TO THE RIGHT OF THE MANTISSA
          lda  FP0SGN         ; TEST SIGN OF FPA0 MANTISSA
          bpl  LBCD7          ; BRANCH IF POSITIVE
          com  FPCARY         ; COMPLEMENT CARRY IN BYTE
          jsr  LBA7B          ; NEGATE MANTISSA OF FPA0
LBCD7     ldx  #FP0EXP        ; POINT X TO FPA0
          cmpb #-8            ; EXPONENT DIFFERENCE < -8?
          bgt  LBCE4          ; YES
          jsr  LBAAE          ; SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0
          clr  FPCARY         ; CLEAR CARRY IN BYTE
          rts
LBCE4     clr  FPCARY         ; CLEAR CARRY IN BYTE
          lda  FP0SGN         ; * GET SIGN OF FPA0 MANTISSA
          rola                ; * ROTATE IT INTO THE CARRY FLAG
          ror  FPA0           ; ROTATE CARRY (MANTISSA SIGN) INTO BIT 7
*                             ; OF LS BYTE OF MANTISSA
          jmp  LBABA          ; DE-NORMALIZE FPA0

* INT
* THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT
* TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE
* THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT
* BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION
* ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.
*
INT       ldb  FP0EXP         ; GET EXPONENT OF FPA0
          cmpb #$A0           ; LARGEST POSSIBLE INTEGER EXPONENT
          bcc  LBD11          ; RETURN IF FPA0 >= 32768
          bsr  LBCC8          ; SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE
*                             ; LS BYTE OF THE FPA0 MANTISSA
          stb  FPSBYT         ; ACCB = 0: ZERO OUT THE SUB BYTE
          lda  FP0SGN         ; GET MANTISSA SIGN
          stb  FP0SGN         ; FORCE MANTISSA SIGN TO BE POSITIVE
          suba #$80           ; SET CARRY IF MANTISSA
          lda  #$A0           ; * GET DENORMALIZED EXPONENT AND
          sta  FP0EXP         ; * SAVE IT IN FPA0 EXPONENT
          lda  FPA0+3         ; = GET LS BYTE OF FPA0 AND
          sta  CHARAC         ; = SAVE IT IN CHARAC
          jmp  LBA18          ; NORMALIZE FPA0

LBD09     stb  FPA0           ; * LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB
          stb  FPA0+1         ; *
          stb  FPA0+2         ; *
          stb  FPA0+3         ; *
LBD11     rts                 ; *

* CONVERT ASCII STRING TO FLOATING POINT
LBD12     ldx  ZERO           ; (X) = 0
          stx  FP0SGN         ; * ZERO OUT FPA0 & THE SIGN FLAG (COEFCT)
          stx  FP0EXP         ; *
          stx  FPA0+1         ; *
          stx  FPA0+2         ; *
          stx  V47            ; INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO
          stx  V45            ; INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0
          bcs  LBD86          ; IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST
*         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK
          jsr  XVEC19         ; CALL EXTENDED BASIC ADD-IN
LBD25     cmpa #'-'           ; * CHECK FOR A LEADING MINUS SIGN AND BRANCH
          bne  LBD2D          ; * IF NO MINUS SIGN
          com  COEFCT         ; TOGGLE SIGN; 0 = +; FF = -
          bra  LBD31          ; INTERPRET THE REST OF THE STRING
LBD2D     cmpa #'+'           ; * CHECK FOR LEADING PLUS SlGN AND BRANCH
          bne  LBD35          ; * IF NOT A PLUS SIGN
LBD31     jsr  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
          bcs  LBD86          ; BRANCH IF NUMERIC CHARACTER
LBD35     cmpa #'.'           ; DECIMAL POlNT?
          beq  LBD61          ; YES
          cmpa #'E'           ; "E" SHORTHAND FORM (SCIENTIFIC NOTATION)?
          bne  LBD65          ; NO
* EVALUATE EXPONENT OF EXPONENTIAL FORMAT
          jsr  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
          bcs  LBDA5          ; BRANCH IF NUMERIC
          cmpa #TOK_MINUS     ; MINUS TOKEN?
          beq  LBD53          ; YES
          cmpa #'-'           ; ASCII MINUS?
          beq  LBD53          ; YES
          cmpa #TOK_PLUS      ; PLUS TOKEN?
          beq  LBD55          ; YES
          cmpa #'+'           ; ASCII PLUS?
          beq  LBD55          ; YES
          bra  LBD59          ; BRANCH IF NO SIGN FOUND
LBD53     com  V48            ; SET EXPONENT SIGN FLAG TO NEGATIVE
* STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT TO BINARY IN V47
LBD55     jsr  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
          bcs  LBDA5          ; IF NUMERIC CHARACTER, CONVERT TO BINARY
LBD59     tst  V48            ; * CHECK EXPONENT SIGN FLAG
          beq  LBD65          ; * AND BRANCH IF POSITIVE
          neg  V47            ; NEGATE VALUE OF EXPONENT
          bra  LBD65
LBD61     com  V46            ; *TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER
          bne  LBD31          ; *CHARACTER IF <> 0 - TERMINATE INTERPRETATION
*         IF   SECOND DECIMAL POINT
* ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47
LBD65     lda  V47            ; * GET EXPONENT, SUBTRACT THE NUMBER OF
          suba V45            ; * PLACES TO THE RIGHT OF DECIMAL POINT
          sta  V47            ; * AND RESAVE IT.
          beq  LBD7F          ; EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO
          bpl  LBD78          ; BRANCH IF POSITIVE EXPONENT
LBD6F     jsr  LBB82          ; DIVIDE FPA0 BY 10
          inc  V47            ; INCREMENT EXPONENT COUNTER (MULTIPLY BY 10)
          bne  LBD6F          ; KEEP MULTIPLYING
          bra  LBD7F          ; EXIT ROUTINE
LBD78     jsr  LBB6A          ; MULTIPLY FPA0 BY 10
          dec  V47            ; DECREMENT EXPONENT COUNTER (DIVIDE BY 10)
          bne  LBD78          ; KEEP MULTIPLYING
LBD7F     lda  COEFCT         ; GET THE SIGN FLAG
          lbpl  LBD11         ; RETURN IF POSITIVE
          jmp  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE
*MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT
LBD86     ldb  V45            ; *GET THE RIGHT DECIMAL COUNTER AND SUBTRACT
          subb V46            ; *THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT
          stb  V45            ; *FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS
*                             -1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE
          pshs a              ; SAVE NEW DIGIT ON STACK
          jsr  LBB6A          ; MULTIPLY FPA0 BY 10
          puls b              ; GET NEW DIGIT BACK
          subb #'0'            ; MASK OFF ASCII
          bsr  LBD99          ; ADD ACCB TO FPA0
          bra  LBD31          ; GET ANOTHER CHARACTER FROM BASIC
LBD99     jsr  LBC2F          ; PACK FPA0 AND SAVE IT IN FPA3
          jsr  LBC7C          ; CONVERT ACCB TO FP NUMBER IN FPA0
          ldx  #V40           ; * ADD FPA0 TO
          jmp  LB9C2          ; * FPA3


LBDA5     ldb  V47
          aslb                ; TIMES 2
          aslb                ; TIMES 4
          addb V47            ; ADD 1 = TIMES 5
          aslb                ; TIMES 10
          suba #'0'            ; *MASK OFF ASCII FROM ACCA, PUSH
          pshs b              ; *RESULT ONTO THE STACK AND
          adda ,s+            ; ADD lT TO ACCB
          sta  V47            ; SAVE IN V47
          bra  LBD55          ; INTERPRET ANOTHER CHARACTER
*
LBDB6     fcb  $9b,$3E,$BC,$1F,$FD ; * 99999999.9
LBDBB     fcb  $9E,$6E,$6b,$27,$FD ; * 999999999
LBDC0     fcb  $9E,$6E,$6b,$28,$00 ; * 1E + 09
*
LBDC5     ldx  #LABE8-1       ; POINT X TO " IN " MESSAGE
          bsr  LBDD6          ; COPY A STRING FROM (X) TO CONSOLE OUT
          ldd  CURLIN         ; GET CURRENT BASIC LINE NUMBER TO ACCD
* CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER AND PRINT IT TO CONSOLE OUT
LBDCC     std  FPA0           ; SAVE ACCD IN TOP HALF OF FPA0
          ldb  #$90           ; REQ'D EXPONENT IF TOP HALF OF ACCD = INTEGER
          coma                ; SET CARRY FLAG - FORCE POSITIVE MANTISSA
          jsr  LBC86          ; ZERO BOTTOM HALF AND SIGN OF FPA0, THEN SAVE EXPONENT AND NORMALIZE IT
          bsr  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
LBDD6     jmp  LB99C          ; COPY A STRING FROM (X) TO CONSOLE OUT

* CONVERT FP NUMBER TO ASCII STRING
LBDD9     ldu  #STRBUF+3      ; POINT U TO BUFFER WHICH WILL NOT CAUSE
*                             ; THE STRING TO BE STORED IN STRING SPACE
LBDDC     lda  #SPACE         ; SPACE = DEFAULT SIGN FOR POSITIVE #
          ldb  FP0SGN         ; GET SIGN OF FPA0
          bpl  LBDE4          ; BRANCH IF POSITIVE
          lda  #'-'           ; ASCII MINUS SIGN
LBDE4     sta  ,u+            ; STORE SIGN OF NUMBER
          stu  COEFPT         ; SAVE BUFFER POINTER
          sta  FP0SGN         ; SAVE SIGN (IN ASCII)
          lda  #'0'            ; ASCII ZERO IF EXPONENT = 0
          ldb  FP0EXP         ; GET FPA0 EXPONENT
          lbeq LBEB8          ; BRANCH IF FPA0 = 0
          clra                ; BASE 10 EXPONENT=0 FOR FP NUMBER > 1
          cmpb #$80           ; CHECK EXPONENT
          bhi  LBDFF          ; BRANCH IF FP NUMBER > 1
* IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS
          ldx  #LBDC0         ; POINT X TO FP 1E+09
          jsr  LBACA          ; MULTIPLY FPA0 BY (X)
          lda  #-9            ; BASE 10 EXPONENT = -9
LBDFF     sta  V45            ; BASE 10 EXPONENT
* PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE
* OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST
* NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE
* SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING
* SCIENTIFIC NOTATION
LBE01     ldx  #LBDBB         ; POINT X TO FP 999,999,999
          jsr  LBCA0          ; COMPARE FPA0 TO 999,999,999
          bgt  LBE18          ; BRANCH IF > 999,999,999
LBE09     ldx  #LBDB6         ; POINT X TO FP 99,999,999.9
          jsr  LBCA0          ; COMPARE FPA0 TO 99,999,999.9
          bgt  LBE1F          ; BRANCH IF > 99,999,999.9 (IN RANGE)
          jsr  LBB6A          ; MULTIPLY FPA0 BY 10
          dec  V45            ; SUBTRACT ONE FROM DECIMAL OFFSET
          bra  LBE09          ; PSEUDO - NORMALIZE SOME MORE
LBE18     jsr  LBB82          ; DIVIDE FPA0 BY 10
          inc  V45            ; ADD ONE TO BASE 10 EXPONENT
          bra  LBE01          ; PSEUDO - NORMALIZE SOME MORE
LBE1F     jsr  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
          jsr  LBCC8          ; CONVERT FPA0 TO AN INTEGER
          ldb  #1             ; DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT)
          lda  V45            ; * GET BASE 10 EXPONENT AND ADD TEN TO IT
          adda #9+1           ; * (NUMBER 'NORMALIZED' TO 9 PLACES & DECIMAL PT)
          bmi  LBE36          ; BRANCH IF NUMBER < 1.0
          cmpa #9+2           ; NINE PLACES MAY BE DISPLAYED WITHOUT
*         USING SCIENTIFIC NOTATION
          bcc  LBE36          ; BRANCH IF SCIENTIFIC NOTATION REQUIRED
          deca                ; * SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR
          tfr  a,b            ; * AND SAVE IT IN ACCB (DECiMAL POINT FLAG)
          lda  #2             ; FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION
LBE36     deca                ; * SUBTRACT TWO (WITHOUT AFFECTING CARRY)
          deca                ; * FROM BASE 10 EXPONENT
          sta  V47            ; SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY
*         IN   SCIENTIFIC NOTATION
          stb  V45            ; DECIMAL POINT FLAG - NUMBER OF PLACES TO
*         LEFT OF DECIMAL POINT
          bgt  LBE4B          ; BRANCH IF >= 1
          ldu  COEFPT         ; POINT U TO THE STRING BUFFER
          lda  #'.'           ; * STORE A PERIOD
          sta  ,u+            ; * IN THE BUFFER
          tstb                ; CHECK DECIMAL POINT FLAG
          beq  LBE4B          ; BRANCH IF NOTHING TO LEFT OF DECIMAL POINT
          lda  #'0'            ; * STORE A ZERO
          sta  ,u+            ; * IN THE BUFFER

* CONVERT FPA0 INTO A STRING OF ASCII DIGITS
LBE4B     ldx  #LBEC5         ; POINT X TO FP POWER OF 10 MANTISSA
          ldb  #0+$80         ; INITIALIZE DIGIT COUNTER TO 0+$80
* BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
* IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
* THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW
* THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.
LBE50     lda  FPA0+3         ; * ADD MANTISSA LS
          adda 3,x            ; * BYTE OF FPA0
          sta  FPA0+3         ; * AND (X)
          lda  FPA0+2         ; = ADD MANTISSA
          adca 2,x            ; = NUMBER 3 BYTE OF
          sta  FPA0+2         ; = FPA0 AND (X)
          lda  FPA0+1         ; * ADD MANTISSA
          adca 1,x            ; * NUMBER 2 BYTE OF
          sta  FPA0+1         ; * FPA0 AND (X)
          lda  FPA0           ; = ADD MANTISSA
          adca ,x             ; = MS BYTE OF
          sta  FPA0           ; = FPA0 AND (X)
          incb                ; ADD ONE TO DIGIT COUNTER
          rorb                ; ROTATE CARRY INTO BIT 7
          rolb                ; *SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND
          bvc  LBE50          ; *POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA
          bcc  LBE72          ; BRANCH IF NEGATIVE MANTISSA
          subb #10+1          ; * TAKE THE 9'S COMPLEMENT IF
          negb                ; * ADDING MANTISSA
LBE72     addb #'0'-1          ; ADD ASCII OFFSET TO DIGIT
          leax 4,x            ; MOVE TO NEXT POWER OF 10 MANTISSA
          tfr  b,a            ; SAVE DIGIT IN ACCA
          anda #$7F           ; MASK OFF BIT 7 (ADD/SUBTRACT FLAG)
          sta  ,u+            ; STORE DIGIT IN STRING BUFFER
          dec  V45            ; DECREMENT DECIMAL POINT FLAG
          bne  LBE84          ; BRANCH IF NOT TIME FOR DECIMAL POINT
          lda  #'.'           ; * STORE DECIMAL POINT IN
          sta  ,u+            ; * STRING BUFFER
LBE84     comb                ; TOGGLE BIT 7 (ADD/SUBTRACT FLAG)
          andb #$80           ; MASK OFF ALL BUT ADD/SUBTRACT FLAG
          cmpx #LBEC5+36      ; COMPARE X TO END OF MANTISSA TABLE
          bne  LBE50          ; BRANCH IF NOT AT END OF TABLE
* BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY
LBE8C     lda  ,-u            ; GET THE LAST CHARACTER; MOVE POINTER BACK
          cmpa #'0'            ; WAS IT A ZERO?
          beq  LBE8C          ; IGNORE TRAILING ZEROS IF SO
          cmpa #'.'           ; CHECK FOR DECIMAL POINT
          bne  LBE98          ; BRANCH IF NOT DECIMAL POINT
          leau -1,u           ; STEP OVER THE DECIMAL POINT
LBE98     lda  #'+'           ; ASCII PLUS SIGN
          ldb  V47            ; GET SCIENTIFIC NOTATION EXPONENT
          beq  LBEBA          ; BRANCH IF NOT SCIENTIFIC NOTATION
          bpl  LBEA3          ; BRANCH IF POSITIVE EXPONENT
          lda  #'-'           ; ASCII MINUS SIGN
          negb                ; NEGATE EXPONENT IF NEGATIVE
LBEA3     sta  2,u            ; STORE EXPONENT SIGN IN STRING
          lda  #'E'           ; * GET ASCII 'E' (SCIENTIFIC NOTATION
          sta  1,u            ; * FLAG) AND SAVE IT IN THE STRING
          lda  #'0'-1          ; INITIALIZE ACCA TO ASCII ZERO


LBEAB     inca                ; ADD ONE TO 10'S DIGIT OF EXPONENT
          subb #10            ; SUBTRACT 10 FROM ACCB
          bcc  LBEAB          ; ADD 1 TO 10'S DIGIT IF NO CARRY
          addb #'9'+1         ; CONVERT UNITS DIGIT TO ASCII
          std  3,u            ; SAVE EXPONENT IN STRING
          clr  5,u            ; CLEAR LAST BYTE (TERMINATOR)
          bra  LBEBC          ; GO RESET POINTER
LBEB8     sta  ,u             ; STORE LAST CHARACTER
LBEBA     clr  1,u            ; CLEAR LAST BYTE (TERMINATOR - REQUIRED BY
*         PRINT SUBROUTINES)
LBEBC     ldx  #STRBUF+3      ; RESET POINTER TO START OF BUFFER
          rts
*
LBEC0     fcb  $80,$00,$00,$00,$00 ; FLOATING POINT .5
*
*** TABLE OF UNNORMALIZED POWERS OF 10
LBEC5     fcb  $Fa,$0a,$1F,$00 ; -100000000
LBEC9     fcb  $00,$98,$96,$80 ; 10000000
LBECD     fcb  $FF,$F0,$Bd,$C0 ; -1000000
LBED1     fcb  $00,$01,$86,$A0 ; 100000
LBED5     fcb  $FF,$FF,$D8,$F0 ; -10000
LBED9     fcb  $00,$00,$03,$E8 ; 1000
LBEDD     fcb  $FF,$FF,$FF,$9C ; -100
LBEE1     fcb  $00,$00,$00,$0A ; 10
LBEE5     fcb  $FF,$FF,$FF,$FF ; -1
*
*
LBEE9     lda  FP0EXP         ; GET EXPONENT OF FPA0
          beq  LBEEF          ; BRANCH IF FPA0 = 0
          com  FP0SGN         ; TOGGLE MANTISSA SIGN OF FPA0
LBEEF     rts
* EXPAND A POLYNOMIAL OF THE FORM
* AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0
* AND THE X REGISTER POINTS TO A TABLE OF
* COEFFICIENTS A,B,C,D....
LBEF0     stx  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
          jsr  LBC2F          ; MOVE FPA0 TO FPA3
          bsr  LBEFC          ; MULTIPLY FPA3 BY FPA0
          bsr  LBF01          ; EXPAND POLYNOMIAL
          ldx  #V40           ; POINT X TO FPA3
LBEFC     jmp  LBACA          ; MULTIPLY (X) BY FPA0

* CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
* EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
* OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
* NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
* OF PACKED FLOATING POINT NUMBERS. THE
* POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
* (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0...YN)
LBEFF     stx  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
LBF01     jsr  LBC2A          ; MOVE FPA0 TO FPA4
          ldx  COEFPT         ; GET THE COEFFICIENT POINTER
          ldb  ,x+            ; GET THE TOP OF COEFFICIENT TABLE TO
          stb  COEFCT         ; * USE AND STORE IT IN TEMPORARY COUNTER
          stx  COEFPT         ; SAVE NEW COEFFICIENT POINTER
LBF0C     bsr  LBEFC          ; MULTIPLY (X) BY FPA0
          ldx  COEFPT         ; *GET COEFFICIENT POINTER
          leax 5,x            ; *MOVE TO NEXT FP NUMBER
          stx  COEFPT         ; *SAVE NEW COEFFICIENT POINTER
          jsr  LB9C2          ; ADD (X) AND FPA0
          ldx  #V45           ; POINT (X) TO FPA4
          dec  COEFCT         ; DECREMENT TEMP COUNTER
          bne  LBF0C          ; BRANCH IF MORE COEFFICIENTS LEFT
          rts

* RND
RND       jsr  LBC6D          ; TEST FPA0
          bmi  LBF45          ; BRANCH IF FPA0 = NEGATIVE
          beq  LBF3B          ; BRANCH IF FPA0 = 0
          bsr  LBF38          ; CONVERT FPA0 TO AN INTEGER
          jsr  LBC2F          ; PACK FPA0 TO FPA3
          bsr  LBF3B          ; GET A RANDOM NUMBER: FPA0 < 1.0
          ldx  #V40           ; POINT (X) TO FPA3
          bsr  LBEFC          ; MULTIPLY (X) BY FPA0
          ldx  #LBAC5         ; POINT (X) TO FP VALUE OF 1.0
          jsr  LB9C2          ; ADD 1.0 TO FPA0
LBF38     jmp  INT            ; CONVERT FPA0 TO AN INTEGER
* CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0
LBF3B     ldx  RVSEED+1       ; * MOVE VARIABLE
          stx  FPA0           ; * RANDOM NUMBER
          ldx  RVSEED+3       ; * SEED TO
          stx  FPA0+2         ; * FPA0
LBF45     ldx  RSEED          ; = MOVE FIXED
          stx  FPA1           ; = RANDOM NUMBER
          ldx  RSEED+2        ; = SEED TO
          stx  FPA1+2         ; = MANTISSA OF FPA0
          jsr  LBAD0          ; MULTIPLY FPA0 X FPA1
          ldd  VAD            ; GET THE TWO LOWEST ORDER PRODUCT BYTES
          addd #$658B         ; ADD A CONSTANT
          std  RVSEED+3       ; SAVE NEW LOW ORDER VARIABLE RANDOM # SEED
          std  FPA0+2         ; SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA
          ldd  VAB            ; GET 2 MORE LOW ORDER PRODUCT BYTES
          adcb #$B0           ; ADD A CONSTANT
          adca #5             ; ADD A CONSTANT
          std  RVSEED+1       ; SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED
          std  FPA0           ; SAVE NEW HIGH ORDER FPA0 MANTISSA
          clr  FP0SGN         ; FORCE FPA0 MANTISSA = POSITIVE
          lda  #$80           ; * SET FPA0 BIASED EXPONENT
          sta  FP0EXP         ; * TO 0 1 < FPA0 < 0
          lda  FPA2+2         ; GET A BYTE FROM FPA2 (MORE RANDOMNESS)
          sta  FPSBYT         ; SAVE AS SUB BYTE
          jmp  LBA1C          ; NORMALIZE FPA0
*
RSEED     fdb  $40E6          ; *CONSTANT RANDOM NUMBER GENERATOR SEED
          fdb  $4DAB          ; *

* SIN
* THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY
* 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS
* RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE
* MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.

* SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:
* SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)
SIN       jsr  LBC5F          ; COPY FPA0 TO FPA1
          ldx  #LBFBD         ; POINT (X) TO 2*PI
          ldb  FP1SGN         ; *GET MANTISSA SIGN OF FPA1
          jsr  LBB89          ; *AND DIVIDE FPA0 BY 2*PI
          jsr  LBC5F          ; COPY FPA0 TO FPA1
          bsr  LBF38          ; CONVERT FPA0 TO AN INTEGER
          clr  RESSGN         ; SET RESULT SIGN = POSITIVE
          lda  FP1EXP         ; *GET EXPONENT OF FPA1
          ldb  FP0EXP         ; *GET EXPONENT OF FPA0
          jsr  LB9BC          ; *SUBTRACT FPA0 FROM FPA1
* NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI
          ldx  #LBFC2         ; POINT X TO FP (.25)
          jsr  LB9B9          ; SUBTRACT FPA0 FROM .25 (PI/2)
          lda  FP0SGN         ; GET MANTISSA SIGN OF FPA0
          pshs a              ; SAVE IT ON STACK
          bpl  LBFA6          ; BRANCH IF MANTISSA POSITIVE
          jsr  LB9B4          ; ADD .5 (PI) TO FPA0
          lda  FP0SGN         ; GET SIGN OF FPA0
          bmi  LBFA9          ; BRANCH IF NEGATIVE
          com  RELFLG         ; com IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG)
LBFA6     jsr  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0
LBFA9     ldx  #LBFC2         ; POINT X TO FP (.25)
          jsr  LB9C2          ; ADD .25 (PI/2) TO FPA0
          puls a              ; GET OLD MANTISSA SIGN
          tsta                ; * BRANCH IF OLD
          bpl  LBFB7          ; * SIGN WAS POSITIVE
          jsr  LBEE9          ; TOGGLE MANTISSA SIGN
LBFB7     ldx  #LBFC7         ; POINT X TO TABLE OF COEFFICIENTS
          jmp  LBEF0          ; GO CALCULATE POLYNOMIAL VALUE

LBFBD     fcb  $83,$49,$0F,$Da,$A2 ; 6.28318531 (2*PI)
LBFC2     fcb  $7F,$00,$00,$00,$00 ; .25


LBFC7     fcb  6-1            ; SIX COEFFICIENTS
LBFC8     fcb  $84,$E6,$1a,$2d,$1B ; * -((2*PI)**11)/11!
LBFCD     fcb  $86,$28,$07,$Fb,$F8 ; * ((2*PI)**9)/9!
LBFD2     fcb  $87,$99,$68,$89,$01 ; * -((2*PI)**7)/7!
LBFD7     fcb  $87,$23,$35,$DF,$E1 ; * ((2*PI)**5)/5!
LBFDC     fcb  $86,$A5,$5d,$E7,$28 ; * -((2*PI)**3)/3!
LBFE1     fcb  $83,$49,$0F,$Da,$A2 ; *

          fcb  $A1,$54,$46,$8F,$13 ; UNUSED GARBAGE BYTES
          fcb  $8F,$52,$43,$89,$CD ; UNUSED GARBAGE BYTES
* EXTENDED BASIC

* COS
* THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTITY COS(X)=SIN((PI/2)+X)
COS       ldx  #L83AB         ; POINT X TO FP CONSTANT (P1/2)
          jsr  LB9C2          ; ADD FPA0 TO (X)
L837E     jmp  SIN            ; JUMP TO SIN ROUTINE

* TAN
* THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)
TAN       jsr  LBC2F          ; PACK FPA0 AND MOVE IT TO FPA3
          clr  RELFLG         ; RESET QUADRANT FLAG
          bsr  L837E          ; CALCULATE SIN OF ARGUMENT
          ldx  #V4A           ; POINT X TO FPA5
          jsr  LBC35          ; PACK FPA0 AND MOVE IT TO FPA5
          ldx  #V40           ; POINT X TO FPA3
          jsr  LBC14          ; MOVE FPA3 TO FPA0
          clr  FP0SGN         ; FORCE FPA0 MANTISSA TO BE POSITIVE
          lda  RELFLG         ; GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3
          bsr  L83A6          ; CALCULATE VALUE OF COS(FPA0)
          tst  FP0EXP         ; CHECK EXPONENT OF FPA0
          beq  LBA92          ; 'OV' ERROR IF COS(X)=0
          ldx  #V4A           ; POINT X TO FPA5
L83A3     jmp  LBB8F          ; DIVIDE (X) BY FPA0 - SIN(X)/COS(X)
L83A6     pshs a              ; SAVE SIGN FLAG ON STACK
          jmp  LBFA6          ; EXPAND POLYNOMIAL

L83AB     fcb  $81,$49,$0F,$Da,$A2 ; 1.57079633 (PI/2)

* ATN
* A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE
* ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED
* TO EVALUATE THE EXPRESSION DEPENDING UPON
* WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0

* IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .
* IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-. . .)

ATN       lda  FP0SGN         ; * GET THE SIGN OF THE MANTISSA AND
          pshs a              ; * SAVE IT ON THE STACK
          bpl  L83B8          ; BRANCH IF POSITIVE MANTISSA
          bsr  L83DC          ; CHANGE SIGN OF FPA0
L83B8     lda  FP0EXP         ; * GET EXPONENT OF FPA0 AND
          pshs a              ; * SAVE IT ON THE STACK
          cmpa #$81           ; IS FPAO < 1.0?
          blo  L83C5          ; YES
          ldx  #LBAC5         ; POINT X TO FP CONSTANT 1.0
          bsr  L83A3          ; GET RECIPROCAL OF FPA0
L83C5     ldx  #L83E0         ; POINT (X) TO TAYLOR SERIES COEFFICIENTS
          jsr  LBEF0          ; EXPAND POLYNOMIAL
          puls a              ; GET EXPONENT OF ARGUMENT
          cmpa #$81           ; WAS ARGUMENT < 1.0?
          blo  L83D7          ; YES
          ldx  #L83AB         ; POINT (X) TO FP NUMBER (PI/2)
          jsr  LB9B9          ; SUBTRACT FPA0 FROM (PI/2)
L83D7     puls a              ; * GET SIGN OF INITIAL ARGUMENT MANTISSA
          tsta                ; * AND SET FLAGS ACCORDING TO IT
          bpl  L83DF          ; RETURN IF ARGUMENT WAS POSITIVE
L83DC     jmp  LBEE9          ; CHANGE MANTISSA SIGN OF FPA0
L83DF     rts
*
* TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT
L83E0     fcb  $0B            ; TWELVE COEFFICIENTS
L83E1     fcb  $76,$B3,$83,$Bd,$D3 ; -6.84793912E-04 1/23
L83E6     fcb  $79,$1E,$F4,$A6,$F5 ; +4.85094216E-03 1/21
L83EB     fcb  $7b,$83,$FC,$B0,$10 ; -0.0161117018
L83F0     fcb  $7C,$0C,$1F,$67,$CA ; 0.0342096381
L83F5     fcb  $7C,$DE,$53,$Cb,$C1 ; -0.0542791328
L83FA     fcb  $7d,$14,$64,$70,$4C ; 0.0724571965
L83FF     fcb  $7d,$B7,$Ea,$51,$7A ; -0.0898023954
L8404     fcb  $7d,$63,$30,$88,$7E ; 0.110932413
L8409     fcb  $7E,$92,$44,$99,$3A ; -0.142839808
L840E     fcb  $7E,$4C,$CC,$91,$C7 ; 0.199999121
L8413     fcb  $7F,$Aa,$Aa,$Aa,$13 ; -0.333333316
L8418     fcb  $81,$00,$00,$00,$00 ; 1
*
*** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)
*
L841D     fcb  3              ; FOUR COEFFICIENTS
L841E     fcb  $7F,$5E,$56,$Cb,$79 ; 0.434255942
L8423     fcb  $80,$13,$9b,$0b,$64 ; 0.576584541
L8428     fcb  $80,$76,$38,$93,$16 ; 0.961800759
L842D     fcb  $82,$38,$Aa,$3b,$20 ; 2.88539007

L8432     fcb  $80,$35,$04,$F3,$34 ; 1/SQR(2)

L8437     fcb  $81,$35,$04,$F3,$34 ; SQR(2)

L843C     fcb  $80,$80,$00,$00,$00 ; -0.5

L8441     fcb  $80,$31,$72,$17,$F8 ; LN(2)
*
* LOG - NATURAL LOGARITHM (LN)

* THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USING
* MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*(2**B) (SCIENTIFIC
* NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE VALUE OF
* LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WILL EXPAND THIS
* TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)*LN(2). ALL OF
* THE TERMS OF THE LATTER EXPRESSION ARE CONstaNTS EXCEPT FOR THE
* LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLOR SERIES EXPANSION
LOG       jsr  LBC6D          ; CHECK STATUS OF FPA0
          ble  LB44A          ; 'FC' ERROR IF NEGATIVE OR ZERO
          ldx  #L8432         ; POINT (X) TO FP NUMBER (1/SQR(2))
          lda  FP0EXP         ; *GET EXPONENT OF ARGUMENT
          suba #$80           ; *SUBTRACT OFF THE BIAS AND
          pshs a              ; *SAVE IT ON THE STACK
          lda  #$80
          sta  FP0EXP
          jsr  LB9C2          ; ADD FPA0 TO (X)
          ldx  #L8437         ; POINT X TO SQR(2)
          jsr  LBB8F          ; DIVIDE SQR(2) BY FPA0
          ldx  #LBAC5         ; POINT X TO FP VALUE OF 1.00
          jsr  LB9B9          ; SUBTRACT FPA0 FROM (X)
*         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT
          ldx  #L841D         ; POINT X TO TABLE OF COEFFICIENTS
          jsr  LBEF0          ; EXPAND POLYNOMIAL
          ldx  #L843C         ; POINT X TO FP VALUE OF (-.5)
          jsr  LB9C2          ; ADD FPA0 TO X
          puls b              ; GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS)
          jsr  LBD99          ; ADD ACCB TO FPA0
          ldx  #L8441         ; POINT X TO LN(2)
          jmp  LBACA          ; MULTIPLY FPA0 * LN(2)

* SQR
SQR       jsr  LBC5F          ; MOVE FPA0 TO FPA1
          ldx  #LBEC0         ; POINT (X) TO FP NUMBER (.5)
          jsr  LBC14          ; COPY A PACKED NUMBER FROM (X) TO FPA0

* ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS
* HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION
* IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818
L8489     beq  EXP            ; DO A NATURAL EXPONENTIATION IF EXPONENT = 0
          tsta                ; *CHECK VALUE BEING EXPONENTIATED
          bne  L8491          ; *AND BRANCH IF IT IS <> 0
          jmp  LBA3A          ; FPA0=0 IF RAISING ZERO TO A POWER
L8491     ldx  #V4A           ; * PACK FPA0 AND SAVE
          jsr  LBC35          ; * IT IN FPA5 (ARGUMENT'S EXPONENT)
          clrb                ; ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE
          lda  FP1SGN         ; *CHECK THE SIGN OF ARGUMENT
          bpl  L84AC          ; *BRANCH IF POSITIVE
          jsr  INT            ; CONVERT EXPONENT INTO AN INTEGER
          ldx  #V4A           ; POINT X TO FPA5 (ORIGINAL EXPONENT)
          lda  FP1SGN         ; GET MANTISSA SIGN OF FPA1 (ARGUMENT)
          jsr  LBCA0          ; *COMPARE FPA0 TO (X) AND
          bne  L84AC          ; *BRANCH IF NOT EQUAL
          coma                ; TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE
          ldb  CHARAC         ; GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG)
L84AC     jsr  LBC4C          ; COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN
          pshs b              ; PUT RESULT SIGN FLAG ON THE STACK
          jsr  LOG
          ldx  #V4A           ; POINT (X) TO FPA5
          jsr  LBACA          ; MULTIPLY FPA0 BY FPA5
          bsr  EXP            ; CALCULATE E**(FPA0)
          puls a              ; * GET RESULT SIGN FLAG FROM THE STACK
          rora                ; * AND BRANCH IF NEGATIVE
          bcs  LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
          rts

* CORRECTION FACTOR FOR EXPONENTIAL FUNCTION
L84C4     fcb  $81,$38,$Aa,$3b,$29 ; 1.44269504 ( CF )
*
* TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X
*
L84C9     fcb  7              ; EIGHT COEFFICIENTS
L84CA     fcb  $71,$34,$58,$3E,$56 ; 2.14987637E-05: 1/(7!*(CF**7))
L84CF     fcb  $74,$16,$7E,$B3,$1B ; 1.4352314E-04 : 1/(6!*(CF**6))
L84D4     fcb  $77,$2F,$EE,$E3,$85 ; 1.34226348E-03: 1/(5!*(CF**5))
L84D9     fcb  $7A,$1D,$84,$1C,$2A ; 9.61401701E-03: 1/(4!*(CF**4))
L84DE     fcb  $7C,$63,$59,$58,$0A ; 0.0555051269
L84E3     fcb  $7E,$75,$FD,$E7,$C6 ; 0.240226385
L84E8     fcb  $80,$31,$72,$18,$10 ; 0.693147186
L84ED     fcb  $81,$00,$00,$00,$00 ; 1
*
* EXP ( E**X)
* THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTIPLYING THE
* ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN
* ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A
* NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE
* ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT
* THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.

EXP       ldx  #L84C4         ; POINT X TO THE CORRECTION FACTOR
          jsr  LBACA          ; MULTIPLY FPA0 BY (X)
          jsr  LBC2F          ; PACK FPA0 AND STORE IT IN FPA3
          lda  FP0EXP         ; *GET EXPONENT OF FPA0 AND
          cmpa #$88           ; *COMPARE TO THE MAXIMUM VALUE
          blo  L8504          ; BRANCH IF FPA0 < 128
L8501     jmp  LBB5C          ; SET FPA0 = 0 OR 'OV' ERROR
L8504     jsr  INT            ; CONVERT FPA0 TO INTEGER
          lda  CHARAC         ; GET LS BYTE OF INTEGER
          adda #$81           ; * WAS THE ARGUMENT =127, IF SO
          beq  L8501          ; * THEN 'OV' ERROR; THIS WILL ALSO ADD THE $80 BIAS
*              ; * REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW
          deca                ; DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE
          pshs a              ; SAVE EXPONENT OF INTEGER PORTION ON STACK
          ldx  #V40           ; POINT (X) TO FPA3
          jsr  LB9B9          ; SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT
          ldx  #L84C9         ; POINT X TO COEFFICIENTS
          jsr  LBEFF          ; EVALUATE POLYNOMIAL FOR FRACTIONAL PART
          clr  RESSGN         ; FORCE THE MANTISSA TO BE POSITIVE
          puls a              ; GET INTEGER EXPONENT FROM STACK
          jsr  LBB48          ; * CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE
*              ; * INTEGER AND FRACTIONAL PARTS
          rts

* FIX
FIX       jsr  LBC6D          ; CHECK STATUS OF FPA0
          bmi  L852C          ; BRANCH IF FPA0 = NEGATIVE
L8529     jmp  INT            ; CONVERT FPA0 TO INTEGER
L852C     com  FP0SGN         ; TOGGLE SIGN OF FPA0 MANTISSA
          bsr  L8529          ; CONVERT FPA0 TO INTEGER
          jmp  LBEE9          ; TOGGLE SIGN OF FPA0

* EDIT
EDIT      jsr  L89AE          ; GET LINE NUMBER FROM BASIC
          leas $02,s          ; PURGE RETURN ADDRESS OFF OF THE STACK
L8538     lda  #$01           ; 'LIST' FLAG
          sta  VD8            ; SET FLAG TO LIST LINE
          jsr  LAD01          ; GO FIND THE LINE NUMBER IN PROGRAM
          bcs  LAED2          ; ERROR #7 'UNDEFINED LINE #'
          jsr  LB7C2          ; GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1
          tfr  y,d            ; PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD
          subd #LINBUF+2      ; SUBTRACT OUT THE START OF LINE
          stb  VD7            ; SAVE LENGTH OF LINE
L854D     ldd  BINVAL         ; GET THE HEX VALUE OF LINE NUMBER
          jsr  LBDCC          ; LIST THE LINE NUMBER ON THE SCREEN
          jsr  LB9AC          ; PRINT A SPACE
          ldx  #LINBUF+1      ; POINT X TO BUFFER
          ldb  VD8            ; * CHECK TO SEE IF LINE IS TO BE
          bne  L8581          ; * LISTED TO SCREEN - BRANCH IF IT IS
L855C     clrb                ; RESET DIGIT ACCUMULATOR - DEFAULT VALUE
L855D     jsr  L8687          ; GET KEY STROKE
          jsr  L90AA          ; SET CARRY IF NOT NUMERIC
          blo  L8570          ; BRANCH IF NOT NUMERIC
          suba #'0'            ; MASK OFF ASCII
          pshs a              ; SAVE IT ON STACK
          lda  #10            ; NUMBER BEING CONVERTED IS BASE 10
          mul                 ; MULTIPLY ACCUMULATED VALUE BY BASE (10)
          addb ,s+            ; ADD DIGIT TO ACCUMULATED VALUE
          bra  L855D          ; CHECK FOR ANOTHER DIGIT
L8570     subb #$01           ; * REPEAT PARAMETER IN ACCB; IF IT
          adcb #$01           ; *IS 0, THEN MAKE IT '1'
          cmpa #'A'           ; ABORT?
          bne  L857D          ; NO
          jsr  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
          bra  L8538          ; RESTART EDIT PROCESS - CANCEL ALL CHANGES
L857D     cmpa #'L'           ; LIST?
          bne  L858C          ; NO
L8581     bsr  L85B4          ; LIST THE LINE
          clr  VD8            ; RESET THE LIST FLAG TO 'NO LIST'
          jsr  LB958          ; PRINT CARRIAGE RETURN
          bra  L854D          ; GO INTERPRET ANOTHER EDIT COMMAND
L858A     leas $02,s          ; PURGE RETURN ADDRESS OFF OF THE STACK
L858C     cmpa #CR            ; ENTER KEY?
          bne  L859D          ; NO
          bsr  L85B4          ; ECHO THE LINE TO THE SCREEN
L8592     jsr  LB958          ; PRINT CARRIAGE RETURN
          ldx  #LINBUF+1      ; * RESET BASIC'S INPUT POINTER
          stx  CHARAD         ; * TO THE LINE INPUT BUFFER
          jmp  LACA8          ; GO PUT LINE BACK IN PROGRAM
L859D     cmpa #'E'           ; EXIT?
          beq  L8592          ; YES - SAME AS ENTER EXCEPT NO ECHO
          cmpa #'Q'           ; QUIT?
          bne  L85AB          ; NO
          jsr  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
          jmp  LAC73          ; GO TO COMMAND LEVEL - MAKE NO CHANGES
L85AB     bsr  L85AF          ; INTERPRET THE REMAINING COMMANDS AS SUBROUTINES
          bra  L855C          ; GO INTERPRET ANOTHER EDIT COMMAND
L85AF     cmpa #SPACE         ; SPACE BAR?
          bne  L85C3          ; NO
L85B3     fcb  SKP2           ; SKIP TWO BYTES
* DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFER TO THE SCREEN
*
L85B4     ldb  #LBUFMX-1      ; 250 BYTES MAX IN BUFFER
L85B6     lda  ,x             ; GET A CHARACTER FROM BUFFER
          beq  L85C2          ; EXIT IF IT'S A 0
          jsr  PUTCHR         ; SEND CHAR TO CONSOLE OUT
          leax $01,x          ; MOVE POINTER UP ONE
          decb                ; DECREMENT CHARACTER COUNTER
          bne  L85B6          ; LOOP IF NOT DONE
L85C2     rts
L85C3     cmpa #'D'           ; DELETE?
          bne  L860F          ; NO
L85C7     tst  ,x             ; * CHECK FOR END OF LINE
          beq  L85C2          ; * AND BRANCH IF SO
          bsr  L85D1          ; REMOVE A CHARACTER
          decb                ; DECREMENT REPEAT PARAMETER
          bne  L85C7          ; BRANCH IF NOT DONE
          rts
* REMOVE ONE CHARACTER FROM BUFFER
L85D1     dec  VD7            ; DECREMENT LENGTH OF BUFFER
          leay -1,x           ; POINT Y TO ONE BEFORE CURRENT BUFFER POINTER
L85D5     leay $01,y          ; INCREMENT TEMPORARY BUFFER POINTER
          lda  $01,y          ; GET NEXT CHARACTER
          sta  ,y             ; PUT IT IN CURRENT POSITION
          bne  L85D5          ; BRANCH IF NOT END OF LINE
          rts
L85DE     cmpa #'I'           ;  INSERT?
          beq  L85F5          ; YES
          cmpa #'X'           ; EXTEND?
          beq  L85F3          ; YES
          cmpa #'H'           ; HACK?
          bne  L8646          ; NO
          clr  ,x             ; TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG
          tfr  x,d            ; PUT CURRENT BUFFER POINTER IN ACCD
          subd #LINBUF+2      ; SUBTRACT INITIAL POINTER POSITION
          stb  VD7            ; SAVE NEW BUFFER LENGTH
L85F3     bsr  L85B4          ; DISPLAY THE LINE ON THE SCREEN
L85F5     jsr  L8687          ; GET A KEYSTROKE
          cmpa #CR            ; ENTER KEY?
          beq  L858A          ; YES - INTERPRET ANOTHER COMMAND - PRINT LINE
          cmpa #ESC           ; ESCAPE?
          beq  L8625          ; YES - RETURN TO COMMAND LEVEL - DON'T PRINT LINE
          cmpa #BS            ; BACK SPACE?
          bne  L8626          ; NO
          cmpx #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
          beq  L85F5          ; DO NOT ALLOW BS IF AT START
          bsr  L8650          ; MOVE POINTER BACK ONE, BS TO SCREEN
          bsr  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
          bra  L85F5          ; GET INSERT SUB COMMAND
L860F     cmpa #'C'           ; CHANGE?
          bne  L85DE          ; NO
L8613     tst  ,x             ; CHECK CURRENT BUFFER CHARACTER
          beq  L8625          ; BRANCH IF END OF LINE
          jsr  L8687          ; GET A KEYSTROKE
          blo  L861E          ; BRANCH IF LEGITIMATE KEY
          bra  L8613          ; TRY AGAIN IF ILLEGAL KEY
L861E     sta  ,x+            ; INSERT NEW CHARACTER INTO BUFFER
          bsr  L8659          ; SEND NEW CHARACTER TO SCREEN
          decb                ; DECREMENT REPEAT PARAMETER
          bne  L8613          ; BRANCH IF NOT DONE
L8625     rts
L8626     ldb  VD7            ; GET LENGTH OF LINE
          cmpb #LBUFMX-1      ; COMPARE TO MAXIMUM LENGTH
          bne  L862E          ; BRANCH IF NOT AT MAXIMUM
          bra  L85F5          ; IGNORE INPUT IF LINE AT MAXIMUM LENGTH
L862E     pshs x              ; SAVE CURRENT BUFFER POINTER
L8630     tst  ,x+            ; * SCAN THE LINE UNTIL END OF
          bne  L8630          ; * LINE (0) IS FOUND
L8634     ldb  ,-x            ; DECR TEMP LINE POINTER AND GET A CHARACTER
          stb  $01,x          ; PUT CHARACTER BACK DOWN ONE SPOT
          cmpx ,s             ; HAVE WE REACHED STARTING POINT?
          bne  L8634          ; NO - KEEP GOING
          leas $02,s          ; PURGE BUFFER POINTER FROM STACK
          sta  ,x+            ; INSERT NEW CHARACTER INTO THE LINE
          bsr  L8659          ; SEND A CHARACTER TO CONSOLE OUT
          inc  VD7            ; ADD ONE TO BUFFER LENGTH
          bra  L85F5          ; GET INSERT SUB COMMAND
L8646     cmpa #BS            ; BACKSPACE?
          bne  L865C          ; NO
L864A     bsr  L8650          ; MOVE POINTER BACK 1, SEND BS TO SCREEN
          decb                ; DECREMENT REPEAT PARAMETER
          bne  L864A          ; LOOP UNTIL DONE
          rts
L8650     cmpx #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
          beq  L8625          ; DO NOT ALLOW BS IF AT START
          leax -1,x           ; MOVE POINTER BACK ONE
          lda  #BS            ; BACK SPACE
L8659     jmp  PUTCHR         ; SEND TO CONSOLE OUT
L865C     cmpa #'K'           ; KILL?
          beq  L8665          ; YES
          suba #'S'           ; SEARCH?
          beq  L8665          ; YES
          rts
L8665     pshs a              ; SAVE KILL/SEARCH FLAG ON STACK
          bsr  L8687          ; * GET A KEYSTROKE (TARGET CHARACTER)
          pshs a              ; * AND SAVE IT ON STACK
L866B     lda  ,x             ; GET CURRENT BUFFER CHARACTER
          beq  L8685          ; AND RETURN IF END OF LINE
          tst  $01,s          ; CHECK KILL/SEARCH FLAG
          bne  L8679          ; BRANCH IF KILL
          bsr  L8659          ; SEND A CHARACTER TO CONSOLE OUT
          leax $01,x          ; INCREMENT BUFFER POINTER
          bra  L867C          ; CHECK NEXT INPUT CHARACTER
L8679     jsr  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
L867C     lda  ,x             ; GET CURRENT INPUT CHARACTER
          cmpa ,s             ; COMPARE TO TARGET CHARACTER
          bne  L866B          ; BRANCH IF NO MATCH
          decb                ; DECREMENT REPEAT PARAMETER
          bne  L866B          ; BRANCH IF NOT DONE
L8685     puls y,pc           ; THE Y PULL WILL CLEAN UP THE STACK FOR THE 2 pshs a
*
* GET A KEYSTRKE
L8687     jsr  LA171          ; CALL CONSOLE IN : DEV NBR=SCREEN
          cmpa #$7F           ; GRAPHIC CHARACTER?
          bcc  L8687          ; YES - GET ANOTHER CHAR
          cmpa #$5F           ; SHIFT UP ARROW (QUIT INSERT)
          bne  L8694          ; NO
          lda  #ESC           ; REPLACE W/ESCAPE CODE
L8694     cmpa #CR            ; ENTER KEY
          beq  L86A6          ; YES
          cmpa #ESC           ; ESCAPE?
          beq  L86A6          ; YES
          cmpa #BS            ; BACKSPACE?
          beq  L86A6          ; YES
          cmpa #SPACE         ; SPACE
          blo  L8687          ; GET ANOTHER CHAR IF CONTROL CHAR
          orcc #$01           ; SET CARRY
L86A6     rts

* TRON
TRON      fcb  SKP1LD         ; SKIP ONE BYTE AND lda #$4F

* TROFF
TROFF     clra                ; TROFF FLAG
          sta  TRCFLG         ; TRON/TROFF FLAG:0=TROFF, <> 0=TRON
          rts

* POS

POS       lda  #0             ; GET DEVICE NUMBER
          ldb  LPTPOS         ; GET PRINT POSITION
LA5E8     sex                 ; CONVERT ACCB TO 2 DIGIT SIGNED INTEGER
          jmp  GIVABF         ; CONVERT ACCD TO FLOATING POINT


* VARPTR
VARPT     jsr  LB26A          ; SYNTAX CHECK FOR '('
          ldd  ARYEND         ; GET ADDR OF END OF ARRAYS
          pshs b,a            ; SAVE IT ON STACK
          jsr  LB357          ; GET VARIABLE DESCRIPTOR
          jsr  LB267          ; SYNTAX CHECK FOR ')'
          puls a,b            ; GET END OF ARRAYS ADDR BACK
          exg  x,d            ; SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR
          cmpx ARYEND         ; COMPARE TO NEW END OF ARRAYS
          bne  L8724          ; 'FC' ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR
          jmp  GIVABF         ; CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER

* MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT
L86D6     jsr  GETNCH         ; GET INPUT CHAR FROM BASIC
          jsr  LB26A          ; SYNTAX CHECK FOR '('
          jsr  LB357          ; * GET VARIABLE DESCRIPTOR ADDRESS AND
          pshs x              ; * SAVE IT ON THE STACK
          ldd  $02,x          ; POINT ACCD TO START OF OLDSTRING
          cmpd FRETOP         ; COMPARE TO START OF CLEARED SPACE
          bls  L86EB          ; BRANCH IF <=
          subd MEMSIZ         ; SUBTRACT OUT TOP OF CLEARED SPACE
          bls  L86FD          ; BRANCH IF STRING IN STRING SPACE
L86EB     ldb  ,x             ; GET LENGTH OF OLDSTRING
          jsr  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
          pshs x              ; SAVE RESERVED SPACE STRING ADDRESS ON STACK
          ldx  $02,s          ; POINT X TO OLDSTRING DESCRIPTOR
          jsr  LB643          ; MOVE OLDSTRING INTO STRING SPACE
          puls x,u            ; * GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING
          stx  $02,u          ; * ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS
          pshs u              ; SAVE OLDSTRING DESCRIPTOR ADDRESS
L86FD     jsr  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
          pshs b              ; SAVE POSITION PARAMETER ON STACK
          tstb                ; * CHECK POSITION PARAMETER AND BRANCH
          beq  L8724          ; * IF START OF STRING
          ldb  #$FF           ; DEFAULT REPLACEMENT LENGTH = $FF
          cmpa #')'           ; * CHECK FOR END OF MID$ STATEMENT AND
          beq  L870E          ; * BRANCH IF AT END OF STATEMENT
          jsr  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
L870E     pshs b              ; SAVE LENGTH PARAMETER ON STACK
          jsr  LB267          ; SYNTAX CHECK FOR ')'
          ldb  #TOK_EQUALS    ; TOKEN FOR =
          jsr  LB26F          ; SYNTAX CHECK FOR '='
          bsr  L8748          ; EVALUATE REPLACEMENT STRING
          tfr  x,u            ; SAVE REPLACEMENT STRING ADDRESS IN U
          ldx  $02,s          ; POINT X TO OLOSTRING DESCRIPTOR ADDRESS
          lda  ,x             ; GET LENGTH OF OLDSTRING
          suba $01,s          ; SUBTRACT POSITION PARAMETER
          bcc  L8727          ; INSERT REPLACEMENT STRING INTO OLDSTRING
L8724     jmp  LB44A          ; 'FC' ERROR IF POSITION > LENGTH OF OLDSTRING
L8727     inca                ; * NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT
*                             ; * (INCLUSIVE) OF THE POSITION PARAMETER
          cmpa ,s
          bcc  L872E          ; BRANCH IF NEW STRING WILL FIT IN OLDSTRING
          sta  ,s             ; IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT
L872E     lda  $01,s          ; GET POSITION PARAMETER
          exg  a,b            ; ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER
          ldx  $02,x          ; POINT X TO OLDSTRING ADDRESS
          decb                ; * BASIC'S POSITION PARAMETER STARTS AT 1; THIS ROUTINE
*                             ; * WANTS IT TO START AT ZERO
          abx                 ; POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO
          tsta                ; * IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO
          beq  L8746          ; * THEN RETURN
          cmpa ,s
          bls  L873F          ; ADJUSTED LENGTH PARAMETER, THEN BRANCH
          lda  ,s             ; OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE
L873F     tfr  a,b            ; SAVE NUMBER OF BYTES TO MOVE IN ACCB
          exg  u,x            ; SWAP SOURCE AND DESTINATION POINTERS
          jsr  LA59A          ; MOVE (B) BYTES FROM (X) TO (U)
L8746     puls a,b,x,pc
L8748     jsr  LB156          ; EVALUATE EXPRESSION
          jmp  LB654          ; *'TM' ERROR IF NUMERIC; RETURN WITH X POINTING
*                             ; *TO STRING, ACCB = LENGTH

* STRING
STRING    jsr  LB26A          ; SYNTAX CHECK FOR '('
          jsr  LB70B          ; EVALUATE EXPRESSION; ERROR IF > 255
          pshs b              ; SAVE LENGTH OF STRING
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          jsr  LB156          ; EVALUATE EXPRESSION
          jsr  LB267          ; SYNTAX CHECK FOR ')'
          lda  VALTYP         ; GET VARIABLE TYPE
          bne  L8768          ; BRANCH IF STRING
          jsr  LB70E          ; CONVERT FPA0 INTO AN INTEGER IN ACCB
          bra  L876B          ; SAVE THE STRING IN STRING SPACE
L8768     jsr  LB6A4          ; GET FIRST BYTE OF STRING
L876B     pshs b              ; SAVE FIRST BYTE OF EXPRESSION
          ldb  $01,s          ; GET LENGTH OF STRING
          jsr  LB50F          ; RESERVE ACCB BYTES IN STRING SPACE
          puls a,b            ; GET LENGTH OF STRING AND CHARACTER
          beq  L877B          ; BRANCH IF NULL STRING
L8776     sta  ,x+            ; SAVE A CHARACTER IN STRING SPACE
          decb                ; DECREMENT LENGTH
          bne  L8776          ; BRANCH IF NOT DONE
L877B     jmp  LB69B          ; PUT STRING DESCRIPTOR ONTO STRING STACK

* INSTR
INSTR     jsr  LB26A          ; SYNTAX CHECK FOR '('
          jsr  LB156          ; EVALUATE EXPRESSION
          ldb  #$01           ; DEFAULT POSITION = 1 (SEARCH START)
          pshs b              ; SAVE START
          lda  VALTYP         ; GET VARIABLE TYPE
          bne  L879C          ; BRANCH IF STRING
          jsr  LB70E          ; CONVERT FPA0 TO INTEGER IN ACCB
          stb  ,s             ; SAVE START SEARCH VALUE
          beq  L8724          ; BRANCH IF START SEARCH AT ZERO
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          jsr  LB156          ; EVALUATE EXPRESSION - SEARCH STRING
          jsr  LB146          ; 'TM' ERROR IF NUMERIC
L879C     ldx  FPA0+2         ; SEARCH STRING DESCRIPTOR ADDRESS
          pshs x              ; SAVE ON THE STACK
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          jsr  L8748          ; EVALUATE TARGET STRING EXPRESSION
          pshs x,b            ; SAVE ADDRESS AND LENGTH ON STACK
          jsr  LB267          ; SYNTAX CHECK FOR ')'
          ldx  $03,s          ; * LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS
          jsr  LB659          ; * AND GET THE LENGTH AND ADDRESS OF SEARCH STRING
          pshs b              ; SAVE LENGTH ON STACK
*
* AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATION
* ON IT: 0,s-SEARCH LENGTH; 1,s-TARGET LENGTH; 2 3,s-TARGET
* ADDRESS; 4 5,s-SEARCH DESCRIPTOR ADDRESS; 6,s-SEARCH POSITION
          cmpb $06,s          ; COMPARE LENGTH OF SEARCH STRING TO START
          blo  L87D9          ; POSITION; RETURN 0 IF LENGTH < START
          lda  $01,s          ; GET LENGTH OF TARGET STRING
          beq  L87D6          ; BRANCH IF TARGET STRING = NULL
          ldb  $06,s          ; GET START POSITION
          decb                ; MOVE BACK ONE
          abx                 ; POINT X TO POSITION IN SEARCH STRING WHERE SEARCHING WILL START
L87BE     leay ,x             ; POINT Y TO SEARCH POSITION
          ldu  $02,s          ; POINT U TO START OF TARGET
          ldb  $01,s          ; LOAD ACCB WITH LENGTH OF TARGET
          lda  ,s             ; LOAD ACCA WITH LENGTH OF SEARCH
          suba $06,s          ; SUBTRACT SEARCH POSITION FROM SEARCH LENGTH
          inca                ; ADD ONE
          cmpa $01,s          ; COMPARE TO TARGET LENGTH
          blo  L87D9          ; RETURN 0 IF TARGET LENGTH > WHAT'S LEFT OF SEARCH STRING
L87CD     lda  ,x+            ; GET A CHARACTER FROM SEARCH STRING
          cmpa ,u+            ; COMPARE IT TO TARGET STRING
          bne  L87DF          ; BRANCH IF NO MATCH
          decb                ; DECREMENT TARGET LENGTH
          bne  L87CD          ; CHECK ANOTHER CHARACTER
L87D6     ldb  $06,s          ; GET MATCH POSITION
L87D8     fcb  SKP1           ; SKIP NEXT BYTE
L87D9     clrb                ; MATCH ADDRESS = 0
          leas $07,s          ; CLEAN UP THE STACK
          jmp  LB4F3          ; CONVERT ACCB TO FP NUMBER
L87DF     inc  $06,s          ; INCREMENT SEARCH POSITION
          leax $01,y          ; MOVE X TO NEXT SEARCH POSITION
          bra  L87BE          ; KEEP LOOKING FOR A MATCH

* EXTENDED BASIC RVEC19 HOOK CODE
XVEC19    cmpa #'&'           ; *
          bne  L8845          ; * RETURN IF NOT HEX OR OCTAL VARIABLE
          leas $02,s          ; PURGE RETURN ADDRESS FROM STACK
* PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
L87EB     clr  FPA0+2         ; * CLEAR BOTTOM TWO
          clr  FPA0+3         ; * BYTES OF FPA0
          ldx  #FPA0+2        ; BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR)
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          cmpa #'O'
          beq  L880A          ; YES
          cmpa #'H'
          beq  L881F          ; YES
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          bra  L880C          ; DEFAULT TO OCTAL (&O)
L8800     cmpa #'8'
          bhi  LB277
          ldb  #$03           ; BASE 8 MULTIPLIER
          bsr  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
* EVALUATE AN &O VARIABLE
L880A     jsr  GETNCH         ; GET A CHARACTER FROM BASIC
L880C     blo  L8800          ; BRANCH IF NUMERIC
L880E     clr  FPA0           ; * CLEAR 2 HIGH ORDER
          clr  FPA0+1         ; * BYTES OF FPA0
          clr  VALTYP         ; SET VARXABLE TYPE TO NUMERIC
          clr  FPSBYT         ; ZERO OUT SUB BYTE OF FPA0
          clr  FP0SGN         ; ZERO OUT MANTISSA SIGN OF FPA0
          ldb  #$A0           ; * SET EXPONENT OF FPA0
          stb  FP0EXP         ; *
          jmp  LBA1C          ; GO NORMALIZE FPA0
* EVALUATE AN &H VARIABLE
L881F     jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          blo  L882E          ; BRANCH IF NUMERIC
          jsr  LB3A2          ; SET CARRY IF NOT ALPHA
          blo  L880E          ; BRANCH IF NOT ALPHA OR NUMERIC
          cmpa #'G'           ; CHECK FOR LETTERS A-F
          bcc  L880E          ; BRANCH IF >= G (ILLEGAL HEX LETTER)
          suba #7             ; SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9
L882E     ldb  #$04           ; BASE 16 DIGIT MULTIPLIER = 2**4
          bsr  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
          bra  L881F          ; KEEP EVALUATING VARIABLE
L8834     asl  $01,x          ; * MULTIPLY TEMPORARY
          rol  ,x             ; * ACCUMULATOR BY TWO
          bcs  LBA92          ; 'OV' OVERFLOW ERROR
          decb                ; DECREMENT SHIFT COUNTER
          bne  L8834          ; MULTIPLY TEMPORARY ACCUMULATOR AGAIN
          suba #'0'            ; MASK OFF ASCII
          adda $01,x          ; * ADD DIGIT TO TEMPORARY
          sta  $01,x          ; * ACCUMULATOR AND SAVE IT
L8845     rts

XVEC15    puls u              ; PULL RETURN ADDRESS AND SAVE IN U REGISTER
          clr  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
          ldx  CHARAD         ; CURRENT INPUT POINTER TO X
          jsr  GETNCH         ; GET CHARACTER FROM BASIC
          cmpa #'&'           ; HEX AND OCTAL VARIABLES ARE PRECEEDED BY &
          beq  L87EB          ; PROCESS A '&' VARIABLE
          cmpa #TOK_FN        ; TOKEN FOR FN
          beq  L88B4          ; PROCESS FN CALL
          cmpa #$FF           ; CHECK FOR SECONDARY TOKEN
          bne  L8862          ; NOT SECONDARY
          jsr  GETNCH         ; GET CHARACTER FROM BASIC
          cmpa #TOK_USR       ; TOKEN FOR USR
          lbeq L892C          ; PROCESS USR CALL
L8862     stx  CHARAD         ; RESTORE BASIC'S INPUT POINTER
          jmp  ,u             ; RETURN TO CALLING ROUTINE
L8866     ldx  CURLIN         ; GET CURRENT LINE NUMBER
          leax $01,x          ; IN DIRECT MODE?
          bne  L8845          ; RETURN IF NOT IN DIRECT MODE
          ldb  #2*11          ; 'ILLEGAL DIRECT STATEMENT' ERROR
L886E     jmp  LAC46          ; PROCESS ERROR

DEF       ldx  [CHARAD]       ; GET TWO INPUT CHARS
          cmpx #TOK_FF_USR    ; TOKEN FOR USR
          beq  L890F          ; BRANCH IF DEF USR
          bsr  L88A1          ; GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME
          bsr  L8866          ; DON'T ALLOW DEF FN IF IN DIRECT MODE
          jsr  LB26A          ; SYNTAX CHECK FOR '('
          ldb  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE
          stb  ARYDIS         ; * AND SAVE IT IN THE ARRAY DISABLE FLAG
          jsr  LB357          ; GET VARIABLE DESCRIPTOR
          bsr  L88B1          ; 'TM' ERROR IF STRING
          jsr  LB267          ; SYNTAX CHECK FOR ')'
          ldb  #TOK_EQUALS    ; TOKEN FOR '='
          jsr  LB26F          ; DO A SYNTAX CHECK FOR =
          ldx  V4B            ; GET THE ADDRESS OF THE FN NAME DESCRIPTOR
          ldd  CHARAD         ; * GET THE CURRENT INPUT POINTER ADDRESS AND
          std  ,x             ; * SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR
          ldd  VARPTR         ; = GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT
          std  $02,x          ; = VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME
          jmp  DATA           ; MOVE INPUT POINTER TO END OF LINE OR SUBLINE
L88A1     ldb  #TOK_FN        ; TOKEN FOR FN
          jsr  LB26F          ; DO A SYNTAX CHECK FOR FN
          ldb  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG
          stb  ARYDIS         ; * AND SAVE IT IN ARRAY VARIABLE FLAG
          ora  #$80           ; SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE
          jsr  LB35C          ; * GET THE DESCRIPTOR ADDRESS OF THIS
          stx  V4B            ; * VARIABLE AND SAVE IT IN V4B
L88B1     jmp  LB143          ; 'TM' ERROR IF STRING VARIABLE
* EVALUATE AN FN CALL
L88B4     bsr  L88A1          ; * GET THE DESCRIPTOR OF THE FN NAME
          pshs x              ; * VARIABLE AND SAVE IT ON THE STACK
          jsr  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
          bsr  L88B1          ; 'TM' ERROR IF STRING VARIABLE
          puls u              ; POINT U TO FN NAME DESCRIPTOR
          ldb  #2*25          ; 'UNDEFINED FUNCTION CALL' ERROR
          ldx  $02,u          ; POINT X TO ARGUMENT VARIABLE DESCRIPTOR
          beq  L886E          ; BRANCH TO ERROR HANDLER
          ldy  CHARAD         ; SAVE CURRENT INPUT POINTER IN Y
          ldu  ,u             ; * POINT U TO START OF FN FORMULA AND
          stu  CHARAD         ; * SAVE IT IN INPUT POINTER
          lda  $04,x          ; = GET FP VALUE OF
          pshs a              ; = ARGUMENT VARIABLE, CURRENT INPUT
          ldd  ,x             ; = POINTER, AND ADDRESS OF START
          ldu  $02,x          ; = OF FN FORMULA AND SAVE
          pshs u,y,x,b,a      ; = THEM ON THE STACK
          jsr  LBC35          ; PACK FPA0 AND SAVE IT IN (X)
L88D9     jsr  LB141          ; EVALUATE FN EXPRESSION
          puls a,b,x,y,u      ; RESTORE REGISTERS
          std  ,x             ; * GET THE FP
          stu  $02,x          ; * VALUE OF THE ARGUMENT
          puls a              ; * VARIABLE OFF OF THE
          sta  $04,x          ; * STACK AND RE-SAVE IT
          jsr  GETCCH         ; GET FINAL CHARACTER OF THE FN FORMULA
          lbne LB277          ; 'SYNTAX' ERROR IF NOT END OF LINE
          sty  CHARAD         ; RESTORE INPUT POINTER
L88EF     rts



* DEF USR
L890F     jsr  GETNCH         ; SKIP PAST SECOND BYTE OF DEF USR TOKEN
          bsr  L891C          ; GET FN NUMBER
          pshs x              ; SAVE FN EXEC ADDRESS STORAGE LOC
          bsr  L8944          ; CALCULATE EXEC ADDRESS
          puls u              ; GET FN EXEC ADDRESS STORAGE LOC
          stx  ,u             ; SAVE EXEC ADDRESS
          rts
L891C     clrb                ; DEFAULT TO USR0 IF NO ARGUMENT
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          bcc  L8927          ; BRANCH IF NOT NUMERIC
          suba #'0'            ; MASK OFF ASCII
          tfr  a,b            ; SAVE USR NUMBER IN ACCB
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
L8927     ldx  USRADR         ; GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS
          aslb                ; X2 - 2 BYTES/USR ADDRESS
          abx                 ; ADD OFFSET TO START ADDRESS OF STORAGE LOCs
          rts
* PROCESS A USR CALL
L892C     bsr  L891C          ; GET STORAGE LOC OF EXEC ADDRESS FOR USR N
          ldx  ,x             ; * GET EXEC ADDRESS AND
          pshs x              ; * PUSH IT ONTO STACK
          jsr  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
          ldx  #FP0EXP        ; POINT X TO FPA0
          lda  VALTYP         ; GET VARIABLE TYPE
          beq  L8943          ; BRANCH IF NUMERIC, STRING IF <> 0
          jsr  LB657          ; GET LENGTH & ADDRESS OF STRING VARIABLE
          ldx  FPA0+2         ; GET POINTER TO STRING DESCRIPTOR
          lda  VALTYP         ; GET VARIABLE TYPE
L8943     rts                 ; JUMP TO USR ROUTINE (pshs x ABOVE)
L8944     ldb  #TOK_EQUALS    ; TOKEN FOR '='
          jsr  LB26F          ; DO A SYNTAX CHECK FOR =
          jmp  LB73D          ; EVALUATE EXPRESSION, RETURN VALUE IN X



* DEL
DEL       beq  LB44A          ; 'FC' ERROR IF NO ARGUMENT
          jsr  LAF67          ; CONVERT A DECIMAL BASiC NUMBER TO BINARY
          jsr  LAD01          ; FIND RAM ADDRESS OF START OF A BASIC LINE
          stx  VD3            ; SAVE RAM ADDRESS OF STARTING LINE NUMBER
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          beq  L8990          ; BRANCH IF END OF LINE
          cmpa #TOK_MINUS     ; TOKEN FOR '-'
          bne  L89BF          ; TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY '-'
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          beq  L898C          ; IF END OF LINE, USE DEFAULT ENDING LINE NUMBER
          bsr  L89AE          ; * CONVERT ENDING LINE NUMBER TO BINARY
          bra  L8990          ; * AND SAVE IT IN BINVAL
L898C     lda  #$FF           ; = USE $FFXX AS DEFAULT ENDING
          sta  BINVAL         ; = LINE NUMBER - SAVE IT IN BINVAL
L8990     ldu  VD3            ; POINT U TO STARTING LINE NUMBER ADDRESS
L8992     fcb  SKP2           ; SKIP TWO BYTES
L8993     ldu  ,u             ; POINT U TO START OF NEXT LINE
          ldd  ,u             ; CHECK FOR END OF PROGRAM
          beq  L899F          ; BRANCH IF END OF PROGRAM
          ldd  $02,u          ; LOAD ACCD WITH THIS LINE'S NUMBER
          subd BINVAL         ; SUBTRACT ENDING LINE NUMBER ADDRESS
          bls  L8993          ; BRANCH IF = < ENDING LINE NUMBER
L899F     ldx  VD3            ; GET STARTING LINE NUMBER
          bsr  L89B8          ; MOVE (U) TO (X) UNTIL END OF PROGRAM
          jsr  LAD21          ; RESET BASIC'S INPUT POINTER AND ERASE VARIABLES
          ldx  VD3            ; GET STARTING LINE NUMBER ADDRESS
          jsr  LACF1          ; RECOMPUTE START OF NEXT LINE ADDRESSES
          jmp  LAC73          ; JUMP TO BASIC'S MAIN COMMAND LOOP
L89AE     jsr  LAF67          ; GO GET LINE NUMBER CONVERTED TO BINARY
          jmp  LA5C7          ; MAKE SURE THERE'S NO MORE ON THIS LINE
L89B4     lda  ,u+            ; GET A BYTE FROM (U)
          sta  ,x+            ; MOVE THE BYTE TO (X)
L89B8     cmpu VARTAB         ; COMPARE TO END OF BASIC
          bne  L89B4          ; BRANCH IF NOT AT END
          stx  VARTAB         ; SAVE (X) AS NEW END OF BASIC
L89BF     rts


L89C0     jsr  L8866          ; 'BS' ERROR IF IN DIRECT MODE
          jsr  GETNCH         ; GET A CHAR FROM BASIC
L89D2     cmpa #'"'           ; CHECK FOR PROMPT STRING
          bne  L89E1          ; BRANCH IF NO PROMPT STRING
          jsr  LB244          ; STRIP OFF PROMPT STRING & PUT IT ON STRING STACK
          ldb  #';'           ; *
          jsr  LB26F          ; * DO A SYNTAX CHECK FOR;
          jsr  LB99F          ; REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT
L89E1     leas -2,s           ; RESERVE TWO STORAGE SLOTS ON STACK
          jsr  LB035          ; INPUT A LINE FROM CURRENT INPUT DEVICE
          leas $02,s          ; CLEAN UP THE STACK
          jsr  LB357          ; SEARCH FOR A VARIABLE
          stx  VARDES         ; SAVE POINTER TO VARIABLE DESCRIPTOR
          jsr  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
          ldx  #LINBUF        ; POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED
          clra                ; TERMINATOR CHARACTER 0 (END OF LINE)
          jsr  LB51A          ; PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE
          jmp  LAFA4          ; REMOVE DESCRIPTOR FROM STRING STACK
		  		  
L89FC     jsr  LAF67          ; STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE
          ldx  BINVAL         ; GET BINARY VALUE
          rts
L8A02     ldx  VD1            ; GET CURRENT OLD NUMBER BEING RENUMBERED
L8A04     stx  BINVAL         ; SAVE THE LINE NUMBER BEING SEARCHED FOR
          jmp  LAD01          ; GO FIND THE LINE NUMBER IN BASIC PROGRAM

* RENUM
RENUM     jsr  LAD26          ; ERASE VARIABLES
          ldd  #10            ; DEFAULT LINE NUMBER INTERVAL
          std  VD5            ; SAVE DEFAULT RENUMBER START LINE NUMBER
          std  VCF            ; SAVE DEFAULT INTERVAL
          clrb                ; NOW ACCD = 0
          std  VD1            ; DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          bcc  L8A20          ; BRANCH IF NOT NUMERIC
          bsr  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
          stx  VD5            ; SAVE LINE NUMBER WHERE RENUMBERING STARTS
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
L8A20     beq  L8A3D          ; BRANCH IF END OF LINE
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          bcc  L8A2D          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
          bsr  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
          stx  VD1            ; SAVE NEW RENUMBER LINE
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
L8A2D     beq  L8A3D          ; BRANCH IF END OF LINE
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          bcc  L8A3A          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
          bsr  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
          stx  VCF            ; SAVE NEW INTERVAL
          beq  L8A83          ; 'FC' ERROR
L8A3A     jsr  LA5C7          ; CHECK FOR MORE CHARACTERS ON LINE - 'SYNTAX' ERROR IF ANY
L8A3D     bsr  L8A02          ; GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED
          stx  VD3            ; SAVE ADDRESS
          ldx  VD5            ; GET NEXT RENUMBERED LINE NUMBER TO USE
          bsr  L8A04          ; FIND THE LINE NUMBER IN THE BASIC PROGRAM
          cmpx VD3            ; COMPARE TO ADDRESS OF OLD LINE NUMBER
          blo  L8A83          ; 'FC' ERROR IF NEW ADDRESS < OLD ADDRESS
          bsr  L8A67          ; MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE
          jsr  L8ADD          ; CONVERT ASCII LINE NUMBERS TO 'EXPANDED' BINARY
          jsr  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESSES
          bsr  L8A02          ; GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED
          stx  VD3            ; SAVE IT
          bsr  L8A91          ; MAKE SURE LINE NUMBERS EXIST
          bsr  L8A68          ; INSERT NEW LINE NUMBERS IN LINE HEADERS
          bsr  L8A91          ; INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS
          jsr  L8B7B          ; CONVERT PACKED BINARY LINE NUMBERS TO ASCII
          jsr  LAD26          ; ERASE VARIABLES
          jsr  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESS
          jmp  LAC73          ; GO BACK TO BASIC'S MAIN LOOP
L8A67     fcb  SKP1LD         ; SKIP ONE BYTE - lda #$4F
L8A68     clra                ; NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS
          sta  VD8            ; SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS
          ldx  VD3            ; GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED
          ldd  VD5            ; GET THE CURRENT RENUMBERED LINE NUMBER
          bsr  L8A86          ; RETURN IF END OF PROGRAM
L8A71     tst  VD8            ; CHECK NEW LINE NUMBER FLAG
          bne  L8A77          ; BRANCH IF NOT INSERTING NEW LINE NUMBERS
          std  $02,x          ; STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM
L8A77     ldx  ,x             ; POINT X TO THE NEXT LINE IN BASIC
          bsr  L8A86          ; RETURN IF END OF PROGRAM
          addd VCF            ; ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER
          blo  L8A83          ; 'FC' ERROR IF LINE NUMBER > $FFFF
          cmpa #MAXLIN        ; LARGEST LINE NUMBER = $F9FF
          blo  L8A71          ; BRANCH IF LEGAL LINE NUMBER
L8A83     jmp  LB44A          ; 'FC' ERROR IF LINE NUMBER MS BYTE > $F9
* TEST THE TWO BYTES POINTED TO BY (X).
* NORMAL RETURN IF <> 0. IF = 0 (END OF
* PROGRAM) RETURN IS PULLED OFF STACK AND
* YOU RETURN TO PREVIOUS SUBROUTINE CALL.
L8A86     pshs b,a            ; SAVE ACCD
          ldd  ,x             ; TEST THE 2 BYTES POINTED TO BY X
          puls a,b            ; RESTORE ACCD
          bne  L8A90          ; BRANCH IF NOT END OF PROGRAM
          leas $02,s          ; PURGE RETURN ADDRESS FROM STACK
L8A90     rts
L8A91     ldx  TXTTAB         ; GET START OF BASIC PROGRAM
          leax -1,x           ; MOVE POINTER BACK ONE
L8A95     leax $01,x          ; MOVE POINTER UP ONE
          bsr  L8A86          ; RETURN IF END OF PROGRAM
L8A99     leax $03,x          ; SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER
L8A9B     leax $01,x          ; MOVE POINTER TO NEXT CHARACTER
          lda  ,x             ; CHECK CURRENT CHARACTER
          beq  L8A95          ; BRANCH IF END OF LINE
          stx  TEMPTR         ; SAVE CURRENT POINTER
          deca                ; =
          beq  L8AB2          ; =BRANCH IF START OF PACKED NUMERIC LINE
          deca                ; *
          beq  L8AD3          ; *BRANCH IF LINE NUMBER EXISTS
          deca                ; =
          bne  L8A9B          ; =MOVE TO NEXT CHARACTER IF > 3
L8AAC     lda  #$03           ; * SET 1ST BYTE = 3 TO INDICATE LINE
          sta  ,x+            ; * NUMBER DOESN'T CURRENTLY EXIST
          bra  L8A99          ; GO GET ANOTHER CHARACTER
L8AB2     ldd  $01,x          ; GET MS BYTE OF LINE NUMBER
          dec  $02,x          ; DECREMENT ZERO CHECK BYTE
          beq  L8AB9          ; BRANCH IF MS BYTE <> 0
          clra                ; CLEAR MS BYTE
L8AB9     ldb  $03,x          ; GET LS BYTE OF LINE NUMBER
          dec  $04,x          ; DECREMENT ZERO CHECK FLAG
          beq  L8AC0          ; BRANCH IF IS BYTE <> 0
          clrb                ; CLEAR LS BYTE
L8AC0     std  $01,x          ; SAVE BINARY LINE NUMBER
          std  BINVAL         ; SAVE TRIAL LINE NUMBER
          jsr  LAD01          ; FIND RAM ADDRESS OF A BASIC LINE NUMBER
L8AC7     ldx  TEMPTR         ; GET BACK POINTER TO START OF PACKED LINE NUMBER
          blo  L8AAC          ; BRANCH IF NO LINE NUMBER MATCH FOUND
          ldd  V47            ; GET START ADDRESS OF LINE NUMBER
          inc  ,x+            ; * SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXIsts IF CHECKING FOR
*              ; * EXISTENCE OF LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS

          std  ,x             ; SAVE RAM ADDRESS OF CORRECT LINE NUMBER
          bra  L8A99          ; GO GET ANOTHER CHARACTER
L8AD3     clr  ,x             ; CLEAR CARRY FLAG AND 1ST BYTE
          ldx  $01,x          ; POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER
          ldx  $02,x          ; PUT CORRECT LINE NUMBER INTO (X)
          stx  V47            ; SAVE IT TEMPoraRILY
          bra  L8AC7          ; GO INSERT IT INTO BASIC LINE
L8ADD     ldx  TXTTAB         ; GET BEGINNING OF BASIC PROGRAM
          bra  L8AE5
L8AE1     ldx  CHARAD         ; *GET CURRENT INPUT POINTER
          leax $01,x          ; *AND BUMP IT ONE
L8AE5     bsr  L8A86          ; RETURN IF END OF PROGRAM
          leax $02,x          ; SKIP PAST NEXT LINE ADDRESS
L8AE9     leax $01,x          ; ADVANCE POINTER BY ONE
L8AEB     stx  CHARAD         ; SAVE NEW BASIC INPUT POINTER
L8AED     jsr  GETNCH         ; GET NEXT CHARACTER FROM BASIC
L8AEF     tsta                ; CHECK THE CHARACTER
          beq  L8AE1          ; BRANCH IF END OF LINE
          bpl  L8AED          ; BRANCH IF NOT A TOKEN
          ldx  CHARAD         ; GET CURRENT INPUT POINTER
          cmpa #$FF           ; IS THIS A SECONDARY TOKEN?
          beq  L8AE9          ; YES - IGNORE IT
          cmpa #TOK_THEN      ; TOKEN FOR THEN?
          beq  L8B13          ; YES
          cmpa #TOK_ELSE      ; TOKEN FOR ELSE?
          beq  L8B13          ; YES
          cmpa #TOK_GO        ; TOKEN FOR GO?
          bne  L8AED          ; NO
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          cmpa #TOK_TO        ; TOKEN FOR TO?
          beq  L8B13          ; YES
          cmpa #TOK_SUB       ; TOKEN FOR SUB?
          bne  L8AEB          ; NO
L8B13     jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          blo  L8B1B          ; BRANCH IF NUMERIC
L8B17     jsr  GETCCH         ; GET CURRENT BASIC INPUT CHARRACTER
          bra  L8AEF          ; KEEP CHECKING THE LINE
L8B1B     ldx  CHARAD         ; GET CURRENT INPUT ADDRESS
          pshs x              ; SAVE IT ON THE STACK
          jsr  LAF67          ; CONVERT DECIMAL BASIC NUMBER TO BINARY
          ldx  CHARAD         ; GET CURRENT INPUT POINTER
L8B24     lda  ,-x            ; GET PREVIOUS INPUT CHARACTER
          jsr  L90AA          ; CLEAR CARRY IF NUMERIC INPUT VALUE
          blo  L8B24          ; BRANCH IF NON-NUMERIC
          leax $01,x          ; MOVE POINTER UP ONE
          tfr  x,d            ; NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER
          subb $01,s          ; SUBTRACT PRE-NUMERIC POINTER LS BYTE
          subb #$05           ; MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE
*
          beq  L8B55          ; BRANCH IF EXACTLY 5
          blo  L8B41          ; BRANCH IF < 5
          leau ,x             ; TRANSFER X TO U
          negb                ; NEGATE B
          leax b,x            ; MOVE X BACK B BYTES
          jsr  L89B8          ; *MOVE BYTES FROM (U) TO (X) UNTIL
*         *U   = END OF BASIC; (I) = NEW END OF BASIC
          bra  L8B55
* FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER
L8B41     stx  V47            ; SAVE END OF NUMERIC VALUE
          ldx  VARTAB         ; GET END OF BASIC PROGRAM
          stx  V43            ; SAVE IT
          negb                ; NEGATE B
          leax b,x            ; ADD IT TO END OF NUMERIC POiNTER
          stx  V41            ; SAVE POINTER
          stx  VARTAB         ; STORE END OF BASIC PROGRAM
          jsr  LAC1E          ; ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM
          ldx  V45            ; * GET AND SAVE THE
          stx  CHARAD         ; * NEW CURRENT INPUT POINTER
L8B55     puls x              ; RESTORE POINTER TO START OF NUMERIC VALUE
          lda  #$01           ; NEW LINE NUMBER FLAG
          sta  ,x             ; * SAVE NEW LINE FLAG
          sta  $02,x          ; *
          sta  $04,x          ; *
          ldb  BINVAL         ; GET MS BYTE OF BINARY LINE NUMBER
          bne  L8B67          ; BRANCH IF IT IS NOT ZERO
          ldb  #$01           ; ; SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL
*              ; THINK IT IS THE END OF A LINE
          inc  $02,x          ; IF 2,x = 2, THEN PREVIOUS BYTE WAS A ZERO
L8B67     stb  $01,x          ; SAVE MS BYTE OF BINARY LINE NUMBER
          ldb  BINVAL+1       ; GET IS BYTE OF BINARY LINE NUMBER
          bne  L8B71          ; BRANCH IF NOT A ZERO BYTE
          ldb  #$01           ; SAVE A 1 IF BYTE IS A 0
          inc  $04,x          ; IF 4,x = 2, THEN PREVIOUS BYTE WAS A 0
L8B71     stb  $03,x          ; SAVE LS BYTE OF BINARY LINE NUMBER
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          cmpa #','            ; IS IT A COMMA?
          beq  L8B13          ; YES - PROCESS ANOTHER NUMERIC VALUE
          bra  L8B17          ; NO - GO GET AND PROCESS AN INPUT CHARACTER
L8B7B     ldx  TXTTAB         ; POINT X TO START OF BASIC PROGRAM
          leax -1,x           ; MOVE POINTER BACK ONE
L8B7F     leax $01,x          ; MOVE POINTER UP ONE
          ldd  $02,x          ; GET ADDRESS OF NEXT LINE
          std  CURLIN         ; SAVE IT IN CURLIN
          jsr  L8A86          ; RETURN IF END OF PROGRAM
          leax $03,x          ; SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER
L8B8A     leax $01,x          ; MOVE POINTER UP ONE
L8B8C     lda  ,x             ; GET CURRENT CHARACTER
          beq  L8B7F          ; BRANCH IF END OF LINE
          deca                ; INPUT CHARACTER = 1? - VALID LINE NUMBER
          beq  L8BAE          ; YES
          suba #$02           ; INPUT CHARACTER 3? - UL LINE NUMBER
          bne  L8B8A          ; NO
          pshs x              ; SAVE CURRENT POSITION OF INPUT POINTER
          ldx  #L8BD9-1       ; POINT X TO 'UL' MESSAGE
          jsr  LB99C          ; PRINT STRING TO THE SCREEN
          ldx  ,s             ; GET INPUT POINTER
          ldd  $01,x          ; GET THE UNDEFINED LINE NUMBER
          jsr  LBDCC          ; CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT
          jsr  LBDC5          ; PRINT 'IN XXXX' XXXX = CURRENT LINE NUMBER
          jsr  LB958          ; SEND A CR TO CONSOLE OUT
          puls x              ; GET INPUT POINTER BACK
L8BAE     pshs x              ; SAVE CURRENT POSITION OF INPUT POINTER
          ldd  $01,x          ; LOAD ACCD WITH BINARY VALUE OF LINE NUMBER
          std  FPA0+2         ; SAVE IN BOTTOM 2 BYTES OF FPA0
          jsr  L880E          ; ADJUST REST OF FPA0 AS AN INTEGER
          jsr  LBDD9          ; CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER
          puls u              ; LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER
          ldb  #$05           ; EACH EXPANDED LINE NUMBER USES 5 BYTES
L8BBE     leax $01,x          ; MOVE POINTER FORWARD ONE
          lda  ,x             ; GET AN ASCII BYTE
          beq  L8BC9          ; BRANCH IF END OF NUMBER
          decb                ; DECREMENT BYTE COUNTER
          sta  ,u+            ; STORE ASCII NUMBER IN BASIC LINE
          bra  L8BBE          ; CHECK FOR ANOTHER DIGIT
L8BC9     leax ,u             ; TRANSFER NEW LINE POINTER TO (X)
          tstb                ; DOES THE NEW LINE NUMBER REQUIRE 5 BYTES?
          beq  L8B8C          ; YES - GO GET ANOTHER INPUT CHARACTER
          leay ,u             ; SAVE NEW LINE POINTER IN Y
          leau b,u            ; POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK
          jsr  L89B8          ; MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM
          leax ,y             ; LOAD (X) WITH NEW LINE POINTER
          bra  L8B8C          ; GO GET ANOTHER INPUT CHARACTER

L8BD9     fcc  "UL "          ; UNKNOWN LINE NUMBER MESSAGE
          fcb  0


HEXDOL    jsr  LB740          ; CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER
          ldx  #STRBUF+2      ; POINT TO TEMPORARY BUFFER
          ldb  #$04           ; CONVERT 4 NIBBLES
L8BE5     pshs b              ; SAVE NIBBLE COUNTER
          clrb                ; CLEAR CARRY FLAG
          lda  #$04           ; 4 SHIFTS
L8BEA     asl  FPA0+3         ; * SHIFT BOTTOM TWO BYTES OF
          rol  FPA0+2         ; * FPA0 LEFT ONE BIT (X2)
          rolb                ; IF OVERFLOW, ACCB <> 0
          deca                ; * DECREMENT SHIFT COUNTER AND
          bne  L8BEA          ; * BRANCH IF NOT DONE
          tstb                ; CHECK FOR OVERFLOW
          bne  L8BFF          ; BRANCH IF OVERFLOW
          lda  ,s             ; * GET NIBBLE COUNTER,
          deca                ; * DECREMENT IT AND
          beq  L8BFF          ; * BRANCH IF DONE
          cmpx #STRBUF+2      ; DO NOT DO A CONVERSION UNTIL A NON-ZERO
          beq  L8C0B          ; BYTE IS FOUND - LEADING ZERO SUPPRESSION
L8BFF     addb #'0'            ; ADD IN ASCII ZERO
          cmpb #'9'           ; COMPARE TO ASCII 9
          bls  L8C07          ; BRANCH IF < 9
          addb #7             ; ADD ASCII OFFSET IF HEX LETTER
L8C07     stb  ,x+            ; STORE HEX VALUE AND ADVANCE POINTER
          clr  ,x             ; CLEAR NEXT BYTE - END OF STRING FLAG
L8C0B     puls b              ; * GET NIBBLE COUNTER,
          decb                ; * DECREMENT IT AND
          bne  L8BE5          ; * BRANCH IF NOT DONE
          leas $02,s          ; PURGE RETURN ADDRESS OFF OF STACK
          ldx  #STRBUF+1      ; RESET POINTER
          jmp  LB518          ; SAVE STRING ON STRING STACK
* PROCESS EXCLAMATION POINT
L8E37     lda  #$01           ; * SET SPACES
          sta  VD9            ; * COUNTER = 1		 
* PROCESS STRING ITEM - LIST
L8E3B     decb                ; DECREMENT FORMAT STRING LENGTH COUNTER
          jsr  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <>0
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          lbeq L8ED8          ; EXIT PRINT USING IF END OF LINE
          stb  VD3            ; SAVE REMAINDER FORMAT STRING LENGTH
          jsr  LB156          ; EVALUATE EXPRESSION
          jsr  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
          ldx  FPA0+2         ; * GET ITEM - LIST DESCRIPTOR ADDRESS
          stx  V4D            ; * AND SAVE IT IN V4D
          ldb  VD9            ; GET SPACES COUNTER
          jsr  LB6AD          ; PUT ACCB BYTES INTO STRING SPACE & PUT DESCRIPTOR ON STRING STACK
          jsr  LB99F          ; PRINT THE FORMATTED STRING TO CONSOLE OUT
* PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING < FORMAT STRING LENGTH
          ldx  FPA0+2         ; POINT X TO FORMATTED STRING DESCRIPTOR ADDRESS
          ldb  VD9            ; GET SPACES COUNTER
          subb ,x             ; SUBTRACT LENGTH OF FORMATTED STRING
L8E5F     decb                ; DECREMENT DIFFERENCE
          lbmi L8FB3          ; GO INTERPRET ANOTHER ITEM - LIST
          jsr  LB9AC          ; PAD FORMAT STRING WITH A SPACE
          bra  L8E5F          ; KEEP PADDING
* PERCENT SIGN - PROCESS A %SPACES% COMMAND
L8E69     stb  VD3            ; * SAVE THE CURRENT FORMAT STRING
          stx  TEMPTR         ; * COUNTER AND POINTER
          lda  #$02           ; INITIAL SPACES COUNTER = 2
          sta  VD9            ; SAVE IN SPACES COUNTER
L8E71     lda  ,x             ; GET A CHARACTER FROM FORMAT STRING
          cmpa #'%'           ; COMPARE TO TERMINATOR CHARACTER
          beq  L8E3B          ; BRANCH IF END OF SPACES COMMAND
          cmpa #' '           ; BLANK
          bne  L8E82          ; BRANCH IF ILLEGAL CHARACTER
          inc  VD9            ; ADD ONE TO SPACES COUNTER
          leax $01,x          ; MOVE FORMAT POINTER UP ONE
          decb                ; DECREMENT LENGTH COUNTER
          bne  L8E71          ; BRANCH IF NOT END OF FORMAT STRING
L8E82     ldx  TEMPTR         ; * RESTORE CURRENT FORMAT STRING COUNTER
          ldb  VD3            ; * AND POINTER TO POSITION BEFORE SPACES COMMAND
          lda  #'%'           ; SEND A '%' TO CONSOLE OUT AS A DEBUGGING AID
* ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN FORMAT STRING
L8E88     jsr  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
          jsr  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
          bra  L8EB9          ; GET NEXT CHARACTER IN FORMAT STRING

* PRINT RAM HOOK
XVEC9     cmpa #TOK_USING     ; USING TOKEN
          beq  L8E95          ; BRANCH IF PRINT USING
          rts

* PRINT USING
* VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE
* BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FORCE
* BIT 3 = PRE SIGN FORCE; BIT 2 = POST SIGN FORCE; BIT 0 = EXPONENTIAL FORCE
L8E95     leas $02,s          ; PURGE RETURN ADDRESS OFF THE STACK
          jsr  LB158          ; EVALUATE FORMAT STRING
          jsr  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
          ldb  #';'           ; CHECK FOR ITEM LIST SEPARATOR
          jsr  LB26F          ; SYNTAX CHECK FOR ;
          ldx  FPA0+2         ; * GET FORMAT STRING DESCRIPTOR ADDRESS
          stx  VD5            ; * AND SAVE IT IN VD5
          bra  L8EAE          ; GO PROCESS FORMAT STRING
L8EA8     lda  VD7            ; *CHECK NEXT PRINT ITEM FLAG AND
          beq  L8EB4          ; *'FC' ERROR IF NO FURTHER PRINT ITEMS
          ldx  VD5            ; RESET FORMAT STRING POINTER TO START OF STRING
L8EAE     clr  VD7            ; RESET NEXT PRINT ITEM FLAG
          ldb  ,x             ; GET LENGTH OF FORMAT STRING
          bne  L8EB7          ; INTERPRET FORMAT STRING IF LENGTH > 0
L8EB4     jmp  LB44A          ; 'FC' ERROR IF FORMAT STRING = NULL
L8EB7     ldx  $02,x          ; POINT X TO START OF FORMAT STRING
* INTERPRET THE FORMAT STRING
L8EB9     clr  VDA            ; CLEAR THE STATUS BYTE
L8EBB     clr  VD9            ; CLEAR LEFT DIGIT COUNTER
          lda  ,x+            ; GET A CHARACTER FROM FORMAT STRING
          cmpa #'!'           ; EXCLAMATION POINT?
          beq L8E37           ; YES - STRING TYPE FORMAT
          cmpa #'#'           ; NUMBER SIGN? (DIGIT LOCATOR)
          beq  L8F24          ; YES - NUMERIC TYPE FORMAT
          decb                ; DECREMENT FORMAT STRING LENGTH
          bne  L8EE2          ; BRANCH IF NOT DONE
          jsr  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
          jsr  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
L8ED2     jsr  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
          bne  L8EA8          ; BRANCH IF NOT END OF LINE
          lda  VD7            ; GET NEXT PRINT ITEM FLAG
L8ED8     bne  L8EDD          ; BRANCH IF MORE PRINT ITEMS
          jsr  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
L8EDD     ldx  VD5            ; POINT X TO FORMAT STRING DESCRIPTOR
          jmp  LB659          ; RETURN ADDRESS AND LENGTH OF FORMAT STRING - EXIT PRINT USING
L8EE2     cmpa #'+'           ; CHECK FOR '+' (PRE-SIGN FORCE)
          bne  L8EEF          ; NO PLUS
          jsr  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
          lda  #$08           ; * LOAD THE STATUS BYTE WITH 8;
          sta  VDA            ; * PRE-SIGN FORCE FLAG
          bra  L8EBB          ; INTERPRET THE REST OF THE FORMAT STRING
L8EEF     cmpa #'.'           ; DECIMAL POINT?
          beq  L8F41          ; YES
          cmpa #'%'           ; PERCENT SIGN?
          lbeq L8E69          ; YES
          cmpa ,x             ; COMPARE THE PRESENT FORMAT STRING INPUT
*              ; CHARACTER TO THE NEXT ONE IN THE STRING
L8EFB     bne  L8E88          ; NO MATCH - ILLEGAL CHARACTER
* TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING
          cmpa #'$'           ; DOLLAR SIGN?
          beq  L8F1A          ; YES - MAKE THE DOLLAR SIGN FLOAT
          cmpa #'*'           ; ASTERISK?
          bne  L8EFB          ; NO - ILLEGAL CHARACTER
          lda  VDA            ; * GRAB THE STATUS BYTE AND BET BIT 5
          ora  #$20           ; * TO INDICATE THAT THE OUTPUT WILL
          sta  VDA            ; * BE LEFT PADDED WITH ASTERISKS
          cmpb #2             ; * CHECK TO SEE IF THE $$ ARE THE LAST TWO
          blo  L8F20          ; * CHARACTERS IN THE FORMAT STRING AND BRANCH IF SO
          lda  $01,x          ; GET THE NEXT CHARACTER AFTER **
          cmpa #'$'           ; CHECK FOR **$
          bne  L8F20          ; CHECK FOR MORE CHARACTERS
          decb                ; DECREMENT STRING LENGTH COUNTER
          leax $01,x          ; MOVE FORMAT STRING POINTER UP ONE
          inc  VD9            ; ADD ONE TO LEFT DIGIT COUNTER - FOR ASTERISK PAD AND
*              ; FLOATING DOLLAR SIGN COMBINATION
L8F1A     lda  VDA            ; * GET THE STATUS BYTE AND SET
          ora  #$10           ; * BIT 4 TO INDICATE A
          sta  VDA            ; * FLOATING DOLLAR SIGN
L8F20     leax $01,x          ; MOVE FORMAT STRING POINTER UP ONE
          inc  VD9            ; ADD ONE TO LEFT DIGIT (FLOATING $ OR ASTERISK PAD)
* PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT IN THE FORMAT STRING
L8F24     clr  VD8            ; CLEAR THE RIGHT DIGIT COUNTER
L8F26     inc  VD9            ; ADD ONE TO LEFT DIGIT COUNTER
          decb                ; DECREMENT FORMAT STRING LENGTH COUNTER
          beq  L8F74          ; BRANCH IF END OF FORMAT STRING
          lda  ,x+            ; GET THE NEXT FORMAT CHARACTER
          cmpa #'.'           ; DECIMAL POINT?
          beq  L8F4F          ; YES
          cmpa #'#'           ; NUMBER SIGN?
          beq  L8F26          ; YES
          cmpa #','            ; COMMA?
          bne  L8F5A          ; NO
          lda  VDA            ; * GET THE STATUS BYTE
          ora  #$40           ; * AND SET BIT 6 WHICH IS THE
          sta  VDA            ; * COMMA SEPARATOR FLAG
          bra  L8F26          ; PROCESS MORE CHARACTERS TO LEFT OF DECIMAL POINT
* PROCESS DECIMAL POINT IF NO DIGITS TO LEFT OF IT
L8F41     lda  ,x             ; GET NEXT FORMAT CHARACTER
          cmpa #'#'           ; IS IT A NUMBER SIGN?
          lbne L8E88          ; NO
          lda  #1             ; * SET THE RIGHT DIGIT COUNTER TO 1 -
          sta  VD8            ; * ALLOW ONE SPOT FOR DECIMAL POINT
          leax $01,x          ; MOVE FORMAT POINTER UP ONE
* PROCESS DIGITS TO RIGHT OF DECIMAL POINT
L8F4F     inc  VD8            ; ADD ONE TO RIGHT DIGIT COUNTER
          decb                ; DECREMENT FORMAT LENGTH COUNTER
          beq  L8F74          ; BRANCH IF END OF FORMAT STRING
          lda  ,x+            ; GET A CHARACTER FROM FORMAT STRING
          cmpa #'#'           ; IS IT NUMBER SIGN?
          beq  L8F4F          ; YES - KEEP CHECKING
* CHECK FOR EXPONENTIAL FORCE
L8F5A     cmpa #$5E           ; CHECK FOR UP ARROW
          bne  L8F74          ; NO UP ARROW
          cmpa ,x             ; IS THE NEXT CHARACTER AN UP ARROW?
          bne  L8F74          ; NO
          cmpa $01,x          ; AND THE NEXT CHARACTER?
          bne  L8F74          ; NO
          cmpa $02,x          ; HOW ABOUT THE 4TH CHARACTER?
          bne  L8F74          ; NO, ALSO
          cmpb #4             ; * CHECK TO SEE IF THE 4 UP ARROWS ARE IN THE
          blo  L8F74          ; * FORMAT STRING AND BRANCH IF NOT
          subb #4             ; * MOVE POINTER UP 4 AND SUBTRACT
          leax $04,x          ; * FOUR FROM LENGTH
          inc  VDA            ; INCREMENT STATUS BYTE - EXPONENTIAL FORM

* CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMAT STRING
L8F74     leax -1,x           ; MOVE POINTER BACK ONE
          inc  VD9            ; ADD ONE TO LEFT DIGIT COUNTER FOR PRE-SIGN FORCE
          lda  VDA            ; * PRE-SIGN
          bita #$08           ; * FORCE AND
          bne  L8F96          ; * BRANCH IF SET
          dec  VD9            ; DECREMENT LEFT DIGIT - NO PRE-SIGN FORCE
          tstb                ; * CHECK LENGTH COUNTER AND BRANCH
          beq  L8F96          ; * IF END OF FORMAT STRING
          lda  ,x             ; GET NEXT FORMAT STRING CHARACTER
          suba #'-'           ; CHECK FOR MINUS SIGN
          beq  L8F8F          ; BRANCH IF MINUS SIGN
          cmpa #$FE           ; * WAS cmpa #('+')-('-')
          bne  L8F96          ; BRANCH IF NO PLUS SIGN
          lda  #$08           ; GET THE PRE-SIGN FORCE FLAG
L8F8F     ora  #$04           ; 'OR' IN POST-SIGN FORCE FLAG
          ora  VDA            ; 'OR' IN THE STATUS BYTE
          sta  VDA            ; SAVE THE STATUS BYTE
          decb                ; DECREMENT FORMAT STRING LENGTH

* EVALUATE NUMERIC ITEM-LIST
L8F96     jsr  GETCCH         ; GET CURRENT CHARACTER
          lbeq L8ED8          ; BRANCH IF END OF LINE
          stb  VD3            ; SAVE FORMAT STRING LENGTH WHEN FORMAT EVALUATION ENDED
          jsr  LB141          ; EVALUATE EXPRESSION
          lda  VD9            ; GET THE LEFT DIGIT COUNTER
          adda VD8            ; ADD IT TO THE RIGHT DIGIT COUNTER
          cmpa #17            ; *
          lbhi LB44A          ; *'FC' ERROR IF MORE THAN 16 DIGITS AND DECIMAL POiNT
          jsr  L8FE5          ; CONVERT ITEM-LIST TO FORMATTED ASCII STRING
          leax -1,x           ; MOVE BUFFER POINTER BACK ONE
          jsr  LB99C          ; DISPLAY THE FORMATTED STRING TO CONSOLE OUT
L8FB3     clr  VD7            ; RESET NEXT PRINT ITEM FLAG
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          beq  L8FC6          ; BRANCH IF END OF LINE
          sta  VD7            ; SAVE CURRENT CHARACTER (<>0) IN NEXT PRINT ITEM FLAG
          cmpa #';'           ; * CHECK FOR ; - ITEM-LIST SEPARATOR AND
          beq  L8FC4          ; * BRANCH IF SEMICOLON
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          bra  L8FC6          ; PROCESS NEXT PRINT ITEM
L8FC4     jsr  GETNCH         ; GET NEXT INPUT CHARACTER
L8FC6     ldx  VD5            ; GET FORMAT STRING DESCRIPTOR ADDRESS
          ldb  ,x             ; GET LENGTH OF FORMAT STRING
          subb VD3            ; SUBTRACT AMOUNT OF FORMAT STRING LEFT AFTER LAST PRINT ITEM
          ldx  $02,x          ; *GET FORMAT STRING START ADDRESS AND ADVANCE
          abx                 ; *POINTER TO START OF UNUSED FORMAT STRING
          ldb  VD3            ; * GET AMOUNT OF UNUSED FORMAT STRING
          lbne L8EB9          ; * REINTERPRET FORMAT STRING FROM THAT POINT
          jmp  L8ED2          ; REINTERPRET FORMAT STRING FROM THE START IF ENTIRELY
*         USED ON LAST PRINT ITEM

* PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
L8FD8     pshs a              ; RESTORE ACCA AND RETURN
          lda  #'+'           ; GET ASCII PLUS SIGN
          tst  VDA            ; * CHECK THE STATUS BYTE AND
          beq  L8FE3          ; * RETURN IF = 0
          jsr  PUTCHR         ; SEND A CHARACTER TO CONSOLE OUT
L8FE3     puls a,pc           ; RETURN ACCA AND RETURN

* CONVERT ITEM-LIST TO DECIMAL ASCII STRING
L8FE5     ldu  #STRBUF+4      ; POINT U TO STRING BUFFER
          ldb  #SPACE         ; BLANK
          lda  VDA            ; * GET THE STATUS FLAG AND
          bita #$08           ; * CHECK FOR A PRE-SIGN FORCE
          beq  L8FF2          ; * BRANCH IF NO PRE-SIGN FORCE
          ldb  #'+'           ; PLUS SIGN
L8FF2     tst  FP0SGN         ; CHECK THE SIGN OF FPA0
          bpl  L8FFA          ; BRANCH IF POSITIVE
          clr  FP0SGN         ; FORCE FPA0 SIGN TO BE POSITIVE
          ldb  #'-'           ; MINUS SIGN
L8FFA     stb  ,u+            ; SAVE THE SIGN IN BUFFER
          ldb  #'0'            ; * PUT A ZERO INTO THE BUFFER
          stb  ,u+            ; *
          anda #$01           ; * CHECK THE EXPONENTIAL FORCE FLAG IN
          lbne L910D          ; * THE STATUS BYTE - BRANCH IF ACTIVE
          ldx  #LBDC0         ; POINT X TO FLOATING POINT 1E + 09
          jsr  LBCA0          ; COMPARE FPA0 TO (X)
          bmi  L9023          ; BRANCH IF FPA0 < 1E+09
          jsr  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
L9011     lda  ,x+            ; * ADVANCE POINTER TO END OF
          bne  L9011          ; * ASCII STRING (ZERO BYTE)
L9015     lda  ,-x            ; MOVE THE
          sta  $01,x          ; ENTIRE STRING
          cmpx #STRBUF+3      ; UP ONE
          bne  L9015          ; BYTE
          lda  #'%'           ; * INSERT A % SIGN AT START OF
          sta  ,x             ; * STRING - OVERFLOW ERROR
          rts

L9023     lda  FP0EXP         ; GET EXPONENT OF FPA0
          sta  V47            ; AND SAVE IT IN V74
          beq  L902C          ; BRANCH IF FPA0 = 0
          jsr  L91CD          ; CONVERT FPA0 TO NUMBER WITH 9 SIGNIFICANT
*              ; PLACES TO LEFT OF DECIMAL POINT
L902C     lda  V47            ; GET BASE 10 EXPONENT OFFSET
          lbmi L90B3          ; BRANCH IF FPA0 < 100,000,000
          nega                ; * CALCULATE THE NUMBER OF LEADING ZEROES TO INSERT -
          adda VD9            ; * SUBTRACT BASE 10 EXPONENT OFFSET AND 9 (FPA0 HAS
          suba #$09           ; * 9 PLACES TO LEFT OF EXPONENT) FROM LEFT DIGIT COUNTER
          jsr  L90EA          ; PUT ACCA ZEROES IN STRING BUFFER
          jsr  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
          jsr  L9202          ; CONVERT FPA0 TO DECIMAL ASCII IN THE STRING BUFFER
          lda  V47            ; * GET BASE 10 EXPONENT AND PUT THAT MANY
          jsr  L9281          ; * ZEROES IN STRING BUFFER - STOP AT DECIMAL POINT
          lda  V47            ; WASTED INSTRUCTION - SERVES NO PURPOSE
          jsr  L9249          ; CHECK FOR DECIMAL POINT
          lda  VD8            ; GET THE RIGHT DIGIT COUNTER
          bne  L9050          ; BRANCH IF RIGHT DIGlT COUNTER <> 0
          leau -1,u           ; * MOVE BUFFER POINTER BACK ONE - DELETE
*                             ; * DECIMAL POINT IF NO RIGHT DIGITS SPECiFIED
L9050     deca                ; SUBTRACT ONE (DECIMAL POINT)
          jsr  L90EA          ; PUT ACCA ZEROES INTO BUFFER (TRAILING ZEROES)
L9054     jsr  L9185          ; INSERT ASTERISK PADDING, FLOATING $, AND POST-SIGN
          tsta                ; WAS THERE A POST-SIGN?
          beq  L9060          ; NO
          cmpb #'*'           ; IS THE FIRST CHARACTER AN $?
          beq  L9060          ; YES
          stb  ,u+            ; STORE THE POST-SIGN
L9060     clr  ,u             ; CLEAR THE LAST CHARACTER IN THE BUFFER
*
* REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE
* STRING BUFFER TO THE LEFT OF THE DECIMAL POINT
          ldx  #STRBUF+3      ; POINT X TO THE START OF THE BUFFER
L9065     leax $01,x          ; MOVE BUFFER POINTER UP ONE
          stx  TEMPTR         ; SAVE BUFFER POINTER IN TEMPTR
          lda  VARPTR+1       ; * GET ADDRESS OF DECIMAL POINT IN BUFFER, SUBTRACT
          suba TEMPTR+1       ; * CURRENT POSITION AND SUBTRACT LEFT DIGIT COUNTER -
          suba VD9            ; * THE RESULT WILL BE ZERO WHEN TEMPTR+1 IS POINTING
*              ; * TO THE FIRST DIGIT OF THE FORMAT STRING
          beq  L90A9          ; RETURN IF NO DIGITS TO LEFT OF THE DECiMAL POINT
          lda  ,x             ; GET THE CURRENT BUFFER CHARACTER
          cmpa #SPACE         ; SPACE?
          beq  L9065          ; YES - ADVANCE POINTER
          cmpa #'*'           ; ASTERISK?
          beq  L9065          ; YES - ADVANCE POINTER
          clra                ; A ZERO ON THE STACK IS END OF DATA POINTER
L907C     pshs a              ; PUSH A CHARACTER ONTO THE STACK
          lda  ,x+            ; GET NEXT CHARACTER FROM BUFFER
          cmpa #'-'           ; MINUS SIGN?
          beq  L907C          ; YES
          cmpa #'+'           ; PLUS SIGN?
          beq  L907C          ; YES
          cmpa #'$'           ; DOLLAR SIGN?
          beq  L907C          ; YES
          cmpa #'0'            ; ZERO?
          bne  L909E          ; NO - ERROR
          lda  $01,x          ; GET CHARACTER FOLLOWING ZERO
          bsr  L90AA          ; CLEAR CARRY IF NUMERIC
          blo  L909E          ; BRANCH IF NOT A NUMERIC CHARACTER - ERROR
L9096     puls a              ; * PULL A CHARACTER OFF OF THE STACK
          sta  ,-x            ; * AND PUT IT BACK IN THE STRING BUFFER
          bne  L9096          ; * KEEP GOING UNTIL ZERO FLAG
          bra  L9065          ; KEEP CLEANING UP THE INPUT BUFFER
L909E     puls a              ;
          tsta                ; * THE STACK AND EXIT WHEN
          bne  L909E          ; * ZERO FLAG FOUND
          ldx  TEMPTR         ; GET THE STRING BUFFER START POINTER
          lda  #'%'           ; * PUT A % SIGN BEFORE THE ERROR POSITION TO
          sta  ,-x            ; * INDICATE AN ERROR
L90A9     rts
*
* CLEAR CARRY IF NUMERIC
L90AA     cmpa #'0'            ; ASCII ZERO
          blo  L90B2          ; RETURN IF ACCA < ASCII 0
          suba #$3A           ; *  #'9'+1
          suba #$C6           ; * #-('9'+1)  CARRY CLEAR IF NUMERIC
L90B2     rts
*
* PROCESS AN ITEM-LIST WHICH IS < 100,000,000
L90B3     lda  VD8            ; GET RIGHT DIGIT COUNTER
          beq  L90B8          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT OF DECIMAL PT
          deca                ; SUBTRACT ONE FOR DECIMAL POINT
L90B8     adda V47            ; *ADD THE BASE 10 EXPONENT OFFSET - ACCA CONTAINS THE
*         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO THE SPECIFIED
*         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMAL POINT
          bmi  L90BD          ; IF ACCA >= 0 THEN NO SHIFTS ARE REQUIRED
          clra                ; FORCE SHIFT COUNTER = 0
L90BD     pshs a              ; SAVE INITIAL SHIFT COUNTER ON THE STACK
L90BF     bpl  L90CB          ; EXIT ROUTINE IF POSITIVE
          pshs a              ; SAVE SHIFT COUNTER ON STACK
          jsr  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT ONE DIGIT TO RIGHT
          puls a              ; GET SHIFT COUNTER FROM THE STACK
          inca                ; BUMP SHIFT COUNTER UP BY ONE
          bra  L90BF          ; CHECK FOR FURTHER DIVISION
L90CB     lda  V47            ; * GET BASE 10 EXPONENT OFFSET, ADD INITIAL SHIFT COUNTER
          suba ,s+            ; * AND SAVE NEW BASE 10 EXPONENT OFFSET - BECAUSE
          sta  V47            ; * FPA0 WAS SHIFTED ABOVE
          adda #$09           ; * ADD NINE (SIGNIFICANT PLACES) AND BRANCH IF THERE ARE NO
          bmi  L90EE          ; * ZEROES TO THE LEFT OF THE DECIMAL POINT IN THIS PRINT ITEM
          lda  VD9            ; *DETERMINE HOW MANY FILLER ZEROES TO THE LEFT OF THE DECIMAL
          suba #$09           ; *POINT. GET THE NUMBER OF FORMAT PLACES TO LEFT OF DECIMAL
          suba V47            ; *POINT, SUBTRACT THE BASE 10 EXPONENT OFFSET AND THE CONstaNT 9
          bsr  L90EA          ; *(UNNORMALIZATION)-THEN OUTPUT THAT MANY ZEROES TO THE BUFFER
          jsr  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
          bra  L90FF          ; PROCESS THE REMAINDER OF THE PRINT ITEM
*
* PUT (ACCA+1) ASCII ZEROES IN BUFFER
L90E2     pshs a              ; SAVE ZERO COUNTER
          lda  #'0'            ; * INSERT A ZERO INTO
          sta  ,u+            ; * THE BUFFER
          puls a              ; RESTORE ZERO COUNTER

* PUT ACCA ASCII ZEROES INTO THE BUFFER
L90EA     deca                ; DECREMENT ZERO COUNTER
          bpl  L90E2          ; BRANCH IF NOT DONE
          rts

L90EE     lda  VD9            ; * GET THE LEFT DIGIT COUNTER AND PUT
          bsr  L90EA          ; * THAT MANY ZEROES IN THE STRiNG BUFFER
          jsr  L924D          ; PUT THE DECIMAL POINT IN THE STRING BUFFER
          lda  #-9            ; *DETERMINE HOW MANY FILLER ZEROES BETWEEN THE DECIMAL POINT
          suba V47            ; *AND SIGNIFICANT DATA. SUBTRACT BASE 10 EXPONENT FROM -9
          bsr  L90EA          ; *(UNNORMALIZATION) AND OUTPUT THAT MANY ZEROES TO BUFFER
          clr  V45            ; CLEAR THE DECIMAL POINT COUNTER - SUPPRESS THE DECIMAL POINT
          clr  VD7            ; CLEAR THE COMMA COUNTER - SUPPRESS COMMAS
L90FF     jsr  L9202          ; DECODE FPA0 INTO A DECIMAL ASCII STRING
          lda  VD8            ; GET THE RIGHT DIGIT COUNTER
          bne  L9108          ; BRANCH IF RIGHT DIGIT COUNTER <> 0
          ldu  VARPTR         ; RESET BUFFER PTR TO THE DECIMAL POINT IF NO DIGITS TO RIGHT
L9108     adda V47            ; *ADD BASE 10 EXPONENT - A POSITIVE ACCA WILL CAUSE THAT MANY
* *FILLER ZEROES TO BE OUTPUT ; TO THE RIGHT OF LAST SIGNIFICANT DATA
*         *SIGNIFICANT DATA
          jmp  L9050          ; INSERT LEADING ASTERISKS, FLOATING DOLLAR SIGN, ETC
*
* FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FORMAT
L910D     lda  FP0EXP         ; * GET EXPONENT OF FPA0 AND
          pshs a              ; * SAVE IT ON THE STACK
          beq  L9116          ; BRANCH IF FPA0 = 0
          jsr  L91CD          ; *CONVERT FPA0 INTO A NUMBER WITH 9 SIGNIFICANT
*         *DIGITS TO THE LEFT OF THE DECIMAL POINT
L9116     lda  VD8            ; GET THE RIGHT DIGIT COUNTER
          beq  L911B          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT
          deca                ; SUBTRACT ONE FOR THE DECIMAL POINT
L911B     adda VD9            ; ADD TO THE LEFT DIGIT COUNTER
          clr  STRBUF+3       ; CLEAR BUFFER BYTE AS TEMPORARY STORAGE LOCATION
          ldb  VDA            ; * GET THE STATUS BYTE FOR A
          andb #$04           ; * POST-BYTE FORCE; BRANCH IF
          bne  L9129          ; * A POST-BYTE FORCE
          com  STRBUF+3       ; TOGGLE BUFFER BYTE TO -1 IF NO POST-BYTE FORCE
L9129     adda STRBUF+3       ; SUBTRACT 1 IF NO POST BYTE FORCE
          suba #$09           ; *SUBTRACT 9 (DUE TO THE CONVERSION TO 9
*         *SIGNIFICANT DIGITS TO LEFT OF DECIMAL POINT)
          pshs a              ; * SAVE SHIFT COUNTER ON THE STACK - ACCA CONTAINS THE NUMBER
*         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE NUMBER OF
*         FORMATTED PLACES TO THE RIGHT OF THE DECIMAL POINT.
L9130     bpl  L913C          ; NO MORE SHIFTS WHEN ACCA >= 0
          pshs a              ; SAVE SHIFT COUNTER
          jsr  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT TO RIGHT ONE
          puls a              ; RESTORE THE SHIFT COUNTER
          inca                ; ADD 1 TO SHIFT COUNTER
          bra  L9130          ; CHECK FOR FURTHER SHIFTING (DIVISION)
L913C     lda  ,s             ; *GET THE INITIAL VALUE OF THE SHIFT COUNTER
          bmi  L9141          ; *AND BRANCH IF SHIFTING HAS TAKEN PLACE
          clra                ; RESET ACCA IF NO SHIFTING HAS TAKEN PLACE
L9141     nega                ; *CALCULATE THE POSITION OF THE DECIMAL POINT BY
          adda VD9            ; *NEGATING SHIFT COUNTER, ADDING THE LEFT DIGIT COUNTER
          inca                ; *PLUS ONE AND THE POST-BYTE POSlTION, IF USED
          adda STRBUF+3       ; *
          sta  V45            ; SAVE DECIMAL POINT COUNTER
          clr  VD7            ; CLEAR COMMA COUNTER - NO COMMAS INSERTED
          jsr  L9202          ; CONVERT FPA0 INTO ASCII DECIMAL STRING
          puls a              ; * GET THE INITIAL VALUE OF SHIFT COUNTER AND
          jsr  L9281          ; * INSERT THAT MANY ZEROES INTO THE BUFFER
          lda  VD8            ; *GET THE RIGHT DIGIT COUNTER AND BRANCH
          bne  L915A          ; *IF NOT ZERO
          leau -1,u           ; MOVE BUFFER POINTER BACK ONE

* CALCULATE VALUE OF EXPONENT AND PUT IN STRING BUFFER
L915A     ldb  ,s+            ; GET ORIGINAL EXPONENT OF FPA0
          beq  L9167          ; BRANCH IF EXPONENT = 0
          ldb  V47            ; GET BASE 10 EXPONENT
          addb #$09           ; ADD 9 FOR 9 SIGNIFICANT DIGIT CONVERSION
          subb VD9            ; SUBTRACT LEFT DIGIT COUNTER
          subb STRBUF+3       ; ADD ONE TO EXPONENT IF POST-SIGN FORCE
L9167     lda  #'+'           ; PLUS SIGN
          tstb                ; TEST EXPONENT
          bpl  L916F          ; BRANCH IF POSITIVE EXPONENT
          lda  #'-'           ; MINUS SIGN
          negb                ; CONVERT EXPONENT TO POSITIVE NUMBER
L916F     sta  $01,u          ; PUT SIGN OF EXPONENT IN STRING BUFFER
          lda  #'E'           ; * PUT AN 'E' (EXPONENTIATION FLAG) IN
          sta  ,u++           ; * BUFFER AND SKIP OVER THE SIGN
          lda  #$2F           ; * WAS lda #'0'-1
*CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACCA
L9177     inca                ; ADD ONE TO TENS DIGIT COUNTER
          subb #10            ; *SUBTRACT 10 FROM EXPONENT AND ADD ONE TO TENS
          bcc  L9177          ; * DIGIT IF NO CARRY. TENS DIGIT DONE IF THERE IS A CARRY
          addb #$3A           ; WAS addb #'9'+1
          std  ,u++           ; SAVE EXPONENT IN BUFFER
          clr  ,u             ; CLEAR FINAL BYTE IN BUFFER - PRINT TERMINATOR
          jmp  L9054          ; INSERT ASTERISK PADDING, FLOATING DOLLAR SIGN, ETC.

* INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN
L9185     ldx  #STRBUF+4      ; POINT X TO START OF PRINT ITEM BUFFER
          ldb  ,x             ; * GET SIGN BYTE OF ITEM-LIST BUFFER
          pshs b              ; * AND SAVE IT ON THE STACK
          lda  #SPACE         ; DEFAULT PAD WITH BLANKS
          ldb  VDA            ; * GET STATUS BYTE AND CHECK FOR
          bitb #$20           ; * ASTERISK LEFT PADDING
          puls b              ; GET SIGN BYTE AGAIN
          beq  L919E          ; BRANCH IF NO PADDING
          lda  #'*'           ; PAD WITH ASTERISK
          cmpb #SPACE         ; WAS THE FIRST BYTE A BLANK (POSITIVE)?
          bne  L919E          ; NO
          tfr  a,b            ; TRANSFER PAD CHARACTER TO ACCB
L919E     pshs b              ; SAVE FIRST CHARACTER ON STACK
L91A0     sta  ,x+            ; STORE PAD CHARACTER IN BUFFER
          ldb  ,x             ; GET NEXT CHARACTER IN BUFFER
          beq  L91B6          ; INSERT A ZERO IF END OF BUFFER
          cmpb #'E'           ; * CHECK FOR AN 'E' AND
          beq  L91B6          ; * PUT A ZERO BEFORE IT
          cmpb #'0'           ; * REPLACE LEADING ZEROES WITH
          beq  L91A0          ; * PAD CHARACTERS
          cmpb #','           ; * REPLACE LEADING COMMAS
          beq  L91A0          ; * WITH PAD CHARACTERS
          cmpb #'.'           ; * CHECK FOR DECIMAL POINT
          bne  L91BA          ; * AND DON'T PUT A ZERO BEFORE IT
L91B6     lda  #'0'           ; * REPLACE PREVIOUS CHARACTER
          sta  ,-x            ; * WITH A ZERO
L91BA     lda  VDA            ; * GET STATUS BYTE, CHECK
          bita #$10           ; * FOR FLOATING $
          beq  L91C4          ; * BRANCH IF NO FLOATING $
          ldb  #'$'           ; * STORE A $ IN
          stb  ,-x            ; * BUFFER
L91C4     anda #$04           ; CHECK PRE-SIGN FLAG
          puls b              ; GET SIGN CHARACTER
          bne  L91CC          ; RETURN IF POST-SIGN REQUIRED
          stb  ,-x            ; STORE FIRST CHARACTER
L91CC     rts
*
* CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN X 10**M.
* THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPONENT).
L91CD     pshs u              ; SAVE BUFFER POINTER
          clra                ; INITIAL EXPONENT OFFSET = 0
L91D0     sta  V47            ; SAVE EXPONENT OFFSET
          ldb  FP0EXP         ; GET EXPONENT OF FPA0
          cmpb #$80           ; * COMPARE TO EXPONENT OF .5
          bhi  L91E9          ; * AND BRANCH IF FPA0 > = 1.0

* IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1
          ldx  #LBDC0         ; POINT X TO FP NUMBER (1E+09)
          jsr  LBACA          ; MULTIPLY FPA0 BY 1E+09
          lda  V47            ; GET EXPONENT OFFSET
          suba #$09           ; SUBTRACT 9 (BECAUSE WE MULTIPLIED BY 1E+09 ABOVE)
          bra  L91D0          ; CHECK TO SEE IF > 1.0
L91E4     jsr  LBB82          ; DIVIDE FPA0 BY 10
          inc  V47            ; INCREMENT EXPONENT OFFSET
L91E9     ldx  #LBDBB         ; POINT X TO FP NUMBER (999,999,999)
          jsr  LBCA0          ; COMPARE FPA0 TO X
          bgt  L91E4          ; BRANCH IF FPA0 > 999,999,999
L91F1     ldx  #LBDB6         ; POINT X TO FP NUMBER (99,999,999.9)
          jsr  LBCA0          ; COMPARE FPA0 TO X
          bgt  L9200          ; RETURN IF 999,999,999 > FPA0 > 99,999,999.9
          jsr  LBB6A          ; MULTIPLY FPA0 BY 10
          dec  V47            ; DECREMENT EXPONENT OFFSET
          bra  L91F1          ; KEEP UNNORMALIZING
L9200     puls u,pc           ; RESTORE BUFFER POINTER AND RETURN
*
* CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT
* INTO A DECIMAL ASCII STRING IN THE BUFFER
L9202     pshs u              ; SAVE BUFFER POINTER
          jsr  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
          jsr  LBCC8          ; CONVERT FPA0 TO INTEGER FORMAT
          puls u              ; RESTORE BUFFER POINTER
*
* CONVERT FPA0 INTO A DECIMAL ASCII STRING
          ldx  #LBEC5         ; POINT X TO UNNORMALIZED POWERS OF 10
          ldb  #$80           ; INITIALIZE DIGIT COUNTER TO 0 + $80.
* BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
* IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSa, IT IS
* THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB
* IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURRING.
L9211     bsr  L9249          ; CHECK FOR COMMA INSERTION
L9213     lda  FPA0+3         ; * 'ADD' A POWER OF 10 MANTISSA TO FPA0.
          adda $03,x          ; * IF THE MANTISSA IS NEGATIVE, A SUBTRACTION
          sta  FPA0+3         ; * WILL BE WHAT REALLY TAKES PLACE.
          lda  FPA0+2         ; *
          adca $02,x          ; *
          sta  FPA0+2         ; *
          lda  FPA0+1         ; *
          adca $01,x          ; *
          sta  FPA0+1         ; *
          lda  FPA0           ; *
          adca ,x             ; *
          sta  FPA0           ; *
          incb                ; ADD ONE TO DIGIT COUNTER
          rorb                ; ROTATE CARRY INTO BIT 7
          rolb                ; * SET OVERFLOW FLAG - BRANCH IF CARRY SET AND
          bvc  L9213          ; * ADDING MANTISSA OR CARRY CLEAR AND SUBTRACTING MANTISSA
          bcc  L9235          ; BRANCH IF SUBTRACTING MANTISSA
          subb #10+1          ; WAS subb #10+1
          negb                ; * IF ADDING MANTISSA
L9235     addb #$2F           ; WAS addb #'0'-1
          leax $04,x          ; MOVE TO NEXT POWER OF 10 MANTISSA
          tfr  b,a            ; SAVE DIGIT IN ACCA
          anda #$7F           ; MASK OFF ADD/SUBTRACT FLAG (BIT 7)
          sta  ,u+            ; STORE DIGIT IN BUFFER
          comb                ; TOGGLE ADD/SUBTRACT FLAG
          andb #$80           ; MASK OFF EVERYTHING BUT ADD/SUB FLAG
          cmpx #LBEE9         ; COMPARE TO END OF UNNORMALIZED POWERS OF 10
          bne  L9211          ; BRANCH IF NOT DONE
          clr  ,u             ; PUT A ZERO AT END OF INTEGER

* DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA INSERTION
L9249     dec  V45            ; DECREMENT DECIMAL POINT COUNTER
          bne  L9256          ; NOT TIME FOR DECIMAL POINT
L924D     stu  VARPTR         ; SAVE BUFFER POINTER-POSITION OF THE DECIMAL POINT
          lda  #'.'           ; * STORE A DECIMAL
          sta  ,u+            ; * POINT IN THE OUTPUT BUFFER
          clr  VD7            ; * CLEAR COMMA COUNTER - NOW IT WILL TAKE 255
*                             ; * DECREMENTS BEFORE ANOTHER COMMA WILL BE INSERTED
          rts
L9256     dec  VD7            ; DECREMENT COMMA COUNTER
          bne  L9262          ; RETURN IF NOT TIME FOR COMMA
          lda  #$03           ; * RESET COMMA COUNTER TO 3; THREE
          sta  VD7            ; * DIGITS BETWEEN COMMAS
          lda  #','            ; * PUT A COMMA INTO
          sta  ,u+            ; * THE BUFFER
L9262     rts

* INITIALIZE DECIMAL POINT AND COMMA COUNTERS
L9263     lda  V47            ; GET THE BASE 10 EXPONENT OFFSET
          adda #10            ; * ADD 10 (FPA0 WAS 'NORMALIZED' TO 9 PLACES LEFT
          sta  V45            ; * OF DECIMAL POINT) - SAVE IN DECIMAL POINT COUNTER
          inca                ; ADD ONE FOR THE DECIMAL POINT
L926A     suba #$03           ; * DIVIDE DECIMAL POINT COUNTER BY 3; LEAVE
          bcc  L926A          ; * THE REMAINDER IN ACCA
          adda #$05           ; CONVERT REMAINDER INTO A NUMBER FROM 1-3
          sta  VD7            ; SAVE COMMA COUNTER
          lda  VDA            ; GET STATUS BYTE
          anda #$40           ; CHECK FOR COMMA FLAG
          bne  L927A          ; BRANCH IF COMMA FLAG ACTIVE
          sta  VD7            ; CLEAR COMMA COUNTER - 255 DIGITS OUTPUT BEFORE A COMMA
L927A     rts
*
* INSERT ACCA ZEROES INTO THE BUFFER
L927B     pshs a              ; SAVE ZEROES COUNTER
          bsr  L9249          ; CHECK FOR DECIMAL POINT
          puls a              ; RESTORE ZEROES COUNTER
L9281     deca                ; * DECREMENT ZEROES COUNTER AND
          bmi  L928E          ; * RETURN IF < 0
          pshs a              ; SAVE ZEROES COUNTER
          lda  #'0'            ; * PUT A ZERO INTO
          sta  ,u+            ; * THE BUFFER
          lda  ,s+            ; RESTORE THE ZEROES COUNTER
          bne  L927B          ; BRANCH IF NOT DONE
L928E     rts


* LINE
LINE      cmpa #TOK_INPUT     ; 'INPUT' TOKEN
          lbeq L89C0          ; GO DO 'LINE INPUT' COMMAND
          jmp  LB277          ; 'SYNTAX ERROR' IF NOT "LINE INPUT"
		  

* END OF EXTENDED BASIC

* DIR COMMAND				; DIR "DRIVE NUMBER"
DIR 	  jsr LD24F 		; SCAN DRIVE NUMBER FROM INPUT LINE		  
		  ;jsr LC79D 		; GET FAT FOR THIS DRIVE
		  ;jsr LB958 		; PRINT CARRIAGE RETURN TO CONSOLE OUT
		  ;ldd #$1102 		; * GET TRACK 17 AND
		  ;sta DCTRK 		; * READ OP CODE AND
		  ;stb DCOPC 		; * SAVE IN DSKCON VARIABLES
		  ;ldb #$03 		; START WITH SECTOR 3 (FIRST DIRECTORY SECTOR)
		  jsr DSK_FDIR		; CALL THE DISK FILE LISTING FUNCTION
		  rts

* GET DRIVE NUMBER FROM BASIC - USE THE DEFAULT DRIVE IF NONE GIVEN
LD24F	  ;ldb				; DEFDRV	GET DEFAULT DRIVE NUMBER		
		  jsr	GETCCH		; GET NEXT INPUT CHAR (TO MAINTAIN BACKWARD COMPATIBILITY)
		  clrb				; ONLY DRIVE 0 SUPPORTED
		  ;beq LD25F			; USE DEFAULT DRIVE NUMBER IF NONE GIVEN
LD256	  ;jsr EVALEXPB		; EVALUATE EXPRESSION
		  ;cmpb #$03		; 4 DRIVES MAX
		  ;lbhi LA61F		; 'DEVICE NUMBER ERROR' IF > 3
LD25F	  ;stb DCDRV		; STORE IN DSKCON VARIABLE
		  rts

FILELENGTH    equ  13		; FORMAT 8.3 + NULL GIVES 13 BYTES

* KILL COMMAND  ; FROM DISK BASIC UNRAVELLED II
KILL	  leas -FILELENGTH,s; ALLOCATE FILENAME STORAGE
		  jsr GET_FN
		  jsr DSK_FDEL		; CALL THE DISK FILE DELETION FUNCTION
		  leas FILELENGTH,s	; FREE FILENAME STACK		  
		  rts

; KILL	  ldb #FILELENGTH
		  ; pshs b			; SAVE FILE LENGTH POSITION
; LC6E9_	  jsr  GETNCH		; GET THE CHARS  
		  ; puls b			; RESTORE FILE LENGTH POSITION
		  ; cmpa #'"'			; UNTIL THE STRING ENDS WITH "
		  ; beq LC6EA_
		  ; pshs a			; THE FILENAME STRING ON THE STACK
		  ; decb
		  ; beq LC6EE_
		  ; pshs b		  	; RE-SAVE FILE LENGTH POSITION
		  ; bra LC6E9_
; LC6EA_	  clra
		  ; pshs a			; FILL FILENAME STRING WITH NULL
		  ; decb
		  ; bne LC6EA_
; LC6EE_	  jsr DSK_FDEL		; CALL THE DISK FILE DELETION FUNCTION
		  ; leas FILELENGTH,s	; FREE FILENAME STACK		  
		  ; rts
		  
* LOAD COMMAND ; FROM DISK BASIC UNRAVELLED II
LOAD 	  leas -FILELENGTH,s; ALLOCATE FILENAME STORAGE
		  jsr GET_FN
		  jsr DSK_FRD		; CALL THE DISK FILE READING FUNCTION
		  leas FILELENGTH,s	; FREE FILENAME STACK		  
		  rts

*LOAD	  cmpa #'M'			; "LOADM" COMMAND
*		  lbeq LCFC1		; *BRANCH IF LOADM
*		 clra 				; RUN	FLAG = ZERO (DON'T RUN)
*LCA4F	 clrb				; CLEAR	MERGE FLAG
*LCA50	 sta	DRUNFL	RUN FLAG (0 = DON'T RUN, 2 = RUN)
*		 stb	DMRGFL	MERGE FLAG (0 = NO MERGE, $FF = MERGE)
*		  bsr	LCA33	GO GET FILENAME, ETC. FROM BASIC
*		  jsr	GETCCH	GET CURRENT INPUT CHAR
*		  beq	LCA6C	BRANCH IF END OF LINE
*		  jsr	SYNCOMMA	SYNTAX CHECK FOR COMMA
		  rts

* SAVE COMMAND
SAVE 	  leas -FILELENGTH,s; ALLOCATE FILENAME STORAGE
		  jsr  GET_FN
		  lbsr LA960		; get the timestamp updated
		  jsr  DSK_FWR		; CALL THE DISK FILE WRITING FUNCTION
		  leas FILELENGTH,s	; FREE FILENAME STACK
		  leas 2,s          ; PURGE RETURN ADDRESS FROM THE STACK		  
		  jmp  LAC73        ; RETURN TO BASIC'S MAIN INPUT LOOP
		  
* SAVE COMMAND ; FROM DISK BASIC UNRAVELLED II
*SAVE	cmpa	#'M	*
;	lbeq	LCF68	*BRANCH IF SAVEM
;	bsr	LCA33	GO GET FILENAME, ETC. FROM BASIC
;	ldx	ZERO	ZERO OUT X REG
;	stx	DFLTYP	SET FILE TYPE AND ASCII FLAG TO ZERO
;	jsr	GETCCH	GET CURRENT INPUT CHARACTER FROM BASIC
;	beq	LCA12	BRANCH IF END OF LINE
;	jsr	SYNCOMMA	SYNTAX CHECK FOR COMMA
;	ldb	#'A		*ASCII FILE?
;	jsr	>LB26F	*SYNTAX CHECK ON CONTENTS OF ACCB
;	bne	LC9DF	RETURN IF NO MORE CHARACTERS ON LINE
;	COM	DASCFL	SET CRUNCHED/ASCII FLAG TO ASCII
;	bsr	LCA04	OPEN A SEQUENTIAL FILE FOR OUTPUT
;	clra		SET	ZERO FLAG - CAUSE ENTIRE FILE TO BE LISTED
;	jmp	LIST	'LIST' THE FILE TO CONSOLE OUT


GET_FN	  pshs u
		  leau 4,s ; +4 BYTES FOR RETURN ADDR + U
		  ldb #FILELENGTH
		  pshs u,b			; SAVE FILE LENGTH POSITION
LC6E9	  jsr  GETNCH		; GET THE CHARS  
		  puls b,u			; RESTORE FILE LENGTH POSITION
		  cmpa #'"'			; UNTIL THE STRING ENDS WITH "
		  beq LC6EA
		  sta ,u+			; THE FILENAME STRING ON THE STACK
		  decb
		  lbeq LC6EA
		  pshs u,b		  	; RE-SAVE FILE LENGTH POSITION
		  bra LC6E9
LC6EA	  clra
		  sta ,u+			; FILL FILENAME STRING WITH NULL
		  decb
		  bne LC6EA
		  jsr  GETNCH		; purge the command
		  puls u
		  rts
		    
*************************CALLING FAT32 FUNCTIONS ****************************************		  
* Generated code from C and optimized afterward
* Note for BASIC ASM -> C : the U, X and Y registers needs to be preserved. Set Y to GV stack.
*****************************************************************************************

* DSK_FDIR()
* {
* 	fileInfo fileList; //18 bytes
* 	
* 	while(FILE_List(&fileList) != END_OF_FILE_LIST) {
DSK_FDIR  pshs 	u,x,y
		  leau 	,s
		  leas 	-18,s			; alloc 18 bytes
		  lbsr  initDISK
		  lbne  FDIR_2			; return when failed
FDIR_3	  leax 	-18,u
		  pshs 	x
		  lbsr	FILE_Lis
		  leas 	2,s		
		  subd 	#$9
		  lbeq 	FDIR_2
* 		PUTCHR('\r');
		  lda	#$d
		  lbsr	PUTCHR	
* 		if(fileList.FI_Attr == ATTR_VOLUME_ID) {
		  ldb	-14,u
		  cmpb	#$8
		  bne	FDIR_4
* 		L85B4("VOLUME NAME IS ");
		  leax	FDIR_5_,pc
		  bra	FDIR_5
FDIR_5_
	fcb	$56, $4f, $4c, $55, $4d, $45, $20, $4e
	fcb	$41, $4d, $45, $20, $49, $53, $20, $0
FDIR_5    lbsr	L85B4
* 		}
* 		L85B4(fileList.FI_Name); PUTCHR(' ');
FDIR_4    leax 	-13,u
		  jsr 	L85B4			; PRINT STRING TO THE SCREEN
		  lda 	#SPACE
		  lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN)
* 		if((fileList.FI_Attr != ATTR_VOLUME_ID) && (fileList.FI_Attr != ATTR_DIRECTORY)) {
		  ldb	-14,u
		  cmpb	#$8
		  beq	FDIR_6	
		  cmpb	#$10
		  beq	FDIR_6	
* 			if(fileList.FI_Size.h > 0xf) { // bigger than 1M (16*64K)
		  ldd	-18,u
		  cmpd	#$f
		  lbls	FDIR_8
* 				PutWhitespace(fileList.FI_Size.h >> 4); PUTCHR('M');
		  lsra
		  rorb
		  lsra
		  rorb
		  lsra
		  rorb
		  lsra
		  rorb
		  pshs	d
		  lbsr	PutWS
		  leas	2,s
		  lda	#'M'
		  lbsr	PUTCHR	
* 				}
* 				else {
		  lbra	FDIR_11
FDIR_8
* 				if((fileList.FI_Size.h == 0) && (fileList.FI_Size.l < 1000)) {  //less than 1K
		  ldd	-18,u
		  bne	FDIR_10
		  ldd	-16,u
		  cmpd	#1000
		  bhs 	FDIR_10
* 					PutWhitespace(fileList.FI_Size.l);
		  pshs	d
		  lbsr	PutWS
		  leas	2,s
		  lda	#' '
		  lbsr	PUTCHR
* 				}
* 				else {
		  lbra	FDIR_11
FDIR_10
* 					i = ((fileList.FI_Size.h & 0xf) << 8) | (fileList.FI_Size.l >> 8);
		  ldd	-18,u
		  andb	#$f
		  tfr 	b,a
		  ldb	-16,u	
* 					PutWhitespace(i >> 2); PUTCHR('K');					
		  lsra
		  rorb
		  lsra
		  rorb	
		  pshs	d
		  lbsr	PutWS
		  leas	2,s
		  lda	#'K'
		  lbsr	PUTCHR
* 				}
* 			}
* 			PUTCHR('B');
FDIR_11	  lda 	#'B'
		  lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN)
		  lda 	#' '
		  lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN)
		  lda  	#'d'
		  lbsr  LA964			; print the date
* 		}
* 	}
FDIR_6
* }
		  lbra	FDIR_3
FDIR_2
		  leas	,u			; free allocated bytes
		  puls	u,x,y,pc

* PutWhitespace(n) unsigned int n; {
* 	if (n < 100) PUTCHR(' ');
PutWS
		  ldd	2,s
		  cmpd	#100
		  bhs	PutWS2
		  lda	#' '
		  lbsr	PUTCHR	
* 	if (n < 10) PUTCHR(' ');
PutWS2	  ldd	2,s
		  cmpb	#10
		  bhs	PutWS3
		  lda	#' '
		  lbsr	PUTCHR	
* 	LBDCC(n);  
PutWS3	  ldd	2,s
		  pshs	u	
		  lbsr	LBDCC
		  puls	u	
* }
		  rts

DSK_FDEL 
		  pshs u,x,y
		  leau 	,s
		  lbsr initDISK
		  bne  DSK_FDL1				; return when failed
		  		  
* 	returnStatus = FILE_Delete(ptr);		  
		  leax 8,u	; +8 BYTES (RETURN ADDR, U, X, Y)
		  pshs	x
		  lbsr	FILE_Del
		  leas	2,s
DSK_FDL1  puls	u,x,y,pc

DSK_FRD   pshs  u,x,y
		  leau 	,s
		  lbsr  initDISK		  
		  lbne  DSK_FRD1			; return when failed
		  
* 	unsigned char returnStatus; //1 byte
		  leas	-1,s		; alloc 1 byte
* 	srcFilePtr = FILE_Open(ptr, READ, &returnStatus);
	 	  leax	-1,u
		  pshs	x
		  clra
		  clrb
		  pshs	d		  
		  leax  8,u			; +8 BYTES (RETURN ADDR, U, X, Y)
		  pshs	x
		  lbsr	FILE_Ope	; file pointer in ACCD
		  leas	6,s		  	; CCR unchanged	
* 	if(srcFilePtr != 0)	{
		  beq   DSK_FRD1
		  std	F_PTR		; let the ConsoleIn pull the file content
* 	}
DSK_FRD1  leas	,u			; free allocated bytes
		  puls	u,x,y,pc


DSK_FWR   pshs  u,x,y	  
		  leau 	,s
		  lbsr  initDISK
		  lbne  FWR_20				; return when failed
		  
* 	fileConfig_st *srcFilePtr; //2 bytes
* 	unsigned char returnStatus; //1 byte
		  leas	-3,s	; alloc 3 bytes
* 	srcFilePtr = FILE_Open(ptr, WRITE, &returnStatus);
		  leax	-3,u
		  pshs	x
		  ldd	#$2
		  pshs	d
		  leax 8,u	; +8 BYTES (RETURN ADDR, U, X, Y)		  
		  pshs	x
		  lbsr	FILE_Ope
		  leas	6,s
		  std	-2,u
		  
* 	if(srcFilePtr == 0)	{
		  ldd	-2,u
		  bne	FWR_19
* 		//print_DebugMsg("\nFile Opening Failed!"); HEXBYTE2(returnStatus); 
		  lbra	FWR_20
* 	}
* 	else {		  
FWR_19
*      send BAS program to the file
		  ldd	-2,u
		  std	F_PTR
		  inc	DEVNUM
		  pshs  u,y			; save U,Y overwritten in LIST routine
		  clra				; SET	ZERO FLAG - CAUSE ENTIRE FILE TO BE LISTED
		  jsr	LIST		; Note for C -> BASIC ASM : the U and Y registers need to be preserved. The C has no persistance in D and X.
		  puls  u,y
		  clr	DEVNUM
		  clr	F_PTR
		  clr	F_PTR+2
		  
* 		FILE_PutCh(srcFilePtr,EOF);
		  ldd	#$1a
		  pshs	d
		  ldd	-2,u
		  pshs	d
		  lbsr	FILE_Put
		  leas	4,s
* 		FILE_Close(srcFilePtr);
		  ldd	-2,u
		  pshs	d
		  lbsr	FILE_Clo
		  leas	2,s
* 	}
* }
FWR_20		  
		  leas	,u			; free allocated bytes
		  puls	u,x,y,pc		  
					

* initDISK() {
* 	unsigned char returnStatus, sdcardType; //2 bytes  -1,u -2,u
initDISK
	pshs	u,x,y
	leau	,s
	leas	-2,s	
* 	
* 	setPins();
	lbsr	setPins
* 	
* 	returnStatus = SD_Init(&sdcardType);		
	leax	-2,u
	pshs	x
	lbsr	SD_Init
	leas	2,s
	stb	-1,u
* 
* 	if(returnStatus != INIT_SUCCESSFUL) {
	ldb	-1,u
	lbeq	init_8
* 		if(returnStatus == NOT_DETECTED)	print_DebugMsg("SD card not detected!\n");
	cmpb	#$1
	bne		init_9
	leax	init_10_,pc
	bra	init_10
init_10_
	fcb	$53, $44, $20, $63, $61, $72, $64, $20
	fcb	$6e, $6f, $74, $20, $64, $65, $74, $65
	fcb	$63, $74, $65, $64, $21, $a, $0
init_10
	pshs	x
	lbsr	print_De
	leas	2,s
* 		if(returnStatus == INIT_FAILED) print_DebugMsg("Card Initialization failed!\n");
init_9
	ldb	-1,u
	cmpb	#$2
	bne		init_15
	leax	init_12_,pc
	bra	init_12
init_12_
	fcb	$43, $61, $72, $64, $20, $49, $6e, $69
	fcb	$74, $69, $61, $6c, $69, $7a, $61, $74
	fcb	$69, $6f, $6e, $20, $66, $61, $69, $6c
	fcb	$65, $64, $21, $a, $0
init_12
	pshs	x
	lbsr	print_De
	leas	2,s
* 	}
    bne		init_15
* 	else {		
init_8
* 		returnStatus = getBootSectorData (); //read boot sector and keep necessary data in global variables
	lbsr	getBootS
	stb	-1,u
* 		if(returnStatus == FAT_INVALID) print_DebugMsg("Invalid FAT file system!\n");
	cmpb #$3
	bne		init_15
	leax	init_16_,pc
	bra	init_16
init_16_
	fcb	$49, $6e, $76, $61, $6c, $69, $64, $20
	fcb	$46, $41, $54, $20, $66, $69, $6c, $65
	fcb	$20, $73, $79, $73, $74, $65, $6d, $21
	fcb	$a, $0
init_16
	pshs	x
	lbsr	print_De
	leas	2,s
* 	}    
init_15
	ldb	-1,u
	clra
* }
	leas	,u			; free allocated bytes
	puls	y,x,u,pc
		  
* END OF DISK BASIC

* micro-C(ver 0.4.1), 1981-1987 Masataka Ohta, Hiroshi Tezuka.
* /***************************************************************************************************/
* /*                                                                                                 */
* /* file:          stdutils.c		                                                               */
* /*                                                                                                 */
* /* source:        2023, written by Adrian Kundert (adrian.kundert@gmail.com)                       */
* /*                                                                                                 */
* /* description:   read and write data from SD CARD (C application for micro-c compiler)            */
* /*                                                                                                 */
* /* This library is free software; you can redistribute it and/or modify it under the terms of the  */
* /* GNU Lesser General Public License as published by the Free Software Foundation;                 */
* /* either version 2.1 of the License, or (at your option) any later version.                       */
* /*                                                                                                 */
* /* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;       */
* /* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.       */
* /* See the GNU Lesser General Public License for more details.                                     */
* /*                                                                                                 */
* /***************************************************************************************************/
* 
* #include "stdutils.h"
* /***************************************************************************************************/
* /*                                                                                                 */
* /* file:          stdutils.h		                                                               */
* /*                                                                                                 */
* /* source:        2023, written by Adrian Kundert (adrian.kundert@gmail.com)                       */
* /*                                                                                                 */
* /* description:   read and write data from SD CARD (C application for micro-c compiler)            */
* /*                                                                                                 */
* /* This library is free software; you can redistribute it and/or modify it under the terms of the  */
* /* GNU Lesser General Public License as published by the Free Software Foundation;                 */
* /* either version 2.1 of the License, or (at your option) any later version.                       */
* /*                                                                                                 */
* /* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;       */
* /* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.       */
* /* See the GNU Lesser General Public License for more details.                                     */
* /*                                                                                                 */
* /***************************************************************************************************/
* 
* /**----------char 8-bit--------
*      char (-128 to 127)
*      signed char (-128 to 127)
*      unsigned char (0 - 255)
* 	-----------------------------*/
* 
* /**---------int 16-bit----------
* 	 int (-32768 to 32767)
* 	 signed int (-32768 to 32767)
*      unsigned int (0 to 65535)
* 	 -----------------------------*/
* 
* /***************************************************************************************************/
* 
* 
* /***************************************************************************************************
*                            Port Direction configurations
*  ***************************************************************************************************/
* #define LOW                0x00
* #define HIGH               0x01
* /**************************************************************************************************/
* 
* /***************************************************************************************************
* ***************************************************************************************************
*                               Commonly used constants
* **************************************************************************************************/
* #define FALSE              0x00
* #define TRUE               0x01
* 
* /**************************************************************************************************
* 			32-bit variable and operation wrapper for 16-bit architecture (big-endian)
* ***************************************************************************************************/
* typedef struct _u32_t {
* 	unsigned int h;
* 	unsigned int l;
* }u32_t;
* 
* 
* /*
* void _u32_and(u32_t *a, u32_t *b, u32_t *out);
* void _u32_div2(u32_t *a, unsigned int b, u32_t *quot);
* void _u32_mul(unsigned int a, u32_t *b, u32_t *prod);
* void _u32_sub(u32_t *a, u32_t *b, u32_t *dif);
* void _u32_dec(u32_t *a);
* void _u32_add(u32_t *a, u32_t *b, u32_t *sum);
* void _u32_inc(u32_t *a);
* unsigned char _u32_lower(u32_t *a, u32_t *b);
* unsigned char _u32_equal(u32_t *a, u32_t *b);
* unsigned char _u32_higher(u32_t *a, u32_t *b); 
* */
* 
* /**************************************************************************************************/
* 
* 
* 
* 
* 
* 
* 
* 
* /***************************************************************************************************
* 			32-bit variable and operation wrapper for 16-bit architecture
*  ***************************************************************************************************/
* 
* // &
* _u32_and(a, b, out) u32_t *a; u32_t *b; u32_t *out; {
* 	out->l = a->l & b->l;
_u32_and
	pshs	u
	leau	,s
	ldx	6,u
	ldd	2,x
	pshs	d
	ldx	4,u
	ldd	2,x
	anda	,s+
	andb	,s+
	ldx	8,u
	std	2,x
* 	out->h = a->h & b->h;
	ldd	[6,u]
	pshs	d
	ldd	[4,u]
	anda	,s+
	andb	,s+
	std	[8,u]
* }
	puls	u,pc
* 
* // /
* _u32_div2(a,b, quot) u32_t *a; unsigned int b; u32_t *quot; {
* 	quot->h = a->h; quot->l = a->l;
_u32_div
	pshs	u
	leau	,s
	ldd	[4,u]
	std	[8,u]
	ldx	4,u
	ldd	2,x
	ldx	8,u
	std	2,x
* 	while (b > 1) {
_3
	ldd	6,u
	subd	#$1
	lbls	_2
* 		quot->l = quot->l >> 1;
	ldd	#$1
	pshs	d
	ldx	8,u
	ldd	2,x
	puls	x
	lbsr	_00009
	ldx	8,u
	std	2,x
* 		if (quot->h & 1) quot->l |= 0x8000;
	ldd	[8,u]
	anda	#$0
	andb	#$1
	subd	#$0
	lbeq	_4
	ldd	8,u
	addd	#$2
	tfr	d,x
	ldd	0,x
	ora	#$80
	orb	#$0
	std	0,x
* 		quot->h = quot->h >> 1;
_4
	ldd	#$1
	pshs	d
	ldd	[8,u]
	puls	x
	lbsr	_00009
	std	[8,u]
* 		b = b >> 1;
	ldd	#$1
	pshs	d
	ldd	6,u
	puls	x
	lbsr	_00009
	std	6,u
* 	}
* }
	lbra	_3
_2
	puls	u,pc
* 
* // *
* _u32_mul(a, b, prod) unsigned int a; u32_t *b; u32_t *prod; {
* 	unsigned int u16, a0, a1, b0, b1, b2, b3; // any changes will impact asm below
* 	{ // brace to ensure proper initialisation before the asm code
_u32_mul
	pshs	u
	leau	,s
	leas	-14,s
* #asm
* 	a0 = a & 0xff;
	ldb	5,u		;lower word
	clra
	std	-4,u
* 	a1 = a >> 8;
	ldb	4,u
	clra
	std	-6,u
* 	b0 = b->l & 0xff;
	ldx	6,u
	ldb	3,x		;lower word
	clra
	std	-8,u
* 	b1 = b->l >> 8;
	ldx	6,u
	ldb	2,x
	clra
	std	-10,u
* 	b2 = b->h & 0xff;
	ldx	6,u
	ldb	1,x		;lower word
	clra
	std	-12,u
* 	b3 = b->h >> 8;
	ldx	6,u
	ldb	0,x
	clra
	std	-14,u
* 	}
* 	// byte 0
* 	u16 = (a0 * b0);
	ldd	-4,u
	pshs	d
	ldd	-8,u
	puls	x
	lbsr	_00001
	std	-2,u
* 	prod->l = u16 & 0xff;	
	ldd	-2,u
	anda	#$0
	andb	#$ff
	ldx	8,u
	std	2,x
* 
* 	// byte 1
* #asm
*	u16 = u16 >> 8;
	ldb	-2,u
	clra
	std	-2,u
* 	u16 += (a1 * b0) + (a0 * b1);
	ldd	-4,u
	pshs	d
	ldd	-10,u
	puls	x
	lbsr	_00001
	pshs	d
	ldd	-6,u
	pshs	d
	ldd	-8,u
	puls	x
	lbsr	_00001
	addd	,s++
	pshs	d
	ldd	-2,u
	addd	,s++
	std	-2,u
* #asm
* 	prod->l += u16 << 8;
	lda	-1,u	; lower word
	clrb
	pshs	d
	ldd	8,u
	addd	#$2
	tfr	d,x
	ldd	0,x
	addd	,s++
	std	0,x
	
*	// byte 2
*	u16 = u16 >> 8;
	ldb	-2,u
	clra
	std -2,u
* 	u16 += (a1 * b1) + (a0 * b2);
	ldd	-4,u
	pshs	d
	ldd	-12,u
	puls	x
	lbsr	_00001
	pshs	d
	ldd	-6,u
	pshs	d
	ldd	-10,u
	puls	x
	lbsr	_00001
	addd	,s++
	pshs	d
	ldd	-2,u
	addd	,s++
	std	-2,u
* 	prod->h = u16 & 0xff;
	ldd	-2,u
	anda	#$0
	andb	#$ff
	std	[8,u]
* 	
* 	// byte 3
* #asm
* 	u16 = u16 >> 8;
	ldb	-2,u	;upper word
	clra
	std	-2,u
* 	u16 += (a1 * b2) + (a0 * b3);
	ldd	-4,u
	pshs	d
	ldd	-14,u
	puls	x
	lbsr	_00001
	pshs	d
	ldd	-6,u
	pshs	d
	ldd	-12,u
	puls	x
	lbsr	_00001
	addd	,s++
	pshs	d
	ldd	-2,u
	addd	,s++
	std	-2,u
* #asm
* 	prod->h += u16 << 8;
	lda	-1,u	; lower word
	clrb
	pshs	d
	ldx	8,u
	ldd	0,x
	addd	,s++
	std	0,x
* }
	leas	,u
	puls	u,pc
* 
* // -
* _u32_sub(a, b, dif) u32_t *a; u32_t *b; u32_t *dif; {
* 	dif->h = a->h - b->h;
_u32_sub
	pshs	u
	leau	,s
	ldd	[6,u]
	pshs	d
	ldd	[4,u]
	subd	,s++
	std	[8,u]
* 	dif->l = a->l - b->l;	
	ldx	6,u
	ldd	2,x
	pshs	d
	ldx	4,u
	ldd	2,x
	subd	,s++
	ldx	8,u
	std	2,x
* 	if(a->l < b->l) dif->h -= 1;
	ldx	6,u
	ldd	2,x
	pshs	d
	ldx	4,u
	ldd	2,x
	subd	,s++
	lbhs	_5
	ldx	8,u
	ldd	0,x
	subd	#$1
	std	0,x
* }
_5
	puls	u,pc
* 
* _u32_dec(a) u32_t *a; {
* 	a->l--;
_u32_dec
	pshs	u
	leau	,s
	ldd	4,u
	addd	#$2
	tfr	d,x
	ldd	,x
	addd	#$ffff
	std	,x
	subd	#$ffff
* 	if (a->l == 0xffff) a->h--;
	ldx	4,u
	ldd	2,x
	subd	#$ffff
	lbne	_6
	ldx	4,u
	ldd	,x
	addd	#$ffff
	std	,x
	subd	#$ffff
* }
_6
	puls	u,pc
* 
* // +
* _u32_add(a, b, sum) u32_t *a; u32_t *b; u32_t *sum; {
* 	sum->h = a->h + b->h;
_u32_add
	pshs	u
	leau	,s
	ldd	[6,u]
	pshs	d
	ldd	[4,u]
	addd	,s++
	std	[8,u]
* 	sum->l = a->l + b->l;
	ldx	6,u
	ldd	2,x
	pshs	d
	ldx	4,u
	ldd	2,x
	addd	,s++
	ldx	8,u
	std	2,x
* 	if ((sum->l < a->l) || (sum->l < b->l)) sum->h++;
	ldx	4,u
	ldd	2,x
	pshs	d
	ldx	8,u
	ldd	2,x
	subd	,s++
	lblo	_8
	ldx	6,u
	ldd	2,x
	pshs	d
	ldx	8,u
	ldd	2,x
	subd	,s++
	lbhs	_7
_8
	ldx	8,u
	ldd	,x
	addd	#$1
	std	,x
	subd	#$1
* }
_7
	puls	u,pc
* 
* _u32_inc(a) u32_t *a; {
* 	a->l++;
_u32_inc
	pshs	u
	leau	,s
	ldd	4,u
	addd	#$2
	tfr	d,x
	ldd	,x
	addd	#$1
	std	,x
	subd	#$1
* 	if (a->l == 0) a->h++;
	ldx	4,u
	ldd	2,x
	subd	#$0
	lbne	_9
	ldx	4,u
	ldd	,x
	addd	#$1
	std	,x
	subd	#$1
* }
_9
	puls	u,pc
* 
* // <
* _u32_lower(a,b) u32_t *a; u32_t *b; {
* 	if ((a->h < b->h) || ((a->h == b->h) && (a->l < b->l))) return TRUE;
_u32_low
	pshs	u
	leau	,s
	ldd	[6,u]
	pshs	d
	ldd	[4,u]
	subd	,s++
	lblo	_11
	ldd	[6,u]
	pshs	d
	ldd	[4,u]
	subd	,s++
	lbne	_10
	ldx	6,u
	ldd	2,x
	pshs	d
	ldx	4,u
	ldd	2,x
	subd	,s++
	lbhs	_10
_11
	ldd	#$1
* 	else return FALSE;
	puls	u,pc
_10
	clra
	clrb
* }
	puls	u,pc
* 
* // ==
* _u32_equal(a,b) u32_t *a; u32_t *b; {
* 	if ((a->h == b->h) && (a->l == b->l)) return TRUE;
_u32_equ
	pshs	u
	leau	,s
	ldd	[6,u]
	pshs	d
	ldd	[4,u]
	subd	,s++
	lbne	_12
	ldx	6,u
	ldd	2,x
	pshs	d
	ldx	4,u
	ldd	2,x
	subd	,s++
	lbne	_12
	ldd	#$1
* 	else return FALSE;
	puls	u,pc
_12
	clra
	clrb
* }
	puls	u,pc
* 
* // >
* _u32_higher(a,b) u32_t *a; u32_t *b; {
* 	if ((a->h > b->h) || ((a->h == b->h) && (a->l > b->l))) return TRUE;
_u32_hig
	pshs	u
	leau	,s
	ldd	[6,u]
	pshs	d
	ldd	[4,u]
	subd	,s++
	lbhi	_14
	ldd	[6,u]
	pshs	d
	ldd	[4,u]
	subd	,s++
	lbne	_13
	ldx	6,u
	ldd	2,x
	pshs	d
	ldx	4,u
	ldd	2,x
	subd	,s++
	lbls	_13
_14
	ldd	#$1
* 	else return FALSE;
	puls	u,pc
_13
	clra
	clrb
* }
	puls	u,pc
* 
* /**************************************************************************************************/
* 
* //unsigned char _strcpy(char *src)
* _strlen(src) char *src;
* {
* 	unsigned char i;
* 	i=0;
_strlen
	pshs	u
	leau	,s
	leas	-1,s
	clra
	clrb
	stb	-1,u
* 	while((src[i] != 0) && (i <= 0xff)) {
_16
	ldb	-1,u
	clra
	ldx	4,u
	ldb	d,x
	clra
	subd	#$0
	lbeq	_15
	ldb	-1,u
	clra
	subd	#$ff
	lbhi	_15
* 		i++;		
	leax	-1,u
	ldb	,x
	inc	,x
	clra
* 	};
	lbra	_16
_15
* 	return i;
	ldb	-1,u
	clra
* }
	leas	,u
	puls	u,pc
* 
* //void _strcpy(char *dest, char *src)
* _strcpy(dest, src) char *dest; char *src;
* {
* 	char b;
* 	do {
_strcpy
	pshs	u
	leau	,s
	leas	-1,s
_19
* 		b = *src++;
	ldx	6,u
	ldb	,x+
	stx	6,u
	sex
	stb	-1,u
* 		*dest++ = b;
	ldb	-1,u
	sex
	ldx	4,u
	stb	,x+
	stx	4,u
* 	}while(b != 0);
_18
	ldb	-1,u
	sex
	subd	#$0
	lbne	_19
* }
_17
	puls	a,u,pc
* 
* //unsigned char _strcmp(char *str1, char *str2)
* _strcmp(str1, str2) char *str1; char *str2;
* {
* 	while((*str1 != 0) && (*str2 != 0)) {
_strcmp
	pshs	u
	leau	,s
_21
	ldb	[4,u]
	sex
	subd	#$0
	lbeq	_20
	ldb	[6,u]
	sex
	subd	#$0
	lbeq	_20
* 		if (*str1++ != *str2++) return 1;
	ldx	6,u
	ldb	,x+
	stx	6,u
	sex
	pshs	d
	ldx	4,u
	ldb	,x+
	stx	4,u
	sex
	subd	,s++
	lbeq	_22
	ldd	#$1
* 	}
	puls	u,pc
_22
* 	return 0;
	lbra	_21
_20
	clra
	clrb
* }
	puls	u,pc
* 
* 
* 
* 
* /***************************************************************************************************/
* /*                                                                                                 */
* /* file:          sdcard.c			                                                               */
* /*                                                                                                 */
* /* source:        2023, written by Adrian Kundert (adrian.kundert@gmail.com)                       */
* /*                                                                                                 */
* /* description:   read and write data from SD CARD (C application for micro-c compiler)            */
* /*                                                                                                 */
* /* This library is free software; you can redistribute it and/or modify it under the terms of the  */
* /* GNU Lesser General Public License as published by the Free Software Foundation;                 */
* /* either version 2.1 of the License, or (at your option) any later version.                       */
* /*                                                                                                 */
* /* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;       */
* /* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.       */
* /* See the GNU Lesser General Public License for more details.                                     */
* /*                                                                                                 */
* /***************************************************************************************************/
* 
* #include "sdcard.h"
* /***************************************************************************************************/
* /*                                                                                                 */
* /* file:          sdcard.h			                                                               */
* /*                                                                                                 */
* /* source:        2023, written by Adrian Kundert (adrian.kundert@gmail.com)                       */
* /*                                                                                                 */
* /* description:   read and write data from SD CARD (C application for micro-c compiler)            */
* /*                                                                                                 */
* /* This library is free software; you can redistribute it and/or modify it under the terms of the  */
* /* GNU Lesser General Public License as published by the Free Software Foundation;                 */
* /* either version 2.1 of the License, or (at your option) any later version.                       */
* /*                                                                                                 */
* /* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;       */
* /* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.       */
* /* See the GNU Lesser General Public License for more details.                                     */
* /*                                                                                                 */
* /***************************************************************************************************/
* 
* /***********************************************************************************
*                                SD CARD INIT STATUS
*  ***********************************************************************************/
* #define INIT_SUCCESSFUL 0
* #define NOT_DETECTED    1
* #define INIT_FAILED     2
* #define FAT_INVALID     3
* #define SIZE_INVALID    4
* 
* 
* #define TYPE_UNKNOWN        0
* #define TYPE_STANDARD       1
* #define TYPE_HIGH_CAPACITY  2
* /***********************************************************************************/
* 
* #define C_MaxPageSize_U16        512
* 
* 
* 
* 
* 
* 
* 
* 
* 
* //SD commands, many of these are not used here
* #define GO_IDLE_STATE            0
* #define SEND_OP_COND             1
* #define SEND_IF_COND			 8
* #define SEND_CSD                 9
* #define STOP_TRANSMISSION        12
* #define SEND_STATUS              13
* #define SET_BLOCK_LEN            16
* #define RD_SINGLE_BLOCK        17
* #define RD_MULTIPLE_BLOCKS     18
* #define WR_SINGLE_BLOCK       24
* #define WR_MULTIPLE_BLOCKS    25
* // #define ERASE_BLOCK_START_ADDR   32
* // #define ERASE_BLOCK_END_ADDR     33
* // #define ERASE_SELECTED_BLOCKS    38
* #define SD_SEND_OP_COND			 41   
* #define APP_CMD					 55
* #define READ_OCR				 58
* #define CRC_ON_OFF               59
* 
* 
* 
*  
* #define PORTA   0xd800
* #define CRA     0xd801
* #define PORTB   0xd802
* #define CRB     0xd803
* 
* //--------------------------------------------------- SPI communication ---------------------------------------------------------------//
* 
* #define SD_TIMEOUT 2000
* 
* /*
*   The circuit:
*     SD card attached to GPIO as follows:
*  ** CS   - PB0 
*  ** MOSI - PB1
*  ** MISO - PB2
*  ** CLK  - PB3
* */
* 
* setPins() {
* 	/*	
* 	DDR |= 0b00000001; CS_HIGH();	// cs_n
* 	DDR |= 0b00000010; MOSI_HIGH();	// mosi
* 	DDR &= 0b11111011;				// miso
* 	DDR |= 0b00001000; SCK_LOW();	// sck
* 	*/
*  	PIAinit(PORTB, 0x0b);
setPins
	pshs	u
	leau	,s
	ldd	#$b
	pshs	d
	ldd	#$d802
	pshs	d
	lbsr	PIAinit
	leas	4,s
* 	CS_HIGH(); MOSI_HIGH(); SCK_LOW();
	lbsr	CS_HIGH
	lbsr	MOSI_HIG
	lbsr	SCK_LOW
* }
	puls	u,pc
* 
* #asm
CS_HIGH		ldb		PORTB
			orb		#%00000001
			stb		PORTB
			rts

CS_LOW		ldb		PORTB
			andb	#%11111110
			stb		PORTB
			rts

MOSI_HIG	ldb		PORTB
			orb		#%00000010
			stb		PORTB
			rts

MOSI_LOW	ldb		PORTB
			andb	#%11111101
			stb		PORTB
			rts		

MISO_REA	ldb		PORTB
			andb	#%00000100
			lsrb	
			lsrb
			clra
			rts

SCK_HIGH	ldb		PORTB
			orb		#%00001000
			stb		PORTB
			rts

SCK_LOW		ldb		PORTB
			andb	#%11110111
			stb		PORTB
			rts
* 
* 
* SPI_Init() {
*   unsigned char i;
* 
*   setPins();
SPI_Init
	pshs	u
	leau	,s
	leas	-1,s
	lbsr	setPins
*   
*   // 80 clks without CS to init the SPI connection  
*   for(i=0; i<80; i++) {
	clra
	clrb
	stb	-1,u
_24
	ldb	-1,u
	clra
	subd	#$50
	lbhs	_23
*     SCK_HIGH();
	lbsr	SCK_HIGH
*     SCK_LOW();
	lbsr	SCK_LOW
*   }  
* }
_25
	leax	-1,u
	ldb	,x
	inc	,x
	sex
	lbra	_24
_23
	puls	a,u,pc
* 
* //SPI_Write(data) unsigned char data; {}
* #asm
SPI_Write
SPI_Writ
		; 0,s return address
		; 2,s not used -> taken as unsigned char i
		; 3,s data
		lda	#8			;8 bits countdown
		sta	2,s		
SPI_W0	lbsr SCK_LOW
		lsl 3,s
		lbcc SPI_W1
		lbsr MOSI_HIG
		lbra SPI_W2
SPI_W1	lbsr MOSI_LOW
SPI_W2	lbsr SCK_HIGH		
		dec 2,s
		lbne SPI_W0
		lbsr SCK_LOW				
		rts
* 
* SPI_Rsync(mask) unsigned char mask; {
*     unsigned char data;			// any changes will impact asm below
*     unsigned int retry;
* 	data = 0xff;
SPI_Rsyn
	pshs	u
	leau	,s
	leas	-3,s
	ldd	#$ff
	stb	-1,u
*     retry = SD_TIMEOUT;
	ldd	#$7d0
	std	-3,u
* 	
* 	MOSI_HIGH(); // rest state 
	lbsr	MOSI_HIG
*     do {  // 10 KHz sck loop
_28
*         if(--retry == 0) break; //{print_DebugMsg("sync timeout\n"); }
	ldd	-3,u
	addd	#$ffff
	std	-3,u
	subd	#$0
	lbne	_29
	lbra	_26
* 		SCK_HIGH();
_29
	lbsr	SCK_HIGH
* #asm
*       data = MISO_READ() | (data<<1);
		lsl		-1,u
		lbsr	MISO_REA
		orb		-1,u
		stb		-1,u
* 		SCK_LOW();		
	lbsr	SCK_LOW
*     }while((data|mask) != mask);  // wait on matching low bit pattern
_27
	ldb	5,u
	clra
	pshs	d
	ldb	5,u
	clra
	pshs	d
	ldb	-1,u
	clra
	ora	,s+
	orb	,s+
	subd	,s++
	lbne	_28
*     
*     return data;
_26
	ldb	-1,u
	clra
* }
	leas	,u
	puls	u,pc
* 
* SPI_Read() {
*     unsigned char i, data;		// any changes will impact asm below
* 	
* 	data=0;
SPI_Read
	pshs	u
	leau	,s
	leas	-2,s
	clra
	clrb
	stb	-2,u
*     MOSI_HIGH(); // rest state 
	lbsr	MOSI_HIG
* #asm
*	for(i=8; i>0; i--)  {   // 10 KHz sck loop     
	ldb	#8
	stb	-1,u
SPI_R1	
*         SCK_HIGH(); 
	lbsr	SCK_HIGH
*         data = MISO_READ() | (data<<1);        
	lbsr	MISO_REA
	lsl		-2,u
	orb		-2,u
	stb		-2,u
*         SCK_LOW();
	lbsr	SCK_LOW
	dec		-1,u
	lbne	SPI_R1
*     }	
*     return data;
	ldb	-2,u
	clra
* }
	puls	x,u,pc
* 
* SPI_EnableChipSelect () {
*     CS_LOW();
SPI_Enab
	pshs	u
	leau	,s
	lbsr	CS_LOW
* }
	puls	u,pc
* 
* SPI_DisableChipSelect () {
*     CS_HIGH();
SPI_Disa
	pshs	u
	leau	,s
	lbsr	CS_HIGH
* }
	puls	u,pc
* 
* //-------------------------------------------------------------------------------------------------------------------------------------//
* unsigned char V_SdHighcapacityFlag_u8;
V_SdHigh	equ	-1
* 
* 
* //******************************************************************
* //Function	: to send a command to SD card
* //Arguments	: unsigned char (8-bit command value)
* // 			  & unsigned long (32-bit command argument)
* //return	: unsigned char; response byte
* //******************************************************************
* SD_sendCommand(cmd, arg) unsigned char cmd; u32_t *arg;
* {
* 	unsigned char response; 		// any changes will impact asm below
* 	unsigned int argLo, argHi;  	// any changes will impact asm below
* 	
* 	response = 0xff;	
SD_sendC
	pshs	u
	leau	,s
	leas	-5,s
	ldd	#$ff
	stb	-1,u
* 	argHi = arg->h;
	ldd	[6,u]
	std	-5,u
* 	argLo = arg->l;
	ldx	6,u
	ldd	2,x
	std	-3,u
* 	
* 	if(SPI_Rsync(0xff) == 0xff) //ensure ready, shall return 0xff
	ldd	#$ff
	pshs	d
	lbsr	SPI_Rsyn
	leas	2,s
	subd	#$ff
	lbne	_30
* 	{
* 		   
* 	    //SD card accepts byte address while SDHC accepts block address in multiples of 512
* 	    //so, if it's SD card we need to convert block address into corresponding byte address by
* 	    //multiplying it with 512. which is equivalent to shifting it left 9 times
* 	    //following 'if' loop does that
* 	    
* 		if(V_SdHighcapacityFlag_u8 == 0)
	ldb	V_SdHigh+0,y
	clra
	subd	#$0
	lbne	_31
* 	    {
* 		    if((cmd == RD_SINGLE_BLOCK)      ||
* 				(cmd == RD_MULTIPLE_BLOCKS)  ||
* 				(cmd == WR_SINGLE_BLOCK)    ||
* 				(cmd == WR_MULTIPLE_BLOCKS))
	ldb	5,u
	clra
	subd	#$11
	lbeq	_33
	ldb	5,u
	clra
	subd	#$12
	lbeq	_33
	ldb	5,u
	clra
	subd	#$18
	lbeq	_33
	ldb	5,u
	clra
	subd	#$19
	lbne	_32
_33
* 		    {
* #asm			
*				argHi = (argHi << 9) | (argLo >> 7);
				clra
				ldb	-2,u	; argLo lower word
				lslb
				rola
				pshs a		; msb argLo lower word
				lda	-4,u	; argHi lower word
				ldb -3,u	; argLo upper word
				lslb
				rola
				addb ,s+
				std	-5,u
 			    
*				argLo = argLo << 9;				
				lda	-2,u	; argLo lower word
				lsla
				clrb
				std	-3,u
* 		    }
* 	    }
_32
* 		
* 		{	// use a brace when starting asm code following a closing brace
_31
* #asm
*		SPI_Write( cmd | 0x40 );
		ldb	5,u
		clra
		orb	#$40
		pshs	d
		lbsr	SPI_Writ
		leas	2,s
*		SPI_Write( argHi >> 8);
		ldb	-5,u	; argHi upper word
		clra
		pshs	d
		lbsr	SPI_Writ
		leas	2,s
*		SPI_Write( argHi & 0xff );
		ldb	-4,u	; argHi lower word
		clra
		pshs	d
		lbsr	SPI_Writ
		leas	2,s		
*		SPI_Write( argLo >> 8);
		ldb	-3,u	; argLo upper word
		clra
		pshs	d
		lbsr	SPI_Writ
		leas	2,s
*		SPI_Write( argLo & 0xff );
		ldb	-2,u	; argLo lower word
		clra
		pshs	d
		lbsr	SPI_Writ
		leas	2,s
* 		}
* 		
* 		if ( cmd == SEND_IF_COND )
	ldb	5,u
	clra
	subd	#$8
	lbne	_34
* 			SPI_Write( 0x87 );     
	ldd	#$87
	pshs	d
	lbsr	SPI_Writ
	leas	2,s
* 		else {
	lbra	_35
_34
* 			SPI_Write( 0x95 ); 
	ldd	#$95
	pshs	d
	lbsr	SPI_Writ
	leas	2,s
* 		}
* 		response = SPI_Rsync(0x7f); //wait response, is 0 when OK
_35
	ldd	#$7f
	pshs	d
	lbsr	SPI_Rsyn
	leas	2,s
	stb	-1,u
* 	}
* 	
* 	if((response == 0x00) && (cmd == READ_OCR))  //checking response of CMD58
_30
	ldb	-1,u
	clra
	subd	#$0
	lbne	_36
	ldb	5,u
	clra
	subd	#$3a
	lbne	_36
* 	{
* 		if((SPI_Read() & 0x40) != 0) //first byte of the OCR register (bit 31:24)
	lbsr	SPI_Read
	anda	#$0
	andb	#$40
	subd	#$0
	lbeq	_37
* 		{
* 			V_SdHighcapacityFlag_u8 = 1;  //we need it to verify SDHC card
	ldd	#$1
	stb	V_SdHigh+0,y
* 			//print_DebugMsg("set SdHighcapacityFlag\n");
* 		}
* 		else
	lbra	_38
_37
* 		{
* 			V_SdHighcapacityFlag_u8 = 0;
	clra
	clrb
	stb	V_SdHigh+0,y
* 		}
* 
* 		SPI_Read(); //remaining 3 bytes of the OCR register are ignored here
_38
	lbsr	SPI_Read
* 		SPI_Read(); //one can use these bytes to check power supply limits of SD
	lbsr	SPI_Read
* 		SPI_Read();
	lbsr	SPI_Read
* 	}
* 	
*     SPI_Read(); //extra 8 CLK
_36
	lbsr	SPI_Read
* 	return response;
	ldb	-1,u
	clra
* }
	leas	,u
	puls	u,pc
* 
* /***************************************************************************************************
*                           uint8_t SD_Init(uint8_t *cardType)
*  ****************************************************************************************************
*  * I/P Arguments :
*                  uint8_t *: Pointer to stire Card Type
*                            SDCARD_TYPE_UNKNOWN
*                            SDCARD_TYPE_STANDARD
*                            SDCARD_TYPE_HIGH_CAPACITY
* 
*  * Return value  :
*                   uint8_t : Returns the SD card initialization status.
*                   SDCARD_INIT_SUCCESSFUL
*                   SDCARD_NOT_DETECTED
*                   SDCARD_INIT_FAILED
*                   SDCARD_FAT_INVALID
* 
*  * description :
*                  This function is used to initialize the SD card.
*                  It returns the initialization status as mentioned above.
*  ****************************************************************************************************/
* SD_Init(cardType) unsigned char *cardType; {
* 	unsigned char response, sd_version;
* 	unsigned int retry;
* 	u32_t tmp;
* 	
* 	{ // brace to ensure proper initialisation before the asm code
SD_Init
	pshs	u
	leau	,s
	leas	-8,s
* #asm	
	ldy  #GV_StackBeginAddr	; restore C global variables stack	
* 	}
* 	
* 	SPI_Init();
	lbsr	SPI_Init
* 	V_SdHighcapacityFlag_u8 = 0;
	clra
	clrb
	stb	V_SdHigh+0,y
* 
* 	SPI_EnableChipSelect ();    
	lbsr	SPI_Enab
* 	retry=SD_TIMEOUT;
	ldd	#$7d0
	std	-4,u
* 	tmp.h = tmp.l = 0x0000;
	clra
	clrb
	std	-6,u
	std	-8,u
* 	do {
_41
*         response = SD_sendCommand(GO_IDLE_STATE, &tmp);
	leax	-8,u
	pshs	x
	clra
	clrb
	pshs	d
	lbsr	SD_sendC
	leas	4,s
	stb	-1,u
*         if(--retry == 0) {return NOT_DETECTED;}   //time out, card not detected
	ldd	-4,u
	addd	#$ffff
	std	-4,u
	subd	#$0
	lbne	_42
	ldd	#$1
	leas	,u
	puls	u,pc
*     }while(response != 1);
_42
_40
	ldb	-1,u
	clra
	subd	#$1
	lbne	_41
* 	//print_DebugMsg("cmd00 OK\n");
*  	
* 	retry = SD_TIMEOUT;
_39
	ldd	#$7d0
	std	-4,u
* 	*cardType = TYPE_STANDARD;
	ldd	#$1
	stb	[4,u]
* 	sd_version = 2; //default set to SD compliance with ver2.x;
	ldd	#$2
	stb	-2,u
* 	//this may change after checking the next command
* 	tmp.h = 0x0000; tmp.l = 0x01AA;
	clra
	clrb
	std	-8,u
	ldd	#$1aa
	std	-6,u
* 	do {        
_45
*         response = SD_sendCommand(SEND_IF_COND, &tmp);
	leax	-8,u
	pshs	x
	ldd	#$8
	pshs	d
	lbsr	SD_sendC
	leas	4,s
	stb	-1,u
*         SPI_Read(); SPI_Read(); SPI_Read(); SPI_Read(); // get the 4 bytes trailer
	lbsr	SPI_Read
	lbsr	SPI_Read
	lbsr	SPI_Read
	lbsr	SPI_Read
* 		if(--retry == 0) {
	ldd	-4,u
	addd	#$ffff
	std	-4,u
	subd	#$0
	lbne	_46
* 			sd_version = 1;			
	ldd	#$1
	stb	-2,u
* 			break;
	lbra	_43
* 		}
*     }while(response != 1);    
_46
_44
	ldb	-1,u
	clra
	subd	#$1
	lbne	_45
*     //print_DebugMsg("cmd08 done\n");
* 	 
* 	retry = SD_TIMEOUT;
_43
	ldd	#$7d0
	std	-4,u
* 	do {
_49
*         tmp.h = tmp.l = 0x0000;
	clra
	clrb
	std	-6,u
	std	-8,u
* 		SD_sendCommand(APP_CMD, &tmp);
	leax	-8,u
	pshs	x
	ldd	#$37
	pshs	d
	lbsr	SD_sendC
	leas	4,s
* 		tmp.h = 0x4000; tmp.l = 0x0000;
	ldd	#$4000
	std	-8,u
	clra
	clrb
	std	-6,u
*         response = SD_sendCommand(SD_SEND_OP_COND, &tmp);
	leax	-8,u
	pshs	x
	ldd	#$29
	pshs	d
	lbsr	SD_sendC
	leas	4,s
	stb	-1,u
*         if(--retry == 0) {return INIT_FAILED;}  //time out, card initialization failed
	ldd	-4,u
	addd	#$ffff
	std	-4,u
	subd	#$0
	lbne	_50
	ldd	#$2
	leas	,u
	puls	u,pc
*     }while(response != 0);
_50
_48
	ldb	-1,u
	clra
	subd	#$0
	lbne	_49
*     //print_DebugMsg("cmd55,cmd41 OK\n");
*     //print_DebugMsg("Wiring is correct and a card is present\n");
* 	
* 	if (sd_version == 2) {
_47
	ldb	-2,u
	clra
	subd	#$2
	lbne	_51
* 		retry = SD_TIMEOUT;
	ldd	#$7d0
	std	-4,u
* 		tmp.h = tmp.l = 0x0000;		
	clra
	clrb
	std	-6,u
	std	-8,u
* 		do {			
_54
* 			response = SD_sendCommand(READ_OCR, &tmp);			
	leax	-8,u
	pshs	x
	ldd	#$3a
	pshs	d
	lbsr	SD_sendC
	leas	4,s
	stb	-1,u
* 			if(--retry == 0) {
	ldd	-4,u
	addd	#$ffff
	std	-4,u
	subd	#$0
	lbne	_55
* 				*cardType = TYPE_UNKNOWN;
	clra
	clrb
	stb	[4,u]
* 				break;  //time out
	lbra	_52
* 			}
* 		}while(response != 0);
_55
_53
	ldb	-1,u
	clra
	subd	#$0
	lbne	_54
* 		//print_DebugMsg("cmd58 sent\n");
* 		
* 		if((cardType != TYPE_UNKNOWN) && (V_SdHighcapacityFlag_u8 == 1)) {
_52
	ldd	4,u
	subd	#$0
	lbeq	_56
	ldb	V_SdHigh+0,y
	clra
	subd	#$1
	lbne	_56
* 			*cardType = TYPE_HIGH_CAPACITY;
	ldd	#$2
	stb	[4,u]
* 		}
* 	}
_56
* 	SPI_DisableChipSelect ();
_51
	lbsr	SPI_Disa
* 
*     //print_DebugMsg("SD init completed\n");
* 	return INIT_SUCCESSFUL;  
	clra
	clrb
* }
	leas	,u
	puls	u,pc
* 
* //******************************************************************
* //Function	: to read a single block from SD card
* //Arguments	: none
* //return	: unsigned char; will be 0 if no error,
* // 			  otherwise the response byte is returned
* //******************************************************************
* SD_readSingleBlock(buf, startBlock) char *buf; u32_t *startBlock;
* {
* 	unsigned char response;
* 	unsigned int i;
* 	
* 	SPI_EnableChipSelect ();
SD_readS
	pshs	u
	leau	,s
	leas	-3,s
	lbsr	SPI_Enab
*     i=SD_TIMEOUT;
	ldd	#$7d0
	std	-3,u
* 	do {
_59
* 		response = SD_sendCommand(RD_SINGLE_BLOCK, startBlock); //read a Block command
	ldd	6,u
	pshs	d
	ldd	#$11
	pshs	d
	lbsr	SD_sendC
	leas	4,s
	stb	-1,u
* 		if(--i == 0) {
	ldd	-3,u
	addd	#$ffff
	std	-3,u
	subd	#$0
	lbne	_60
* 		    //print_DebugMsg("\nread cmd failed!\n");
* 		    return response; //check for SD status: 0x00 - OK (No flags set)
	ldb	-1,u
	clra
* 	    }		
	leas	,u
	puls	u,pc
* 	}while(response != 0x00);
_60
_58
	ldb	-1,u
	clra
	subd	#$0
	lbne	_59
*     
* 	if(SPI_Rsync(0xfe) != 0xfe) //wait data token 0xfe    
_57
	ldd	#$fe
	pshs	d
	lbsr	SPI_Rsyn
	leas	2,s
	subd	#$fe
	lbeq	_61
* 	{									
*   		SPI_DisableChipSelect();        
	lbsr	SPI_Disa
*   		//print_DebugMsg("read token failed!\n");
* 		return 1;
	ldd	#$1
* 	}
	leas	,u
	puls	u,pc
* 	
* 	for (i = 0; i < C_MaxPageSize_U16; i ++ ) {
_61
	clra
	clrb
	std	-3,u
_63
	ldd	-3,u
	subd	#$200
	lbhs	_62
*   		buf[i] = SPI_Read ();
	lbsr	SPI_Read
	pshs	d
	ldd	-3,u
	ldx	4,u
	leax	d,x
	puls	d
	stb	0,x
* 	}
*       
*     SPI_Read (); 	SPI_Read (); // CRC
_64
	ldd	-3,u
	addd	#$1
	std	-3,u
	subd	#$1
	lbra	_63
_62
	lbsr	SPI_Read
	lbsr	SPI_Read
* 	SPI_DisableChipSelect();    
	lbsr	SPI_Disa
*     
* 	return response;
	ldb	-1,u
	clra
* }
	leas	,u
	puls	u,pc
* 
* //******************************************************************
* //Function	: to write to a single block of SD card
* //Arguments	: none
* //return	: unsigned char; will be 0 if no error,
* // 			  otherwise the response byte will be sent
* //******************************************************************
* SD_writeSingleBlock(buf, startBlock) char *buf; u32_t *startBlock;
* {
* 	unsigned char response;
* 	unsigned int i;
* 			
* 	SPI_EnableChipSelect ();
SD_write
	pshs	u
	leau	,s
	leas	-3,s
	lbsr	SPI_Enab
* 	i=SD_TIMEOUT;
	ldd	#$7d0
	std	-3,u
* 	do {		
_67
* 		response = SD_sendCommand(WR_SINGLE_BLOCK, startBlock);
	ldd	6,u
	pshs	d
	ldd	#$18
	pshs	d
	lbsr	SD_sendC
	leas	4,s
	stb	-1,u
* 	    if(--i == 0) {
	ldd	-3,u
	addd	#$ffff
	std	-3,u
	subd	#$0
	lbne	_68
* 		  	//print_DebugMsg("\nwrite cmd failed!\n");
* 			return response; //check for SD status: 0x00 - OK (No flags set)
	ldb	-1,u
	clra
* 		}
	leas	,u
	puls	u,pc
*     }while(response != 0x00);
_68
_66
	ldb	-1,u
	clra
	subd	#$0
	lbne	_67
* 		
* 	SPI_Write (0xff);   //8 clks before the packet
_65
	ldd	#$ff
	pshs	d
	lbsr	SPI_Writ
	leas	2,s
* 	SPI_Write (0xfe);   //data token 0xfe to start transfer	
	ldd	#$fe
	pshs	d
	lbsr	SPI_Writ
	leas	2,s
*     for (i=0; i<C_MaxPageSize_U16; i++) {	//send 512 bytes data
	clra
	clrb
	std	-3,u
_70
	ldd	-3,u
	subd	#$200
	lbhs	_69
*   		SPI_Write(buf[i]);
	ldd	-3,u
	ldx	4,u
	ldb	d,x
	sex
	pshs	d
	lbsr	SPI_Writ
	leas	2,s
* 	}
* 	SPI_Write (0xff);	SPI_Write (0xff);  //transmit dummy CRC (16-bit), CRC is ignored here
_71
	ldd	-3,u
	addd	#$1
	std	-3,u
	subd	#$1
	lbra	_70
_69
	ldd	#$ff
	pshs	d
	lbsr	SPI_Writ
	leas	2,s
	ldd	#$ff
	pshs	d
	lbsr	SPI_Writ
	leas	2,s
*     
* 	response = SPI_Read ();    
	lbsr	SPI_Read
	stb	-1,u
* 	if( ( response & 0x1f) != 0x05 )  		//r1 = 0bXXX0AAA1 ; AAA='010' - data accepted
	ldb	-1,u
	clra
	anda	#$0
	andb	#$1f
	subd	#$5
	lbeq	_72
* 	{										//AAA='101'-data rejected due to CRC error
*   		SPI_DisableChipSelect();          		//AAA='110'-data rejected due to write error
	lbsr	SPI_Disa
*         //print_DebugMsg("\ndata response "); HEXBYTE2(response);
*   		//print_DebugMsg(", write failed!\n");
* 		return response;
	ldb	-1,u
	clra
* 	}
	leas	,u
	puls	u,pc
* 
* 	i = SD_TIMEOUT;
_72
	ldd	#$7d0
	std	-3,u
* 	response = 0;
	clra
	clrb
	stb	-1,u
* 	while ( !SPI_Read ()) { 				//wait till writing completed
_74
	lbsr	SPI_Read
	subd	#$0
	lbne	_73
*         if(--i == 0) {
	ldd	-3,u
	addd	#$ffff
	std	-3,u
	subd	#$0
	lbne	_75
* 			response = -1;
	ldd	#$ffff
	stb	-1,u
* 			//print_DebugMsg("\nwrite failed!\n");
* 			break;			
	lbra	_73
* 		}
*     }	
_75
* 		
* 	SPI_DisableChipSelect();
	lbra	_74
_73
	lbsr	SPI_Disa
*     return response;
	ldb	-1,u
	clra
* }
	leas	,u
	puls	u,pc
* /***************************************************************************************************/
* /*                                                                                                 */
* /* file:          fat32.c			                                                               */
* /*                                                                                                 */
* /* source:        2023-2025, written by Adrian Kundert (adrian.kundert@gmail.com)                  */
* /*                                                                                                 */
* /* description:   read and write data from SD CARD (C application for micro-c compiler)            */
* /*                                                                                                 */
* /* This library is free software; you can redistribute it and/or modify it under the terms of the  */
* /* GNU Lesser General Public License as published by the Free Software Foundation;                 */
* /* either version 2.1 of the License, or (at your option) any later version.                       */
* /*                                                                                                 */
* /* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;       */
* /* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.       */
* /* See the GNU Lesser General Public License for more details.                                     */
* /*                                                                                                 */
* /***************************************************************************************************/
* 
* #include "fat32.h"
* /***************************************************************************************************/
* /*                                                                                                 */
* /* file:          fat32.h			                                                               */
* /*                                                                                                 */
* /* source:        2023, written by Adrian Kundert (adrian.kundert@gmail.com)                       */
* /*                                                                                                 */
* /* description:   read and write data from SD CARD (C application for micro-c compiler)            */
* /*                                                                                                 */
* /* This library is free software; you can redistribute it and/or modify it under the terms of the  */
* /* GNU Lesser General Public License as published by the Free Software Foundation;                 */
* /* either version 2.1 of the License, or (at your option) any later version.                       */
* /*                                                                                                 */
* /* This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;       */
* /* without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.       */
* /* See the GNU Lesser General Public License for more details.                                     */
* /*                                                                                                 */
* /***************************************************************************************************/
* 
* #define C_8_3_FileNameSize    11	//Root Directory Entry Format (SFN) gives 11 bytes
* 
* //Structure to access Master Boot Record for getting info about partitions (Little Endian)
* typedef struct {
*     unsigned char	nothing[446];		//ignore, placed here to fill the gap in the structure
*     unsigned char	partitionData[64];	//partition records (16x4)
*     unsigned char	signature[2];		//0xaa55
* } LE_MBRinfo_Structure;
* 
* 
* 
* //Structure to access boot sector data (Little Endian)
* typedef struct {
*     unsigned char jumpBoot[3];			//00, default: 0x009000EB
*     unsigned char OEMName[8];			//03,
*     unsigned char bytesPerSector[2];	//11, default: 512
*     unsigned char secPrCluster; 		//13, "sectorPerCluster"
*     unsigned char rsvSectorCount[2];	//14, "reservedSectorCount[2]"
*     unsigned char nbofFATs;				//16, "numberofFATs"
*     unsigned char rootEntryCount[2];	//17,
*     unsigned char tSec_F16[2];			//19, "totalSectors_F16[2]" must be 0 for FAT32
*     unsigned char mediaType;			//21,
*     unsigned char FATsz_F16[2];			//22, "FATsize_F16[2]" must be 0 for FAT32
*     unsigned char sectorsPerTrack[2];	//24,
*     unsigned char nbofHeads[2];			//26, "numberofHeads[2]"
*     unsigned char hiddenSectors[4];		//28, 
*     unsigned char tSec_F32[4];			//32, "totalSectors_F32[4]"
*     unsigned char FATsz_F32[4];			//36, "unsigned char FATsize_F32[4]" count of sectors occupied by one FAT
*     unsigned char extFlags[2];
*     unsigned char FSversion[2]; //0x0000 (defines version 0.0)
*     unsigned char rootCluster[4]; //first cluster of root directory (=2)
*     unsigned char FSinfo[2]; //sector number of FSinfo structure (=1)
*     unsigned char BackupBootSector[2];
*     unsigned char rsved[12];//    unsigned char reserved[12];
*     unsigned char driveNumber;
*     unsigned char rsved1;//    unsigned char reserved1;
*     unsigned char bootSignature;
*     unsigned char volumeID[4];
*     unsigned char volumeLabel[11]; //"NO NAME "
*     unsigned char fileSystemType[8]; //"FAT32"
*     unsigned char bootData[420];
*     unsigned char bootEndSignature[2]; //0xaa55
* }LE_BS_Structure;
* 
* 
* //Structure to access FSinfo sector data (Little Endian)
* typedef struct {
*     unsigned char leadSignature[4]; //0x41615252
*     unsigned char rsved3[480];  //    unsigned char reserved1[480];
*     unsigned char structureSignature[4]; //0x61417272
*     unsigned char freeClusterCount[4]; //initial: 0xffffffff
*     unsigned char nextFreeCluster[4]; //initial: 0xffffffff
*     unsigned char rsved4[12];  //    unsigned char reserved2[12];
*     unsigned char trailSignature[4]; //0xaa550000
* }LE_FSinfo_Structure;
* 
* 
* /**************** Each directory is of 32bytes.*****************************************
* Bytes   Content
* 0-10    File name (8 bytes) with extension (3 bytes)
* 11      Attribute - a bitvector. Bit 0: read only. Bit 1: hidden.
* Bit 2: system file. Bit 3: volume label. Bit 4: subdirectory.
* Bit 5: archive. Bits 6-7: unused.
* 12-21   Reserved (see below)
* 22-23   Time (5/6/5 bits, for hour/minutes/doubleseconds)
* 24-25   Date (7/4/5 bits, for year-since-1980/month/day)
* 26-27   Starting cluster (0 for an empty file)
* 28-31   Filesize in bytes
* ****************************************************************************************/
* //Structure to access Directory Entry in the FAT (Little Endian)
* typedef struct{
*     unsigned char name[C_8_3_FileNameSize];
*     unsigned char attrib; //file attributes
*     unsigned char NTreserved; //always 0
*     unsigned char timeTenth; //tenths of seconds, set to 0 here
*     unsigned char createTime[2]; //time file was created
*     unsigned char createDate[2]; //date file was created
*     unsigned char lastAccessDate[2];
*     unsigned char fClsterHI[2]; //higher word of the first cluster number      unsigned int firstClusterHI;
*     unsigned char writeTime[2]; //time of last write
*     unsigned char writeDate[2]; //date of last write
*     unsigned char fClsterLO[2]; //lower word of the first cluster number      unsigned int firstClusterLO;
*     unsigned char fSize[4]; //size of file in bytes							  u32_t fileSize;
* }LE_dir_Structure;
* 
* 
* 
* 
* 
* 
* 
* //Attribute definitions for file/directory
* #define ATTR_READ_ONLY     0x01
* #define ATTR_HIDDEN        0x02
* #define ATTR_SYSTEM        0x04
* #define ATTR_VOLUME_ID     0x08
* #define ATTR_DIRECTORY     0x10
* #define ATTR_ARCHIVE       0x20
* #define ATTR_LONG_NAME     0x0f
* 
* 
* #define END_OF_CLUSTERS    0x0fffffff
* #define DIR_ENTRY_SIZE     0x32
* #define EMPTY              0x00
* #define DELETED            0xe5
* #define GET     0
* #define SET     1
* 
* #define READ	0
* #define VERIFY  1
* #define WRITE   2
* #define APPEND  3
* 
* #define ADD		0
* #define REMOVE	1
* 
* #define TOTAL_FREE   1
* #define NEXT_FREE    2
* 
* #define GET_LIST     0
* #define GET_FILE     1
* #define DELETE		 2
* 
* #define EOF     26
* 
* #define FOPEN_SUCCESSFUL                   0 //FAT32_FILE_OPEN_SUCCESSFUL
* #define FDELETED_OR_NOT_FOUND              1 //FAT32_FILE_DELETED_OR_NOT_FOUND
* #define FALREADY_EXISTS                    2 //FAT32_FILE_ALREADY_EXISTS
* #define VALID_FILE_NAME                    3
* #define INVALID_FILE_NAME                  4
* #define NO_FREE_CLUSTERS_FOUND             5
* #define FILE_OPENED_CANNOT_BE_DELETED      6
* #define TO_MANY_FILES_OPENED               7
* #define MORE_FILES_To_READ                 8
* #define END_OF_FILE_LIST                   9
* 
* #define CONTINUE_LOOP                   0x55
* 
* #define C_MaxFileNameSize     13 //(C_8_3_FileNameSize+2)	//8.3 format (SFN + '.') + NULL gives 13 bytes
* 
* 
* typedef struct
* {
*     u32_t firstSector;
*     u32_t cluster;
*     u32_t prevCluster;
*     u32_t appFSector;
*     unsigned int appFLocation;
*     u32_t fileSize;
*     u32_t byteCounter;
*     u32_t blockNumber_u32;
*     u32_t appendStartCluster;
*     unsigned int sectorIndex;
*     unsigned int bufferIndex_u16;
*     //unsigned int fClstrHigh;
*     //unsigned int fClstrLow;
*     unsigned char LE_fileBuffer[C_MaxPageSize_U16];
*     unsigned char fileOperation_u8;
*     unsigned char fileOpenedFlag;
*     unsigned char fileCreatedFlag;
*     unsigned char appendFileFlag;
*     unsigned char sectorEndFlag;
*     unsigned char endOfFileDetected;
*     char fName[C_MaxFileNameSize];
* }fileConfig_st;
* 
* typedef struct{
* 	u32_t FI_Size;	unsigned char FI_Attr;	char FI_Name[C_MaxFileNameSize];
* }fileInfo;
* 
* 
* 
* 
* 
* /***************************************************************************************
*                            Global Variables
*  ****************************************************************************************/
* u32_t fDataSector, rCluster, totalClusters;   			// "firstDataSector, rootCluster, totalClusters"
fDataSec	equ	-5
rCluster	equ	-9
totalClu	equ	-13
* unsigned int  bPerSector, secPerCluster, rsvSecCnt;  	// "bytesPerSector, sectorPerCluster, reservedSectorCount"
bPerSect	equ	-15
secPerCl	equ	-17
rsvSecCn	equ	-19
* u32_t unusedSectors;
unusedSe	equ	-23
* unsigned char fClstCnU; 								// "freeClusterCountUpdated"
fClstCnU	equ	-24
* unsigned char FL_initialized;
FL_initi	equ	-25
* 	
* fileConfig_st fatMapTb; 								// "fatMappingTable"
fatMapTb	equ	-594
* 
* u32_t clusterNumber, sectorNumber, frstSectorIndex;
clusterN	equ	-598
sectorNu	equ	-602
frstSect	equ	-606
* unsigned int list_i;
list_i	equ	-608
* 
* /****************************************************************************************************************
*                  fileConfig_st* FILE_Open(char* filename,unsigned char fileOperation,unsigned char *fileOpenSts)
*  ****************************************************************************************************************
*  * I/P Arguments :
*                   char *: Name of the file to be opened.
*                   unsigned char: READ, WRITE, APPEND
*                   char *: pointer to update the file opening status.
* 
*  * Return value  :
*                   fileConfig_st *: Pointer to file structure if opened successfully.
*                                  : NULL, if file is not opened.
* 
*  * description :
*                  This functions opens the file with requested mode(Read/Write). 
*                  If the file is successfully opened, it returns the pointer to file structure.
*                  In case the file is not opened it returns NULL, fileOpenSts contains the failure cause.
*  ******************************************************************************************************************/
* //fileConfig_st* FILE_Open(char* filename,unsigned char fileOperation,unsigned char *fileOpenSts)
* FILE_Open(filename, fOperation, fOpenSts) char* filename; unsigned char fOperation; unsigned char *fOpenSts;
* {
*     fileConfig_st *filePtr;
*     u32_t nextCluster, clusterCount, tmp1, tmp2;
*     
* 	_setGVpt(); // call when GV are utilized
FILE_Ope
	pshs	u
	leau	,s
	leas	-18,s
	lbsr	_setGVpt
* 
* 	filePtr = 0;
	clra
	clrb
	std	-2,u
* 	
*     // ensure the filename length
* 	if(_strlen(filename) >= C_MaxFileNameSize) {
	ldd	4,u
	pshs	d
	lbsr	_strlen
	leas	2,s
	subd	#$d
	lblt	_76
* 		*fOpenSts = INVALID_FILE_NAME;
	ldd	#$4
	stb	[8,u]
* 		return 0; /* Set the pointer to NULL indication when failed */
	clra
	clrb
* 	}
	leas	,u
	puls	u,pc
* 	
*     if(fatMapTb.fileOpenedFlag == FALSE)
_76
	ldb	fatMapTb+551,y
	clra
	subd	#$0
	lbne	_77
*     {
*         filePtr = &fatMapTb;
	leax	fatMapTb+0,y
	tfr	x,d
	std	-2,u
*         _strcpy(filePtr->fName,filename);
	ldd	4,u
	pshs	d
	ldd	-2,u
	addd	#$22c
	pshs	d
	lbsr	_strcpy
	leas	4,s
* 		filePtr->fileOperation_u8 = fOperation;
	ldb	7,u
	clra
	ldx	-2,u
	stb	550,x
*         filePtr->firstSector.h = filePtr->firstSector.l = 0x00;
	clra
	clrb
	ldx	-2,u
	std	2,x
	std	[-2,u]
*         filePtr->cluster.h = filePtr->cluster.l =0x00;
	ldd	-2,u
	addd	#$4
	addd	#$2
	tfr	d,x
	clra
	clrb
	std	0,x
	ldx	-2,u
	std	4,x
*         filePtr->blockNumber_u32.h = filePtr->blockNumber_u32.l = 0x00;
	ldd	-2,u
	addd	#$1a
	addd	#$2
	tfr	d,x
	clra
	clrb
	std	0,x
	ldx	-2,u
	std	26,x
*         filePtr->appFSector.h = filePtr->appFSector.l = 0x00;
	ldd	-2,u
	addd	#$c
	addd	#$2
	tfr	d,x
	clra
	clrb
	std	0,x
	ldx	-2,u
	std	12,x
*         filePtr->appFLocation= 0x00;
	clra
	clrb
	ldx	-2,u
	std	16,x
*         filePtr->fileSize.h = filePtr->fileSize.l = 0x00;
	ldd	-2,u
	addd	#$12
	addd	#$2
	tfr	d,x
	clra
	clrb
	std	0,x
	ldx	-2,u
	std	18,x
*         filePtr->byteCounter.h = filePtr->byteCounter.l = 0x00;;
	ldd	-2,u
	addd	#$16
	addd	#$2
	tfr	d,x
	clra
	clrb
	std	0,x
	ldx	-2,u
	std	22,x
*         filePtr->appendStartCluster.h = filePtr->appendStartCluster.l = 0x00;
	ldd	-2,u
	addd	#$1e
	addd	#$2
	tfr	d,x
	clra
	clrb
	std	0,x
	ldx	-2,u
	std	30,x
*         filePtr->sectorIndex= 0x00;
	clra
	clrb
	ldx	-2,u
	std	34,x
*         filePtr->bufferIndex_u16= 0x00;
	clra
	clrb
	ldx	-2,u
	std	36,x
* 		filePtr->appendFileFlag = 0;
	clra
	clrb
	ldx	-2,u
	stb	553,x
*         filePtr->fileCreatedFlag = 0x00;
	clra
	clrb
	ldx	-2,u
	stb	552,x
*         filePtr->endOfFileDetected = 0x00;
	clra
	clrb
	ldx	-2,u
	stb	555,x
* 
*         if(fOperation == READ)
	ldb	7,u
	clra
	subd	#$0
	lbne	_78
*         {
*             *fOpenSts = openFile( READ, filePtr);
	ldd	-2,u
	pshs	d
	clra
	clrb
	pshs	d
	lbsr	openFile
	leas	4,s
	stb	[8,u]
*             if(*fOpenSts != FOPEN_SUCCESSFUL) return 0; /* Set the pointer to NULL indication File not found or Read failed, */
	ldb	[8,u]
	clra
	subd	#$0
	lbeq	_79
	clra
	clrb
*         }
	leas	,u
	puls	u,pc
_79
*         else if((fOperation == WRITE) || (fOperation == APPEND))
	lbra	_80
_78
	ldb	7,u
	clra
	subd	#$2
	lbeq	_82
	ldb	7,u
	clra
	subd	#$3
	lbne	_81
_82
*         {
*             *fOpenSts = openFile (VERIFY, filePtr);
	ldd	-2,u
	pshs	d
	ldd	#$1
	pshs	d
	lbsr	openFile
	leas	4,s
	stb	[8,u]
* 
*             if(*fOpenSts == FOPEN_SUCCESSFUL)
	ldb	[8,u]
	clra
	subd	#$0
	lbne	_83
*             {
* 				filePtr->appendFileFlag = 1;
	ldd	#$1
	ldx	-2,u
	stb	553,x
*                 filePtr->cluster.h = filePtr->appendStartCluster.h; filePtr->cluster.l = filePtr->appendStartCluster.l;
	ldx	-2,u
	ldd	30,x
	ldx	-2,u
	std	4,x
	ldd	-2,u
	addd	#$1e
	pshs	d
	ldd	#$2
	puls	x
	ldd	d,x
	pshs	d
	ldd	-2,u
	addd	#$4
	addd	#$2
	tfr	d,x
	puls	d
	std	0,x
* 				clusterCount.h = clusterCount.l = 0;
	clra
	clrb
	std	-8,u
	std	-10,u
*                 while(1)
_85
*                 {
*                     //nextCluster = getSetNextCluster (filePtr->fileBuffer,filePtr->cluster, GET, 0);
* 					tmp1.h = tmp1.l = 0;
	clra
	clrb
	std	-12,u
	std	-14,u
* 					getSetNC(filePtr->LE_fileBuffer, &filePtr->cluster, GET, &tmp1, &nextCluster);
	leax	-6,u
	pshs	x
	leax	-14,u
	pshs	x
	clra
	clrb
	pshs	d
	ldd	-2,u
	addd	#$4
	pshs	d
	ldd	-2,u
	addd	#$26
	pshs	d
	lbsr	getSetNC
	leas	10,s
* 					
*                     //if(nextCluster == END_OF_CLUSTERS) break;
* 					tmp1.h = 0x0fff; tmp1.l = 0xffff; // = END_OF_CLUSTERS
	ldd	#$fff
	std	-14,u
	ldd	#$ffff
	std	-12,u
* 					if(_u32_equal(&nextCluster, &tmp1) != 0) break;
	leax	-14,u
	pshs	x
	leax	-6,u
	pshs	x
	lbsr	_u32_equ
	leas	4,s
	subd	#$0
	lbeq	_86
	lbra	_84
*                     filePtr->cluster.h = nextCluster.h; filePtr->cluster.l = nextCluster.l;
_86
	ldd	-6,u
	ldx	-2,u
	std	4,x
	ldd	-2,u
	addd	#$4
	addd	#$2
	tfr	d,x
	ldd	-4,u
	std	0,x
*                     _u32_inc(&clusterCount);
	leax	-10,u
	pshs	x
	lbsr	_u32_inc
	leas	2,s
*                 }
* 
*                 //filePtr->sectorIndex = (filePtr->fileSize - (clusterCount * sectorPerCluster * bytesPerSector)) / bytesPerSector;
* 				_u32_mul(secPerCluster, &clusterCount, &tmp1);
	lbra	_85
_84
	leax	-14,u
	pshs	x
	leax	-10,u
	pshs	x
	ldd	secPerCl+0,y
	pshs	d
	lbsr	_u32_mul
	leas	6,s
* 				_u32_mul(bPerSector, &tmp1, &tmp2);
	leax	-18,u
	pshs	x
	leax	-14,u
	pshs	x
	ldd	bPerSect+0,y
	pshs	d
	lbsr	_u32_mul
	leas	6,s
* 				_u32_sub(&filePtr->fileSize, &tmp2, &tmp1);
	leax	-14,u
	pshs	x
	leax	-18,u
	pshs	x
	ldd	-2,u
	addd	#$12
	pshs	d
	lbsr	_u32_sub
	leas	6,s
* 				_u32_div2(&tmp1, bPerSector, &tmp2);
	leax	-18,u
	pshs	x
	ldd	bPerSect+0,y
	pshs	d
	leax	-14,u
	pshs	x
	lbsr	_u32_div
	leas	6,s
* 				filePtr->sectorIndex = tmp2.l;
	ldd	-16,u
	ldx	-2,u
	std	34,x
* 					
*                 getFirstSector (&filePtr->cluster, &filePtr->blockNumber_u32);
	ldd	-2,u
	addd	#$1a
	pshs	d
	ldd	-2,u
	addd	#$4
	pshs	d
	lbsr	getFirst
	leas	4,s
* 				tmp1.h = filePtr->blockNumber_u32.h; tmp1.l = filePtr->blockNumber_u32.l;
	ldx	-2,u
	ldd	26,x
	std	-14,u
	ldd	-2,u
	addd	#$1a
	pshs	d
	ldd	#$2
	puls	x
	ldd	d,x
	std	-12,u
* 				tmp2.h = 0; tmp2.l = filePtr->sectorIndex;
	clra
	clrb
	std	-18,u
	ldx	-2,u
	ldd	34,x
	std	-16,u
* 				_u32_add(&tmp1, &tmp2, &filePtr->blockNumber_u32);
	ldd	-2,u
	addd	#$1a
	pshs	d
	leax	-18,u
	pshs	x
	leax	-14,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
*                 if(SD_readSingleBlock(filePtr->LE_fileBuffer, &filePtr->blockNumber_u32) != 0) return 0; // failed
	ldd	-2,u
	addd	#$1a
	pshs	d
	ldd	-2,u
	addd	#$26
	pshs	d
	lbsr	SD_readS
	leas	4,s
	subd	#$0
	lbeq	_87
	clra
	clrb
*                 filePtr->bufferIndex_u16 = filePtr->fileSize.l & (bPerSector-1);
	leas	,u
	puls	u,pc
_87
	ldd	bPerSect+0,y
	subd	#$1
	pshs	d
	ldd	-2,u
	addd	#$12
	pshs	d
	ldd	#$2
	puls	x
	ldd	d,x
	anda	,s+
	andb	,s+
	ldx	-2,u
	std	36,x
*             }
*             else if(*fOpenSts == FDELETED_OR_NOT_FOUND)
	lbra	_88
_83
	ldb	[8,u]
	clra
	subd	#$1
	lbne	_89
*             {
*                 *fOpenSts = FOPEN_SUCCESSFUL;
	clra
	clrb
	stb	[8,u]
* 
*                 getSetFreeCluster(filePtr->LE_fileBuffer, NEXT_FREE, GET, 0, &filePtr->cluster);
	ldd	-2,u
	addd	#$4
	pshs	d
	clra
	clrb
	pshs	d
	clra
	clrb
	pshs	d
	ldd	#$2
	pshs	d
	ldd	-2,u
	addd	#$26
	pshs	d
	lbsr	getSetFr
	leas	10,s
* 				if((filePtr->cluster.h == 0xffff) && (filePtr->cluster.l == 0xffff)) return 0; // failed
	ldx	-2,u
	ldd	4,x
	subd	#$ffff
	lbne	_90
	ldd	-2,u
	addd	#$4
	pshs	d
	ldd	#$2
	puls	x
	ldd	d,x
	subd	#$ffff
	lbne	_90
	clra
	clrb
* 				if(_u32_higher(&filePtr->cluster, &totalClusters) != 0)
	leas	,u
	puls	u,pc
_90
	leax	totalClu+0,y
	pshs	x
	ldd	-2,u
	addd	#$4
	pshs	d
	lbsr	_u32_hig
	leas	4,s
	subd	#$0
	lbeq	_91
*                 {
*                     filePtr->cluster.h = rCluster.h; 	filePtr->cluster.l = rCluster.l;
	ldd	rCluster+0,y
	ldx	-2,u
	std	4,x
	ldd	-2,u
	addd	#$4
	addd	#$2
	tfr	d,x
	ldd	rCluster+2,y
	std	0,x
* 	            }
*                 searchNextFreeCluster(filePtr->LE_fileBuffer, &filePtr->cluster, &filePtr->cluster);
_91
	ldd	-2,u
	addd	#$4
	pshs	d
	ldd	-2,u
	addd	#$4
	pshs	d
	ldd	-2,u
	addd	#$26
	pshs	d
	lbsr	searchNe
	leas	6,s
*                 if((filePtr->cluster.h == 0) && (filePtr->cluster.l == 0))
	ldx	-2,u
	ldd	4,x
	subd	#$0
	lbne	_92
	ldd	-2,u
	addd	#$4
	pshs	d
	ldd	#$2
	puls	x
	ldd	d,x
	subd	#$0
	lbne	_92
*                 {
*                     *fOpenSts = NO_FREE_CLUSTERS_FOUND;
	ldd	#$5
	stb	[8,u]
*                     return 0; /* Set the pointer to NULL indication when failed */
	clra
	clrb
*                 } 
	leas	,u
	puls	u,pc
* 
*                 tmp1.h = 0x0fff; tmp1.l = 0xffff; // = END_OF_CLUSTERS
_92
	ldd	#$fff
	std	-14,u
	ldd	#$ffff
	std	-12,u
* 				getSetNC(filePtr->LE_fileBuffer, &filePtr->cluster, SET, &tmp1, &tmp2);
	leax	-18,u
	pshs	x
	leax	-14,u
	pshs	x
	ldd	#$1
	pshs	d
	ldd	-2,u
	addd	#$4
	pshs	d
	ldd	-2,u
	addd	#$26
	pshs	d
	lbsr	getSetNC
	leas	10,s
* 				
*                 filePtr->appendStartCluster.h = filePtr->cluster.h;
	ldx	-2,u
	ldd	4,x
	ldx	-2,u
	std	30,x
*                 filePtr->appendStartCluster.l = filePtr->cluster.l;
	ldd	-2,u
	addd	#$4
	pshs	d
	ldd	#$2
	puls	x
	ldd	d,x
	pshs	d
	ldd	-2,u
	addd	#$1e
	addd	#$2
	tfr	d,x
	puls	d
	std	0,x
*                 filePtr->fileSize.h = filePtr->fileSize.l = 0;
	ldd	-2,u
	addd	#$12
	addd	#$2
	tfr	d,x
	clra
	clrb
	std	0,x
	ldx	-2,u
	std	18,x
* 
*                 getFirstSector (&filePtr->cluster, &filePtr->blockNumber_u32);
	ldd	-2,u
	addd	#$1a
	pshs	d
	ldd	-2,u
	addd	#$4
	pshs	d
	lbsr	getFirst
	leas	4,s
*                 filePtr->bufferIndex_u16=0;
	clra
	clrb
	ldx	-2,u
	std	36,x
*                 filePtr->sectorIndex=0;					
	clra
	clrb
	ldx	-2,u
	std	34,x
*             }
*             else
	lbra	_93
_89
*             {
*                 filePtr = 0;
	clra
	clrb
	std	-2,u
*             }
*         }
_93
_88
* 
*         if(filePtr != 0)
_81
_80
	ldd	-2,u
	subd	#$0
	lbeq	_94
*         {
*             fatMapTb.fileOpenedFlag = TRUE;
	ldd	#$1
	stb	fatMapTb+551,y
*         }
*     }
_94
* 
*     return filePtr;
_77
	ldd	-2,u
* }
	leas	,u
	puls	u,pc
* 
* 
* 
* 
* /****************************************************************************************************************
*                          void FILE_Close(fileConfig_st *ptr)
*  ****************************************************************************************************************
*  * I/P Arguments :
*                   fileConfig_st *: structure pointer containing the file info that needs to be closed.
* 
*  * Return value  :
*                   none
* 
*  * description :
*                  This functions closes the file and releases the memory used by the file.
*                  Once the file is closed, no more file operation are allowed.
*  ******************************************************************************************************************/
* //void FILE_Close(fileConfig_st *ptr)
* FILE_Close(ptr) fileConfig_st *ptr;
* {
* 	if(ptr != 0) {
FILE_Clo
	pshs	u
	leau	,s
	ldd	4,u
	subd	#$0
	lbeq	_95
*         ptr->fileOpenedFlag = FALSE; /* Clear the file Opened flag */
	clra
	clrb
	ldx	4,u
	stb	551,x
* 	}
* }
_95
	puls	u,pc
* 
* 
* 
* 
* /****************************************************************************************************************
*                          unsigned char FILE_Delete(char *fileName)
*  ****************************************************************************************************************
*  * I/P Arguments :
*                   char *: Name of the file to be deleted.
* 
*  * Return value  :
*                   unsigned char:
*                   INVALID_FILE_NAME--> In case file name is not valid.
*                   FILE_OPENED_CANNOT_BE_DELETED--> File cannot be deleted as it is open.
*                   FILE_DELETED_OR_NOT_FOUND --> File is deleted or not found.
* 
*  * description :
*                  This functions deletes the file from SD card .
*  ******************************************************************************************************************/
* //unsigned char FILE_Delete(char *fileName)
* FILE_Delete(fileName) char *fileName;
* {
*     unsigned char returnStatus;
*     char localfileName[C_MaxFileNameSize];
* 
* 	_setGVpt(); // call when GV are utilized
FILE_Del
	pshs	u
	leau	,s
	leas	-14,s
	lbsr	_setGVpt
* 
* 	// ensure the filename length
* 	if(_strlen(fileName) >= C_MaxFileNameSize) {
	ldd	4,u
	pshs	d
	lbsr	_strlen
	leas	2,s
	subd	#$d
	lblt	_96
* 		returnStatus = INVALID_FILE_NAME;		
	ldd	#$4
	stb	-1,u
* 	}
* 	else {
	lbra	_97
_96
* 		_strcpy(localfileName, fileName);
	ldd	4,u
	pshs	d
	leax	-14,u
	pshs	x
	lbsr	_strcpy
	leas	4,s
* 		returnStatus = convertFileName (localfileName);
	leax	-14,u
	pshs	x
	lbsr	convertF
	leas	2,s
	stb	-1,u
* 	}
* 
*     if(returnStatus == VALID_FILE_NAME)
_97
	ldb	-1,u
	clra
	subd	#$3
	lbne	_98
*     {
*         returnStatus = 0; // default
	clra
	clrb
	stb	-1,u
* 		if(fatMapTb.fileOpenedFlag == TRUE)
	ldb	fatMapTb+551,y
	clra
	subd	#$1
	lbne	_99
*         {
*             /* Check the file to be deleted is already opened */
*             if(_strcmp(localfileName,fatMapTb.fName)==0) returnStatus = FILE_OPENED_CANNOT_BE_DELETED; //override
	leax	fatMapTb+556,y
	pshs	x
	leax	-14,u
	pshs	x
	lbsr	_strcmp
	leas	4,s
	subd	#$0
	lbne	_100
	ldd	#$6
	stb	-1,u
*         }
_100
* 
*         if(returnStatus == 0) returnStatus = deleteFile(localfileName);        
_99
	ldb	-1,u
	clra
	subd	#$0
	lbne	_101
	leax	-14,u
	pshs	x
	lbsr	deleteFi
	leas	2,s
	stb	-1,u
*     }
_101
* 
*     return returnStatus;
_98
	ldb	-1,u
	clra
* }
	leas	,u
	puls	u,pc
* 
* /****************************************************************************************************************
*                          char FILE_GetCh(fileConfig_st *filePtr)
*  ****************************************************************************************************************
*  * I/P Arguments :
*                   fileConfig_st *: structure pointer containing the file info from which the data needs to be read.
* 
*  * Return value  :
*                    char : Byte of data read from file.
* 
* 
*  * description :
*                  This functions reads a byte of data from the file.
*                  It checks whether the requested file is opened or not, it reads the data only if the file is open else returns EOF.
*                  Once the End of File is reached it returns EOF(26). User should stop calling the function after this.
*  ******************************************************************************************************************/
* //char FILE_GetCh(fileConfig_st *filePtr)
* FILE_GetCh(filePtr) fileConfig_st *filePtr;
* {
*     char ch;
* 	u32_t tmp1, tmp2;
* 
* 	_setGVpt(); // call when GV are utilized
FILE_Get
	pshs	u
	leau	,s
	leas	-9,s
	lbsr	_setGVpt
* 
*     if( ((_u32_higher(&filePtr->fileSize, &filePtr->byteCounter)) != 0)   &&  (filePtr->fileOpenedFlag == TRUE))
	ldd	4,u
	addd	#$16
	pshs	d
	ldd	4,u
	addd	#$12
	pshs	d
	lbsr	_u32_hig
	leas	4,s
	subd	#$0
	lbeq	_102
	ldx	4,u
	ldb	551,x
	clra
	subd	#$1
	lbne	_102
*     {
*         if(filePtr->bufferIndex_u16 == 0)
	ldx	4,u
	ldd	36,x
	subd	#$0
	lbne	_103
*         {
*             if((filePtr->sectorIndex == 0))
	ldx	4,u
	ldd	34,x
	subd	#$0
	lbne	_104
*             {
*                 getFirstSector(&filePtr->cluster, &filePtr->firstSector);
	ldd	4,u
	pshs	d
	ldd	4,u
	addd	#$4
	pshs	d
	lbsr	getFirst
	leas	4,s
*             }            
* 			tmp1.h = 0; tmp1.l = filePtr->sectorIndex;
_104
	clra
	clrb
	std	-5,u
	ldx	4,u
	ldd	34,x
	std	-3,u
* 			_u32_add(&filePtr->firstSector, &tmp1, &tmp2);
	leax	-9,u
	pshs	x
	leax	-5,u
	pshs	x
	ldd	4,u
	pshs	d
	lbsr	_u32_add
	leas	6,s
* 			SD_readSingleBlock(filePtr->LE_fileBuffer, &tmp2);  // TBD failure handling
	leax	-9,u
	pshs	x
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	SD_readS
	leas	4,s
*         }
* 
*         ch = filePtr->LE_fileBuffer[filePtr->bufferIndex_u16++];
_103
	ldd	4,u
	addd	#$26
	pshs	d
	ldd	4,u
	addd	#$24
	tfr	d,x
	ldd	,x
	addd	#$1
	std	,x
	subd	#$1
	puls	x
	ldb	d,x
	sex
	stb	-1,u
*         _u32_inc(&filePtr->byteCounter);
	ldd	4,u
	addd	#$16
	pshs	d
	lbsr	_u32_inc
	leas	2,s
* 
*         if(filePtr->bufferIndex_u16 == C_MaxPageSize_U16)
	ldx	4,u
	ldd	36,x
	subd	#$200
	lbne	_105
*         {
*             filePtr->sectorIndex++;
	ldd	4,u
	addd	#$22
	tfr	d,x
	ldd	,x
	addd	#$1
	std	,x
	subd	#$1
*             filePtr->bufferIndex_u16 = 0;
	clra
	clrb
	ldx	4,u
	std	36,x
*             if(filePtr->sectorIndex == secPerCluster)
	ldx	4,u
	ldd	34,x
	subd	secPerCl+0,y
	lbne	_106
*             {
*                 filePtr->sectorIndex = 0;
	clra
	clrb
	ldx	4,u
	std	34,x
*                 tmp1.h = tmp1.l = 0;
	clra
	clrb
	std	-3,u
	std	-5,u
* 				getSetNC (filePtr->LE_fileBuffer, &filePtr->cluster, GET, &tmp1, &filePtr->cluster);
	ldd	4,u
	addd	#$4
	pshs	d
	leax	-5,u
	pshs	x
	clra
	clrb
	pshs	d
	ldd	4,u
	addd	#$4
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	getSetNC
	leas	10,s
*             }
*         }
_106
*     }
_105
*     else
	lbra	_107
_102
*     {
*         ch = EOF;
	ldd	#$1a
	stb	-1,u
*     }
* 
*     return ch;
_107
	ldb	-1,u
	sex
* }
	leas	,u
	puls	u,pc
* 
* /****************************************************************************************************************
*                          void FILE_PutCh (fileConfig_st *filePtr, char data)
*  ****************************************************************************************************************
*  * I/P Arguments :
*                   fileConfig_st *: structure pointer containing the file info where the data needs to be written.
*                   char           : Byte of data to be written to the file.
* 
*  * Return value  :
*                   0 when successfully
* 
* 
*  * description :
*                  This functions writes a byte of data to the file.
*                  It checks whether the requested file is opened or not, it writes the data only if the file is open.
* 
*            Note: CTRL+Z(26) needs to be passed to mark the end of file. After which it saves the file and updates the FAT.
*  ******************************************************************************************************************/
* //void FILE_PutCh (fileConfig_st *filePtr, char data)
* FILE_PutCh(filePtr, data) fileConfig_st *filePtr; char data;
* {
*     unsigned char k;
*     LE_dir_Structure *dir;
*     u32_t tmp1, tmp2;
* 
* 	_setGVpt(); // call when GV are utilized
FILE_Put
	pshs	u
	leau	,s
	leas	-11,s
	lbsr	_setGVpt
* 	
*     if(filePtr->fileOpenedFlag == TRUE)
	ldx	4,u
	ldb	551,x
	clra
	subd	#$1
	lbne	_108
*     {
*         if((filePtr->endOfFileDetected == 0) && (data != EOF))
	ldx	4,u
	ldb	555,x
	sex
	subd	#$0
	lbne	_109
	ldb	7,u
	sex
	subd	#$1a
	lbeq	_109
*         {
*             if(filePtr->sectorEndFlag == 1) //special case when the last character in previous sector was '\r'
	ldx	4,u
	ldb	554,x
	clra
	subd	#$1
	lbne	_110
*             {
*                 filePtr->LE_fileBuffer[filePtr->bufferIndex_u16++] = '\n'; //appending 'Line Feed (LF)' character
	ldd	4,u
	addd	#$24
	tfr	d,x
	ldd	,x
	addd	#$1
	std	,x
	subd	#$1
	pshs	d
	ldd	4,u
	addd	#$26
	addd	,s++
	tfr	d,x
	ldd	#$a
	stb	0,x
*                 _u32_inc(&filePtr->fileSize);
	ldd	4,u
	addd	#$12
	pshs	d
	lbsr	_u32_inc
	leas	2,s
*                 filePtr->sectorEndFlag = 0;
	clra
	clrb
	ldx	4,u
	stb	554,x
*             }
* 
*             if(data == 0x08)    //'Back Space' key pressed
_110
	ldb	7,u
	sex
	subd	#$8
	lbne	_111
*             {
*                 if(filePtr->bufferIndex_u16 != 0)
	ldx	4,u
	ldd	36,x
	subd	#$0
	lbeq	_112
*                 {
*                     filePtr->bufferIndex_u16--;
	ldd	4,u
	addd	#$24
	tfr	d,x
	ldd	,x
	addd	#$ffff
	std	,x
	subd	#$ffff
*                     _u32_dec(&filePtr->fileSize);
	ldd	4,u
	addd	#$12
	pshs	d
	lbsr	_u32_dec
	leas	2,s
*                 }
*             }
_112
*             else
	lbra	_113
_111
*             {
*                 filePtr->LE_fileBuffer[filePtr->bufferIndex_u16++] = data;
	ldd	4,u
	addd	#$24
	tfr	d,x
	ldd	,x
	addd	#$1
	std	,x
	subd	#$1
	pshs	d
	ldd	4,u
	addd	#$26
	addd	,s++
	tfr	d,x
	ldb	7,u
	clra
	stb	0,x
*                 _u32_inc(&filePtr->fileSize);
	ldd	4,u
	addd	#$12
	pshs	d
	lbsr	_u32_inc
	leas	2,s
*             }
* 
* 
*             if(data == '\r')  //'Carriage Return (CR)' character
_113
	ldb	7,u
	sex
	subd	#$d
	lbne	_114
*             {
*                 if(filePtr->bufferIndex_u16 == C_MaxPageSize_U16)
	ldx	4,u
	ldd	36,x
	subd	#$200
	lbne	_115
*                     filePtr->sectorEndFlag = 1;  //flag to indicate that the appended '\n' char should be put in the next sector
	ldd	#$1
	ldx	4,u
	stb	554,x
*                 else
	lbra	_116
_115
*                 {
*                     filePtr->LE_fileBuffer[filePtr->bufferIndex_u16++] = '\n'; //appending 'Line Feed (LF)' character
	ldd	4,u
	addd	#$24
	tfr	d,x
	ldd	,x
	addd	#$1
	std	,x
	subd	#$1
	pshs	d
	ldd	4,u
	addd	#$26
	addd	,s++
	tfr	d,x
	ldd	#$a
	stb	0,x
*                     _u32_inc(&filePtr->fileSize);
	ldd	4,u
	addd	#$12
	pshs	d
	lbsr	_u32_inc
	leas	2,s
*                 }
*             }
_116
* 
*             if(filePtr->bufferIndex_u16 >= C_MaxPageSize_U16)   //though 'i' will never become greater than 512, it's kept here to avoid
_114
	ldx	4,u
	ldd	36,x
	subd	#$200
	lblo	_117
*             {               //infinite loop in case it happens to be greater than 512 due to some data corruption
*                 filePtr->bufferIndex_u16=0;                
	clra
	clrb
	ldx	4,u
	std	36,x
* 				if (SD_writeSingleBlock(filePtr->LE_fileBuffer, &filePtr->blockNumber_u32) != 0) return -1;
	ldd	4,u
	addd	#$1a
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	SD_write
	leas	4,s
	subd	#$0
	lbeq	_118
	ldd	#$ffff
*                 filePtr->sectorIndex++;
	leas	,u
	puls	u,pc
_118
	ldd	4,u
	addd	#$22
	tfr	d,x
	ldd	,x
	addd	#$1
	std	,x
	subd	#$1
*                 if(filePtr->sectorIndex == secPerCluster)
	ldx	4,u
	ldd	34,x
	subd	secPerCl+0,y
	lbne	_119
*                 {
*                     filePtr->sectorIndex = 0;
	clra
	clrb
	ldx	4,u
	std	34,x
*                     filePtr->prevCluster.h = filePtr->cluster.h; filePtr->prevCluster.l = filePtr->cluster.l;
	ldx	4,u
	ldd	4,x
	ldx	4,u
	std	8,x
	ldd	4,u
	addd	#$4
	pshs	d
	ldd	#$2
	puls	x
	ldd	d,x
	pshs	d
	ldd	4,u
	addd	#$8
	addd	#$2
	tfr	d,x
	puls	d
	std	0,x
* 
*                     searchNextFreeCluster(filePtr->LE_fileBuffer, &filePtr->prevCluster, &filePtr->cluster); //look for a free cluster starting from the current cluster
	ldd	4,u
	addd	#$4
	pshs	d
	ldd	4,u
	addd	#$8
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	searchNe
	leas	6,s
* 
*                     tmp1.h = tmp1.l = 0;
	clra
	clrb
	std	-5,u
	std	-7,u
*                     if(_u32_equal(&filePtr->cluster, &tmp1)) return -1;
	leax	-7,u
	pshs	x
	ldd	4,u
	addd	#$4
	pshs	d
	lbsr	_u32_equ
	leas	4,s
	subd	#$0
	lbeq	_120
	ldd	#$ffff
* 
*                     getSetNC(filePtr->LE_fileBuffer, &filePtr->prevCluster, SET, &filePtr->cluster, &tmp1);
	leas	,u
	puls	u,pc
_120
	leax	-7,u
	pshs	x
	ldd	4,u
	addd	#$4
	pshs	d
	ldd	#$1
	pshs	d
	ldd	4,u
	addd	#$8
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	getSetNC
	leas	10,s
* 					tmp1.h = 0x0fff; tmp1.l = 0xffff; // = END_OF_CLUSTERS
	ldd	#$fff
	std	-7,u
	ldd	#$ffff
	std	-5,u
*                     getSetNC(filePtr->LE_fileBuffer, &filePtr->cluster, SET, &tmp1, &tmp2);   //last cluster of the file, marked END_OF_CLUSTERS
	leax	-11,u
	pshs	x
	leax	-7,u
	pshs	x
	ldd	#$1
	pshs	d
	ldd	4,u
	addd	#$4
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	getSetNC
	leas	10,s
* 
*                     getFirstSector (&filePtr->cluster, &filePtr->blockNumber_u32);
	ldd	4,u
	addd	#$1a
	pshs	d
	ldd	4,u
	addd	#$4
	pshs	d
	lbsr	getFirst
	leas	4,s
*                     filePtr->bufferIndex_u16=0;
	clra
	clrb
	ldx	4,u
	std	36,x
*                 }
*                 _u32_inc(&filePtr->blockNumber_u32);
_119
	ldd	4,u
	addd	#$1a
	pshs	d
	lbsr	_u32_inc
	leas	2,s
*             }
*         }
_117
*         else if(filePtr->endOfFileDetected == 0)
	lbra	_121
_109
	ldx	4,u
	ldb	555,x
	clra
	subd	#$0
	lbne	_122
*         {
*             filePtr->endOfFileDetected = 1;
	ldd	#$1
	ldx	4,u
	stb	555,x
*             for(;filePtr->bufferIndex_u16<C_MaxPageSize_U16; filePtr->bufferIndex_u16++)  //fill the rest of the buffer with 0x00
_124
	ldx	4,u
	ldd	36,x
	subd	#$200
	lbhs	_123
*                 filePtr->LE_fileBuffer[filePtr->bufferIndex_u16]= 0x00;
	ldx	4,u
	ldd	36,x
	pshs	d
	ldd	4,u
	addd	#$26
	addd	,s++
	tfr	d,x
	clra
	clrb
	stb	0,x
* 
* 			if (SD_writeSingleBlock(filePtr->LE_fileBuffer, &filePtr->blockNumber_u32) != 0) return -1;
_125
	ldd	4,u
	addd	#$24
	tfr	d,x
	ldd	,x
	addd	#$1
	std	,x
	subd	#$1
	lbra	_124
_123
	ldd	4,u
	addd	#$1a
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	SD_write
	leas	4,s
	subd	#$0
	lbeq	_126
	ldd	#$ffff
*             
* 			getSetFreeCluster(filePtr->LE_fileBuffer,NEXT_FREE, SET, &filePtr->cluster, &tmp1); //update FSinfo next free cluster entry
	leas	,u
	puls	u,pc
_126
	leax	-7,u
	pshs	x
	ldd	4,u
	addd	#$4
	pshs	d
	ldd	#$1
	pshs	d
	ldd	#$2
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	getSetFr
	leas	10,s
* 
*             if(filePtr->appendFileFlag == 1)  //executes this loop if file is to be appended
	ldx	4,u
	ldb	553,x
	clra
	subd	#$1
	lbne	_127
*             {
*                 if (SD_readSingleBlock(filePtr->LE_fileBuffer, &filePtr->appFSector) != 0)	return -1;
	ldd	4,u
	addd	#$c
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	SD_readS
	leas	4,s
	subd	#$0
	lbeq	_128
	ldd	#$ffff
* 				
*                 dir = &filePtr->LE_fileBuffer[filePtr->appFLocation];  //cast was ok, but removed
	leas	,u
	puls	u,pc
_128
	ldx	4,u
	ldd	16,x
	pshs	d
	ldd	4,u
	addd	#$26
	addd	,s++
	std	-3,u
* 				set_Word(getTimeF32(), dir->writeTime);        // time of last write	                        
	ldd	-3,u
	addd	#$16
	pshs	d
	lbsr	getTimeF
	pshs	d
	lbsr	set_Word
	leas	4,s
* 				set_Word(getDateF32(), dir->lastAccessDate);   // date of last access
	ldd	-3,u
	addd	#$12
	pshs	d
	lbsr	getDateF
	pshs	d
	lbsr	set_Word
	leas	4,s
* 	            set_Word(getDateF32(), dir->writeDate);        // date of last write	                        
	ldd	-3,u
	addd	#$18
	pshs	d
	lbsr	getDateF
	pshs	d
	lbsr	set_Word
	leas	4,s
*                 get_QByte(dir->fSize, &tmp1);
	leax	-7,u
	pshs	x
	ldd	-3,u
	addd	#$1c
	pshs	d
	lbsr	get_QByt
	leas	4,s
* 				_u32_sub(&filePtr->fileSize, &tmp1, &tmp2);
	leax	-11,u
	pshs	x
	leax	-7,u
	pshs	x
	ldd	4,u
	addd	#$12
	pshs	d
	lbsr	_u32_sub
	leas	6,s
* 				set_QByte(&filePtr->fileSize, dir->fSize);
	ldd	-3,u
	addd	#$1c
	pshs	d
	ldd	4,u
	addd	#$12
	pshs	d
	lbsr	set_QByt
	leas	4,s
*                 if (SD_writeSingleBlock(filePtr->LE_fileBuffer, &filePtr->appFSector) != 0) return -1;
	ldd	4,u
	addd	#$c
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	SD_write
	leas	4,s
	subd	#$0
	lbeq	_129
	ldd	#$ffff
*                 freeMemoryUpdate (filePtr->LE_fileBuffer, REMOVE, &tmp2); //updating free memory count in FSinfo sector;
	leas	,u
	puls	u,pc
_129
	leax	-11,u
	pshs	x
	ldd	#$1
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	freeMemo
	leas	6,s
*                 return 0;
	clra
	clrb
*             }
	leas	,u
	puls	u,pc
* 
*             //executes following portion when new file is created
* 			filePtr->prevCluster.h = rCluster.h; filePtr->prevCluster.l = rCluster.l; //root cluster
_127
	ldd	rCluster+0,y
	ldx	4,u
	std	8,x
	ldd	4,u
	addd	#$8
	addd	#$2
	tfr	d,x
	ldd	rCluster+2,y
	std	0,x
* 
*             while(1)
_131
*             {
*                 getFirstSector(&filePtr->prevCluster, &filePtr->firstSector);
	ldd	4,u
	pshs	d
	ldd	4,u
	addd	#$8
	pshs	d
	lbsr	getFirst
	leas	4,s
* 
*                 for(filePtr->sectorIndex = 0; filePtr->sectorIndex < secPerCluster; filePtr->sectorIndex++)
	clra
	clrb
	ldx	4,u
	std	34,x
_133
	ldx	4,u
	ldd	34,x
	subd	secPerCl+0,y
	lbhs	_132
*                 {
*                     tmp1.h = 0; tmp1.l = filePtr->sectorIndex;
	clra
	clrb
	std	-7,u
	ldx	4,u
	ldd	34,x
	std	-5,u
*                     _u32_add(&filePtr->firstSector, &tmp1, &tmp2);					
	leax	-11,u
	pshs	x
	leax	-7,u
	pshs	x
	ldd	4,u
	pshs	d
	lbsr	_u32_add
	leas	6,s
* 					if (SD_readSingleBlock(filePtr->LE_fileBuffer, &tmp2) != 0) return -1;
	leax	-11,u
	pshs	x
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	SD_readS
	leas	4,s
	subd	#$0
	lbeq	_135
	ldd	#$ffff
* 					
*                     for(filePtr->bufferIndex_u16=0; filePtr->bufferIndex_u16<bPerSector; filePtr->bufferIndex_u16+=32)
	leas	,u
	puls	u,pc
_135
	clra
	clrb
	ldx	4,u
	std	36,x
_137
	ldx	4,u
	ldd	36,x
	subd	bPerSect+0,y
	lbhs	_136
*                     {
*                         dir = &filePtr->LE_fileBuffer[filePtr->bufferIndex_u16];  //cast was ok, but removed
	ldx	4,u
	ldd	36,x
	pshs	d
	ldd	4,u
	addd	#$26
	addd	,s++
	std	-3,u
* 						if(filePtr->fileCreatedFlag != 0)   //to mark last directory entry with 0x00 (empty) mark
	ldx	4,u
	ldb	552,x
	clra
	subd	#$0
	lbeq	_139
*                         {                     //indicating end of the directory file list
*                             dir->name[0] = 0x00;
	clra
	clrb
	ldx	-3,u
	stb	0,x
*                             return 0;
	clra
	clrb
*                         }
	leas	,u
	puls	u,pc
* 
*                         if((dir->name[0] == EMPTY) || (dir->name[0] == DELETED))  //looking for an empty slot to enter file info
_139
	ldx	-3,u
	ldb	0,x
	clra
	subd	#$0
	lbeq	_141
	ldx	-3,u
	ldb	0,x
	clra
	subd	#$e5
	lbne	_140
_141
*                         {                            
* 							// Root Directory Entry Format (SFN)					
* 							for(k=0; k<C_8_3_FileNameSize; k++) {                            
	clra
	clrb
	stb	-1,u
_143
	ldb	-1,u
	clra
	subd	#$b
	lbhs	_142
* 								dir->name[k] = filePtr->fName[k];
	ldd	4,u
	addd	#$22c
	pshs	d
	ldb	-1,u
	clra
	puls	x
	ldb	d,x
	clra
	pshs	d
	ldb	-1,u
	clra
	ldx	-3,u
	leax	d,x
	puls	d
	stb	0,x
* 							}
*                             dir->attrib = ATTR_ARCHIVE; 					//setting file attribute as 'archive'
_144
	leax	-1,u
	ldb	,x
	inc	,x
	clra
	lbra	_143
_142
	ldd	#$20
	ldx	-3,u
	stb	11,x
*                             dir->NTreserved = 0;            				//always set to 0
	clra
	clrb
	ldx	-3,u
	stb	12,x
* 							dir->timeTenth = 0;         					//always set to 0
	clra
	clrb
	ldx	-3,u
	stb	13,x
*                             set_Word(getTimeF32(), dir->createTime);       // time of creation
	ldd	-3,u
	addd	#$e
	pshs	d
	lbsr	getTimeF
	pshs	d
	lbsr	set_Word
	leas	4,s
* 	                        set_Word(getTimeF32(), dir->writeTime);        // time of last write	                        
	ldd	-3,u
	addd	#$16
	pshs	d
	lbsr	getTimeF
	pshs	d
	lbsr	set_Word
	leas	4,s
* 							set_Word(getDateF32(), dir->createDate); 	   // date of creation
	ldd	-3,u
	addd	#$10
	pshs	d
	lbsr	getDateF
	pshs	d
	lbsr	set_Word
	leas	4,s
* 	                        set_Word(getDateF32(), dir->lastAccessDate);   // date of last access
	ldd	-3,u
	addd	#$12
	pshs	d
	lbsr	getDateF
	pshs	d
	lbsr	set_Word
	leas	4,s
* 	                        set_Word(getDateF32(), dir->writeDate);        // date of last write
	ldd	-3,u
	addd	#$18
	pshs	d
	lbsr	getDateF
	pshs	d
	lbsr	set_Word
	leas	4,s
* 	                        set_Word(filePtr->appendStartCluster.h, dir->fClsterHI);
	ldd	-3,u
	addd	#$14
	pshs	d
	ldx	4,u
	ldd	30,x
	pshs	d
	lbsr	set_Word
	leas	4,s
* 	                        set_Word(filePtr->appendStartCluster.l, dir->fClsterLO);
	ldd	-3,u
	addd	#$1a
	pshs	d
	ldd	4,u
	addd	#$1e
	pshs	d
	ldd	#$2
	puls	x
	ldd	d,x
	pshs	d
	lbsr	set_Word
	leas	4,s
* 	                        set_QByte(&filePtr->fileSize, dir->fSize);
	ldd	-3,u
	addd	#$1c
	pshs	d
	ldd	4,u
	addd	#$12
	pshs	d
	lbsr	set_QByt
	leas	4,s
* 							
* 							tmp1.h = 0; tmp1.l = filePtr->sectorIndex;
	clra
	clrb
	std	-7,u
	ldx	4,u
	ldd	34,x
	std	-5,u
* 							_u32_add(&filePtr->firstSector, &tmp1, &tmp2);
	leax	-11,u
	pshs	x
	leax	-7,u
	pshs	x
	ldd	4,u
	pshs	d
	lbsr	_u32_add
	leas	6,s
* 							if (SD_writeSingleBlock(filePtr->LE_fileBuffer, &tmp2) != 0) return -1;
	leax	-11,u
	pshs	x
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	SD_write
	leas	4,s
	subd	#$0
	lbeq	_145
	ldd	#$ffff
*                             filePtr->fileCreatedFlag = 1;
	leas	,u
	puls	u,pc
_145
	ldd	#$1
	ldx	4,u
	stb	552,x
*                             freeMemoryUpdate (filePtr->LE_fileBuffer,REMOVE, &filePtr->fileSize); //updating free memory count in FSinfo sector
	ldd	4,u
	addd	#$12
	pshs	d
	ldd	#$1
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	freeMemo
	leas	6,s
*                         }
*                     }
_140
*                 }
_138
	ldd	4,u
	addd	#$24
	tfr	d,x
	ldd	0,x
	addd	#$20
	std	0,x
	lbra	_137
_136
* 				tmp1.h = tmp1.l = 0;
_134
	ldd	4,u
	addd	#$22
	tfr	d,x
	ldd	,x
	addd	#$1
	std	,x
	subd	#$1
	lbra	_133
_132
	clra
	clrb
	std	-5,u
	std	-7,u
*                 getSetNC (filePtr->LE_fileBuffer, &filePtr->prevCluster, GET, &tmp1, &filePtr->cluster);
	ldd	4,u
	addd	#$4
	pshs	d
	leax	-7,u
	pshs	x
	clra
	clrb
	pshs	d
	ldd	4,u
	addd	#$8
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	getSetNC
	leas	10,s
* 
*                 tmp1.h = 0x0fff; tmp1.l = 0xfff6;
	ldd	#$fff
	std	-7,u
	ldd	#$fff6
	std	-5,u
* 				if(_u32_higher(&filePtr->cluster, &tmp1) != 0)
	leax	-7,u
	pshs	x
	ldd	4,u
	addd	#$4
	pshs	d
	lbsr	_u32_hig
	leas	4,s
	subd	#$0
	lbeq	_146
*                 {
*                     tmp1.h = 0x0fff; tmp1.l = 0xffff; //END_OF_CLUSTERS
	ldd	#$fff
	std	-7,u
	ldd	#$ffff
	std	-5,u
* 					if(_u32_equal(&filePtr->cluster, &tmp1) != 0)   //this situation will come when total files in root is multiple of (32*sectorPerCluster)
	leax	-7,u
	pshs	x
	ldd	4,u
	addd	#$4
	pshs	d
	lbsr	_u32_equ
	leas	4,s
	subd	#$0
	lbeq	_147
*                     {
*                         searchNextFreeCluster(filePtr->LE_fileBuffer, &filePtr->prevCluster, &filePtr->cluster); //find next cluster for root directory entries
	ldd	4,u
	addd	#$4
	pshs	d
	ldd	4,u
	addd	#$8
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	searchNe
	leas	6,s
*                         getSetNC(filePtr->LE_fileBuffer, &filePtr->prevCluster, SET, &filePtr->cluster, &tmp2); //link the new cluster of root to the previous cluster                        
	leax	-11,u
	pshs	x
	ldd	4,u
	addd	#$4
	pshs	d
	ldd	#$1
	pshs	d
	ldd	4,u
	addd	#$8
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	getSetNC
	leas	10,s
* 						getSetNC(filePtr->LE_fileBuffer, &filePtr->cluster, SET, &tmp1, &tmp2);  //set the new cluster as end of the root directory
	leax	-11,u
	pshs	x
	leax	-7,u
	pshs	x
	ldd	#$1
	pshs	d
	ldd	4,u
	addd	#$4
	pshs	d
	ldd	4,u
	addd	#$26
	pshs	d
	lbsr	getSetNC
	leas	10,s
*                     }
*                     else
	lbra	_148
_147
*                     {
*                         return -1;
	ldd	#$ffff
*                     }
	leas	,u
	puls	u,pc
*                 }
_148
*                 tmp1.h = tmp1.l = 0;
_146
	clra
	clrb
	std	-5,u
	std	-7,u
*                 if(_u32_equal(&filePtr->cluster, &tmp1) != 0) return -1;
	leax	-7,u
	pshs	x
	ldd	4,u
	addd	#$4
	pshs	d
	lbsr	_u32_equ
	leas	4,s
	subd	#$0
	lbeq	_149
	ldd	#$ffff
* 
*                 filePtr->prevCluster.h = filePtr->cluster.h; filePtr->prevCluster.l = filePtr->cluster.l;
	leas	,u
	puls	u,pc
_149
	ldx	4,u
	ldd	4,x
	ldx	4,u
	std	8,x
	ldd	4,u
	addd	#$4
	pshs	d
	ldd	#$2
	puls	x
	ldd	d,x
	pshs	d
	ldd	4,u
	addd	#$8
	addd	#$2
	tfr	d,x
	puls	d
	std	0,x
*             }
*         }
	lbra	_131
_130
*     }
_122
_121
*     else
	lbra	_150
_108
*     {
*         /* FIle not opened, do not handle the file operation */
*     }
* 
*     return -1;
_150
	ldd	#$ffff
* }
	leas	,u
	puls	u,pc
* 
* /****************************************************************************************************************
*                          unsigned char FILE_List (fileInfo *fileList)
*  ****************************************************************************************************************
*  * I/P Arguments :
*                   fileInfo *: structure pointer to store the filename and size..
* 
*  * Return value  :
*                   unsigned char : MORE_FILES_To_READ(8)--> If there are files to be listed.
*                             END_OF_FILE_LIST(9)  --> If there are no more files to be listed.
* 
* 
*  * description :
*                  This functions traverses through the SD card and lists the available files with their size.
*                  It updates the file name and its size in the structure pointer passed to the function.
*                  It returns MORE_FILES_To_READ(8), if there are files to be listed.
*                  In case there are no files to be listed it returns END_OF_FILE_LIST(9).
*  ******************************************************************************************************************/
* //unsigned char FILE_List (fileInfo *fileList)
* FILE_List(fileList) fileInfo *fileList;
* {
*     LE_dir_Structure *dir;
*     unsigned char j;
*     unsigned char fNameIndex;
* 	u32_t tmp;
* 
* 	_setGVpt(); // call when GV are utilized
FILE_Lis
	pshs	u
	leau	,s
	leas	-8,s
	lbsr	_setGVpt
* 
* 	if(FL_initialized == 0)
	ldb	FL_initi+0,y
	clra
	subd	#$0
	lbne	_151
*     {
*         clusterNumber.h = rCluster.h; clusterNumber.l = rCluster.l;
	ldd	rCluster+0,y
	std	clusterN+0,y
	ldd	rCluster+2,y
	std	clusterN+2,y
*         sectorNumber.h = 0; sectorNumber.l = 0;
	clra
	clrb
	std	sectorNu+0,y
	clra
	clrb
	std	sectorNu+2,y
*         list_i = 0;
	clra
	clrb
	std	list_i+0,y
* 		getFirstSector(&clusterNumber, &frstSectorIndex);
	leax	frstSect+0,y
	pshs	x
	leax	clusterN+0,y
	pshs	x
	lbsr	getFirst
	leas	4,s
* 		_u32_add(&frstSectorIndex, &sectorNumber, &tmp);
	leax	-8,u
	pshs	x
	leax	sectorNu+0,y
	pshs	x
	leax	frstSect+0,y
	pshs	x
	lbsr	_u32_add
	leas	6,s
* 		SD_readSingleBlock(fatMapTb.LE_fileBuffer, &tmp);  // TBD failure handling
	leax	-8,u
	pshs	x
	leax	fatMapTb+38,y
	pshs	x
	lbsr	SD_readS
	leas	4,s
* 		FL_initialized = 1;		
	ldd	#$1
	stb	FL_initi+0,y
*     }
* 
*     fNameIndex = 0;
_151
	clra
	clrb
	stb	-4,u
*     do
_154
*     {
*         dir = &fatMapTb.LE_fileBuffer[list_i];  //cast ok, but removed
	leax	fatMapTb+38,y
	tfr	x,d
	addd	list_i+0,y
	std	-2,u
* 		
* 		if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
	ldx	-2,u
	ldb	0,x
	clra
	subd	#$0
	lbne	_155
*         {
*             FL_initialized = 0;
	clra
	clrb
	stb	FL_initi+0,y
*             return (END_OF_FILE_LIST);
	ldd	#$9
*         }
	leas	,u
	puls	u,pc
*         if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
_155
	ldx	-2,u
	ldb	0,x
	clra
	subd	#$e5
	lbeq	_156
	ldx	-2,u
	ldb	11,x
	clra
	subd	#$f
	lbeq	_156
*         {
*             for(j=0; j<11; j++)
	clra
	clrb
	stb	-3,u
_158
	ldb	-3,u
	clra
	subd	#$b
	lbhs	_157
*             {
*                 if(dir->name[j] == '\n') fileList->FI_Name[fNameIndex++] = '\r';
	ldb	-3,u
	clra
	ldx	-2,u
	ldb	d,x
	clra
	subd	#$a
	lbne	_160
	leax	-4,u
	ldb	,x
	inc	,x
	sex
	pshs	d
	ldd	4,u
	addd	#$5
	addd	,s++
	tfr	d,x
	ldd	#$d
	stb	0,x
* 				else {
	lbra	_161
_160
* 					fileList->FI_Name[fNameIndex++] = dir->name[j];
	ldb	-3,u
	sex
	ldx	-2,u
	ldb	d,x
	sex
	pshs	d
	leax	-4,u
	ldb	,x
	inc	,x
	sex
	pshs	d
	ldd	4,u
	addd	#$5
	addd	,s++
	tfr	d,x
	puls	d
	stb	0,x
* 				}
*             }		
_161
*             fileList->FI_Name[fNameIndex] = 0;
_159
	leax	-3,u
	ldb	,x
	inc	,x
	sex
	lbra	_158
_157
	ldb	-4,u
	sex
	pshs	d
	ldd	4,u
	addd	#$5
	addd	,s++
	tfr	d,x
	clra
	clrb
	stb	0,x
* 			
* 			fileList->FI_Attr = dir->attrib;
	ldx	-2,u
	ldb	11,x
	clra
	ldx	4,u
	stb	4,x
* 			get_QByte(dir->fSize, &fileList->FI_Size);
	ldd	4,u
	pshs	d
	ldd	-2,u
	addd	#$1c
	pshs	d
	lbsr	get_QByt
	leas	4,s
* 			setTimeF(get_Word(dir->writeTime));			
	ldd	-2,u
	addd	#$16
	pshs	d
	lbsr	get_Word
	leas	2,s
	pshs	d
	lbsr	setTimeF
	leas	2,s
* 			setDateF(get_Word(dir->writeDate));
	ldd	-2,u
	addd	#$18
	pshs	d
	lbsr	get_Word
	leas	2,s
	pshs	d
	lbsr	setDateF
	leas	2,s
*         }
* 
*         list_i = list_i+32;
_156
	ldd	list_i+0,y
	addd	#$20
	std	list_i+0,y
* 
*         if(list_i >= bPerSector)
	ldd	list_i+0,y
	subd	bPerSect+0,y
	lblo	_162
*         {
*             list_i = 0;
	clra
	clrb
	std	list_i+0,y
*             _u32_inc(&sectorNumber);
	leax	sectorNu+0,y
	pshs	x
	lbsr	_u32_inc
	leas	2,s
* 
*             tmp.h = 0x00; tmp.l = secPerCluster;
	clra
	clrb
	std	-8,u
	ldd	secPerCl+0,y
	std	-6,u
*             if(_u32_equal(&sectorNumber, &tmp) != 0)
	leax	-8,u
	pshs	x
	leax	sectorNu+0,y
	pshs	x
	lbsr	_u32_equ
	leas	4,s
	subd	#$0
	lbeq	_163
*             {
*                 sectorNumber.h = sectorNumber.l = 0;				
	clra
	clrb
	std	sectorNu+2,y
	std	sectorNu+0,y
*                 tmp.h = tmp.l = 0;
	clra
	clrb
	std	-6,u
	std	-8,u
*                 getSetNC (fatMapTb.LE_fileBuffer, &clusterNumber, GET, &tmp, &clusterNumber);
	leax	clusterN+0,y
	pshs	x
	leax	-8,u
	pshs	x
	clra
	clrb
	pshs	d
	leax	clusterN+0,y
	pshs	x
	leax	fatMapTb+38,y
	pshs	x
	lbsr	getSetNC
	leas	10,s
* 
*                 tmp.h = 0x0fff; tmp.l = 0xfff6;              
	ldd	#$fff
	std	-8,u
	ldd	#$fff6
	std	-6,u
* 				if(_u32_higher(&clusterNumber, &tmp) != 0)
	leax	-8,u
	pshs	x
	leax	clusterN+0,y
	pshs	x
	lbsr	_u32_hig
	leas	4,s
	subd	#$0
	lbeq	_164
*                 {
*                     FL_initialized = 0;
	clra
	clrb
	stb	FL_initi+0,y
*                     return END_OF_FILE_LIST;
	ldd	#$9
*                 }
	leas	,u
	puls	u,pc
* 
*                 tmp.h = 0x00; tmp.l = 0x00;
_164
	clra
	clrb
	std	-8,u
	clra
	clrb
	std	-6,u
*                 if(_u32_equal(&clusterNumber, &tmp) != 0)
	leax	-8,u
	pshs	x
	leax	clusterN+0,y
	pshs	x
	lbsr	_u32_equ
	leas	4,s
	subd	#$0
	lbeq	_165
*                 {
*                     FL_initialized = 0;
	clra
	clrb
	stb	FL_initi+0,y
*                     return END_OF_FILE_LIST;
	ldd	#$9
*                 }
	leas	,u
	puls	u,pc
* 
*                 getFirstSector(&clusterNumber, &frstSectorIndex);
_165
	leax	frstSect+0,y
	pshs	x
	leax	clusterN+0,y
	pshs	x
	lbsr	getFirst
	leas	4,s
*             }
* 	        _u32_add(&frstSectorIndex, &sectorNumber, &tmp);
_163
	leax	-8,u
	pshs	x
	leax	sectorNu+0,y
	pshs	x
	leax	frstSect+0,y
	pshs	x
	lbsr	_u32_add
	leas	6,s
*             SD_readSingleBlock(fatMapTb.LE_fileBuffer,&tmp);  // TBD failure handling
	leax	-8,u
	pshs	x
	leax	fatMapTb+38,y
	pshs	x
	lbsr	SD_readS
	leas	4,s
*         }
*     }while(fNameIndex == 0);
_162
_153
	ldb	-4,u
	clra
	subd	#$0
	lbeq	_154
* 
*     return MORE_FILES_To_READ;
_152
	ldd	#$8
* }
	leas	,u
	puls	u,pc
* 
* // split the ROMs
* #asm
    jmp $e000
	org $e000    
* 
* //unsigned char getBootSectorData (void)
* getBootSectorData()
* {
* 	LE_BS_Structure *bpb; //mapping the buffer onto the structure
* 	LE_MBRinfo_Structure *mbr;
*     u32_t FATsize_t;
* 	u32_t dataSectors;
* 	u32_t tmp1, tmp2;
* 	unsigned char i, n;
* 	unsigned int tmp16;
* 
* 	FL_initialized = 0;	
getBootS
	pshs	u
	leau	,s
	leas	-24,s
	clra
	clrb
	stb	FL_initi+0,y
* 	unusedSectors.h = unusedSectors.l = 0;   //init at first sector
	clra
	clrb
	std	unusedSe+2,y
	std	unusedSe+0,y
*     fatMapTb.fileOpenedFlag = FALSE;
	clra
	clrb
	stb	fatMapTb+551,y
* 	
*     if(SD_readSingleBlock(fatMapTb.LE_fileBuffer, &unusedSectors) != 0) return FAT_INVALID;
	leax	unusedSe+0,y
	pshs	x
	leax	fatMapTb+38,y
	pshs	x
	lbsr	SD_readS
	leas	4,s
	subd	#$0
	lbeq	_166
	ldd	#$3
* 	
* 	bpb = fatMapTb.LE_fileBuffer;   //cast removed
	leas	,u
	puls	u,pc
_166
	leax	fatMapTb+38,y
	tfr	x,d
	std	-2,u
* 	
*     if((bpb->jumpBoot[0]!=0xE9) && (bpb->jumpBoot[0]!=0xEB))   //check if it is boot sector
	ldx	-2,u
	ldb	0,x
	clra
	subd	#$e9
	lbeq	_167
	ldx	-2,u
	ldb	0,x
	clra
	subd	#$eb
	lbeq	_167
*     {
*         mbr = fatMapTb.LE_fileBuffer;       //if it is not boot sector, it must be MBR
	leax	fatMapTb+38,y
	tfr	x,d
	std	-4,u
* 		
* 		if(get_Word(mbr->signature) != 0xaa55)
	ldd	-4,u
	addd	#$1fe
	pshs	d
	lbsr	get_Word
	leas	2,s
	subd	#$aa55
	lbeq	_168
*         {
*             return FAT_INVALID;       //if it is not even MBR then it's not FAT32
	ldd	#$3
*         }
	leas	,u
	puls	u,pc
*         
*         //partition = (struct partitionInfo_Structure *)(mbr->partitionData);//first partition  (useless line)
*         get_QByte(fatMapTb.LE_fileBuffer+454, &unusedSectors);//partition->firstSector; //the unused sectors, hidden to the FAT // cast removed
_168
	leax	unusedSe+0,y
	pshs	x
	leax	fatMapTb+492,y
	pshs	x
	lbsr	get_QByt
	leas	4,s
* 		
*         if(SD_readSingleBlock(fatMapTb.LE_fileBuffer, &unusedSectors) != 0) return INIT_FAILED; //read the bpb sector
	leax	unusedSe+0,y
	pshs	x
	leax	fatMapTb+38,y
	pshs	x
	lbsr	SD_readS
	leas	4,s
	subd	#$0
	lbeq	_169
	ldd	#$2
*         bpb = fatMapTb.LE_fileBuffer;  //cast removed
	leas	,u
	puls	u,pc
_169
	leax	fatMapTb+38,y
	tfr	x,d
	std	-2,u
*         if((bpb->jumpBoot[0]!=0xE9) && (bpb->jumpBoot[0]!=0xEB))
	ldx	-2,u
	ldb	0,x
	clra
	subd	#$e9
	lbeq	_170
	ldx	-2,u
	ldb	0,x
	clra
	subd	#$eb
	lbeq	_170
*         {
*             return FAT_INVALID;
	ldd	#$3
*         }
	leas	,u
	puls	u,pc
*     }
_170
* 
*     bPerSector = get_Word(bpb->bytesPerSector);
_167
	ldd	-2,u
	addd	#$b
	pshs	d
	lbsr	get_Word
	leas	2,s
	std	bPerSect+0,y
* 	i=0;
	clra
	clrb
	stb	-21,u
* 	tmp16 = bPerSector;
	ldd	bPerSect+0,y
	std	-24,u
* 	for (n=0; n<16; n++) {
	clra
	clrb
	stb	-22,u
_172
	ldb	-22,u
	clra
	subd	#$10
	lbhs	_171
* 		if (tmp16 & 1) i++;
	ldd	-24,u
	anda	#$0
	andb	#$1
	subd	#$0
	lbeq	_174
	leax	-21,u
	ldb	,x
	inc	,x
	clra
* 		tmp16 = tmp16 >> 1;
_174
	ldd	#$1
	pshs	d
	ldd	-24,u
	puls	x
	lbsr	_00009
	std	-24,u
* 	}
* 	if (i != 1) return SIZE_INVALID; //allow just 2^n based value to avoid modulo and division operations
_173
	leax	-22,u
	ldb	,x
	inc	,x
	clra
	lbra	_172
_171
	ldb	-21,u
	clra
	subd	#$1
	lbeq	_175
	ldd	#$4
* 	
*     secPerCluster = bpb->secPrCluster;
	leas	,u
	puls	u,pc
_175
	ldx	-2,u
	ldb	13,x
	clra
	std	secPerCl+0,y
* 	i=0;
	clra
	clrb
	stb	-21,u
* 	tmp16 = secPerCluster;
	ldd	secPerCl+0,y
	std	-24,u
* 
* 	for (n=0; n<16; n++) {
	clra
	clrb
	stb	-22,u
_177
	ldb	-22,u
	clra
	subd	#$10
	lbhs	_176
* 		if (tmp16 & 1) i++;
	ldd	-24,u
	anda	#$0
	andb	#$1
	subd	#$0
	lbeq	_179
	leax	-21,u
	ldb	,x
	inc	,x
	clra
* 		tmp16 = tmp16 >> 1;
_179
	ldd	#$1
	pshs	d
	ldd	-24,u
	puls	x
	lbsr	_00009
	std	-24,u
* 	}
* 	if (i != 1) return SIZE_INVALID; //allow just 2^n based value to avoid modulo and division operations
_178
	leax	-22,u
	ldb	,x
	inc	,x
	clra
	lbra	_177
_176
	ldb	-21,u
	clra
	subd	#$1
	lbeq	_180
	ldd	#$4
* 
*     rsvSecCnt = get_Word(bpb->rsvSectorCount);
	leas	,u
	puls	u,pc
_180
	ldd	-2,u
	addd	#$e
	pshs	d
	lbsr	get_Word
	leas	2,s
	std	rsvSecCn+0,y
*     get_QByte(bpb->rootCluster, &rCluster);
	leax	rCluster+0,y
	pshs	x
	ldd	-2,u
	addd	#$2c
	pshs	d
	lbsr	get_QByt
	leas	4,s
*     
* 	//firstDataSector = bpb->hiddenSectors + reservedSectorCount + bpb->numberofFATs * bpb->FATsize_F32
* 	get_QByte(bpb->FATsz_F32, &tmp1);
	leax	-16,u
	pshs	x
	ldd	-2,u
	addd	#$24
	pshs	d
	lbsr	get_QByt
	leas	4,s
* 	_u32_mul(bpb->nbofFATs, &tmp1, &FATsize_t);
	leax	-8,u
	pshs	x
	leax	-16,u
	pshs	x
	ldx	-2,u
	ldb	16,x
	sex
	pshs	d
	lbsr	_u32_mul
	leas	6,s
* 	get_QByte(bpb->hiddenSectors, &fDataSector);    
	leax	fDataSec+0,y
	pshs	x
	ldd	-2,u
	addd	#$1c
	pshs	d
	lbsr	get_QByt
	leas	4,s
* 	tmp1.h = 0; tmp1.l = rsvSecCnt; 
	clra
	clrb
	std	-16,u
	ldd	rsvSecCn+0,y
	std	-14,u
* 	_u32_add(&fDataSector, &tmp1, &tmp2);
	leax	-20,u
	pshs	x
	leax	-16,u
	pshs	x
	leax	fDataSec+0,y
	pshs	x
	lbsr	_u32_add
	leas	6,s
* 	_u32_add(&tmp2, &FATsize_t, &fDataSector);
	leax	fDataSec+0,y
	pshs	x
	leax	-8,u
	pshs	x
	leax	-20,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
*     	
*     //dataSectors = bpb->totalSectors_F32 - reservedSectorCount - bpb->numberofFATs * bpb->FATsize_F32
*     get_QByte(bpb->tSec_F32, &dataSectors);
	leax	-12,u
	pshs	x
	ldd	-2,u
	addd	#$20
	pshs	d
	lbsr	get_QByt
	leas	4,s
* 	tmp1.h = 0; tmp1.l = rsvSecCnt;
	clra
	clrb
	std	-16,u
	ldd	rsvSecCn+0,y
	std	-14,u
* 	_u32_sub(&dataSectors, &tmp1, &tmp2);
	leax	-20,u
	pshs	x
	leax	-16,u
	pshs	x
	leax	-12,u
	pshs	x
	lbsr	_u32_sub
	leas	6,s
* 	_u32_sub(&tmp2, &FATsize_t, &dataSectors);
	leax	-12,u
	pshs	x
	leax	-8,u
	pshs	x
	leax	-20,u
	pshs	x
	lbsr	_u32_sub
	leas	6,s
*    
* 	//totalClusters = dataSectors / sectorPerCluster;
* 	_u32_div2(&dataSectors, secPerCluster, &totalClusters);
	leax	totalClu+0,y
	pshs	x
	ldd	secPerCl+0,y
	pshs	d
	leax	-12,u
	pshs	x
	lbsr	_u32_div
	leas	6,s
*    	
* 	//if((getSetFreeCluster (GlobalBuffer,TOTAL_FREE, GET, 0)) > totalClusters)  //check if FSinfo free clusters count is valid
* 	tmp1.h = tmp1.l = 0;
	clra
	clrb
	std	-14,u
	std	-16,u
* 	getSetFreeCluster(fatMapTb.LE_fileBuffer,TOTAL_FREE, GET, &tmp1, &tmp2);    
	leax	-20,u
	pshs	x
	leax	-16,u
	pshs	x
	clra
	clrb
	pshs	d
	ldd	#$1
	pshs	d
	leax	fatMapTb+38,y
	pshs	x
	lbsr	getSetFr
	leas	10,s
* 	if(_u32_higher(&tmp2, &totalClusters) != 0)
	leax	totalClu+0,y
	pshs	x
	leax	-20,u
	pshs	x
	lbsr	_u32_hig
	leas	4,s
	subd	#$0
	lbeq	_181
*         fClstCnU = 0;
	clra
	clrb
	stb	fClstCnU+0,y
*     else
	lbra	_182
_181
*         fClstCnU = 1;
	ldd	#$1
	stb	fClstCnU+0,y
* 
*     return INIT_SUCCESSFUL;
_182
	clra
	clrb
* }
	leas	,u
	puls	u,pc
* 
* /***********************************************************************************************************************************************
*                                      Local Functions
* ************************************************************************************************************************************************/
* //unsigned int get_Word(unsigned char *ptr)
* //get_Word(ptr) unsigned char *ptr;
* //{
* 	// Conversion from the FAT allocated in Little-endian to compiler (6809 is Big-Endian)
* #asm
get_Word
*	unsigned int retval;
*	retval = *ptr++; //cast removed
* 	retval += (*ptr) << 8; //cast removed
*	return retval;
	ldd	[2,s]
	exg	a,b
	rts
* //}
* 
* //void set_Word(unsigned int data, unsigned char *ptr)
* //set_Word(data, ptr) unsigned int data; unsigned char *ptr;
* //{
* 	// Conversion to the FAT allocated in Little-endian
* #asm
set_Word
* 	*ptr++ = data & 0xff;
* 	*ptr = data >> 8;
	ldd	2,s	
	exg	a,b
	std	[4,s]
	rts
* //}
* 
* //void get_QByte(unsigned char *ptr, u32_t *sData)
* //get_QByte(ptr, sData) unsigned char *ptr; u32_t *sData;
* //{
* 	// Conversion from the FAT allocated in Little-endian to compiler (6809 is Big-Endian)
* //	sData->l = get_Word(ptr);
* //	ptr += 2; 
* //	sData->h = get_Word(ptr);
* #asm
get_QByt	
	pshs y
	ldy	4,s	;src
	ldx	6,s ;dst
	ldd 0,y
	sta	3,x
	stb	2,x
	ldd 2,y
	sta	1,x
	stb	0,x
	puls y,pc
* //}
* 
* //void set_QByte(u32_t *sData, unsigned char *ptr)
* /*set_QByte(sData, ptr) u32_t *sData; unsigned char *ptr;
* {
* 	// Conversion to the FAT allocated in Little-endian
* 	set_Word(sData->l, ptr);
* 	ptr += 2;
* 	set_Word(sData->h, ptr);
* }*/
* #asm
set_QByt 	equ 	get_QByt	; same bytes swapping
* 
* // unsigned int getDateF32()
* //{	
* #asm
getDateF
*	return APLdate;
	ldd  APLdate	
	rts
* //}
* 
* // unsigned int getTimeF32()
* //{	
* #asm
getTimeF
*	return APLdate;
	ldd  APLtime	
	rts
* //}
* 
* // setDateF32(unsigned int d)
* //{	
* #asm
setDateF
*	APLdate = d;
	ldd	 2,s
	std  APLdate	
	rts
* //}
* 
* // setTimeF32(unsigned int t)
* //{	
* #asm
setTimeF
*	APLtime = t;
	ldd	 2,s
	std  APLtime	
	rts
* //}
* 
* /***************************************************************************************/
* #asm
_setGVpt
	ldy  #GV_StackBeginAddr	; set C global variables stack pointer
	rts
* 
* 
* //***************************************************************************
* //Function: to calculate first sector address of any given cluster
* //Arguments: cluster number for which first sector is to be found
* //return: first sector address
* //***************************************************************************
* //void getFirstSector(u32_t *clusterNumber, u32_t *rValue)
* getFirstSector(clusterNumber, rValue) u32_t *clusterNumber; u32_t *rValue;
* {
*     u32_t tmp1, tmp2;
* 		
* 	//*rValue = ((clusterNumber - 2) * secPerCluster) + firstDataSector);	
* 	tmp1.h = 0; tmp1.l = 2;
getFirst
	pshs	u
	leau	,s
	leas	-8,s
	clra
	clrb
	std	-4,u
	ldd	#$2
	std	-2,u
* 	_u32_sub(clusterNumber, &tmp1, &tmp2);
	leax	-8,u
	pshs	x
	leax	-4,u
	pshs	x
	ldd	4,u
	pshs	d
	lbsr	_u32_sub
	leas	6,s
* 	_u32_mul(secPerCluster, &tmp2, &tmp1);
	leax	-4,u
	pshs	x
	leax	-8,u
	pshs	x
	ldd	secPerCl+0,y
	pshs	d
	lbsr	_u32_mul
	leas	6,s
* 	_u32_add(&tmp1, &fDataSector, rValue);	
	ldd	6,u
	pshs	d
	leax	fDataSec+0,y
	pshs	x
	leax	-4,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
* }
	leas	,u
	puls	u,pc
* 
* //***************************************************************************
* //Function: get cluster entry value from FAT to find out the next cluster in the chain
* //or set new cluster entry in FAT
* //Arguments: 1. current cluster number, 2. get_set (=GET, if next cluster is to be found or = SET,
* //if next cluster is to be set 3. next cluster number, if argument#2 = SET, else 0
* //return: next cluster number, if if argument#2 = GET, else 0
* //****************************************************************************
* //uint32_t getSetNextCluster(char *inputBuffer,uint32_t clusterNumber,uint8_t get_set,uint32_t clusterEntry)
* getSetNC(inputBuffer, clusterNumber, get_set, clusterEntry, rValue) char *inputBuffer; u32_t *clusterNumber; unsigned char get_set; u32_t *clusterEntry; u32_t *rValue;
* {
*     unsigned int EntryOffset; // "FATEntryOffset"
*     //uint32_t *FATEntryValue;
*     u32_t EntrySector; // "FATEntrySector"
*     unsigned char retry;
* 	u32_t tmp1, tmp2;
* 	
*     //get sector number of the cluster entry in the FAT
*     //FATEntrySector = unusedSectors + reservedSectorCount + ((clusterNumber * 4) / bytesPerSector) ;
* 	_u32_mul(4, clusterNumber, &tmp1);	
getSetNC
	pshs	u
	leau	,s
	leas	-15,s
	leax	-11,u
	pshs	x
	ldd	6,u
	pshs	d
	ldd	#$4
	pshs	d
	lbsr	_u32_mul
	leas	6,s
* 	_u32_div2(&tmp1, bPerSector, &tmp2);
	leax	-15,u
	pshs	x
	ldd	bPerSect+0,y
	pshs	d
	leax	-11,u
	pshs	x
	lbsr	_u32_div
	leas	6,s
* 	EntrySector.h = 0; EntrySector.l = rsvSecCnt;
	clra
	clrb
	std	-6,u
	ldd	rsvSecCn+0,y
	std	-4,u
* 	_u32_add(&tmp2, &EntrySector, &tmp1);
	leax	-11,u
	pshs	x
	leax	-6,u
	pshs	x
	leax	-15,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
* 	_u32_add(&tmp1, &unusedSectors, &EntrySector);
	leax	-6,u
	pshs	x
	leax	unusedSe+0,y
	pshs	x
	leax	-11,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
* 	
*     //get the offset address in that sector number
* 	//FATEntryOffset = (uint16_t) ((clusterNumber * 4) % bytesPerSector);
*     EntryOffset = (clusterNumber->l * 4) & (bPerSector-1);
	ldd	bPerSect+0,y
	subd	#$1
	pshs	d
	ldx	6,u
	ldd	2,x
	aslb
	rola
	aslb
	rola
	anda	,s+
	andb	,s+
	std	-2,u
* 
*     //read the sector into a buffer
*     retry = 0;
	clra
	clrb
	stb	-7,u
*     while(retry <10)
_184
*     {
	ldb	-7,u
	clra
	subd	#$a
	lbhs	_183
*         if(!SD_readSingleBlock(inputBuffer, &EntrySector) != 0)
	leax	-6,u
	pshs	x
	ldd	4,u
	pshs	d
	lbsr	SD_readS
	leas	4,s
	subd	#$0
	lbeq	_186
	clra
	clrb
	bra	*+5
_186
	ldd	#$1
	subd	#$0
	lbeq	_185
*             break;
	lbra	_183
*         retry++;
_185
	leax	-7,u
	ldb	,x
	inc	,x
	clra
*     }
* 
*     //get the cluster address from the buffer
*     //FATEntryValue = (uint32_t *) &inputBuffer[FATEntryOffset];
*     
* 	if(get_set == GET) {		
	lbra	_184
_183
	ldb	9,u
	clra
	subd	#$0
	lbne	_187
* 		//return ((*FATEntryValue) & 0x0fffffff);
* 		get_QByte(&inputBuffer[EntryOffset], &tmp1);
	leax	-11,u
	pshs	x
	ldd	-2,u
	addd	4,u
	pshs	d
	lbsr	get_QByt
	leas	4,s
* 		tmp2.h = 0x0fff; tmp2.l = 0xffff;
	ldd	#$fff
	std	-15,u
	ldd	#$ffff
	std	-13,u
* 		_u32_and(&tmp1, &tmp2, rValue);
	ldd	12,u
	pshs	d
	leax	-15,u
	pshs	x
	leax	-11,u
	pshs	x
	lbsr	_u32_and
	leas	6,s
* 		return;
* 	}
	leas	,u
	puls	u,pc
* 
*     //*FATEntryValue = clusterEntry;   //for setting new value in cluster entry in FAT
* 	set_QByte(clusterEntry, &inputBuffer[EntryOffset]);
_187
	ldd	-2,u
	addd	4,u
	pshs	d
	ldd	10,u
	pshs	d
	lbsr	set_QByt
	leas	4,s
*     SD_writeSingleBlock(inputBuffer, &EntrySector);  // TBD failure handling
	leax	-6,u
	pshs	x
	ldd	4,u
	pshs	d
	lbsr	SD_write
	leas	4,s
* 
*     rValue->h = rValue->l = 0;	
	clra
	clrb
	ldx	12,u
	std	2,x
	std	[12,u]
* }
	leas	,u
	puls	u,pc
* 
* //********************************************************************************************
* //Function: to get or set next free cluster or total free clusters in FSinfo sector of SD card
* //Arguments: 1.flag:TOTAL_FREE or NEXT_FREE, 
* //			 2.flag: GET or SET 
* //			 3.new FS entry, when argument2 is SET; or 0, when argument2 is GET
* //return: next free cluster, if arg1 is NEXT_FREE & arg2 is GET
* //        total number of free clusters, if arg1 is TOTAL_FREE & arg2 is GET
* //		  0xffffffff, if any error or if arg2 is SET
* //********************************************************************************************
* //uint32_t getSetFreeCluster(char *inputBuffer, uint8_t totOrNext, uint8_t get_set, uint32_t FSEntry)
* getSetFreeCluster(inputBuffer, totOrNext, get_set, FSEntry, rValue) char *inputBuffer; unsigned char totOrNext; unsigned char get_set; u32_t *FSEntry; u32_t *rValue;
* {
* 	LE_FSinfo_Structure *FS;
* 	u32_t _unusedSectors, tmp;
* 	
* 	FS = inputBuffer; //cast ok, but removed
getSetFr
	pshs	u
	leau	,s
	leas	-10,s
	ldd	4,u
	std	-2,u
*     
* 	//SD_readSingleBlock(inputBuffer,unusedSectors + 1);
* 	_unusedSectors.h = unusedSectors.h; _unusedSectors.l = unusedSectors.l; 
	ldd	unusedSe+0,y
	std	-6,u
	ldd	unusedSe+2,y
	std	-4,u
* 	_u32_inc(&_unusedSectors);
	leax	-6,u
	pshs	x
	lbsr	_u32_inc
	leas	2,s
* 	SD_readSingleBlock(inputBuffer, &_unusedSectors);  // TBD failure handling
	leax	-6,u
	pshs	x
	ldd	4,u
	pshs	d
	lbsr	SD_readS
	leas	4,s
* 
* 	//if((FS->leadSignature != 0x41615252) || (FS->structureSignature != 0x61417272) || (FS->trailSignature !=0xaa550000))
*     rValue->h = rValue->l = 0xffff; //return default value    
	ldd	#$ffff
	ldx	12,u
	std	2,x
	std	[12,u]
* 	get_QByte(FS->leadSignature, &tmp);	//print_DebugMsg("\nFS->leadSignature:"); HEXWORD2(tmp.h); HEXWORD2(tmp.l);
	leax	-10,u
	pshs	x
	ldd	-2,u
	pshs	d
	lbsr	get_QByt
	leas	4,s
* 	if((tmp.h != 0x4161) || (tmp.l != 0x5252)) return;
	ldd	-10,u
	subd	#$4161
	lbne	_189
	ldd	-8,u
	subd	#$5252
	lbeq	_188
_189
* 	get_QByte(FS->structureSignature, &tmp); //print_DebugMsg("\nFS->structureSignature:"); HEXWORD2(tmp.h); HEXWORD2(tmp.l);
	leas	,u
	puls	u,pc
_188
	leax	-10,u
	pshs	x
	ldd	-2,u
	addd	#$1e4
	pshs	d
	lbsr	get_QByt
	leas	4,s
* 	if((tmp.h != 0x6141) || (tmp.l != 0x7272)) return;
	ldd	-10,u
	subd	#$6141
	lbne	_191
	ldd	-8,u
	subd	#$7272
	lbeq	_190
_191
* 	get_QByte(FS->trailSignature, &tmp); //print_DebugMsg("\nFS->trailSignature:"); HEXWORD2(tmp.h); HEXWORD2(tmp.l);
	leas	,u
	puls	u,pc
_190
	leax	-10,u
	pshs	x
	ldd	-2,u
	addd	#$1fc
	pshs	d
	lbsr	get_QByt
	leas	4,s
* 	if((tmp.h != 0xaa55) || (tmp.l != 0x0000)) return;
	ldd	-10,u
	subd	#$aa55
	lbne	_193
	ldd	-8,u
	subd	#$0
	lbeq	_192
_193
* 	
*     if(get_set == GET)
	leas	,u
	puls	u,pc
_192
	ldb	9,u
	clra
	subd	#$0
	lbne	_194
*     {
*         if(totOrNext == TOTAL_FREE) {			
	ldb	7,u
	clra
	subd	#$1
	lbne	_195
* 			//return(FS->freeClusterCount);
* 			get_QByte(FS->freeClusterCount, rValue);
	ldd	12,u
	pshs	d
	ldd	-2,u
	addd	#$1e8
	pshs	d
	lbsr	get_QByt
	leas	4,s
* 			return;
* 		}
	leas	,u
	puls	u,pc
*         else { // when totOrNext = NEXT_FREE		
_195
* 			//return(FS->nextFreeCluster);
* 			get_QByte(FS->nextFreeCluster, rValue);
	ldd	12,u
	pshs	d
	ldd	-2,u
	addd	#$1ec
	pshs	d
	lbsr	get_QByt
	leas	4,s
* 			return;
* 		}
	leas	,u
	puls	u,pc
*     }
*     else
_194
*     {
*         if(totOrNext == TOTAL_FREE) {            
	ldb	7,u
	clra
	subd	#$1
	lbne	_196
* 			//FS->freeClusterCount = FSEntry;			
* 			set_QByte(FSEntry, FS->freeClusterCount);
	ldd	-2,u
	addd	#$1e8
	pshs	d
	ldd	10,u
	pshs	d
	lbsr	set_QByt
	leas	4,s
* 		}
*         else { // when totOrNext = NEXT_FREE
	lbra	_197
_196
*             //FS->nextFreeCluster = FSEntry;
* 			set_QByte(FSEntry, FS->nextFreeCluster);
	ldd	-2,u
	addd	#$1ec
	pshs	d
	ldd	10,u
	pshs	d
	lbsr	set_QByt
	leas	4,s
* 		}
*         //SD_writeSingleBlock(inputBuffer,unusedSectors + 1);	//update FSinfo
* 		SD_writeSingleBlock(inputBuffer, &_unusedSectors);	//update FSinfo  // TBD failure handling
_197
	leax	-6,u
	pshs	x
	ldd	4,u
	pshs	d
	lbsr	SD_write
	leas	4,s
*     }
* }
	leas	,u
	puls	u,pc
* 
* 
* 
* 
* //***************************************************************************
* //Function: to search for the next free cluster in the root directory
* //          starting from a specified cluster
* //Arguments: Starting cluster
* //return: the next free cluster
* //****************************************************************
* //uint32_t searchNextFreeCluster (char *inputBuffer, uint32_t startCluster)
* searchNextFreeCluster(inputBuffer, startCluster, rValue) char *inputBuffer; u32_t *startCluster; u32_t *rValue;
* {
*     u32_t cluster, sector;
*     unsigned char i;
* 	u32_t tmp1, tmp2;
* 
*     //startCluster -=  (startCluster & 127);   //to start with the first file in a FAT sector
* 	//for(cluster =startCluster; cluster < totalClusters; cluster+=128)
* 	cluster.h = startCluster->h; cluster.l = startCluster->l & 0xff80;
searchNe
	pshs	u
	leau	,s
	leas	-17,s
	ldd	[6,u]
	std	-4,u
	ldx	6,u
	ldd	2,x
	anda	#$ff
	andb	#$80
	std	-2,u
* 	while(_u32_higher(&totalClusters, &cluster)) {
_199
	leax	-4,u
	pshs	x
	leax	totalClu+0,y
	pshs	x
	lbsr	_u32_hig
	leas	4,s
	subd	#$0
	lbeq	_198
*         //sector = unusedSectors + reservedSectorCount + ((cluster * 4) / bytesPerSector);			
* 		_u32_mul(4, &cluster, &tmp2);		
	leax	-17,u
	pshs	x
	leax	-4,u
	pshs	x
	ldd	#$4
	pshs	d
	lbsr	_u32_mul
	leas	6,s
* 		_u32_div2(&tmp2, bPerSector, &tmp1);
	leax	-13,u
	pshs	x
	ldd	bPerSect+0,y
	pshs	d
	leax	-17,u
	pshs	x
	lbsr	_u32_div
	leas	6,s
* 		sector.h = 0; sector.l = rsvSecCnt;
	clra
	clrb
	std	-8,u
	ldd	rsvSecCn+0,y
	std	-6,u
* 		_u32_add(&tmp1, &sector, &tmp2);
	leax	-17,u
	pshs	x
	leax	-8,u
	pshs	x
	leax	-13,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
* 		_u32_add(&tmp2, &unusedSectors, &sector);
	leax	-8,u
	pshs	x
	leax	unusedSe+0,y
	pshs	x
	leax	-17,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
* 		
*         SD_readSingleBlock(inputBuffer, &sector);  // TBD failure handling
	leax	-8,u
	pshs	x
	ldd	4,u
	pshs	d
	lbsr	SD_readS
	leas	4,s
*         for(i=0; i<128; i++)
	clra
	clrb
	stb	-9,u
_201
	ldb	-9,u
	clra
	subd	#$80
	lbhs	_200
*         {
*             // if(((uint32_t *) &inputBuffer[i*4]) & 0x0fffffff) == 0)
* 			get_QByte((unsigned char*)&inputBuffer[i*4], &tmp1);
	leax	-13,u
	pshs	x
	ldb	-9,u
	sex
	aslb
	rola
	aslb
	rola
	addd	4,u
	pshs	d
	lbsr	get_QByt
	leas	4,s
* 			tmp2.h = 0x0fff; tmp2.l = 0xffff;
	ldd	#$fff
	std	-17,u
	ldd	#$ffff
	std	-15,u
* 			_u32_and(&tmp1, &tmp2, &tmp1);
	leax	-13,u
	pshs	x
	leax	-17,u
	pshs	x
	leax	-13,u
	pshs	x
	lbsr	_u32_and
	leas	6,s
* 			tmp2.h = tmp2.l = 0;
	clra
	clrb
	std	-15,u
	std	-17,u
* 			if(_u32_equal(&tmp1, &tmp2)) {
	leax	-17,u
	pshs	x
	leax	-13,u
	pshs	x
	lbsr	_u32_equ
	leas	4,s
	subd	#$0
	lbeq	_203
*                 tmp1.h = 0; tmp1.l = i;
	clra
	clrb
	std	-13,u
	ldb	-9,u
	clra
	std	-11,u
* 				_u32_add(&cluster, &tmp1, rValue);				
	ldd	8,u
	pshs	d
	leax	-13,u
	pshs	x
	leax	-4,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
* 				return;
*             }
	leas	,u
	puls	u,pc
*         }
_203
* 		tmp1.h = 0; tmp1.l = 128;
_202
	leax	-9,u
	ldb	,x
	inc	,x
	sex
	lbra	_201
_200
	clra
	clrb
	std	-13,u
	ldd	#$80
	std	-11,u
* 		_u32_add(&cluster, &tmp1, &tmp2);
	leax	-17,u
	pshs	x
	leax	-13,u
	pshs	x
	leax	-4,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
* 		cluster.h = tmp2.h; cluster.l = tmp2.l;
	ldd	-17,u
	std	-4,u
	ldd	-15,u
	std	-2,u
*     }
* 	rValue->h = rValue->l = 0; //return value
	lbra	_199
_198
	clra
	clrb
	ldx	8,u
	std	2,x
	std	[8,u]
* }
	leas	,u
	puls	u,pc
* 
* //***************************************************************************
* //Function: to convert normal short file name into FAT format
* //Arguments: pointer to the file name
* //return: 0, if successful else 1.
* //***************************************************************************
* //unsigned char convertFileName (char *inputFileName)
* convertFileName(inputFileName) char *inputFileName;
* {
*     unsigned char fileNameFAT[C_8_3_FileNameSize];
*     unsigned char j, k;
* 
*     for(j=0; j<C_MaxFileNameSize-1; j++)
convertF
	pshs	u
	leau	,s
	leas	-13,s
	clra
	clrb
	stb	-12,u
_205
	ldb	-12,u
	clra
	subd	#$c
	lbhs	_204
*         if(inputFileName[j] == '.') break;
	ldb	-12,u
	sex
	ldx	4,u
	ldb	d,x
	sex
	subd	#$2e
	lbne	_207
	lbra	_204
* 
*     if(j>8) {
_207
_206
	leax	-12,u
	ldb	,x
	inc	,x
	sex
	lbra	_205
_204
	ldb	-12,u
	clra
	subd	#$8
	lbls	_208
*         return INVALID_FILE_NAME;
	ldd	#$4
*     }
	leas	,u
	puls	u,pc
* 
*     for(k=0; k<j; k++) //setting file name
_208
	clra
	clrb
	stb	-13,u
_210
	ldb	-12,u
	clra
	pshs	d
	ldb	-13,u
	clra
	subd	,s++
	lbhs	_209
*         fileNameFAT[k] = inputFileName[k];
	ldb	-13,u
	clra
	ldx	4,u
	ldb	d,x
	clra
	pshs	d
	ldb	-13,u
	clra
	leax	-11,u
	leax	d,x
	puls	d
	stb	0,x
* 
*     for(k=j; k<=7; k++) //filling file name trail with blanks
_211
	leax	-13,u
	ldb	,x
	inc	,x
	clra
	lbra	_210
_209
	ldb	-12,u
	clra
	stb	-13,u
_213
	ldb	-13,u
	clra
	subd	#$7
	lbhi	_212
*         fileNameFAT[k] = ' ';
	ldb	-13,u
	clra
	leax	-11,u
	leax	d,x
	ldd	#$20
	stb	0,x
* 
*     j++;
_214
	leax	-13,u
	ldb	,x
	inc	,x
	clra
	lbra	_213
_212
	leax	-12,u
	ldb	,x
	inc	,x
	clra
*     for(k=8; k<C_8_3_FileNameSize; k++) //setting file extension
	ldd	#$8
	stb	-13,u
_216
	ldb	-13,u
	clra
	subd	#$b
	lbhs	_215
*     {
*         if(inputFileName[j] != 0)
	ldb	-12,u
	sex
	ldx	4,u
	ldb	d,x
	sex
	subd	#$0
	lbeq	_218
*             fileNameFAT[k] = inputFileName[j++];
	leax	-12,u
	ldb	,x
	inc	,x
	clra
	ldx	4,u
	ldb	d,x
	clra
	pshs	d
	ldb	-13,u
	clra
	leax	-11,u
	leax	d,x
	puls	d
	stb	0,x
*         else //filling extension trail with blanks
	lbra	_219
_218
*             while(k<C_8_3_FileNameSize)
_221
*                 fileNameFAT[k++] = ' ';
	ldb	-13,u
	clra
	subd	#$b
	lbhs	_220
	leax	-13,u
	ldb	,x
	inc	,x
	clra
	leax	-11,u
	leax	d,x
	ldd	#$20
	stb	0,x
*     }
	lbra	_221
_220
_219
* 
*     for(j=0; j<C_8_3_FileNameSize; j++) //converting small letters to caps
_217
	leax	-13,u
	ldb	,x
	inc	,x
	clra
	lbra	_216
_215
	clra
	clrb
	stb	-12,u
_223
	ldb	-12,u
	clra
	subd	#$b
	lbhs	_222
*     {
*         if((fileNameFAT[j] >= 'a') && (fileNameFAT[j] <= 'z'))
	ldb	-12,u
	clra
	leax	-11,u
	ldb	d,x
	clra
	subd	#$61
	lblo	_225
	ldb	-12,u
	clra
	leax	-11,u
	ldb	d,x
	clra
	subd	#$7a
	lbhi	_225
*         {
*             inputFileName[j] = fileNameFAT[j] - 0x20;
	ldb	-12,u
	sex
	leax	-11,u
	ldb	d,x
	sex
	subd	#$20
	pshs	d
	ldb	-12,u
	sex
	ldx	4,u
	leax	d,x
	puls	d
	stb	0,x
*         }
*         else
	lbra	_226
_225
*         {
*             inputFileName[j] = fileNameFAT[j];
	ldb	-12,u
	sex
	leax	-11,u
	ldb	d,x
	sex
	pshs	d
	ldb	-12,u
	sex
	ldx	4,u
	leax	d,x
	puls	d
	stb	0,x
*         }
*     }
_226
* 	inputFileName[C_8_3_FileNameSize] = 0;
_224
	leax	-12,u
	ldb	,x
	inc	,x
	sex
	lbra	_223
_222
	clra
	clrb
	ldx	4,u
	stb	11,x
* 
*     return VALID_FILE_NAME;
	ldd	#$3
* }
	leas	,u
	puls	u,pc
* 
* 
* //************************************************************************************
* //Function: to create a file in FAT32 format in the root directory if given 
* //			file name does not exist; if the file already exists then append the data
* //Arguments: pointer to the file name
* //return: status
* //************************************************************************************
* //unsigned char openFile (unsigned char fileOperation, fileConfig_st *filePtr)
* openFile(fileOperation, filePtr) unsigned char fileOperation; fileConfig_st *filePtr;
* {
*     unsigned char returnStatus;
*     u32_t cluster_, sector, firstSector;
*     LE_dir_Structure *dir;
*     u32_t tmp1, tmp2; 
* 	unsigned int i;
*     unsigned char j;
* 	cluster_.h = rCluster.h; cluster_.l = rCluster.l;
openFile
	pshs	u
	leau	,s
	leas	-26,s
	ldd	rCluster+0,y
	std	-5,u
	ldd	rCluster+2,y
	std	-3,u
* 	
*     returnStatus = convertFileName(filePtr->fName); //convert fileName into FAT format
	ldd	6,u
	addd	#$22c
	pshs	d
	lbsr	convertF
	leas	2,s
	stb	-1,u
* 
*     if(returnStatus == VALID_FILE_NAME)
	ldb	-1,u
	clra
	subd	#$3
	lbne	_227
*     {
*        returnStatus = CONTINUE_LOOP;
	ldd	#$55
	stb	-1,u
* 
*         do
_230
*         {
*             getFirstSector(&cluster_, &firstSector);
	leax	-13,u
	pshs	x
	leax	-5,u
	pshs	x
	lbsr	getFirst
	leas	4,s
* 			
* 			sector.h = 0;
	clra
	clrb
	std	-9,u
* 			for(sector.l = 0; ((sector.l < secPerCluster) && (returnStatus == CONTINUE_LOOP)); sector.l++)
	clra
	clrb
	std	-7,u
_232
	ldd	-7,u
	subd	secPerCl+0,y
	lbhs	_231
	ldb	-1,u
	clra
	subd	#$55
	lbne	_231
*             {                
*                 _u32_add(&firstSector, &sector, &tmp1);
	leax	-19,u
	pshs	x
	leax	-9,u
	pshs	x
	leax	-13,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
* 				SD_readSingleBlock(filePtr->LE_fileBuffer, &tmp1);  // TBD failure handling
	leax	-19,u
	pshs	x
	ldd	6,u
	addd	#$26
	pshs	d
	lbsr	SD_readS
	leas	4,s
* 
*                 for(i=0; ((i<bPerSector) && (returnStatus == CONTINUE_LOOP)); i+=32)
	clra
	clrb
	std	-25,u
_235
	ldd	-25,u
	subd	bPerSect+0,y
	lbhs	_234
	ldb	-1,u
	clra
	subd	#$55
	lbne	_234
*                 {
* 					dir = &filePtr->LE_fileBuffer[i];  //cast ok, but removed
	ldd	6,u
	addd	#$26
	addd	-25,u
	std	-15,u
* 
*                     if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
	ldx	-15,u
	ldb	0,x
	clra
	subd	#$0
	lbne	_237
*                     {
*                         returnStatus = FDELETED_OR_NOT_FOUND;
	ldd	#$1
	stb	-1,u
*                         break;
	lbra	_234
*                     }
*                     if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
_237
	ldx	-15,u
	ldb	0,x
	clra
	subd	#$e5
	lbeq	_238
	ldx	-15,u
	ldb	11,x
	clra
	subd	#$f
	lbeq	_238
*                     {
*                         for(j=0; j<C_8_3_FileNameSize; j++)
	clra
	clrb
	stb	-26,u
_240
	ldb	-26,u
	clra
	subd	#$b
	lbhs	_239
*                         {
*                             if(dir->name[j] != filePtr->fName[j])
	ldd	6,u
	addd	#$22c
	pshs	d
	ldb	-26,u
	sex
	puls	x
	ldb	d,x
	sex
	pshs	d
	ldb	-26,u
	sex
	ldx	-15,u
	ldb	d,x
	sex
	subd	,s++
	lbeq	_242
*                                 break;
	lbra	_239
*                         }
_242
*                         if(j == C_8_3_FileNameSize)
_241
	leax	-26,u
	ldb	,x
	inc	,x
	sex
	lbra	_240
_239
	ldb	-26,u
	clra
	subd	#$b
	lbne	_243
*                         {
*                             _u32_add(&firstSector, &sector, &filePtr->appFSector);
	ldd	6,u
	addd	#$c
	pshs	d
	leax	-9,u
	pshs	x
	leax	-13,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
*                             filePtr->appFLocation = i;
	ldd	-25,u
	ldx	6,u
	std	16,x
*                             filePtr->appendStartCluster.h = get_Word(dir->fClsterHI);
	ldd	-15,u
	addd	#$14
	pshs	d
	lbsr	get_Word
	leas	2,s
	ldx	6,u
	std	30,x
* 							filePtr->appendStartCluster.l = get_Word(dir->fClsterLO);							 
	ldd	-15,u
	addd	#$1a
	pshs	d
	lbsr	get_Word
	leas	2,s
	pshs	d
	ldd	6,u
	addd	#$1e
	addd	#$2
	tfr	d,x
	puls	d
	std	0,x
*                             get_QByte(dir->fSize, &filePtr->fileSize);
	ldd	6,u
	addd	#$12
	pshs	d
	ldd	-15,u
	addd	#$1c
	pshs	d
	lbsr	get_QByt
	leas	4,s
*                             returnStatus = FOPEN_SUCCESSFUL;
	clra
	clrb
	stb	-1,u
*                             break;
	lbra	_234
*                         }
*                     }
_243
*                 }
_238
*             }
_236
	ldd	-25,u
	addd	#$20
	std	-25,u
	lbra	_235
_234
* 
*             if(returnStatus == CONTINUE_LOOP)
_233
	ldd	-7,u
	addd	#$1
	std	-7,u
	subd	#$1
	lbra	_232
_231
	ldb	-1,u
	clra
	subd	#$55
	lbne	_244
*             {
*                 getSetNC (filePtr->LE_fileBuffer, &cluster_, GET, 0, &cluster_);
	leax	-5,u
	pshs	x
	clra
	clrb
	pshs	d
	clra
	clrb
	pshs	d
	leax	-5,u
	pshs	x
	ldd	6,u
	addd	#$26
	pshs	d
	lbsr	getSetNC
	leas	10,s
* 
*                 tmp1.h = 0x0fff; tmp1.l = 0xfff6;
	ldd	#$fff
	std	-19,u
	ldd	#$fff6
	std	-17,u
* 				tmp2.h = 0x00; tmp2.l = 0x00;
	clra
	clrb
	std	-23,u
	clra
	clrb
	std	-21,u
*                 if((_u32_higher(&cluster_, &tmp1) != 0) || (_u32_equal(&cluster_, &tmp2) != 0))
	leax	-19,u
	pshs	x
	leax	-5,u
	pshs	x
	lbsr	_u32_hig
	leas	4,s
	subd	#$0
	lbne	_246
	leax	-23,u
	pshs	x
	leax	-5,u
	pshs	x
	lbsr	_u32_equ
	leas	4,s
	subd	#$0
	lbeq	_245
_246
* 				{
*                     returnStatus = NO_FREE_CLUSTERS_FOUND;
	ldd	#$5
	stb	-1,u
*                 }
*             }
_245
*         }while(returnStatus == CONTINUE_LOOP);
_244
_229
	ldb	-1,u
	clra
	subd	#$55
	lbeq	_230
* 
* 
*         if((returnStatus == FOPEN_SUCCESSFUL) && (fileOperation == READ ))
_228
	ldb	-1,u
	clra
	subd	#$0
	lbne	_247
	ldb	5,u
	clra
	subd	#$0
	lbne	_247
*         {
*             filePtr->cluster.h = get_Word(dir->fClsterHI); filePtr->cluster.l = get_Word(dir->fClsterLO);
	ldd	-15,u
	addd	#$14
	pshs	d
	lbsr	get_Word
	leas	2,s
	ldx	6,u
	std	4,x
	ldd	-15,u
	addd	#$1a
	pshs	d
	lbsr	get_Word
	leas	2,s
	pshs	d
	ldd	6,u
	addd	#$4
	addd	#$2
	tfr	d,x
	puls	d
	std	0,x
*             get_QByte(dir->fSize, &filePtr->fileSize);
	ldd	6,u
	addd	#$12
	pshs	d
	ldd	-15,u
	addd	#$1c
	pshs	d
	lbsr	get_QByt
	leas	4,s
*         }
*     }
_247
*  
*     return returnStatus;
_227
	ldb	-1,u
	clra
* }
	leas	,u
	puls	u,pc
* 
* //********************************************************************
* //Function: update the free memory count in the FSinfo sector. 
* //			Whenever a file is deleted or created, this function will be called
* //			to ADD or REMOVE clusters occupied by the file
* //Arguments: #1.flag ADD or REMOVE #2.file size in Bytes
* //return: none
* //********************************************************************
* //void freeMemoryUpdate (char *inputBuffer, unsigned char flag, u32_t *size)
* freeMemoryUpdate(inputBuffer, flag, size) char *inputBuffer; unsigned char flag; u32_t *size;
* {
*     u32_t freeClusters;
* 	u32_t tmp;
*     
* 	//convert file size into number of clusters occupied
*     tmp.h = size->h; tmp.l = size->l;
freeMemo
	pshs	u
	leau	,s
	leas	-8,s
	ldd	[8,u]
	std	-8,u
	ldx	8,u
	ldd	2,x
	std	-6,u
* 	_u32_div2(&tmp, C_MaxPageSize_U16, size);
	ldd	8,u
	pshs	d
	ldd	#$200
	pshs	d
	leax	-8,u
	pshs	x
	lbsr	_u32_div
	leas	6,s
* 	if((tmp.l & 511) != 0) _u32_inc(size);
	ldd	-6,u
	anda	#$1
	andb	#$ff
	subd	#$0
	lbeq	_248
	ldd	8,u
	pshs	d
	lbsr	_u32_inc
	leas	2,s
*     
* 	tmp.h = size->h; tmp.l = size->l;
_248
	ldd	[8,u]
	std	-8,u
	ldx	8,u
	ldd	2,x
	std	-6,u
* 	_u32_div2(&tmp, 8, size);
	ldd	8,u
	pshs	d
	ldd	#$8
	pshs	d
	leax	-8,u
	pshs	x
	lbsr	_u32_div
	leas	6,s
* 	if((tmp.l & 7) != 0) _u32_inc(size);
	ldd	-6,u
	anda	#$0
	andb	#$7
	subd	#$0
	lbeq	_249
	ldd	8,u
	pshs	d
	lbsr	_u32_inc
	leas	2,s
* 
*     if(fClstCnU != 0)
_249
	ldb	fClstCnU+0,y
	clra
	subd	#$0
	lbeq	_250
*     {
*         tmp.h = tmp.l = 0;
	clra
	clrb
	std	-6,u
	std	-8,u
* 		getSetFreeCluster (inputBuffer,TOTAL_FREE, GET, &tmp, &freeClusters);
	leax	-4,u
	pshs	x
	leax	-8,u
	pshs	x
	clra
	clrb
	pshs	d
	ldd	#$1
	pshs	d
	ldd	4,u
	pshs	d
	lbsr	getSetFr
	leas	10,s
*         tmp.h = freeClusters.h; tmp.l = freeClusters.l;
	ldd	-4,u
	std	-8,u
	ldd	-2,u
	std	-6,u
* 		if(flag == ADD) {            
	ldb	7,u
	clra
	subd	#$0
	lbne	_251
* 			_u32_add(&tmp, size, &freeClusters);			
	leax	-4,u
	pshs	x
	ldd	8,u
	pshs	d
	leax	-8,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
* 		}
*         else {  //when flag = REMOVE
	lbra	_252
_251
*             _u32_sub(&tmp, size, &freeClusters);            
	leax	-4,u
	pshs	x
	ldd	8,u
	pshs	d
	leax	-8,u
	pshs	x
	lbsr	_u32_sub
	leas	6,s
* 		}
*         getSetFreeCluster(inputBuffer,TOTAL_FREE, SET, &freeClusters, &tmp);
_252
	leax	-8,u
	pshs	x
	leax	-4,u
	pshs	x
	ldd	#$1
	pshs	d
	ldd	#$1
	pshs	d
	ldd	4,u
	pshs	d
	lbsr	getSetFr
	leas	10,s
*     }
* }
_250
	leas	,u
	puls	u,pc
* 
* //************************************************************************************
* //Function: file deletion FAT32 format 
* //Arguments: pointer to the file name
* //return: 0 when successfully
* //************************************************************************************
* //unsigned char deleteFile (char *fileName)
* deleteFile(fileName) char *fileName;
* {
*     u32_t sector, cluster_, firstCluster, nextCluster, firstSector;
* 	u32_t tmp1, tmp2;
*     LE_dir_Structure *dir;
*     unsigned int i, j;
* 
*     cluster_.h = rCluster.h; cluster_.l = rCluster.l; //root cluster
deleteFi
	pshs	u
	leau	,s
	leas	-34,s
	ldd	rCluster+0,y
	std	-8,u
	ldd	rCluster+2,y
	std	-6,u
* 
*     while(1)
_254
*     {
*         getFirstSector(&cluster_, &firstSector);
	leax	-20,u
	pshs	x
	leax	-8,u
	pshs	x
	lbsr	getFirst
	leas	4,s
* 		sector.h = 0;
	clra
	clrb
	std	-4,u
*         for(sector.l = 0; sector.l < secPerCluster; sector.l++)            
	clra
	clrb
	std	-2,u
_256
	ldd	-2,u
	subd	secPerCl+0,y
	lbhs	_255
* 		{
*             _u32_add(&firstSector, &sector, &tmp1);
	leax	-24,u
	pshs	x
	leax	-4,u
	pshs	x
	leax	-20,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
* 			if(SD_readSingleBlock(fatMapTb.LE_fileBuffer, &tmp1) != 0) return -1;
	leax	-24,u
	pshs	x
	leax	fatMapTb+38,y
	pshs	x
	lbsr	SD_readS
	leas	4,s
	subd	#$0
	lbeq	_258
	ldd	#$ffff
*             for(i=0; i<bPerSector; i+=32)
	leas	,u
	puls	u,pc
_258
	clra
	clrb
	std	-32,u
_260
	ldd	-32,u
	subd	bPerSect+0,y
	lbhs	_259
*             {
*                 dir = &fatMapTb.LE_fileBuffer[i];  //cast ok, but removed
	leax	fatMapTb+38,y
	tfr	x,d
	addd	-32,u
	std	-30,u
* 
*                 if(dir->name[0] == EMPTY) //indicates end of the file list of the directory
	ldx	-30,u
	ldb	0,x
	clra
	subd	#$0
	lbne	_262
*                 {
*                     return FDELETED_OR_NOT_FOUND;
	ldd	#$1
*                 }
	leas	,u
	puls	u,pc
*                 if((dir->name[0] != DELETED) && (dir->attrib != ATTR_LONG_NAME))
_262
	ldx	-30,u
	ldb	0,x
	clra
	subd	#$e5
	lbeq	_263
	ldx	-30,u
	ldb	11,x
	clra
	subd	#$f
	lbeq	_263
*                 {
*                     for(j=0; j<11; j++)
	clra
	clrb
	std	-34,u
_265
	ldd	-34,u
	subd	#$b
	lbhs	_264
*                         if(dir->name[j] != fileName[j]) break;
	ldd	-34,u
	ldx	4,u
	ldb	d,x
	sex
	pshs	d
	ldd	-34,u
	ldx	-30,u
	ldb	d,x
	sex
	subd	,s++
	lbeq	_267
	lbra	_264
*                     if(j == 11)
_267
_266
	ldd	-34,u
	addd	#$1
	std	-34,u
	subd	#$1
	lbra	_265
_264
	ldd	-34,u
	subd	#$b
	lbne	_268
*                     {
*                         firstCluster.h = get_Word(dir->fClsterHI); firstCluster.l = get_Word(dir->fClsterLO);
	ldd	-30,u
	addd	#$14
	pshs	d
	lbsr	get_Word
	leas	2,s
	std	-12,u
	ldd	-30,u
	addd	#$1a
	pshs	d
	lbsr	get_Word
	leas	2,s
	std	-10,u
* 
*                         //mark file as 'deleted' in FAT table
*                         dir->name[0] = DELETED;
	ldd	#$e5
	ldx	-30,u
	stb	0,x
*                         _u32_add(&firstSector, &sector, &tmp1);
	leax	-24,u
	pshs	x
	leax	-4,u
	pshs	x
	leax	-20,u
	pshs	x
	lbsr	_u32_add
	leas	6,s
* 						if(SD_writeSingleBlock(fatMapTb.LE_fileBuffer, &tmp1) != 0) return -1;
	leax	-24,u
	pshs	x
	leax	fatMapTb+38,y
	pshs	x
	lbsr	SD_write
	leas	4,s
	subd	#$0
	lbeq	_269
	ldd	#$ffff
* 
*                         get_QByte(dir->fSize, &tmp1);
	leas	,u
	puls	u,pc
_269
	leax	-24,u
	pshs	x
	ldd	-30,u
	addd	#$1c
	pshs	d
	lbsr	get_QByt
	leas	4,s
* 						freeMemoryUpdate (fatMapTb.LE_fileBuffer,ADD, &tmp1);
	leax	-24,u
	pshs	x
	clra
	clrb
	pshs	d
	leax	fatMapTb+38,y
	pshs	x
	lbsr	freeMemo
	leas	6,s
* 
*                         //update next free cluster entry in FSinfo sector
*                         tmp1.h = tmp1.l = 0;
	clra
	clrb
	std	-22,u
	std	-24,u
* 						getSetFreeCluster (fatMapTb.LE_fileBuffer,NEXT_FREE, GET, &tmp1, &cluster_);
	leax	-8,u
	pshs	x
	leax	-24,u
	pshs	x
	clra
	clrb
	pshs	d
	ldd	#$2
	pshs	d
	leax	fatMapTb+38,y
	pshs	x
	lbsr	getSetFr
	leas	10,s
*                         //if(firstCluster < cluster)
*                         if(_u32_higher(&cluster_, &firstCluster) != 0)
	leax	-12,u
	pshs	x
	leax	-8,u
	pshs	x
	lbsr	_u32_hig
	leas	4,s
	subd	#$0
	lbeq	_270
* 						    getSetFreeCluster (fatMapTb.LE_fileBuffer,NEXT_FREE, SET, &firstCluster, &tmp1);
	leax	-24,u
	pshs	x
	leax	-12,u
	pshs	x
	ldd	#$1
	pshs	d
	ldd	#$2
	pshs	d
	leax	fatMapTb+38,y
	pshs	x
	lbsr	getSetFr
	leas	10,s
* 
*                         //mark all the clusters allocated to the file as 'free'
*                         while(1)
_270
_272
*                         {
*                             tmp1.h = tmp1.l = 0;
	clra
	clrb
	std	-22,u
	std	-24,u
* 							getSetNC(fatMapTb.LE_fileBuffer, &firstCluster, GET, &tmp1, &nextCluster);
	leax	-16,u
	pshs	x
	leax	-24,u
	pshs	x
	clra
	clrb
	pshs	d
	leax	-12,u
	pshs	x
	leax	fatMapTb+38,y
	pshs	x
	lbsr	getSetNC
	leas	10,s
*                             getSetNC(fatMapTb.LE_fileBuffer, &firstCluster, SET, &tmp1, &tmp1);  //tmp as dummy
	leax	-24,u
	pshs	x
	leax	-24,u
	pshs	x
	ldd	#$1
	pshs	d
	leax	-12,u
	pshs	x
	leax	fatMapTb+38,y
	pshs	x
	lbsr	getSetNC
	leas	10,s
*                             tmp1.h = 0x0fff; tmp1.l = 0xfff6;
	ldd	#$fff
	std	-24,u
	ldd	#$fff6
	std	-22,u
* 							//if(nextCluster > 0x0ffffff6)
* 							if(_u32_higher(&nextCluster, &tmp1) != 0) return 0;
	leax	-24,u
	pshs	x
	leax	-16,u
	pshs	x
	lbsr	_u32_hig
	leas	4,s
	subd	#$0
	lbeq	_273
	clra
	clrb
*                             firstCluster.h = nextCluster.h; firstCluster.l = nextCluster.l;
	leas	,u
	puls	u,pc
_273
	ldd	-16,u
	std	-12,u
	ldd	-14,u
	std	-10,u
*                         }
*                     }
	lbra	_272
_271
*                 }
_268
*             }
_263
*         }
_261
	ldd	-32,u
	addd	#$20
	std	-32,u
	lbra	_260
_259
* 
*         tmp1.h = tmp1.l = 0;
_257
	ldd	-2,u
	addd	#$1
	std	-2,u
	subd	#$1
	lbra	_256
_255
	clra
	clrb
	std	-22,u
	std	-24,u
* 		getSetNC(fatMapTb.LE_fileBuffer, &cluster_, GET, &tmp1, &cluster_);
	leax	-8,u
	pshs	x
	leax	-24,u
	pshs	x
	clra
	clrb
	pshs	d
	leax	-8,u
	pshs	x
	leax	fatMapTb+38,y
	pshs	x
	lbsr	getSetNC
	leas	10,s
* 
*         tmp1.h = 0x0fff; tmp1.l = 0xfff6;
	ldd	#$fff
	std	-24,u
	ldd	#$fff6
	std	-22,u
*         tmp2.h = 0x00; tmp2.l = 0x00;
	clra
	clrb
	std	-28,u
	clra
	clrb
	std	-26,u
*         if((_u32_higher(&cluster_, &tmp1)) || (_u32_equal(&cluster_, &tmp2)))
	leax	-24,u
	pshs	x
	leax	-8,u
	pshs	x
	lbsr	_u32_hig
	leas	4,s
	subd	#$0
	lbne	_275
	leax	-28,u
	pshs	x
	leax	-8,u
	pshs	x
	lbsr	_u32_equ
	leas	4,s
	subd	#$0
	lbeq	_274
_275
*         {
*             return FDELETED_OR_NOT_FOUND;
	ldd	#$1
*         }
	leas	,u
	puls	u,pc
*     }
_274
* }
	lbra	_254
_253
	leas	,u
	puls	u,pc
* 
* /*************************************************************End of Local Functions*************************************************************/
_GLOBALS	equ	608

*
* micro-c driver under flex
*
*	12-dec-81	m.ohta,h.tezuka
*

_00001	pshs	d,x,y		;multiply	
		lda	,s
		ldb	3,s
		mul
		stb	4,s		
		ldd	1,s
		mul
		stb	5,s		
		lda	1,s
		ldb	3,s
		mul
		adda	4,s
		adda	5,s		
		leas	6,s
		rts

; _00002	clr	,-s				; signed divide	
		; cmpx	#0
		; bpl	_02000		
		; com	,s		
		; exg	d,x
		; lbsr	_00020
		; exg	d,x
; _02000	tsta
		; bpl	_02001		
		; com	,s		
		; lbsr	_00020	
; _02001	lbsr	_00010
		; tfr	x,d
		; tst	,s+
		; bpl	_02002		
		; lbsr	_00020	
; _02002	rts

; _00003	lbsr	_00010		; unsigned divide
		; tfr	x,d
		; rts

; _00004	clr	,-s				; signed modulous	
		; cmpx	#0
		; bpl	_04000		
		; exg	d,x
		; bsr	_00020
		; exg	d,x
; _04000	tsta
		; bpl	_04001		
		; com	,s
		; bsr	_00020	
; _04001	bsr	_00010	
		; tst	,s+
		; bpl	_04002		
		; bsr	_00020	
; _04002	rts

; _00005	bsr	_00010		; unsigned modulous
		; rts

; _00006	cmpx	#0		; signed left shift
		; bmi	_06001 
; _06000	beq	_06009
		; lslb
		; rola
		; leax	-1,x
		; bra	_06000	
; _06001	beq	_06009
		; asra
		; rorb
		; leax	1,x
		; bra	_06001	
; _06009	rts

; _00007	cmpx	#0		; unsigned left shift
		; bmi	_07001	
; _07000	beq	_07009
		; lslb
		; rola
		; leax	-1,x
		; bra	_07000	
; _07001	beq	_07009
		; lsra
		; rorb
		; leax	1,x
		; bra	_07001	
; _07009	rts

; _00008	cmpx	#0		; signed right shift
		; bmi	_08001	
; _08000	beq	_08009
		; asra
		; rorb
		; leax	-1,x
		; bra	_08000
	
; _08001	beq	_08009
		; lslb
		; rola
		; leax	1,x
		; bra	_08001	
; _08009	rts

_00009	cmpx	#0		; unsigned right shift
		bmi	_09001	
_09000	beq	_09009
		lsra
		rorb
		leax	-1,x
		bra	_09000	
_09001	beq	_09009
		lslb
		rola
		leax	1,x
		bra	_09001	
_09009	rts

_00020	nega			;negate d reg
		negb
		sbca	#0
		rts

; _00010	pshs	d,x		;divide subroutine	
		; clra
		; clrb	
		; ldx	#17
	
; _00011	subd	2,s
		; bcc	_00012	
		; addd	2,s
	
; _00012	rol	1,s
		; rol	,s
		; rolb
		; rola	
		; leax	-1,x
		; bne	_00011	
		; rora
		; rorb	
		; com	1,s
		; com	,s
		; puls	x	
		; leas	2,s
		; rts


; coding convention:
; normal function paramters are passed by the stack: arg 1 is "2,s", arg 2 is "4,s", ...
; the returned value is in D
; the registers D and X can modified in the called function. Y is used as GV pointer. U is preserved.
;
; special function lead by an 's' (e.g. sFUNCTION) is a low level fast assembler execution. The parameters are passed by the registers.
;
;{ ----------------------------------- Program Start -----------------------------------------
					code
					
MONITOR_PROCESS_ID	equ		$10
BASIC_PROCESS_ID	equ		$20


; configuration DEBUG_MON_PORT linked to USB_COM_PORT
ENABLE_MON_INT		equ		%11101111			; enable irq for monitor
DEBUG_MON_PORT		equ		USB_COM_WR			; link the debugMonPort to USB Port
sMON_PORT_RD		equ		USB_COM_RD			; use the defined monitor port
sMON_PORT_WR		stb		USB_COM_WR			; use the defined monitor port
					rts
						
VERSION         	db      CR,"version 2.2.0.2",CR		; version [major, minor, branch, build]. branch = 0 is a release
BOOT_SCR         	db      "2014-2025, Retro 6809 SBC",CR
					db		"https://github.com/akund/retro-6809-SBC",CR,CR,0

CheckSum16_ROM0		equ		$35d7
CheckSum16_ROM1		dw		CSum16_ROM1			; BASIC ROM1 CheckSum16 (here for ROM pairing purpose)

RESET           	orcc	#%01010000			; disable all interrrupts in case of software reset
															
					; init (clear 16-bit) the re-mapping int vector table
					ldx		#IntVectSWI3
					clra
					clrb
					std		,x++	;sw3
					std		,x++	;sw2
					std		,x++	;firq
					std		,x++	;irq
					std		,x++	;sw1
					std		,x++	;nmi
					std		,x++	;start
					
					lds		#LV_StackBeginAddr	; NMI is now enabled
					
					ldx		#VERSION			; version at boot up
					lbsr	sPUTSTR
					
					ldx		#ROM0_ORG										
					pshs	x					; push as 1st arg
					leax	$2000,x				; calculate end addr+2 (8k size)
					pshs	x					; push as 2nd arg
					clra
					clrb
					subd	ROM_Integrity		; ROM0 initial CheckSum16 is excluded by negating the value
					pshs	d					; push as 3rd arg (initial value)
					lbsr	getCheckSum16		; ret value in d
					leas	6,s					; free the 3 pushes					
					ldx		#ROM_Integrity
					lbsr	sROMcheck			; check the ROM integrity															
					
					;--------- init peripherals and others --------------------------------;
					; port A and B initialized with SD Card (requires a minimal delay after the reset)
					lbsr	SELECTBANK0
					
					;---------- initialize monitor resources --------------------------------;
					lbsr	sMONITORSTART
					
					;---------- initialize DISK EXT BASIC resources -------------------------;															
					ldd		ROM1_ORG			; check if BASIC ROM available
					cmpd	CheckSum16_ROM1
					bne		main
					ldx		#ROM1_ORG										
					pshs	x					; push as 1st arg
					leax	$4000,x				; calculate end addr+2 (16k size)
					pshs	x					; push as 2nd arg
					clra
					clrb
					subd	ROM1_ORG			; ROM1 initial CheckSum16 is excluded by negating the value
					pshs	d					; push as 3rd arg (initial value)
					lbsr	getCheckSum16		; ret value in d
					leas	6,s					; free the 3 pushes
					ldx		#ROM1_ORG
					lbsr	sROMcheck			; check the ROM integrity
					tstb
					bne		main				; start BASIC only when ROM1 validated
					lbsr	APL_init
					lbsr    setPins				; PIA initialization

;-------------------------------- main program ---------------------------------------------------;	
main				leas	-1,s				; last APL status @ 2,u
					leas	-2,s				; heart beat countdown @ 0,u
					leau	0,s					

loop				lbsr	sMonProcessCmd		; monitor process call
					
					lbsr	BASICprocess		; BASIC process call
					
					cmpa	#APL_RESET			; reset supervision
					bne		_loop1
					cmpa	2,u
					beq		_loop1
					sta		2,u
					ldx		#APL_RESET_STR
					lbsr	sPUTSTR
					
					;--------- heart beat ~1 sec period -----------------------------------;
_loop1				ldd		0,u					; get heart beat countdown
					subd    #1
					bne     _loop2
					ldb		#'.'
					stb		DEBUG_MON_PORT 		; write the dot as life check
				
					ldd		#$1fff
_loop2				std		0,u					; save heart beat countdown					
					bra		loop
APL_RESET_STR      	db      CR,"APL reset",CR,0

;-------------------------------------------------------------------------------------------------;
; APL interface routines
;-------------------------------------------------------------------------------------------------;
					code
					
; APL status definitions
APL_RESET 			equ		'0'
APL_READY			equ		'1'
APL_BUSY			equ		'2'
APL_UNDEFINED		equ		'9'

					
; interface to APL API for calls from BASIC
APLgetChar			lbra	getKeyboard					

APLsendChar			sta		DEBUG_MON_PORT 		; forward to debug port				
					tfr  	a,b			  		; char in B
					pshs 	d			  		; charater as parameter (16-bit)
					lbsr  	sendCharToScreen          
					puls 	d,pc
					
APLcurBlinking		lbra	cursorBlinking
APLcurOff			lbra	cursorOff

APLclearscreen		pshs 	d
					lbsr	sendClearScreen
					puls 	d,pc

APLsound			pshs b						; save duration value (lower 8-bit)
					clrb
					pshs b						; save duration value (higer 8-bit)					
					pshs a						; save tone value (lower 8-bit)					
					pshs b						; save tone value (higer 8-bit)					
					lbsr	setTone
					leas 4,s					; free parameters
					rts

APLsetXY			pshs a						; save ver value (lower 8-bit)
					clra
					pshs a						; save ver value (higer 8-bit)					
					pshs d						; save hor value (16-bit)
					lbsr 	setpointXY			; character location (hor in 0,s; ver in 2,s)
					leas 4,s					; free parameters
					rts

;-------------------------------------------------------------------------------------------------;
; APL initialization
; param: 	none
; return:	none
;-------------------------------------------------------------------------------------------------;
APL_init			pshs	x					; save register(s)

					clr		BasicCallBack		; unused the next callback address
					clr		BasicCallBack+1

					; init APL output stream interpretation
					lda		#APL_UNDEFINED
					sta		APLstatus
					clr		KeyboardRbHead
					clr		KeyboardRbTail
				
					lbsr	UART_Init			; initialize the communication with APL

					ldx		#$ffff				; timeout count
_APL_init0			leax	-1,x
					beq		_APL_init4
					lbsr	APL_OutputStream	; process the APL output stream
					cmpb	#APL_READY				
					bne		_APL_init0			; wait until ready
					
					ldx		#STR_BASIC
					lbsr	sPUTSTR	
					ldb		#BASIC_PROCESS_ID
					pshs	d
					lbsr	HEXBYTE2MONPORT
					ldb		#CR
					pshs	d
					lbsr	BYTE2MONPORT
					lbsr	BYTE2MONPORT
					leas	4,s					; clear the 2 pshs
										
					clrb
					lbsr	sendClearScreen
					
					ldx		#BOOT_SCR					
_APL_init1			ldb		,x+
					beq		_APL_init3 			; string ends with NULL
					clra
					pshs	d
					lbsr	sendCharToScreen
					leas	2,s
_APL_init2			lbsr	APL_OutputStream	; process the APL output stream
					cmpb	#APL_READY				
					bne		_APL_init2			; wait until ready					
					bra		_APL_init1					
_APL_init3			ldd		#BASIC_ORG			; init first time BASIC	
					std		BasicCallBack
_APL_init4			puls	x					; restore the register(s)
					rts
STR_BASIC      		db      CR,"starting BASIC process ID ",0

;-------------------------------------------------------------------------------------------------;
; basic process
; param: 	none
; return:	APLstatus -> B
;-------------------------------------------------------------------------------------------------;
BASICprocess		bsr		APL_OutputStream	; process the APL output stream
					cmpb	#APL_READY				
					bne		_BASICprocess2		; skip BASIC when APL not ready
					
					pshs	d,u,cc				; save the registers					
					ldx  	BasicCallBack
					beq		_BASICprocess1		; skip the process execution when BasicCallBack is NULL
					sts		MonSavReg_S
					ldd  	#_BASICprocess0
					std  	BasicCallBack
					jmp		0,x
_BASICprocess0		lds		MonSavReg_S
_BASICprocess1		puls	d,u,cc				; restore the registers
_BASICprocess2		rts
					
;-------------------------------------------------------------------------------------------------;
; APL output stream process
; param: 	none
; return:	APLstatus -> B
;-------------------------------------------------------------------------------------------------;
APL_OutputStream	pshs	x					; save register(s)
					ldx		#1					; sAPLgetOutput param: 1 iteration only
					lbsr	sAPLgetOutput		; get first protocol byte					
					tsta
					lbeq	_APL_OutputStream5										
					cmpb	#'U'				; Upload msg
					lbne	_APL_OutputStream5
				
					ldx		#$ffff				; sAPLgetOutput param: max iterations
					lbsr	sAPLgetOutput		; get second protocol byte
					tsta
					beq		_APL_OutputStream5
					cmpb	#'a'				; st'A'tus msg type
					bne		_APL_OutputStream2
					bsr		sAPLgetOutput		; get status value
					tsta
					beq		_APL_OutputStream5
					pshs	b					; save status value
					bsr		sAPLgetOutput		; CR
					tsta	
					beq		_APL_OS_1
					cmpb	#CR
					bne		_APL_OS_1
					puls	b					; restore status value
					stb		APLstatus
					bra		_APL_OutputStream5
					
_APL_OutputStream2	cmpb	#'k'				; 'K'eyboard msg type
					bne		_APL_OutputStream3
					
					bsr		sAPLgetOutput		; get msg length
					tsta
					beq		_APL_OutputStream5
					bsr		sAPLgetOutput		; get char value
					tsta
					beq		_APL_OutputStream5
					pshs	b					; save value
					bsr		sAPLgetOutput		; get CR
					tsta
					beq		_APL_OS_1
					cmpb	#CR
					bne		_APL_OS_1
					puls	b
					bsr		sAPL_KeyboardData
					bra		_APL_OutputStream5
					
_APL_OutputStream3	cmpb	#'m'				; DateTime sta'M'p msg type
					bne		_APL_OutputStream5
				
					leas	-4,s				; free storage for values
					bsr		sAPLgetOutput		; get char value (dateMSB)
					tsta
					beq		_APL_OS_4
					stb		0,s					; save value
					bsr		sAPLgetOutput		; get char value (dateLSB)
					tsta
					beq		_APL_OS_4
					stb		1,s					; save value
					bsr		sAPLgetOutput		; get char value (timeMSB)
					tsta
					beq		_APL_OS_4
					stb		2,s					; save value
					bsr		sAPLgetOutput		; get char value (timeLSB)
					tsta
					beq		_APL_OS_4
					stb		3,s					; save value
					
					bsr		sAPLgetOutput		; get CR
					tsta
					beq		_APL_OS_4
					cmpb	#CR
					bne		_APL_OS_4					
					puls	d
					std		APLdate
					puls	d
					std		APLtime
					bra		_APL_OutputStream5
					
_APL_OS_4	 		leas	3,s					; free unrestored value
_APL_OS_1	 		leas	1,s					; free unrestored value
_APL_OutputStream5	clra
					ldb		APLstatus			; return the APL status					
					puls	x,pc				; restore the register(s) and return
					
;-------------------------------------------------------------------------------------------------;
; Get APL output stream with timeout
; param: 	X -> timeout iterations
; return:	char in -> B and A when != 0
;-------------------------------------------------------------------------------------------------;
sAPLgetOutput ;{					
_sAPLgetOutput1		lbsr	UartRead
					tsta
					bne		_sAPLgetOutput2
					leax	-1,x				; dec iteration counter
					bne		_sAPLgetOutput1
_sAPLgetOutput2		rts
;}
;-------------------------------------------------------------------------------------------------;
; Store APL keyboard data in the keyboard RB
; param: 	key value in -> B
; return:	none
;-------------------------------------------------------------------------------------------------;
sAPL_KeyboardData	pshs	x					; save register(s)
					ldx     #KeyboardRbuffer	; get buffer base addr				
					lda		KeyboardRbHead		; head index value
					leax	a,x					; set X to the head pointer
					inca				
					cmpa	#KeyboardRbSize
					blo		_APL_KeyboardData1
					clra
_APL_KeyboardData1  cmpa	KeyboardRbTail
					beq		_APL_KeyboardData2
					sta     KeyboardRbHead
					stb		,x					; store data to keyboard RB head pointer
_APL_KeyboardData2	puls	x					; restore the register(s)
					rts					

;-------------------------------------------------------------------------------------------------;
; Get keyboard char from ringbuffer (C call compatible)
; param: 	none
; return:	key value as char (or zero when no key was pressed) in -> D (unsigned int)
;-------------------------------------------------------------------------------------------------;
getKeyboard ;{
getKeybo			lbsr	isKeyboardData
					tstb
					beq		_getKeyboard2		; fifo empty when tail = head
					pshs	x
					ldx		#KeyboardRbuffer
					lda		KeyboardRbTail					
					ldb		a,x
					puls	x
					inca						; inc tail index
					cmpa	#KeyboardRbSize
					blo		_getKeyboard1
					clra						; wrap RbTail
_getKeyboard1		sta		KeyboardRbTail		; save updated tail index only once data extracted (critical section)
					clra
_getKeyboard2		rts

;-------------------------------------------------------------------------------------------------;
; isKeyboardData in the ringbuffer? (C call compatible)
; param: 	none
; return:	when no data, 0 -> D (unsigned int)
;-------------------------------------------------------------------------------------------------;
isKeyboardData ;{
isKeyboa			ldb		KeyboardRbHead
					subb	KeyboardRbTail
					clra
					rts
;}

;-------------------------------------------------------------------------------------------------;
; Send a char to the screen [Text mode] (C call compatible)
; param: 	2,s -> unused
;			3,s -> char to send
; return:	none
;-------------------------------------------------------------------------------------------------;					
sendCharToScreen ;{
					lbsr	waitSendDone
					lbsr	waitCTS
					ldb		#'D'				; sending
					stb		UART
					ldb		#'f'				; cmd
					stb		UART
					ldb		#'1'				; len
					stb		UART
					ldb		3,s
					stb 	UART  				; char
					ldb		#CR					; end
					stb		UART				
					rts
;}

;-------------------------------------------------------------------------------------------------;
; Set the screen cursor propriety [Text mode], (C call compatible)
; param: 	none
; return:	none
;-------------------------------------------------------------------------------------------------;					
cursorBlinking		lda		#'b'				; param 'b' for blinking
					bra		_sCursor1
cursorOff   		lda		#'0'				; param '0' for Off
_sCursor1			pshs	a
					lbsr	waitSendDone
					lbsr	waitCTS
					puls	a
					ldb		#'D'				; sending
					stb		UART
					ldb		#'c'				; cmd
					stb		UART
					sta 	UART  				; param
					ldb		#CR					; end
					stb		UART				
					rts
	
;-------------------------------------------------------------------------------------------------;
; Send the clear screen command (C call compatible)
; param: 	2,s -> unused
;			3,s -> color
; return:	none
;-------------------------------------------------------------------------------------------------;					
sendClearScreen ;{
					lbsr	waitSendDone
					lbsr	waitCTS
					ldb		#'D'				; sending
					stb		UART
					ldb		#'l'				; cmd
					stb		UART
					ldb		3,s
					addb	#'0'
					stb		UART				; color
					ldb		#CR					; end
					stb		UART				
					rts	
;}		
			
;-------------------------------------------------------------------------------------------------;
; Send the setpointXY command (C call compatible)
; param: 	2,s -> unused
;			3,s -> x
;			4,s -> unused
;			5,s -> y
; return:	none
;-------------------------------------------------------------------------------------------------;					
setpointXY ;{
setpoint			lbsr	waitSendDone
					lbsr	waitCTS
					ldb		#'D'				; sending
					stb		UART
					ldb		#'p'				; cmd
					stb		UART
					ldb		3,s
					addb	#'0'
					stb		UART				; x
					ldb		5,s
					addb	#'0'
					stb		UART				; y
					ldb		#CR					; end
					stb		UART				
					rts	
;}	

;-------------------------------------------------------------------------------------------------;
; Set tile index [Graph mode] (C call compatible)
; param: 	2,s -> unused
;			3,s -> tile index
; return:	none
;-------------------------------------------------------------------------------------------------;					
setTile ;{
					lbsr	waitSendDone
					lbsr	waitCTS
					ldb		#'D'				; sending
					stb		UART
					ldb		#'t'				; cmd
					stb		UART
					ldb		#'1'				; len
					stb		UART
					ldb		3,s
					stb 	UART  				; index
					ldb		#CR					; end
					stb		UART				
					rts
;}

;-------------------------------------------------------------------------------------------------;
; Send the tone command (C call compatible)
; param: 	2,s -> unused
;			3,s -> tone (8-bit)
;			4,s -> unused
;			5,s -> duration (8-bit)
; return:	none
;-------------------------------------------------------------------------------------------------;					
setTone ;{
					lbsr	waitSendDone
					lbsr	waitCTS
					ldb		#'D'				; sending
					stb		UART
					ldb		#'o'				; cmd
					stb		UART
					ldb		3,s
					stb		UART				; tone
					ldb		5,s
					stb		UART				; duration
					ldb		#CR					; end
					stb		UART				
					rts	
;}	

;-------------------------------------------------------------------------------------------------;
; Set sound index (C call compatible)
; param: 	2,s -> unused
;			3,s -> index
; return:	none
;-------------------------------------------------------------------------------------------------;					
setSound ;{
					lbsr	waitSendDone
					lbsr	waitCTS
					ldb		#'D'				; sending
					stb		UART
					ldb		#'s'				; cmd
					stb		UART
					ldb		3,s
					addb	#'0'				; container index
					stb		UART					
					ldb		#CR					; end
					stb		UART				
					rts
;}		

;-------------------------------------------------------------------------------------------------;
; Send container data [Graph mode] (C call compatible)
; param: 	2,s -> unused
;			3,s -> index
;			4-5,s -> pointer (16-bit) to max 32 bytes array "R0,G0,B0,R1,G1,B1,x,x" or sound
; return:	none
;-------------------------------------------------------------------------------------------------;					
sendContainerData ;{
sendCont			lbsr	waitSendDone
					lbsr	waitCTS
					pshs	x					; save used pointers (+2 bytes on stack)					
					ldb		#'D'				; sending
					stb		UART
					ldb		#'d'				; cmd
					stb		UART
					ldb		#32+'0'				; len 32 bytes
					stb		UART
					ldb		5,s					; 3,s +2 bytes, container index
					stb		UART
					ldx		6,s					; 4,s +2 bytes
					ldb		#32
_sendCtnData1		lda		,x+
					sta 	UART  				; data 1 to 32
					lbsr	waitSendDone		; check again when more than 16 byte fifo size					
					lbsr	waitCTS
					decb
					bne		_sendCtnData1					
					ldb		#CR					; end
					stb		UART				
					puls	x,pc				; restore the register(s) and return

;-------------------------------------------------------------------------------------------------;
; Set DateTime (C call compatible). This cmd triggers always the DateTime stamp as answer.
; param: 	2,s -> SS or DD
;			3,s -> MM or MM
;			4,s -> HH or YY
;			5,s -> 't' or 'd'
; return:	none
;-------------------------------------------------------------------------------------------------;					
setDateTime ;{
					lbsr	waitSendDone
					lbsr	waitCTS
					ldb		#'D'				; sending
					stb		UART
					ldb		5,s
					cmpb	#'d'
					beq		setDT_01
					ldb		#'i'				; cmd t'I'me
					bra		setDT_02
setDT_01			ldb		#'a'				; cmd d'A'te
setDT_02			stb		UART				; end execution same as set date
					ldb		4,s
					addb	#'0'
					stb		UART
					ldb		3,s
					addb	#'0'
					stb		UART
					ldb		2,s
					addb	#'0'
					stb		UART
					ldb		#CR					; end
					stb		UART
					rts
;}
	
;-------------------------------------------------------------------------------------------------;
; delay in ms (C call compatible)
; param: 	2-3,s -> delay value (16-bit)
; return:	none
;-------------------------------------------------------------------------------------------------;					
; msDelay ;{
					; ldd		#282		; 3 cycles
; _msDelay0			subd	#1			; 4 cycles
					; bne		_msDelay0	; 3 cycles
					; ldd		2,s			; 5 cycles
					; subd	#1			; 4 cycles
					; std		2,s			; 5 cycles
					; cmpd	#0			; 5 cycles
					; bne		msDelay		; 3 cycles
					; rts
										; 3 + (4+3 cycles * 282) + 5+4+5+5+3 = 2000 cycles/ms (intern clk 2MHz)

;}	;--------------------------------------------------- PIA 6821 ----------------------------------------------------
				code
				
* 
* PIAinit(pPort, DDR) unsigned char *pPort; unsigned char DDR; {
*     *(pPort+1)	= 0x30; // Cx2 used as output, select DDR register
PIAinit
	ldx	2,s
	ldb	#$30
	stb	1,x
*     *pPort      = DDR;  // DDRx configured as: 1 for output, 0 for input
	ldb	5,s
	stb	,x
* 
*     *(pPort+1)	= 0x34; // Cx2 used as output, select PORT register
	ldb	#$34	
	stb	1,x
*     *pPort		= 0x00; // IOs bits cleared	
	clrb
	stb	,x
* }
	rts
* 

* 
* PIA_Out(pPort, value) unsigned char *pPort; unsigned char value; {
*     *pPort	= value;
PIA_Out
	ldb	5,s
	stb	[2,s]
* }
	rts
* 
* PIA_In(pPort) unsigned char *pPort; {
*     return *pPort;
PIA_In
	ldb	[2,s]	
	clra
* }
	rts
* 
* PIA_SetCx2(pPort) unsigned char *pPort; {
*     *(pPort+1)	= *(pPort+1) | 0b00001000; // set bit 3
PIA_SetC
	ldx	2,s
	ldb	1,x
	orb	#$8
	ldx	2,s
	stb	1,x
* }
	rts
* 
* PIA_ClrCx2(pPort) unsigned char *pPort; {
*     *(pPort+1)	= *(pPort+1) & 0b11110111;// clear bit 3
PIA_ClrC
	ldx	2,s
	ldb	1,x
	andb #$f7
	ldx	2,s
	stb	1,x
* }
	rts
* ;--------------------------------------------------- 16550 UART ----------------------------------------------------
				code
				
;----------------------------------------------------;
; UART Init
; param: 	none
; return:	none
;----------------------------------------------------;
UART_Init	;{
				lda		#$80			; DLAB=1
				sta		UART+3
				
										; 12MHz ->  78:baudrate 9600,                    13:baudrate 57600
										; 16MHz -> 104:baudrate 9600, 26:baudrate 38400, 17:baudrate 57600,  9:baudrate 115200
										; 24MHz -> 156:baudrate 9600, 39:baudrate 38400, 26:baudrate 57600, 13:baudrate 115200
				lda		#17
				sta		UART
				lda		#$00	  	
				sta		UART+1
				
				lda		#$01	  		; Fifo enable
				sta		UART+2
				
				lda		#$03			; DLAB=0, config 8N1 
				sta		UART+3
				
				lda		#$01			; enable rx interrrupt
				sta		UART+1
				rts
;}

;----------------------------------------------------;
; UART Read
; param: 	none
; return:	read byte -> B when when A != 0
;----------------------------------------------------;
UartRead ;{
				lda		UART+5 			; check if a byte is available
				anda	#1				; a contains not NULL when a byte available
				beq		_UartRead1
				ldb 	UART   			; read first byte
_UartRead1		rts
;}

;----------------------------------------------------;
; wait until a char available or 256 polling cycles timeout
; param: 	none
; return:	none
;----------------------------------------------------;
waitdata ;{		
				clrb
_waitdata1		decb
				beq		_waitdata2 		; exit
				lda		UART+5 			; check if a byte is available
				anda	#1
				beq		_waitdata1		
_waitdata2		rts
;}

;----------------------------------------------------;
; wait until the remaining char is sent (fifo empty)
; param: 	none
; return:	none
;----------------------------------------------------;
waitSendDone ;{
				lda		UART+5 			; check if uart TX ready (waiting for THRE bit set)
				anda	#$20
				beq		waitSendDone		
				rts
;}

;----------------------------------------------------;
; wait CTS
; param: 	none
; return:	none
;----------------------------------------------------;
waitCTS ;{
				lda		UART+6 			; read the moden status register
				anda	#$10
				beq		waitCTS
				rts
;}
;{ --------------------------------------------------- Monitor for debugging over serial port -----------------------------------------
					code
					
MON_VERSION     	db		"0.9.0.0",0			; version [major, minor, branch, build] string ended by NULL. branch = 0 is a release
					
;---------------------------------------------------
; write commands menu with version in terminal
;---------------------------------------------------
STR_MONITOR      	db      CR,"starting monitor process ID ",0
STR_VERSION			db		CR,"Monitor for 6809 Computer v",0
STR_COMMAND			db		CR,"command menu",CR
					db		"r [first addr] (optional [n repeat]) reads the addresses",CR
					db		"w [addr] [data], optional [n repeat] writes to the addresses",CR
					db		"e [src] [dst] [length] (optional [protection]) copies to flash memory",CR
					db		"l or l [offset] loads a SRec data",CR
					db		"g [addr] executes at the address",CR
					db		"s [process ID] stops the process",CR
					db		"b [addr] sets debugging mode a breakpoint at the address",CR
					db		"q quits debugging mode",CR
					db		"B [BASIC line entry]",CR
					db		"L loads a BASIC program",CR
					db		"h this menu",CR,0

sMONITORSTART		ldd		#BrkPtOff			; init break point variable
					std		BrkPtAddr										
					lbsr	sRbInit				; monitor init ring buffer
					andcc	#ENABLE_MON_INT		; enable monitor interrupt
					
					ldx		#STR_MONITOR		; monitor start-up message
					lbsr	sPUTSTR				;	
					ldb		#MONITOR_PROCESS_ID
					pshs	d
					lbsr	HEXBYTE2MONPORT
					ldb		#CR
					pshs	d
					lbsr	BYTE2MONPORT
					leas	4,s					; clear 2 pushes
					rts
												; print help menu at startup
sMONITORMENU		ldx		#STR_VERSION
					lbsr	sPUTSTR
					ldx		#MON_VERSION
					lbsr	sPUTSTR
					ldx		#STR_COMMAND
					lbsr	sPUTSTR
					rts

	;{ --------------------------------------------------- Cmd Rinbuffer ------------------------------------------
sRbInit	
		;---------------------------------------------------
		; asm call init ring buffer
		;---------------------------------------------------
		;{
					clr		RbHead
					clr		RbTail
					clr		RbDectCR
					rts
		;}

sRbReadCmd 
		;---------------------------------------------------
		; asm call read a byte from ringbuffer (a 'CR' must be in the fifo to get a byte)
		; param:	none
		; return:	cmd value -> A. when invalid, NULL -> B
		;---------------------------------------------------
		;{
					clrb						; no char by default
					lda		RbDectCR
					beq		_sRbRead3			; still no CR in the cmd buffer
		
sRbRead				ldb		RbTail
					cmpb	RbHead
					beq		_sRbRead11			; fifo empty when tail = head
					pshs	x
					ldx		#Rbuffer
					lda		b,x
					puls	x
					incb						; inc tail index
					cmpb	#RbSize
					blo		_sRbRead1
					clrb						; wrap RbTail
_sRbRead1			stb		RbTail				; save updated tail index only once data extracted (critical section)
					ldb		#1					; not null when valid
					bra		_sRbRead2
_sRbRead11			clr		RbDectCR			; no more CR possible
					clrb						; no char
_sRbRead2			andcc	#ENABLE_MON_INT		; re-enable int in case disabled by full fifo
_sRbRead3			rts

	;}

sMonProcessCmd
		;---------------------------------------------------
		; asm call extract and execute the cmd
		;---------------------------------------------------
		;{
					bsr		sRbReadCmd
					tstb						; RB empty ?
					beq		_sMonProcessCmd					
					cmpa	#'h'
					beq		sCMDhelp 			; help command
					cmpa	#'r'
					beq		sCMDrd  			; read command
					cmpa	#'w'
					lbeq	sCMDwr  			; write command
					cmpa	#'e'
					lbeq	sCMDew 				; eeprom write command
					cmpa	#'l'
					lbeq	sCMDld  			; load SRec command
					cmpa	#'g'
					lbeq	sCMDgo  			; Go command
					cmpa	#'s'
					lbeq	sCMDStp  			; Stop process command
					cmpa	#'b'
					lbeq	sCMDbp  			; breakpoint command
					cmpa	#'q'
					lbeq	sCMDqbp  			; stop debugging command
					cmpa	#'B'
					lbeq	sCMDbas  			; BASIC line entry command
					cmpa	#'L'
					lbeq	sCMDldbas			; load BASIC program command
_sMonProcessCmd		rts  						; cmd no existing

			;----------------------------------------------------;
sCMDhelp 			bsr		sRbReadCmd
					tstb
					beq		_sCMDhelp				
					cmpa	#CR
					lbne	sCMDinvalid  		; not CR, invalid CMD
					lbsr	sMONITORMENU
_sCMDhelp			rts							; exit
			
			;----------------------------------------------------;
sCMDrd
RdAddr				equ		0					; uint RdAddr index
RdRepeat			equ		2					; uint Count index
					pshs	u
					leas	-2,s				; allocate 16-bit
					leas	-2,s				; allocate 16-bit
					leau	,s					; use the U as pointer
					clra
					clrb
					std		RdRepeat,u 			; set to 0 by default
				
					;------- extract the ' ' only --------------------
					lbsr	sCMDextr
					cmpb	#' '
					bne		_sCMDrdinvalid	
				
					;------- extract 'raddr' --------------------
					lbsr	sCMDextr
					tstb
					beq		_sCMDrdinvalid
					stx		RdAddr,u 			; save read param 1
					cmpb	#CR					; check if a repeat param follows
					beq		_sCMDexe_rd0
				
					;------- extract the optional 'repeat' --------------------
					lbsr	sCMDextr
					stx		RdRepeat,u 			; save read param 2
					cmpb	#CR
					beq		_sCMDexe_rd0
_sCMDrdinvalid		lbsr	sCMDinvalid
					bra		_sCMDrddone
				
STR_CMD_rd			db		CR,"read",0
_sCMDexe_rd0		ldx		#STR_CMD_rd
					lbsr	sPUTSTR
				
_sCMDexe_rd1   		ldb		#CR
					lbsr	sMON_PORT_WR		; CR when begin with addr
					ldd		RdAddr,u
					pshs	d
					lbsr	HEXWORD2MONPORT
					leas	2,s
_sCMDexe_rd2		ldb		#' '
					lbsr	sMON_PORT_WR
					ldb		[RdAddr,u]
					pshs	d
					lbsr	HEXBYTE2MONPORT
					leas	2,s
					ldd		RdRepeat,u
					cmpd	#0
					beq		_sCMDrddone
					subd	#1
					std		RdRepeat,u
					ldd		RdAddr,u
					addd	#1
					std		RdAddr,u
					andb	#$1f
					beq		_sCMDexe_rd1		; write addr at begin
					bra		_sCMDexe_rd2
_sCMDrddone			leas	2,s					; free 16-bit param 2
					leas	2,s					; free 16-bit param 1
					puls	u
					rts  						; exit

;----------------------------------------------------;
sCMDwr
WrAddr				equ		0					; uint WrAddr index
WrData				equ		2					; uchar WrData index
WrRepeat			equ		3					; uint repeat
					pshs	u
					leas	-2,s				; allocate 16-bit
					leas	-1,s				; allocate 8-bit
					leas	-2,s				; allocate 16-bit
					leau	,s					; use the U as pointer
					clra
					clrb
					std		WrRepeat,u 			; set to 0 by default
					
					;------- extract the ' ' only --------------------
					lbsr	sCMDextr
					cmpb	#' '
					bne		_sCMDwrInvalid

					;------- extract 'waddr' --------------------
					lbsr	sCMDextr
					cmpb	#CR
					beq		_sCMDwrInvalid		; CR shall come later
					cmpb	#' '
					bne		_sCMDwrInvalid		
					cmpx	#ROM0_ORG			; avoid write in ROM
					bhs		_sCMDwrInvalid
					stx		WrAddr,u 			; save read param 1
					
					;------- extract 'wdata' --------------------
					lbsr	sCMDextr
					exg		x,d
					stb		WrData,u 			; save read param 2
					exg		x,d
					cmpb	#CR					; check if param ended
					beq		_sCMDwr1
					cmpb	#' '				; check if a repeat param follows
					bne		_sCMDwrInvalid				
					
					;------- extract the optional 'repeat' --------------------
					lbsr	sCMDextr
					stx		WrRepeat,u 			; save read param 3
					cmpb	#CR
					beq		_sCMDwr1				
				
_sCMDwrInvalid		lbsr	sCMDinvalid
					lbra	_sCMDwrdone
				
STR_CMD_wr			db		CR,"write",0
_sCMDwr1			ldx		#STR_CMD_wr
					lbsr	sPUTSTR
_sCMDexe_wr1     	ldb		#CR					; CR when begin with addr
					lbsr	sMON_PORT_WR
					ldd		WrAddr,u
					pshs	d
					lbsr	HEXWORD2MONPORT
					leas	2,s
_sCMDexe_wr2		ldb		#' '
					lbsr	sMON_PORT_WR
					ldb		WrData,u
					pshs	d
					lbsr	HEXBYTE2MONPORT
					leas	2,s
					lda		WrData,u
					sta		[WrAddr,u]			; perform the write
					ldd		WrRepeat,u
					cmpd	#0
					beq		_sCMDwrdone
					subd	#1
					std		WrRepeat,u
					ldd		WrAddr,u
					addd	#1
					std		WrAddr,u
					andb	#$1f
					beq		_sCMDexe_wr1		; write addr at begin
					bra		_sCMDexe_wr2
	
_sCMDwrdone			leas	2,s					; free 16-bit param 3
					leas	1,s					; free 8-bit param 2
					leas	2,s					; free 16-bit param 1
					puls	u
					rts							; exit

;----------------------------------------------------;
STR_EW1				db		CR,"writing ",0
STR_EW2				db		" byte(s) from ",0
STR_EW3				db		" to ",0
STR_EW4				db		", please wait ...",0
STR_EWdone			db		CR,"eeprom writing done, ",0
STR_EW_CS			db		"CheckSum16: ",0
sCMDew				pshs	u					; save register(s)
					;------- extract ' ' --------------------
					lbsr	sCMDextr
					cmpb	#' '
					bne		_sCMDewInvalid0					
					
					;------- extract 'src' until ' ' --------------------
					lbsr	sCMDextr
					pshs	x					; push WriteEEP param 1 (src)
					cmpb	#' '
					bne		_sCMDewInvalid1					
					
					;------- extract 'dst'until' ' --------------------
					lbsr	sCMDextr
					pshs	x 					; push WriteEEP param 2 (dst)
					cmpb	#' '
					bne		_sCMDewInvalid2								
					
					;------- extract 'len'until' ' --------------------
					lbsr	sCMDextr
					pshs	x 					; push WriteEEP param 3 (len)
					ldx		#0					; no protection param by default
					cmpb	#CR
					beq		_sCMDew1			; no protection param
					cmpb	#' '
					bne		_sCMDewInvalid3					
					
					;------- extract 'protection'until'CR' --------------------					
					lbsr	sCMDextr					
					cmpb	#CR
					beq		_sCMDew1				; branch when OK, otherwise free the saved params
_sCMDewInvalid3		leas	2,s					; free WriteEEP param 3
_sCMDewInvalid2		leas	2,s					; free WriteEEP param 2
_sCMDewInvalid1		leas	2,s					; free WriteEEP param 1
_sCMDewInvalid0		lbsr	sCMDinvalid
					lbra	_sCMDewdone

_sCMDew1			pshs	x 					; WriteEEP param 4 (protection)
					leau	0,s					; use U as parameter pointer
					ldx		#STR_EW1
					lbsr	sPUTSTR
					ldd		2,u					; print param 3 (length in byte)
					pshs	d
					lbsr	HEXWORD2MONPORT
					leas	2,s
					ldx		#STR_EW2
					lbsr	sPUTSTR
					ldd		6,u					; print param 2 (source)
					pshs	d
					lbsr	HEXWORD2MONPORT
					leas	2,s
					ldx		#STR_EW3
					lbsr	sPUTSTR
					ldd		4,u					; print param 1 (destination)
					pshs	d
					lbsr	HEXWORD2MONPORT
					leas	2,s
					ldx		#STR_EW4
					lbsr	sPUTSTR
					
					lbsr	WriteEEP
					ldx		#STR_EWdone
					lbsr	sPUTSTR
					
					ldx		#STR_EW_CS
					lbsr	sPUTSTR
					ldd		4,u					; Checksum calculated in ROM. Take WriteEEP destination
					pshs	d					; push as 1st arg (CheckSum16 begin addr)
					addd	2,u					; add WriteEEP length in byte
					pshs	d					; push as 2nd arg (CheckSum16 end addr)
					clra						; initial CheckSum16 value shall be 0
					clrb
					pshs	d					; push as 3rd arg
					lbsr	getCheckSum16
					leas	6,s					; free the 3 args					
					pshs	d
					lbsr	HEXWORD2MONPORT
					leas	2,s
_sCMDewdone			leas	8,s					; free the WriteEEP 4 params
					puls	u,pc  				; restore u and return				
						
;----------------------------------------------------;
STR_CMD_LD			db		CR,"send now the SRec data, Offset=",0
STR_CMD_LD2			db		" byte(s) @ addr:",0
STR_CMD_LD3			db		"reception completed",CR,0
STR_CMD_LD4			db		" checksum error!",0
ByteCount			equ		0					; uchar byte count index
SRecCheckSum		equ		1					; uchar SRecCheckSum index
Offset				equ		2					; uint Offset index
NewAddr				equ		4					; uint new address
sCMDld				pshs	u
					leas	-2,s				; allocate 16-bit Offset
					leas	-2,s				; allocate 16-bit Offset
					leas	-1,s				; allocate 8-bit SRecCheckSum
					leas	-1,s				; allocate 8-bit ByteCount
					leau	,s					; use the U as pointer
					clra
					clrb
					std		Offset,u 			; set to 0 by default
					
					;------- extract 'CR' or optional ' ''offset' --------------------
					lbsr	sCMDextr
					cmpb	#CR					; no offset
					beq		_sCMDld00
					cmpb	#' '
					bne		_sCMDldInvalid		; with offset data
					
					;------- extract optional 'offset' --------------------
					lbsr	sCMDextr
					cmpb	#CR
					bne		_sCMDldInvalid					
					
_sCMDld00			stx		Offset,u			; save the offset data
					ldx		#STR_CMD_LD
					lbsr	sPUTSTR
					ldd		Offset,u
					pshs	d
					lbsr	HEXWORD2MONPORT
					leas	2,s
					bra		_sCMDld0
_sCMDldInvalid		lbsr	sCMDinvalid
					lbra	_sCMDlddone
					;------- seek for 'S1' --------------------
_sCMDld0			lbsr	sRbRead 			; read a byte
					tstb
					beq		_sCMDld0
					cmpa	#'S'
					bne		_sCMDld0
_sCMDld01			lbsr	sRbRead 			; read a byte
					tstb
					beq		_sCMDld01
					cmpa	#'1'
					bne		_sCMDlddone 		; the last line does not contains S1
					clr		SRecCheckSum,u		; SRecCheckSum = 0
					
					lda		#2					; read byte count
					lbsr	sExtrNByte
					pshs	b
					addb	SRecCheckSum,u		; SRecCheckSum +=  bytecount
					stb		SRecCheckSum,u
					puls	b
					subb	#3					; 3 byte already read
					stb		ByteCount,u
					ldb		#CR
					lbsr	sMON_PORT_WR
					ldb		ByteCount,u
					pshs	d
					lbsr	HEXBYTE2MONPORT
					leas	2,s
					ldx		#STR_CMD_LD2
					lbsr	sPUTSTR
					
					lda		#4  				; read addr
					lbsr	sExtrNByte
					std	    NewAddr,u			; save addr
					adda	SRecCheckSum,u		; SRecCheckSum +=  addr hi
					sta		SRecCheckSum,u
					addb	SRecCheckSum,u		; SRecCheckSum +=  addr lo
					stb		SRecCheckSum,u	
					ldd	    NewAddr,u			; addr -= offset
					subd	Offset,u
					std	    NewAddr,u			; save new addr
					pshs	d
					lbsr	HEXWORD2MONPORT
					leas	2,s

_sCMDld1			lda		#2					; read data
					lbsr	sExtrNByte
					pshs	b
					addb	SRecCheckSum,u		; SRecCheckSum +=  data
					stb		SRecCheckSum,u
					puls	b
					ldx	    NewAddr,u			; get new addr
					stb     ,x+ 				; write to dst addr and inc
					stx	    NewAddr,u			; save new addr
					dec		ByteCount,u
					bne		_sCMDld1
						
					lda		#2					; read checksum
					lbsr	sExtrNByte
					eorb	SRecCheckSum,u 		; checksum xor with sum should give 0xff
					cmpb	#$ff
					beq		_sCMDld2
					ldx		#STR_CMD_LD4
					lbsr	sPUTSTR
_sCMDld2			lbra	_sCMDld0
_sCMDlddone      	ldb		#CR
					lbsr	sMON_PORT_WR
					ldx		#STR_CMD_LD3
					lbsr	sPUTSTR
					leas	1,s					; free 8-bit
					leas	1,s					; free 8-bit
					leas	2,s					; free 16-bit
					leas	2,s					; free 16-bit
					puls	u
					rts							; exit

;----------------------------------------------------;
STR_GO				db		CR,"go address ",0
sCMDgo				;------- extract ' ' --------------------
					lbsr	sCMDextr
					cmpb	#' '
					bne		_sCMDgoInvalid
					
					;------- extract 'addr' with 'CR' --------------------
					lbsr	sCMDextr
					cmpb	#CR								
					beq		_sCMDgo0			; missing addr param	
_sCMDgoInvalid		lbsr	sCMDinvalid
					bra		_sCMDgodone
_sCMDgo0         	pshs	x					; save go addr
					ldx		#STR_GO
					lbsr	sPUTSTR					
					ldd		0,s					; get go addr
					pshs	d
					lbsr	HEXWORD2MONPORT
					leas	2,s
					ldd		#$ffff
_sCMDgo1			subd	#1
					bne		_sCMDgo1			; wait until MONPORT output processed
					puls	x
					jsr     ,x      			; execute @ addr
_sCMDgodone			rts							; exit

;----------------------------------------------------;
STR_ST				db		CR,"stop process ",0
sCMDStp				;------- extract ' ' --------------------
					lbsr	sCMDextr
					cmpb	#' '
					bne		_sCMDstpInvalid
					
					;------- extract 'process ID' with 'CR' --------------------
					lbsr	sCMDextr
					cmpb	#CR								
					beq		_sCMDstp0			; missing ID param	
_sCMDstpInvalid		lbsr	sCMDinvalid
					bra		_sCMDstpdone
_sCMDstp0         	pshs	x					; save process ID
					ldx		#STR_ST
					lbsr	sPUTSTR					
					ldd		0,s					; get process ID
					pshs	d
					lbsr	HEXBYTE2MONPORT
					leas	2,s
					puls	d
					cmpb	#BASIC_PROCESS_ID
					bne		_sCMDstpdone
					clr		BasicCallBack		; void the next callback address
					clr		BasicCallBack+1
_sCMDstpdone		rts							; exit

;----------------------------------------------------;
STR_BP				db		CR,"set breakkpoint address ",0
STR_BP1				db		CR,"breakkpoint existing! ",0
sCMDbp				;------- extract ' ' --------------------
					lbsr	sCMDextr
					cmpb	#' '
					bne		_sCMDbpInvalid
					
					;------- extract addr param with 'CR ' --------------------
					lbsr	sCMDextr
					cmpb	#CR
					bne		_sCMDbpInvalid
					
					cmpx	#RAM_ORG			; validate address within RAM
					blo		_sCMDbpInvalid
					cmpx	#RAM_END
					bhi		_sCMDbpInvalid
					
					pshs	x 					; save bp addr
					bra		_sCMDbp1
_sCMDbpInvalid		lbsr	sCMDinvalid
					bra		_sCMDbpdone
_sCMDbp1         	ldd		BrkPtAddr			; verify if breakpoint already set
					cmpd	#BrkPtOff
					beq		_sCMDbp2			; breakpoint not existing
					cmpd	#BrkPtTriggered
					beq		_sCMDbp2			; breakpoint can be set again				
					ldx		#STR_BP1
					lbsr	sPUTSTR
					bra		_sCMDbpdone
_sCMDbp2			ldx		#STR_BP
					lbsr	sPUTSTR
					puls	d					; restore bp addr
					std		BrkPtAddr			; save addr
					pshs	d
					lbsr	HEXWORD2MONPORT
					leas	2,s
					lda		[BrkPtAddr]			; save instruction
					sta		BrkPtInst
					lda		#$3f				;swi instruction
					sta		[BrkPtAddr]			;replace by swi
_sCMDbpdone			rts							; exit

;----------------------------------------------------;
STR_QBP				db		CR,"quit debugging mode",0
STR_QBP1			db		CR,"not in debugging mode",0
sCMDqbp	    	    ldd		BrkPtAddr			; verify if breakpoint set
					cmpd	#BrkPtOff			; Off when not in debug mode
					beq		_sCMDqbp1	
					pshs	d
					ldx		#STR_QBP
					lbsr	sPUTSTR
					puls	d
					cmpd	#BrkPtTriggered		; was triggered
					beq		_sCMDqbp0
					lda		BrkPtInst
					sta		[BrkPtAddr]			; replace initial instruction at breakpoint addr
_sCMDqbp0			ldd		#BrkPtOff	
					std		BrkPtAddr			; place in off state
					bra		_sCMDqbpdone				
_sCMDqbp1			ldx		#STR_QBP1
					lbsr	sPUTSTR
_sCMDqbpdone		rts							; exit


;----------------------------------------------------;
STR_CMD_LDBAS		db		CR,"send now the BAS file",CR,0
STR_CMD_LDBASEND	db		"END",CR,0
sCMDldbas			lbsr	sRbReadCmd
					tstb
					lbeq	sCMDinvalid				
					cmpa	#CR
					lbne	sCMDinvalid  		; not CR, invalid CMD
					ldx		#STR_CMD_LDBAS
					lbsr	sPUTSTR
										
					;------- read until 'END' --------------------
_sCMDldbas0 		ldx		#STR_CMD_LDBASEND
_sCMDldbas1			lbsr	sRbRead 			; read a byte					
					tstb
					beq		_sCMDldbas1
					cmpa    #10
					beq		_sCMDldbas1			; remove LF
					pshs	a,x
					tfr		a,b
					lbsr	sAPL_KeyboardData
_sCMDldbas2			lbsr	BASICprocess		; BASIC process call
					lbsr    isKeyboardData		; check if the data is processed by BASIC
					tstb
					bne		_sCMDldbas2			; loop until the data is completely processed
					puls	x,a
					cmpa	,x+
					bne		_sCMDldbas0
					tfr		x,d
					subd	#STR_CMD_LDBASEND
					cmpd	#4
					blo		_sCMDldbas1
					rts

;----------------------------------------------------;
sCMDbas				;------- extract ' ' --------------------------------------
					lbsr	sCMDextr
					cmpb	#' '
					bne		sCMDinvalid
					
					;------- extract 'BASIC code' with 'CR' --------------------
_sCMDbas0			lbsr	sRbRead
					tstb
					beq		_sCMDbasdone
					pshs    a
					tfr		a,b
					lbsr	sAPL_KeyboardData
_sCMDbas1			lbsr	BASICprocess		; BASIC process call
					lbsr    isKeyboardData		; check if the data is processed by BASIC
					tstb
					bne		_sCMDbas1			; loop until the data is completely processed
					puls    a
					cmpa    #CR					; CR ends the command
					bne		_sCMDbas0
_sCMDbasdone		rts	

;----------------------------------------------------;
STR_CMDinvalid		db		CR,"invalid command!!",CR,0
sCMDinvalid			ldx		#STR_CMDinvalid
					lbsr	sPUTSTR
					rts
;}

;----------------------------------------------------;
sCMDextr ;{
;---------------------------------------------------;
; extract text command (converted in hex) until a ' ' or 'CR'
; param: 	none
; return: 	cmd value -> X, end condition -> B (NULL when invalid)
;---------------------------------------------------;
					ldx		#0					; clear
_sCMDextr0			lbsr	sRbReadCmd 			; read a byte
					tstb
					beq		_sCMDextrEnd			; RB empty, B is NULL
					tfr		a,b					; B contains the end condition
					cmpa	#' '				; end value?
					beq		_sCMDextrEnd  		; return value already in B
					cmpa	#CR					; or CR ends ?
					beq		_sCMDextrEnd  		; not expected
					lbsr	sTEXT2HEX			; convert
					pshs	a					; save new value on stack
					tfr		x,d
					lbsr	sWLSL4bit
					addb	,s+					; add the new value and free 8-bit stack
					tfr		d,x
					bra		_sCMDextr0
_sCMDextrEnd     	rts
;}
;----------------------------------------------------;
sExtrNByte ;{
;---------------------------------------------------
; asm call extract (text to hex) 
; param: 	A -> n byte to extract
; return:	out value -> D		
;---------------------------------------------------
					pshs	a					; contains the count
					ldx		#0					; clear
_sExtrNByte0		lbsr	sRbRead				; read a byte
					tstb
					beq     _sExtrNByte0 		; loop until RB no more empty
					lbsr	sTEXT2HEX			; convert
					pshs	a					; save
					tfr		x,d
					lbsr	sWLSL4bit
					addb	,s+					; free 8-bit stack
					tfr		d,x
					dec		,s					; decrease the count					
					bne		_sExtrNByte0
_sExtrEnd        	leas	1,s					; puls, free end param
					rts
	;}
;}

;----------------------------------------------------;
; asm call send string on debug port
; param: 	X -> pointer
; return:	none
;----------------------------------------------------;
sPUTSTR         	pshs	x
					lbsr	PUTSTR
					leas	2,s
					rts
;}



;{ --------------------------------------------------- Auxiliary Functions ------------------------------------
					code
					
SELECTBANK0			lda		UART+4
					ora		#%00000001		; clear ROM addr line DTR_n=1
					sta		UART+4
					rts					
SELECTBANK1			lda		UART+4
					anda	#%11111110		; set ROM addr line DTR_n=0
					sta		UART+4
					rts
					
;----------------------------------------------------;
; write to EEPROM from RAM
; param: 			0,s -> return addr
;			4th arg:2,s -> protection 	-> 0,u
;			3rd arg:4,s -> len			-> 2,u
;			2nd arg:6,s -> dst 			-> 4,u
;			1st arg:8,s -> src 			-> 6,u
; return:	CheckSum16 value -> D
;----------------------------------------------------;
WriteEEP			pshs	u,y,x				; save used pointers (+6 bytes on stack)
					leau	8,s					; set 4th arg to 0,u (8 bytes totally)
										
					ldd		0,u					; get the protection param					
					cmpd	#0					; 1 is the XICOR protection
					beq		_WriteEEP1
					bsr		DISAXICORWP					
				
_WriteEEP1			ldy		4,u					; get the params (X = src, Y = dst)
					ldx		6,u	
					ldd		2,u					; get length value
					pshs	d					; create a length counter variable to preserve the arg
					
_WriteEEP2			lda		,x+
					cmpa	,y
					beq		_no_change
					sta		,y
					lbsr	DELAY_10MS			; eeprom 10 ms delay loop				
_no_change			leay	1,y					; inc the pointer			
					ldd		0,s					; dec length counter variable
					subd	#1
					std		0,s
					bne		_WriteEEP2
					leas	2,s					; free the length counter
					
					ldd		0,u					; get the protection param
					cmpd	#0					; 1 is the XICOR protection
					beq		_WriteEEP5
					bsr		ENAXICORWP				
_WriteEEP5			puls	x,y,u,pc			; restore used registers

;----------------------------------------------------;
; asm call remove XICOR 28C64 / 28C256 eeprom write protection
; param:  none
; return: none
;----------------------------------------------------;				
DISAXICORWP			pshs	ccr,x				; save ccr (for the disabling)
					orcc	#%01010000			; disable interrupts				
					bsr		SELECTBANK1
					ldx 	#$1555+ROM1_ORG  	; $1555 + base addr / $5555 + base addr
					lda		#$aa
					sta		,x
					bsr		SELECTBANK0
					ldx 	#$2aaa+ROM1_ORG
					lda		#$55
					sta		,x
					bsr		SELECTBANK1
					ldx 	#$1555+ROM1_ORG
					lda		#$80
					sta		,x
					ldx 	#$1555+ROM1_ORG
					lda		#$aa
					sta		,x
					bsr		SELECTBANK0
					ldx 	#$2aaa+ROM1_ORG
					lda		#$55
					sta		,x
					bsr		SELECTBANK1
					ldx 	#$1555+ROM1_ORG
					lda		#$20
					sta		,x				
					bsr		SELECTBANK0
					bsr		DELAY_10MS				; eeprom 10 ms delay loop
					puls	x,ccr,pc				; restore registers
				
;----------------------------------------------------;
; asm call enable XICOR 28C64 / 28C256 eeprom write protection by re-write a byte
; param:  none
; return: none
;----------------------------------------------------;				
ENAXICORWP			pshs	ccr,x				; save ccr (for the disabling)
					orcc	#%01010000			; disable interrupts				
					ldb		ROM1_ORG			; get the byte
					bsr		SELECTBANK1
					ldx 	#$1555+ROM1_ORG  	;$1555 + base addr 
					lda		#$aa
					sta		,x
					bsr		SELECTBANK0
					ldx 	#$2aaa+ROM1_ORG
					lda		#$55
					sta		,x
					bsr		SELECTBANK1
					ldx 	#$1555+ROM1_ORG
					lda		#$a0
					sta		,x
					bsr		SELECTBANK0
					; re-write the byte
					stb		ROM1_ORG
					bsr		DELAY_10MS			; eeprom 10 ms delay loop
					puls	x,ccr,pc			; restore registers

DELAY_10MS			clra
					ldb		#10
					pshs	d
					lbsr	msDelay				; 10 ms delay loop
					puls	d,pc					

;----------------------------------------------------;
; asm call ROM integrity check
; param:  D -> CheckSum16 calculated value
;         X -> CheckSum16 addr
; return: 0 -> B when succeed
;----------------------------------------------------;
ROMcheckSTR0		db		CR,"ROM verified",0
ROMcheckSTR1		db		CR,"CheckSum16 ",0
ROMcheckSTR2		db		" was calculated instead ",0
ROMcheckSTR3		db		", ROM failure!",CR,0
sROMcheck			cmpd	,x
					beq		_sROMok
					pshs	x					; save							
					pshs	d					; param for HEXWORD2MONPORT							
					ldx		#ROMcheckSTR1
					lbsr	sPUTSTR
					lbsr	HEXWORD2MONPORT	
					leas	2,s					; free the last push
					ldx		#ROMcheckSTR2
					lbsr	sPUTSTR
					puls    x
					ldd		,x
					pshs	d					; param for HEXWORD2MONPORT							
					lbsr	HEXWORD2MONPORT
					leas	2,s					; free the last push					
					ldx		#ROMcheckSTR3		; failure
					lbsr	sPUTSTR
					ldb		#1					; non zero return value
					bra		sROMcheckdone		; to be removed		
_sROMok				ldx		#ROMcheckSTR0		; success
					lbsr	sPUTSTR
					clrb						; zero return value
sROMcheckdone		rts

;----------------------------------------------------;
; calculate the 16-bit CheckSum of the ROM
; param: 			0,s -> return addr
;			3rd arg:2,s -> CS16InitialValue -> 0,u
;			2nd arg:4,s -> CS16EndAddr		-> 2,u
;			1st arg 6,s -> start addr 		-> 4,u
; return:	CheckSum16 value -> D
;----------------------------------------------------;
getCheckSum16	;{	
					pshs	u,x					; save used registers (+4 bytes on stack)
					leau	6,s					; set arg1 to 0,u (4 bytes after the args)
					ldx		4,u					; get 3rd arg start addr
_getCheckSum160		ldd		,x++
					addd	0,u  				; 16-bit checksum
					std		0,u
					cmpx	2,u 				; end
					bne		_getCheckSum160
					puls	x,u,pc				; restore used registers
;}

;----------------------------------------------------;
; asm call calculate the string length
; param: 	X -> pointer
; return:	length -> D
;----------------------------------------------------;
sStrlen  ;{
					clrb
_sstrlen1 			lda		,x+
					beq		_sstrlenDone 		; string ends with NULL
					incb
					bra		_sstrlen1
					clra
_sstrlenDone		rts
;}

;----------------------------------------------------;
; asm call shift left D 4-bit
; param: 	D -> value
; return:	out -> D
;----------------------------------------------------;
sWLSL4bit	       	lslb
					rola
					lslb
					rola
					lslb
					rola
					lslb
					rola
					rts

;----------------------------------------------------;
; send string on debug port
; param: 	2,s -> string pointer
; return:	none
;----------------------------------------------------;
PUTSTR
print_De   			pshs	x				; +2 bytes on stack
					ldx		4,s
_putstr0			ldb		,x+
					beq		_putstr1 		; string ends with NULL
					lbsr	sMON_PORT_WR
					bra		_putstr0
_putstr1			puls	x,pc

;----------------------------------------------------;
; send Word on debug port, displayed in HEX
; param: 	2,s -> 8-bit high byte
;			3,s -> 8-bit low byte
; return:	none, D is not preserved
;----------------------------------------------------;
HEXWORD2MONPORT		
HEXWORD2			pshs	u					; +2 bytes on stack
					leau	4,s					; fix arg1 pointer to 0,u	
					ldb		#'$'
					lbsr	sMON_PORT_WR
					ldb		0,u		  			; param high byte
					pshs	d
					lbsr	DHEX2TEXT
					leas	2,s 
					pshs	b					; save low byte
					tfr		a,b
					stb		DEBUG_MON_PORT		; write high byte (write directly)
					puls	b					; get low byte
					stb		DEBUG_MON_PORT		; write low byte (write directly)
					ldb		1,u		  			; param low byte
					pshs	d
					lbsr	DHEX2TEXT
					leas	2,s 
					pshs	b					; save low byte
					tfr		a,b
					stb		DEBUG_MON_PORT		; write high byte (write directly)
					puls	b					; get low byte
					stb		DEBUG_MON_PORT		; write low byte (write directly)
					puls	u,pc
;}

;----------------------------------------------------;
; send Byte on debug port, displayed in HEX
; param: 	2,s -> xx
;			3,s -> 8-bit value
; return:	none, D is not preserved
;----------------------------------------------------;
HEXBYTE2MONPORT
HEXBYTE2			pshs	u
					leau	4,s					; fix arg1 pointer to 0,u		
					ldb		#'$'
					lbsr	sMON_PORT_WR
					ldb		1,u
					pshs	d
					lbsr	DHEX2TEXT
					leas	2,s 
					pshs	b
					tfr		a,b
					stb		DEBUG_MON_PORT			; write high nibble
					puls	b
					stb		DEBUG_MON_PORT			; write low nibble
					puls	u,pc

;----------------------------------------------------;
; send a byte on debug port
; param: 	2,s -> xx
;			3,s -> 8-bit value
; return:	none
;----------------------------------------------------;
BYTE2MONPORT
BYTE2MON			ldb		3,s
					lbsr	sMON_PORT_WR
					rts

;----------------------------------------------------;
; convert a byte to ascii hex value
; param: 	2,s -> xx
;			3,s -> 8-bit value
; return:	high nible -> A
;			low nibble -> B
;----------------------------------------------------;
DHEX2TEXT	   		lda		3,s
					lsra
					lsra
					lsra
					lsra
					bsr		sHEX2TEXT
					tfr		a,b
					lda		3,s
					anda	#$f					;lower nible
					bsr		sHEX2TEXT
					exg		a,b
					rts

;----------------------------------------------------;
; asm call hex to dec conversion
; param: 	A -> hex value
; return:	dec out -> A
;----------------------------------------------------;
sHEX2TEXT			anda	#$f					;lower nible
					cmpa	#9
					bhi     sHEX2TEXT_1
					adda	#'0'				;for number
					bra     sHEX2TEXT_2
sHEX2TEXT_1	    	adda	#$37				;for letter
sHEX2TEXT_2			rts

;----------------------------------------------------;
; asm call dec to hex conversion
; param: 	A -> dec value
; return:	hex out -> A
;----------------------------------------------------;
sTEXT2HEX			cmpa	#'9'
					bhi     sTEXT2HEX_1
					anda	#$f					;for number
					bra     sTEXT2HEX_2
sTEXT2HEX_1      	cmpa	#'F'
					bhi     sTEXT2HEX_11
					suba	#$37				;for higher case letter
					bra     sTEXT2HEX_2
sTEXT2HEX_11     	suba	#$57				;for lower case letter
sTEXT2HEX_2			rts

;-------------------------------------------------------------------------------------------------;
; delay in ms (C call compatible)
; param: 	2-3,s -> delay value (16-bit)
; return:	none
;-------------------------------------------------------------------------------------------------;					
msDelay ;{
					ldd		#282		; 3 cycles
_msDelay0			subd	#1			; 4 cycles
					bne		_msDelay0	; 3 cycles
					ldd		2,s			; 5 cycles
					subd	#1			; 4 cycles
					std		2,s			; 5 cycles
					cmpd	#0			; 5 cycles
					bne		msDelay		; 3 cycles
					rts
										; 3 + (4+3 cycles * 282) + 5+4+5+5+3 = 2000 cycles/ms (intern clk 2MHz)
					
;Interrupt service routines
				code
				
;{ --------------------------------------------------- IRQs ---------------------------------------------------
IRQ            	ldx		IntVectIRQ			; load the new vector
				beq		_irq0
				jmp		,x					; execute the re-mapped isr
_irq0			ldx     #Rbuffer			; get buffer base addr				
				lda		RbHead				; head index value
				leax	a,x					; set X to the head pointer
				inca				
				cmpa	#RbSize
				blo		_irq1
				clra
_irq1		    cmpa	RbTail
				bne		_irq2				; stop filling before reaching the tail index
				lda		,s 					; modify the stacked CCR
				ora		#%00010000			; disable irq only when fifo full
				sta		,s
				inc 	RbDectCR 			; CR detect on, otherwise the fifo content will never be processed				
				bra		_irq3
_irq2			sta     RbHead
				lda		sMON_PORT_RD
				cmpa	#CR					; CR compare
				bne		_irq22
				inc 	RbDectCR 			; CR found
_irq22			sta		,x					; store data to RB head pointer
_irq3			rti

FIRQ  			tst		IntVectFIRQ			; cmp the new vector stored
				bne		_firq
				tst		IntVectFIRQ+1		; cmp the new vector stored
				beq		_firq0
_firq			jmp		[IntVectFIRQ]		; execute the re-mapped isr
_firq0			rti

NMI            	ldx		IntVectNMI			; load the new vector stored @ $a00a
				beq		_nmi0
				jmp		,x					; execute the re-mapped isr
_nmi0			rti
;}

;{ --------------------------------------------------- SWI routines ------------------------------------------
SWI1_STR1		db		CR,"Debugging Mode: Program execution stopped. Enter a new breakpoint or quit",CR,0
SWI1_STR2		db		"PC, S, U, Y, X, DP, D, CC",CR,0
SWI1_STR3		db		", ",0

SWI1            ldx		IntVectSWI1			; load the new vector
				beq		_swi10
				jmp		,x
_swi10          ldx		#SWI1_STR1 			; Breakpoint
				lbsr	sPUTSTR
				ldx		#SWI1_STR2
				lbsr	sPUTSTR
				ldd		10,s				; PC
				subd	#1					; step back the executed swi instruction
				std		10,s
				pshs	d
				lbsr	HEXWORD2MONPORT
				leas	2,s
				ldx		#SWI1_STR3
				lbsr	sPUTSTR
				tfr		s,d		
				addb	#12					;PS
				pshs	d
				lbsr	HEXWORD2MONPORT
				leas	2,s
				ldx		#SWI1_STR3
				lbsr	sPUTSTR
				ldd		8,s					;US
				pshs	d
				lbsr	HEXWORD2MONPORT
				leas	2,s
				ldx		#SWI1_STR3
				lbsr	sPUTSTR
				ldd		6,s					;Y
				pshs	d
				lbsr	HEXWORD2MONPORT
				leas	2,s
				ldx		#SWI1_STR3
				lbsr	sPUTSTR
				ldd		4,s					;X
				pshs	d
				lbsr	HEXWORD2MONPORT
				leas	2,s
				ldx		#SWI1_STR3
				lbsr	sPUTSTR
				ldb		3,s					;DPR
				pshs	d
				lbsr	HEXBYTE2MONPORT
				leas	2,s
				ldx		#SWI1_STR3
				lbsr	sPUTSTR
				ldd		2,s					;D
				pshs	d
				lbsr	HEXWORD2MONPORT
				leas	2,s
				ldx		#SWI1_STR3
				lbsr	sPUTSTR
				ldb		0,s					;CCR
				pshs	d
				lbsr	HEXBYTE2MONPORT
				leas	2,s
				ldx		#SWI1_STR3
				lbsr	sPUTSTR				
				
				lda		BrkPtInst
				sta		[BrkPtAddr]			; replace initial instruction at breakpoint addr	
				ldd		#BrkPtTriggered
				std		BrkPtAddr			; state to triggered

				andcc	#ENABLE_MON_INT		; re-enable int
_swi12			lbsr	sMonProcessCmd		; get next cmd: quit or new bp				
				ldd		BrkPtAddr		
				cmpd	#BrkPtTriggered		; wait until next command
				beq		_swi12
SWI3			
SWI2			rti
;}

;{ --------------------------------------------------- vector table ---------------------------------------------------
				org		ROM_Integrity
				dw		CheckSum16_ROM0
				
				org    INT_VECTOR

				dw      SWI3
				dw 		SWI2
				dw      FIRQ
				dw      IRQ
				dw      SWI1
				dw      NMI
				dw      RESET
;}
				end



;{ ---------------------- asm Global Variables and Stack declarations -----------------------------------------------
					
BSS_SEG_ORG			equ     RAM_END+1 -3-35-5-10-4-14 			; asm global variables
GV_StackBeginAddr	equ		BSS_SEG_ORG							; C global variables stack (Y pointer)
LV_StackBeginAddr	equ		BSS_SEG_ORG - _GLOBALS				; local variables stack

;{ --------------------------------------------------- RAM Data Segment -----------------------------------------
					bss						; bss segment is in RAM (hidden in SRec file)
					org		BSS_SEG_ORG
BrkPtOff			equ     0
BrkPtTriggered		equ     1
BrkPtAddr	  		ds		2				; BrkPtOff, BrkPtTriggered or 16-bit address where is placed the breakpoint
BrkPtInst       	ds		1				; previous instruction where is placed the breakpoint

RbSize				equ     32
RbHead		  		ds		1
RbTail          	ds		1
Rbuffer				ds		RbSize
RbDectCR        	ds		1

APLstatus			ds		1
APLdate				ds		2
APLtime				ds		2

KeyboardRbSize		equ     8
KeyboardRbHead		ds		1
KeyboardRbTail     	ds		1
KeyboardRbuffer		ds		KeyboardRbSize

MonSavReg_S			ds		2				; monitor context saving registers PC, S, U, Y, X, DP, D, CCR 
BasicCallBack		ds		2				; BASIC call address

	; addresses re-mapping interrupt table
IntVectSWI3			ds		2
IntVectSWI2			ds		2
IntVectFIRQ			ds		2
IntVectIRQ			ds		2
IntVectSWI1			ds		2
IntVectNMI			ds		2
IntVectSTART		ds		2

;}		


