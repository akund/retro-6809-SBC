AS09 Assembler for M6809 [1.42].                                     Page    1
--------------------------------- merge.a09 ----------------------------------

-------------------------------- Symbol Table --------------------------------

              Symbol   Value        Decimal

                 ABS : $94a0          38048
      APLclearscreen : $edfb          60923
      APLcurBlinking : $edf5          60917
           APLcurOff : $edf8          60920
          APLgetChar : $ede6          60902
         APLsendChar : $ede9          60905
            APLsetXY : $ee11          60945
            APLsound : $ee02          60930
           APLstatus : $7fe3          32739
            APL_BUSY : $0032             50
            APL_init : $ee1e          60958
    APL_OutputStream : $eebc          61116
           APL_READY : $0031             49
           APL_RESET : $0030             48
       APL_RESET_STR : $edda          60890
       APL_UNDEFINED : $0039             57
              ARYDIS : $0008              8
              ARYEND : $001f             31
              ARYTAB : $001d             29
                 ASC : $8ed2          36562
                 ATN : $982f          38959
        BASICprocess : $ee9c          61084
           BASIC_ORG : $8002          32770
    BASIC_PROCESS_ID : $0020             32
       BasicCallBack : $7ff0          32752
         BasicRAMend : $7cff          31999
       BasicSavReg_S : $006f            111
              BINVAL : $002b             43
            BOOT_SCR : $ecf4          60660
              BOTSTK : $0017             23
              BROMHK : $8243          33347
           BrkPtAddr : $7fbd          32701
           BrkPtInst : $7fbf          32703
            BrkPtOff : $0000              0
      BrkPtTriggered : $0001              1
                  BS : $0008              8
         BSS_SEG_ORG : $7fbd          32701
            BYTE2MON : $faed          64237
        BYTE2MONPORT : $faed          64237
           ByteCount : $0000              0
            bPerSect : $fff1            -15
              CHARAC : $0001              1
              CHARAD : $0083            131
                 CHR : $8ebe          36542
     CheckSum16_ROM0 : $fbcd          64461
     CheckSum16_ROM1 : $ed38          60728
               CLEAR : $86a4          34468
                 CLS : $8217          33303
             CMD_TAB : $83c8          33736
              COEFCT : $0055             85
              COEFPT : $0064            100
          COMPARISON : $8b77          35703
              COMVEC : $80fe          33022
                CONT : $8693          34451
                 COS : $97f9          38905
                  CR : $000d             13
                 CRA : $d801          55297
                 CRB : $d803          55299
AS09 Assembler for M6809 [1.42].                                     Page    2
--------------------------------- merge.a09 ----------------------------------

         CSum16_ROM1 : $c882          51330
             CS_HIGH : $aaa2          43682
              CS_LOW : $aaab          43691
              CURLIN : $0068            104
            clusterN : $fdaa           -598
            convertF : $e53c          58684
      cursorBlinking : $ef81          61313
           cursorOff : $ef85          61317
                DATA : $873d          34621
              DATPTR : $0033             51
              DATTMP : $0035             53
              DATTXT : $0031             49
      DEBUG_MON_PORT : $c800          51200
                 DEF : $9ce4          40164
                 DEL : $9d9e          40350
          DELAY_10MS : $f9df          63967
              DEVCFW : $006a            106
              DEVLCF : $006b            107
              DEVNUM : $006e            110
              DEVPOS : $006c            108
              DEVWID : $006d            109
           DHEX2TEXT : $faf3          64243
                 DIM : $8b81          35713
              DIMFLG : $0005              5
                 DIR : $a495          42133
         DISAXICORWP : $f971          63857
            DSK_FDEL : $a5b9          42425
            DSK_FDIR : $a4ec          42220
            DSK_FDL1 : $a5cb          42443
             DSK_FRD : $a5cd          42445
            DSK_FRD1 : $a5f0          42480
             DSK_FWR : $a5f4          42484
            deleteFi : $e9ee          59886
                EDIT : $99b1          39345
                ELSE : $8740          34624
      ENABLE_MON_INT : $00ef            239
          ENAXICORWP : $f9b0          63920
                 END : $866a          34410
              ENDCHR : $0002              2
              ENDFLG : $0000              0
            ENTRYBAS : $801a          32794
                 ESC : $001b             27
                EXEC : $81a2          33186
              EXECJP : $007a            122
             EXITBAS : $800a          32778
                 EXP : $9970          39280
             FDIR_10 : $a59d          42397
             FDIR_11 : $a5ab          42411
            FDIR_11_ : $a5a3          42403
              FDIR_2 : $a5b5          42421
              FDIR_3 : $a4fa          42234
              FDIR_4 : $a52f          42287
              FDIR_5 : $a52c          42284
             FDIR_5_ : $a51c          42268
              FDIR_6 : $a5b2          42418
              FDIR_7 : $a58f          42383
              FDIR_8 : $a56e          42350
              FDIR_9 : $a58c          42380
          FILELENGTH : $000d             13
            FILE_Clo : $b3b7          46007
            FILE_Del : $b3ce          46030
            FILE_Get : $b456          46166
AS09 Assembler for M6809 [1.42].                                     Page    3
--------------------------------- merge.a09 ----------------------------------

            FILE_Lis : $bc56          48214
            FILE_Ope : $af7c          44924
            FILE_Put : $b574          46452
                FIRQ : $fb71          64369
                 FIX : $99a2          39330
            FL_initi : $ffe7            -25
                 FOR : $859a          34202
                FPA0 : $0050             80
                FPA1 : $005d             93
                FPA2 : $0013             19
              FPCARY : $005b             91
              FPSBYT : $0063             99
              FP0EXP : $004f             79
              FP0SGN : $0054             84
              FP1EXP : $005c             92
              FP1SGN : $0061             97
              FRESPC : $0025             37
              FRETOP : $0021             33
            FUNC_TAB : $8252          33362
              FWR_19 : $a61c          42524
              FWR_20 : $a64a          42570
               F_PTR : $0205            517
            fatMapTb : $fdae           -594
            fClstCnU : $ffe8            -24
            fDataSec : $fffb             -5
            freeMemo : $e901          59649
            frstSect : $fda2           -606
              GARBFL : $0007              7
              GETCCH : $0082            130
              GETNCH : $007c            124
              GET_FN : $a4c6          42182
              GIVABF : $8d27          36135
                  GO : $86e3          34531
   GV_StackBeginAddr : $7fbd          32701
            getBootS : $be9e          48798
       getCheckSum16 : $fa64          64100
            getFirst : $e191          57745
            getKeybo : $ef3c          61244
         getKeyboard : $ef3c          61244
            getSetFr : $e2df          58079
            getSetNC : $e1d8          57816
            get_QByt : $e17c          57724
            get_Word : $e16e          57710
            HEXBYTE2 : $facd          64205
     HEXBYTE2MONPORT : $facd          64205
              HEXDOL : $9ff9          40953
            HEXWORD2 : $fa98          64152
     HEXWORD2MONPORT : $fa98          64152
                  IF : $8771          34673
               IFCTR : $0004              4
              IKEYIM : $0073            115
               INKEY : $81cb          33227
              INPFLG : $0009              9
               INPUT : $884c          34892
               INSTR : $9bf2          39922
                 INT : $94fb          38139
              INTCNV : $8c20          35872
          INT_VECTOR : $fff2          65522
         IntVectFIRQ : $7ff6          32758
          IntVectIRQ : $7ff8          32760
          IntVectNMI : $7ffc          32764
        IntVectSTART : $7ffe          32766
AS09 Assembler for M6809 [1.42].                                     Page    4
--------------------------------- merge.a09 ----------------------------------

         IntVectSWI1 : $7ffa          32762
         IntVectSWI2 : $7ff4          32756
         IntVectSWI3 : $7ff2          32754
                 IRQ : $fb3c          64316
            initDISK : $a64e          42574
             init_10 : $a689          42633
            init_10_ : $a672          42610
             init_12 : $a6b9          42681
            init_12_ : $a69c          42652
             init_15 : $a6f2          42738
             init_16 : $a6eb          42731
            init_16_ : $a6d1          42705
              init_8 : $a6c2          42690
              init_9 : $a690          42640
            isKeyboa : $ef59          61273
      isKeyboardData : $ef59          61273
               KEYIN : $804f          32847
      KeyboardRbHead : $7fe4          32740
      KeyboardRbSize : $0008              8
      KeyboardRbTail : $7fe5          32741
     KeyboardRbuffer : $7fe6          32742
                KILL : $a4a0          42144
               LAA24 : $824d          33357
               LAA28 : $8251          33361
               LAA29 : $8252          33362
               LAA51 : $828c          33420
               LAA66 : $82a1          33441
               LABAF : $8414          33812
               LABED : $8456          33878
               LABEE : $8457          33879
               LABE1 : $844a          33866
               LABE8 : $8451          33873
               LABFB : $8464          33892
               LABF2 : $845b          33883
               LABF9 : $8462          33890
               LAB1A : $835b          33627
               LAB67 : $83c8          33736
               LACA0 : $84f5          34037
               LACA5 : $84fa          34042
               LACA8 : $84fd          34045
               LACC0 : $8514          34068
               LACC8 : $851c          34076
               LACDD : $8530          34096
               LACEF : $8542          34114
               LACE9 : $853c          34108
               LACF1 : $8544          34116
               LACF7 : $854a          34122
               LAC1A : $8483          33923
               LAC1E : $8487          33927
               LAC16 : $847f          33919
               LAC20 : $8489          33929
               LAC28 : $8491          33937
               LAC32 : $849b          33947
               LAC33 : $849c          33948
               LAC37 : $84a0          33952
               LAC44 : $84ad          33965
               LAC46 : $84af          33967
               LAC60 : $84bb          33979
               LAC68 : $84c3          33987
               LAC7C : $84da          34010
               LAC73 : $84ce          33998
               LADB1 : $85ff          34303
AS09 Assembler for M6809 [1.42].                                     Page    5
--------------------------------- merge.a09 ----------------------------------

               LADB4 : $8602          34306
               LADC0 : $8621          34337
               LADC6 : $8627          34343
               LADD4 : $8639          34361
               LADEA : $8652          34386
               LADEB : $8653          34387
               LADE8 : $8650          34384
               LADFA : $8662          34402
               LADFB : $8663          34403
               LADF0 : $8658          34392
               LAD01 : $8554          34132
               LAD05 : $8558          34136
               LAD12 : $8565          34149
               LAD14 : $8567          34151
               LAD16 : $8569          34153
               LAD19 : $856c          34156
               LAD21 : $8574          34164
               LAD26 : $8579          34169
               LAD33 : $8586          34182
               LAD59 : $85ac          34220
               LAD7F : $85d2          34258
               LAD9E : $85f1          34289
               LAD90 : $85e3          34275
               LAEA4 : $8701          34561
               LAEBB : $8718          34584
               LAEBF : $871c          34588
               LAEB6 : $8713          34579
               LAEDA : $8737          34615
               LAED2 : $872f          34607
               LAED7 : $8734          34612
               LAEEA : $8747          34631
               LAEEB : $8748          34632
               LAEE7 : $8744          34628
               LAEE8 : $8745          34629
               LAEF1 : $874e          34638
               LAEF7 : $8754          34644
               LAE0B : $8670          34416
               LAE11 : $8676          34422
               LAE15 : $867a          34426
               LAE22 : $8687          34439
               LAE40 : $86a3          34467
               LAE5A : $86bd          34493
               LAE6F : $86d2          34514
               LAE72 : $86d5          34517
               LAE88 : $86e5          34533
               LAE9F : $86fc          34556
               LAFA4 : $8801          34817
               LAFBE : $881b          34843
               LAFB1 : $880e          34830
               LAFCE : $882b          34859
               LAFCF : $882c          34860
               LAFDC : $8833          34867
               LAFDF : $8836          34870
               LAFD6 : $8833          34867
               LAFEA : $8841          34881
               LAF0C : $8769          34665
               LAF22 : $877f          34687
               LAF28 : $8785          34693
               LAF39 : $8796          34710
               LAF5D : $87ba          34746
               LAF52 : $87af          34735
               LAF54 : $87b1          34737
AS09 Assembler for M6809 [1.42].                                     Page    6
--------------------------------- merge.a09 ----------------------------------

               LAF6B : $87c8          34760
               LAF67 : $87c4          34756
              LASTPT : $000d             13
               LA0F3 : $80e1          32993
               LA077 : $8091          32913
               LA1C1 : $804f          32847
               LA10D : $80e4          32996
               LA123 : $80f0          33008
               LA147 : $8114          33044
               LA156 : $8143          33091
               LA165 : $8145          33093
               LA171 : $801f          32799
               LA172 : $8042          32834
               LA173 : $804a          32842
               LA174 : $804e          32846
               LA3B4 : $8169          33129
               LA3B8 : $816d          33133
               LA3CC : $8181          33153
               LA3CD : $8182          33154
               LA3C2 : $8177          33143
               LA3C8 : $817d          33149
               LA3D9 : $818e          33166
               LA3E8 : $819d          33181
               LA35F : $8146          33094
               LA37C : $814c          33100
               LA38D : $8154          33108
               LA39A : $815b          33115
               LA390 : $8154          33108
               LA5A1 : $81e6          33254
               LA5C7 : $81e7          33255
               LA5C9 : $81e9          33257
               LA5E8 : $9b2e          39726
               LA545 : $81a9          33193
               LA549 : $81ad          33197
               LA554 : $81b0          33200
               LA56B : $81d2          33234
               LA59A : $81df          33247
               LA6C6 : $81fc          33276
               LA6C7 : $81fe          33278
               LA8C1 : $8209          33289
               LA8D5 : $8216          33302
               LA928 : $8223          33315
               LA93F : $8229          33321
               LA937 : $8225          33317
               LA942 : $822c          33324
               LA948 : $8234          33332
               LA950 : $8242          33346
               LBAAE : $92bb          37563
               LBABA : $92c7          37575
               LBAB8 : $92c5          37573
               LBACA : $92d7          37591
               LBACC : $92d9          37593
               LBAC4 : $92d1          37585
               LBAC5 : $92d2          37586
               LBAD0 : $92dd          37597
               LBA1C : $9229          37417
               LBA1D : $922a          37418
               LBA18 : $9225          37413
               LBA3A : $9247          37447
               LBA3E : $924b          37451
               LBA3F : $924c          37452
               LBA39 : $9246          37446
AS09 Assembler for M6809 [1.42].                                     Page    7
--------------------------------- merge.a09 ----------------------------------

               LBA4F : $925c          37468
               LBA44 : $9251          37457
               LBA5C : $9269          37481
               LBA66 : $9273          37491
               LBA7B : $9288          37512
               LBA72 : $927f          37503
               LBA78 : $9285          37509
               LBA79 : $9286          37510
               LBA83 : $9290          37520
               LBA9A : $92a7          37543
               LBA91 : $929e          37534
               LBA92 : $929f          37535
               LBA97 : $92a4          37540
               LBBA4 : $93b1          37809
               LBBBD : $93ca          37834
               LBBDE : $93eb          37867
               LBBD0 : $93dd          37853
               LBBFC : $9409          37897
               LBBF8 : $9405          37893
               LBB00 : $930d          37645
               LBB02 : $930f          37647
               LBB03 : $9310          37648
               LBB2E : $933b          37691
               LBB2F : $933c          37692
               LBB20 : $932d          37677
               LBB48 : $9355          37717
               LBB5C : $9369          37737
               LBB6A : $9377          37751
               LBB61 : $936e          37742
               LBB63 : $9370          37744
               LBB67 : $9374          37748
               LBB7C : $9389          37769
               LBB7D : $938a          37770
               LBB8F : $939c          37788
               LBB82 : $938f          37775
               LBB89 : $9396          37782
               LBB91 : $939e          37790
               LBbcc : $93d9          37849
               LBCA0 : $94ad          38061
               LBCC3 : $94d0          38096
               LBCC8 : $94d5          38101
               LBCD7 : $94e4          38116
               LBCE4 : $94f1          38129
               LBC0B : $9418          37912
               LBC06 : $9413          37907
               LBC14 : $9421          37921
               LBC2A : $9437          37943
               LBC2F : $943c          37948
               LBC33 : $9440          37952
               LBC35 : $9442          37954
               LBC4A : $9457          37975
               LBC4C : $9459          37977
               LBC5F : $946c          37996
               LBC6D : $947a          38010
               LBC7C : $9489          38025
               LBC71 : $947e          38014
               LBC73 : $9480          38016
               LBC79 : $9486          38022
               LBC82 : $948f          38031
               LBC86 : $9493          38035
               LBC96 : $94a3          38051
               LBDA5 : $95b2          38322
AS09 Assembler for M6809 [1.42].                                     Page    8
--------------------------------- merge.a09 ----------------------------------

               LBDBB : $95c8          38344
               LBDB6 : $95c3          38339
               LBDCC : $95d9          38361
               LBDC0 : $95cd          38349
               LBDC5 : $95d2          38354
               LBDDC : $95e9          38377
               LBDD6 : $95e3          38371
               LBDD9 : $95e6          38374
               LBDE4 : $95f1          38385
               LBDFF : $960c          38412
               LBD09 : $9516          38166
               LBD11 : $951e          38174
               LBD12 : $951f          38175
               LBD2D : $953a          38202
               LBD25 : $9532          38194
               LBD31 : $953e          38206
               LBD35 : $9542          38210
               LBD53 : $9560          38240
               LBD55 : $9562          38242
               LBD59 : $9566          38246
               LBD6F : $957c          38268
               LBD61 : $956e          38254
               LBD65 : $9572          38258
               LBD7F : $958c          38284
               LBD78 : $9585          38277
               LBD86 : $9593          38291
               LBD99 : $95a6          38310
               LBEAB : $96b8          38584
               LBEA3 : $96b0          38576
               LBEBA : $96c7          38599
               LBEBC : $96c9          38601
               LBEB8 : $96c5          38597
               LBECD : $96da          38618
               LBEC0 : $96cd          38605
               LBEC5 : $96d2          38610
               LBEC9 : $96d6          38614
               LBEDD : $96ea          38634
               LBED1 : $96de          38622
               LBED5 : $96e2          38626
               LBED9 : $96e6          38630
               LBEEF : $96fc          38652
               LBEE1 : $96ee          38638
               LBEE5 : $96f2          38642
               LBEE9 : $96f6          38646
               LBEFC : $9709          38665
               LBEFF : $970c          38668
               LBEF0 : $96fd          38653
               LBE01 : $960e          38414
               LBE09 : $9616          38422
               LBE1F : $962c          38444
               LBE18 : $9625          38437
               LBE36 : $9643          38467
               LBE4B : $9658          38488
               LBE50 : $965d          38493
               LBE72 : $967f          38527
               LBE8C : $9699          38553
               LBE84 : $9691          38545
               LBE98 : $96a5          38565
               LBFA6 : $97af          38831
               LBFA9 : $97b2          38834
               LBFBD : $97c6          38854
               LBFB7 : $97c0          38848
AS09 Assembler for M6809 [1.42].                                     Page    9
--------------------------------- merge.a09 ----------------------------------

               LBFCD : $97d6          38870
               LBFC2 : $97cb          38859
               LBFC7 : $97d0          38864
               LBFC8 : $97d1          38865
               LBFDC : $97e5          38885
               LBFD2 : $97db          38875
               LBFD7 : $97e0          38880
               LBFE1 : $97ea          38890
               LBF0C : $9719          38681
               LBF01 : $970e          38670
               LBF3B : $9748          38728
               LBF38 : $9745          38725
               LBF45 : $9750          38736
              LBUFMX : $00fa            250
               LB0A8 : $88e1          35041
               LB0B9 : $88f2          35058
               LB0CD : $8906          35078
               LB0D5 : $890e          35086
               LB0E7 : $8920          35104
               LB0E8 : $8921          35105
               LB0FE : $8937          35127
               LB00F : $8857          34903
               LB01E : $8866          34918
               LB02F : $8873          34931
               LB03F : $8883          34947
               LB035 : $8879          34937
               LB04E : $888e          34958
               LB049 : $8889          34953
               LB069 : $88a6          34982
               LB08B : $88c4          35012
               LB09E : $88d7          35031
               LB098 : $88d1          35025
               LB1A7 : $89e0          35296
               LB1B8 : $89f1          35313
               LB1CB : $8a04          35332
               LB1CC : $8a05          35333
               LB1CE : $8a07          35335
               LB1C6 : $89ff          35327
               LB1DF : $8a18          35352
               LB1D4 : $8a0d          35341
               LB1EA : $8a23          35363
               LB1E2 : $8a1b          35355
               LB1E6 : $8a1f          35359
               LB1FA : $8a33          35379
               LB1F4 : $8a2d          35373
               LB10A : $8943          35139
               LB10C : $8945          35141
               LB101 : $893a          35130
               LB131 : $896a          35178
               LB134 : $896d          35181
               LB14F : $8988          35208
               LB141 : $897a          35194
               LB143 : $897c          35196
               LB145 : $897e          35198
               LB146 : $897f          35199
               LB148 : $8981          35201
               LB15A : $8993          35219
               LB153 : $898c          35212
               LB156 : $898f          35215
               LB158 : $8991          35217
               LB16A : $89a3          35235
               LB168 : $89a1          35233
AS09 Assembler for M6809 [1.42].                                     Page   10
--------------------------------- merge.a09 ----------------------------------

               LB181 : $89ba          35258
               LB19F : $89d8          35288
               LB2CE : $8b01          35585
               LB2C7 : $8afa          35578
               LB2C9 : $8afc          35580
               LB2D4 : $8b07          35591
               LB2D5 : $8b08          35592
               LB2ED : $8b20          35616
               LB2F1 : $8b24          35620
               LB2F4 : $8b27          35623
               LB201 : $8a3a          35386
               LB203 : $8a3c          35388
               LB22C : $8a65          35429
               LB22F : $8a68          35432
               LB220 : $8a59          35417
               LB222 : $8a5b          35419
               LB223 : $8a5c          35420
               LB24E : $8a87          35463
               LB244 : $8a7d          35453
               LB249 : $8a82          35458
               LB25F : $8a98          35480
               LB26A : $8aa3          35491
               LB26D : $8aa6          35494
               LB26F : $8aa8          35496
               LB262 : $8a9b          35483
               LB267 : $8aa0          35488
               LB27C : $8ab5          35509
               LB277 : $8ab0          35504
               LB284 : $8abd          35517
               LB287 : $8ac0          35520
               LB29F : $8ad6          35542
               LB290 : $8ac9          35529
               LB3AA : $8bdd          35805
               LB3AB : $8bde          35806
               LB3A2 : $8bd5          35797
               LB3DC : $8c0f          35855
               LB3DE : $8c11          35857
               LB3DF : $8c12          35858
               LB3E4 : $8c17          35863
               LB3E6 : $8c19          35865
               LB3E9 : $8c1c          35868
               LB3FE : $8c31          35889
               LB309 : $8b3c          35644
               LB32D : $8b60          35680
               LB328 : $8b5b          35675
               LB33F : $8b72          35698
               LB334 : $8b67          35687
               LB34B : $8b7e          35710
               LB348 : $8b7b          35707
               LB35A : $8b8d          35725
               LB35C : $8b8f          35727
               LB357 : $8b8a          35722
               LB37B : $8bae          35758
               LB371 : $8ba4          35748
               LB373 : $8ba6          35750
               LB385 : $8bb8          35768
               LB395 : $8bc8          35784
               LB4A0 : $8cd3          36051
               LB4A6 : $8cd9          36057
               LB4B9 : $8cec          36076
               LB4CD : $8d00          36096
               LB4CE : $8d01          36097
AS09 Assembler for M6809 [1.42].                                     Page   11
--------------------------------- merge.a09 ----------------------------------

               LB4D8 : $8d0b          36107
               LB4EB : $8d1e          36126
               LB4E6 : $8d19          36121
               LB4F3 : $8d26          36134
               LB40A : $8c3d          35901
               LB404 : $8c37          35895
               LB42A : $8c5d          35933
               LB43B : $8c6e          35950
               LB44A : $8c7d          35965
               LB44C : $8c7f          35967
               LB44F : $8c82          35970
               LB447 : $8c7a          35962
               LB46D : $8ca0          36000
               LB461 : $8c94          35988
               LB48C : $8cbf          36031
               LB5AA : $8ddd          36317
               LB5A0 : $8dd3          36307
               LB5A8 : $8ddb          36315
               LB5B2 : $8de5          36325
               LB5B4 : $8de7          36327
               LB5B6 : $8de9          36329
               LB5CA : $8dfd          36349
               LB5D2 : $8e05          36357
               LB5D8 : $8e0b          36363
               LB5EC : $8e1f          36383
               LB5EE : $8e21          36385
               LB5EF : $8e22          36386
               LB50D : $8d40          36160
               LB50F : $8d42          36162
               LB51A : $8d4f          36175
               LB51E : $8d51          36177
               LB511 : $8d44          36164
               LB516 : $8d49          36169
               LB518 : $8d4b          36171
               LB526 : $8d59          36185
               LB533 : $8d66          36198
               LB537 : $8d6a          36202
               LB539 : $8d6c          36204
               LB54C : $8d7f          36223
               LB543 : $8d76          36214
               LB555 : $8d88          36232
               LB558 : $8d8b          36235
               LB56D : $8da0          36256
               LB56F : $8da2          36258
               LB585 : $8db8          36280
               LB591 : $8dc4          36292
               LB593 : $8dc6          36294
               LB6AD : $8edf          36575
               LB6AE : $8ee0          36576
               LB6A4 : $8ed6          36566
               LB6B5 : $8ee7          36583
               LB6DE : $8f0f          36623
               LB6F5 : $8f26          36646
               LB60F : $8e41          36417
               LB62A : $8e5c          36444
               LB64A : $8e7c          36476
               LB64E : $8e80          36480
               LB643 : $8e75          36469
               LB645 : $8e77          36471
               LB654 : $8e86          36486
               LB657 : $8e89          36489
               LB659 : $8e8b          36491
AS09 Assembler for M6809 [1.42].                                     Page   12
--------------------------------- merge.a09 ----------------------------------

               LB66F : $8ea1          36513
               LB672 : $8ea4          36516
               LB675 : $8ea7          36519
               LB68F : $8ec1          36545
               LB680 : $8eb2          36530
               LB683 : $8eb5          36533
               LB686 : $8eb8          36536
               LB69B : $8ecd          36557
               LB69D : $8ecf          36559
               LB7B9 : $8fe3          36835
               LB7CB : $8ff2          36850
               LB7C2 : $8fec          36844
               LB7E0 : $9007          36871
               LB7E2 : $9009          36873
               LB7E6 : $900d          36877
               LB7F1 : $9018          36888
               LB7F3 : $901a          36890
               LB70B : $8f3c          36668
               LB70E : $8f3f          36671
               LB706 : $8f37          36663
               LB709 : $8f3a          36666
               LB73D : $8f6e          36718
               LB734 : $8f65          36709
               LB738 : $8f69          36713
               LB740 : $8f71          36721
               LB78D : $8fb6          36790
               LB783 : $8fae          36782
               LB784 : $8faf          36783
               LB789 : $8fb4          36788
               LB79F : $8fc9          36809
               LB797 : $8fc0          36800
               LB8A6 : $90ca          37066
               LB8A8 : $90cc          37068
               LB8CE : $90f2          37106
               LB8C2 : $90e6          37094
               LB8C6 : $90ea          37098
               LB8D2 : $90f6          37110
               LB8D4 : $90f8          37112
               LB8EA : $910e          37134
               LB8FE : $9120          37152
               LB8F1 : $9115          37141
               LB80A : $9031          36913
               LB801 : $9028          36904
               LB804 : $902b          36907
               LB814 : $903b          36923
               LB82D : $9051          36945
               LB820 : $9047          36935
               LB821 : $9048          36936
               LB829 : $904d          36941
               LB842 : $9066          36966
               LB844 : $9068          36968
               LB85A : $907e          36990
               LB85C : $9080          36992
               LB852 : $9076          36982
               LB86B : $908f          37007
               LB87C : $90a0          37024
               LB87E : $90a2          37026
               LB873 : $9097          37015
               LB88A : $90ae          37038
               LB886 : $90aa          37034
               LB89B : $90bf          37055
               LB89D : $90c1          37057
AS09 Assembler for M6809 [1.42].                                     Page   13
--------------------------------- merge.a09 ----------------------------------

               LB892 : $90b6          37046
               LB9AC : $91b9          37305
               LB9AF : $91bc          37308
               LB9A3 : $91b0          37296
               LB9BC : $91c9          37321
               LB9B1 : $91be          37310
               LB9B4 : $91c1          37313
               LB9B9 : $91c6          37318
               LB9CD : $91da          37338
               LB9C2 : $91cf          37327
               LB9C5 : $91d2          37330
               LB9EC : $91f9          37369
               LB9E2 : $91ef          37359
               LB9FB : $9208          37384
               LB902 : $9124          37156
               LB905 : $9127          37159
               LB907 : $9129          37161
               LB91B : $9137          37175
               LB91D : $9139          37177
               LB911 : $912d          37165
               LB918 : $9134          37172
               LB938 : $9154          37204
               LB949 : $915b          37211
               LB95C : $916e          37230
               LB954 : $9166          37222
               LB958 : $916a          37226
               LB965 : $9177          37239
               LB966 : $9178          37240
               LB97E : $9190          37264
               LB975 : $9187          37255
               LB977 : $9189          37257
               LB98E : $91a0          37280
               LB99C : $91a9          37289
               LB99F : $91ac          37292
               LB992 : $91a0          37280
               LB997 : $91a5          37285
               LC6EA : $a4e1          42209
               LC6E9 : $a4ce          42190
               LD24F : $a49c          42140
               LD25F : $a49f          42143
               LD256 : $a49f          42143
                LEFT : $8edd          36573
                 LEN : $8eb3          36531
                 LET : $87e6          34790
                  LF : $000a             10
              LINBUF : $00e1            225
                LINE : $a48c          42124
              LINHDR : $00df            223
                LIST : $8f8f          36751
                LL01 : $825a          33370
                LL02 : $827e          33406
                LL03 : $8282          33410
                LL04 : $8284          33412
                LL05 : $828c          33420
                LL06 : $83ce          33742
                LL07 : $83d0          33744
                LL08 : $83d2          33746
                LL09 : $83d4          33748
                LL10 : $83d6          33750
                LL11 : $83d8          33752
                LL12 : $83dc          33756
                LOAD : $a4ab          42155
AS09 Assembler for M6809 [1.42].                                     Page   14
--------------------------------- merge.a09 ----------------------------------

                 LOG : $98c5          39109
              LPTCFW : $0076            118
              LPTLCF : $0077            119
              LPTPOS : $0079            121
              LPTWID : $0078            120
              LSTTXT : $0066            102
   LV_StackBeginAddr : $7d5d          32093
               L8AAC : $9ecb          40651
               L8AB2 : $9ed1          40657
               L8AB9 : $9ed8          40664
               L8AC0 : $9edf          40671
               L8AC7 : $9ee6          40678
               L8ADD : $9efc          40700
               L8AD3 : $9ef2          40690
               L8AEB : $9f0a          40714
               L8AED : $9f0c          40716
               L8AEF : $9f0e          40718
               L8AE1 : $9f00          40704
               L8AE5 : $9f04          40708
               L8AE9 : $9f08          40712
               L8A02 : $9e21          40481
               L8A04 : $9e23          40483
               L8A2D : $9e4c          40524
               L8A20 : $9e3f          40511
               L8A3A : $9e59          40537
               L8A3D : $9e5c          40540
               L8A67 : $9e86          40582
               L8A68 : $9e87          40583
               L8A71 : $9e90          40592
               L8A77 : $9e96          40598
               L8A83 : $9ea2          40610
               L8A86 : $9ea5          40613
               L8A9B : $9eba          40634
               L8A90 : $9eaf          40623
               L8A91 : $9eb0          40624
               L8A95 : $9eb4          40628
               L8A99 : $9eb8          40632
               L8BAE : $9fca          40906
               L8BBE : $9fda          40922
               L8BC9 : $9fe5          40933
               L8BD9 : $9ff5          40949
               L8BEA : $a006          40966
               L8BE5 : $a001          40961
               L8BFF : $a01b          40987
               L8B1B : $9f37          40759
               L8B13 : $9f2f          40751
               L8B17 : $9f33          40755
               L8B24 : $9f40          40768
               L8B41 : $9f5d          40797
               L8B55 : $9f71          40817
               L8B67 : $9f83          40835
               L8B7B : $9f97          40855
               L8B7F : $9f9b          40859
               L8B71 : $9f8d          40845
               L8B8A : $9fa6          40870
               L8B8C : $9fa8          40872
               L8C0B : $a027          40999
               L8C07 : $a023          40995
               L8EAE : $a0ab          41131
               L8EA8 : $a0a5          41125
               L8EBB : $a0b8          41144
               L8EB4 : $a0b1          41137
AS09 Assembler for M6809 [1.42].                                     Page   15
--------------------------------- merge.a09 ----------------------------------

               L8EB7 : $a0b4          41140
               L8EB9 : $a0b6          41142
               L8EDD : $a0da          41178
               L8ED2 : $a0cf          41167
               L8ED8 : $a0d5          41173
               L8EEF : $a0ec          41196
               L8EE2 : $a0df          41183
               L8EFB : $a0f8          41208
               L8E3B : $a038          41016
               L8E37 : $a034          41012
               L8E5F : $a05c          41052
               L8E69 : $a066          41062
               L8E71 : $a06e          41070
               L8E82 : $a07f          41087
               L8E88 : $a085          41093
               L8E95 : $a092          41106
               L8FB3 : $a1b0          41392
               L8FC4 : $a1c1          41409
               L8FC6 : $a1c3          41411
               L8FD8 : $a1d5          41429
               L8FE3 : $a1e0          41440
               L8FE5 : $a1e2          41442
               L8FFA : $a1f7          41463
               L8FF2 : $a1ef          41455
               L8F1A : $a117          41239
               L8F20 : $a11d          41245
               L8F24 : $a121          41249
               L8F26 : $a123          41251
               L8F4F : $a14c          41292
               L8F41 : $a13e          41278
               L8F5A : $a157          41303
               L8F74 : $a171          41329
               L8F8F : $a18c          41356
               L8F96 : $a193          41363
               L8031 : $80d6          32982
               L83AB : $982a          38954
               L83A3 : $9823          38947
               L83A6 : $9826          38950
               L83B8 : $9837          38967
               L83C5 : $9844          38980
               L83DC : $985b          39003
               L83DF : $985e          39006
               L83D7 : $9856          38998
               L83EB : $986a          39018
               L83E0 : $985f          39007
               L83E1 : $9860          39008
               L83E6 : $9865          39013
               L83FA : $9879          39033
               L83FF : $987e          39038
               L83F0 : $986f          39023
               L83F5 : $9874          39028
               L837E : $97ff          38911
               L84AC : $992b          39211
               L84CA : $9948          39240
               L84CF : $994d          39245
               L84C4 : $9942          39234
               L84C9 : $9947          39239
               L84DE : $995c          39260
               L84D4 : $9952          39250
               L84D9 : $9957          39255
               L84ED : $996b          39275
               L84E3 : $9961          39265
AS09 Assembler for M6809 [1.42].                                     Page   16
--------------------------------- merge.a09 ----------------------------------

               L84E8 : $9966          39270
               L840E : $988d          39053
               L8404 : $9883          39043
               L8409 : $9888          39048
               L841D : $989c          39068
               L841E : $989d          39069
               L8413 : $9892          39058
               L8418 : $9897          39063
               L842D : $98ac          39084
               L8423 : $98a2          39074
               L8428 : $98a7          39079
               L843C : $98bb          39099
               L8432 : $98b1          39089
               L8437 : $98b6          39094
               L8441 : $98c0          39104
               L8489 : $9908          39176
               L8491 : $9910          39184
               L85AB : $9a29          39465
               L85AF : $9a2d          39469
               L85B3 : $9a31          39473
               L85B4 : $9a32          39474
               L85B6 : $9a34          39476
               L85C2 : $9a40          39488
               L85C3 : $9a41          39489
               L85C7 : $9a45          39493
               L85DE : $9a5c          39516
               L85D1 : $9a4f          39503
               L85D5 : $9a53          39507
               L85F3 : $9a71          39537
               L85F5 : $9a73          39539
               L8501 : $997f          39295
               L8504 : $9982          39298
               L852C : $99aa          39338
               L8529 : $99a7          39335
               L8538 : $99b6          39350
               L854D : $99cb          39371
               L855C : $99da          39386
               L855D : $99db          39387
               L857D : $99fb          39419
               L8570 : $99ee          39406
               L858A : $9a08          39432
               L858C : $9a0a          39434
               L8581 : $99ff          39423
               L859D : $9a1b          39451
               L8592 : $9a10          39440
               L86A6 : $9b24          39716
               L86D6 : $9b4a          39754
               L86EB : $9b5f          39775
               L86FD : $9b71          39793
               L860F : $9a8d          39565
               L861E : $9a9c          39580
               L8613 : $9a91          39569
               L862E : $9aac          39596
               L8625 : $9aa3          39587
               L8626 : $9aa4          39588
               L8630 : $9aae          39598
               L8634 : $9ab2          39602
               L864A : $9ac8          39624
               L8646 : $9ac4          39620
               L865C : $9ada          39642
               L8650 : $9ace          39630
               L8659 : $9ad7          39639
AS09 Assembler for M6809 [1.42].                                     Page   17
--------------------------------- merge.a09 ----------------------------------

               L866B : $9ae9          39657
               L8665 : $9ae3          39651
               L867C : $9afa          39674
               L8679 : $9af7          39671
               L8685 : $9b03          39683
               L8687 : $9b05          39685
               L8694 : $9b12          39698
               L87BE : $9c31          39985
               L87CD : $9c40          40000
               L87DF : $9c52          40018
               L87D6 : $9c49          40009
               L87D8 : $9c4b          40011
               L87D9 : $9c4c          40012
               L87EB : $9c5e          40030
               L870E : $9b82          39810
               L872E : $9ba2          39842
               L8724 : $9b98          39832
               L8727 : $9b9b          39835
               L873F : $9bb3          39859
               L8746 : $9bba          39866
               L8748 : $9bbc          39868
               L876B : $9bdf          39903
               L8768 : $9bdc          39900
               L877B : $9bef          39919
               L8776 : $9bea          39914
               L879C : $9c10          39952
               L88A1 : $9d12          40210
               L88B1 : $9d22          40226
               L88B4 : $9d25          40229
               L88D9 : $9d4a          40266
               L88EF : $9d60          40288
               L880A : $9c7d          40061
               L880C : $9c7f          40063
               L880E : $9c81          40065
               L8800 : $9c73          40051
               L881F : $9c92          40082
               L882E : $9ca1          40097
               L8834 : $9ca7          40103
               L8845 : $9cb8          40120
               L886E : $9ce1          40161
               L8862 : $9cd5          40149
               L8866 : $9cd9          40153
               L89AE : $9ddc          40412
               L89BF : $9ded          40429
               L89B4 : $9de2          40418
               L89B8 : $9de6          40422
               L89C0 : $9dee          40430
               L89D2 : $9df3          40435
               L89E1 : $9e02          40450
               L89FC : $9e1b          40475
               L890B : $8446          33862
               L890D : $8448          33864
               L890F : $9d61          40289
               L891C : $9d6e          40302
               L892C : $9d7e          40318
               L8927 : $9d79          40313
               L8943 : $9d95          40341
               L8944 : $9d96          40342
               L898C : $9dba          40378
               L899F : $9dcd          40397
               L8990 : $9dbe          40382
               L8992 : $9dc0          40384
AS09 Assembler for M6809 [1.42].                                     Page   18
--------------------------------- merge.a09 ----------------------------------

               L8993 : $9dc1          40385
               L90AA : $a2a7          41639
               L90A9 : $a2a6          41638
               L90BD : $a2ba          41658
               L90BF : $a2bc          41660
               L90B2 : $a2af          41647
               L90B3 : $a2b0          41648
               L90B8 : $a2b5          41653
               L90CB : $a2c8          41672
               L90EA : $a2e7          41703
               L90EE : $a2eb          41707
               L90E2 : $a2df          41695
               L90FF : $a2fc          41724
               L9011 : $a20e          41486
               L9015 : $a212          41490
               L902C : $a229          41513
               L9023 : $a220          41504
               L9050 : $a24d          41549
               L9054 : $a251          41553
               L9060 : $a25d          41565
               L9065 : $a262          41570
               L907C : $a279          41593
               L909E : $a29b          41627
               L9096 : $a293          41619
               L91A0 : $a39d          41885
               L91BA : $a3b7          41911
               L91B6 : $a3b3          41907
               L91CC : $a3c9          41929
               L91CD : $a3ca          41930
               L91C4 : $a3c1          41921
               L91D0 : $a3cd          41933
               L91E4 : $a3e1          41953
               L91E9 : $a3e6          41958
               L91F1 : $a3ee          41966
               L910D : $a30a          41738
               L9108 : $a305          41733
               L911B : $a318          41752
               L9116 : $a313          41747
               L9129 : $a326          41766
               L913C : $a339          41785
               L9130 : $a32d          41773
               L9141 : $a33e          41790
               L915A : $a357          41815
               L916F : $a36c          41836
               L9167 : $a364          41828
               L9177 : $a374          41844
               L9185 : $a382          41858
               L919E : $a39b          41883
               L9200 : $a3fd          41981
               L9202 : $a3ff          41983
               L9211 : $a40e          41998
               L9213 : $a410          42000
               L9235 : $a432          42034
               L924D : $a44a          42058
               L9249 : $a446          42054
               L9256 : $a453          42067
               L926A : $a467          42087
               L9262 : $a45f          42079
               L9263 : $a460          42080
               L927A : $a477          42103
               L927B : $a478          42104
               L928E : $a48b          42123
AS09 Assembler for M6809 [1.42].                                     Page   19
--------------------------------- merge.a09 ----------------------------------

               L9281 : $a47e          42110
              list_i : $fda0           -608
                loop : $edb1          60849
              MAXLIN : $00fa            250
                 MEM : $8d21          36129
              MEMSIZ : $0027             39
                 MID : $8f00          36608
            MISO_REA : $aac6          43718
  MONITOR_PROCESS_ID : $0010             16
         MON_VERSION : $f0f2          61682
            MOSI_HIG : $aab4          43700
            MOSI_LOW : $aabd          43709
         MonSavReg_S : $7fee          32750
                main : $edab          60843
             msDelay : $fb26          64294
                 NEW : $856a          34154
             NEWLINE : $8085          32901
                NEXT : $8931          35121
             NewAddr : $0004              4
                 NMI : $fb80          64384
         NUM_SEC_FNS : $001d             29
              Offset : $0002              2
              OLDPTR : $002d             45
              OLDTXT : $0029             41
                  ON : $879f          34719
            openFile : $e6a8          59048
                PEEK : $8f81          36737
             PIAinit : $f079          61561
            PIA_ClrC : $f0a1          61601
              PIA_In : $f091          61585
             PIA_Out : $f08b          61579
            PIA_SetC : $f096          61590
                POKE : $8f88          36744
               PORTA : $d800          55296
               PORTB : $d802          55298
                 POS : $9b2a          39722
               PRINT : $911b          37147
              PROGST : $0207            519
              PUTCHR : $805c          32860
              PUTEND : $8087          32903
             PUTEXIT : $8079          32889
              PUTSTR : $fa89          64137
            print_De : $fa89          64137
             RAM_END : $7fff          32767
             RAM_ORG : $0000              0
            RbDectCR : $7fe2          32738
              RbHead : $7fc0          32704
              RbSize : $0020             32
              RbTail : $7fc1          32705
             Rbuffer : $7fc2          32706
              RdAddr : $0000              0
            RdRepeat : $0002              2
                READ : $8886          34950
              RELFLG : $000a             10
              RELPTR : $003d             61
                 REM : $8740          34624
               RENUM : $9e28          40488
               RESET : $ed3a          60730
              RESSGN : $0062             98
              RESTOR : $864c          34380
              RESVEC : $808b          32907
              RETURN : $871d          34589
AS09 Assembler for M6809 [1.42].                                     Page   20
--------------------------------- merge.a09 ----------------------------------

               RIGHT : $8ef9          36601
                 RND : $972c          38700
        ROMcheckSTR0 : $f9e9          63977
        ROMcheckSTR1 : $f9f7          63991
        ROMcheckSTR2 : $fa04          64004
        ROMcheckSTR3 : $fa1d          64029
            ROM0_ORG : $e000          57344
            ROM1_ORG : $8000          32768
       ROM_Integrity : $fff0          65520
               RSEED : $977d          38781
                 RUN : $86d8          34520
              RVSEED : $009e            158
            rCluster : $fff7             -9
            rsvSecCn : $ffed            -19
                SAVE : $a4b7          42167
            SCK_HIGH : $aacf          43727
             SCK_LOW : $aad8          43736
             SD_Init : $acbb          44219
            SD_readS : $ae0d          44557
            SD_sendC : $aba9          43945
            SD_write : $ae9b          44699
              SECTOK : $8641          34369
         SELECTBANK0 : $f924          63780
         SELECTBANK1 : $f92d          63789
                 SET : $81ee          33262
                 SGN : $9487          38023
                 SIN : $9781          38785
                SKP1 : $0021             33
              SKP1LD : $0086            134
                SKP2 : $008c            140
               SOUND : $8237          33335
               SPACE : $0020             32
            SPI_Disa : $aba0          43936
            SPI_Enab : $ab97          43927
            SPI_Init : $aae1          43745
            SPI_Read : $ab6e          43886
            SPI_Rsyn : $ab22          43810
              SPI_R1 : $ab7f          43903
            SPI_Writ : $ab06          43782
           SPI_Write : $ab06          43782
              SPI_W0 : $ab0a          43786
              SPI_W1 : $ab17          43799
              SPI_W2 : $ab19          43801
                 SQR : $98ff          39167
        SRecCheckSum : $0001              1
              STKBUF : $003a             58
                STOP : $866e          34414
                 STR : $8d30          36144
              STRBUF : $01dc            476
              STRDES : $0056             86
              STRING : $9bc2          39874
              STRSTK : $00b7            183
              STRTAB : $0023             35
           STR_BASIC : $ee80          61056
              STR_BP : $f754          63316
             STR_BP1 : $f76e          63342
      STR_CMDinvalid : $f8bd          63677
          STR_CMD_LD : $f5ab          62891
       STR_CMD_LDBAS : $f839          63545
    STR_CMD_LDBASEND : $f851          63569
         STR_CMD_LD2 : $f5cc          62924
         STR_CMD_LD3 : $f5dd          62941
AS09 Assembler for M6809 [1.42].                                     Page   21
--------------------------------- merge.a09 ----------------------------------

         STR_CMD_LD4 : $f5f2          62962
          STR_CMD_rd : $f3d7          62423
          STR_CMD_wr : $f467          62567
         STR_COMMAND : $f135          61749
          STR_EWdone : $f4e7          62695
             STR_EW1 : $f4b7          62647
             STR_EW2 : $f4c1          62657
             STR_EW3 : $f4d0          62672
             STR_EW4 : $f4d5          62677
           STR_EW_CS : $f4fe          62718
              STR_GO : $f6d6          63190
         STR_MONITOR : $f0fa          61690
             STR_QBP : $f7de          63454
            STR_QBP1 : $f7f3          63475
              STR_ST : $f714          63252
         STR_VERSION : $f118          61720
                SWI1 : $fbf2          64498
           SWI1_STR1 : $fb88          64392
           SWI1_STR2 : $fbd4          64468
           SWI1_STR3 : $fbef          64495
                SWI2 : $fc9f          64671
                SWI3 : $fc9f          64671
       sAPLgetOutput : $ef14          61204
   sAPL_KeyboardData : $ef1f          61215
             sCMDbas : $f899          63641
              sCMDbp : $f786          63366
              sCMDew : $f50b          62731
            sCMDextr : $f8d8          63704
              sCMDgo : $f6e3          63203
            sCMDhelp : $f39b          62363
         sCMDinvalid : $f8d1          63697
              sCMDld : $f603          62979
           sCMDldbas : $f856          63574
             sCMDqbp : $f80a          63498
              sCMDrd : $f3aa          62378
             sCMDStp : $f723          63267
              sCMDwr : $f420          62496
          sExtrNByte : $f8fc          63740
            searchNe : $e3fc          58364
            secPerCl : $ffef            -17
            sectorNu : $fda6           -602
    sendCharToScreen : $ef61          61281
     sendClearScreen : $efa4          61348
            sendCont : $f042          61506
   sendContainerData : $f042          61506
             setPins : $aa84          43652
            setpoint : $efc1          61377
          setpointXY : $efc1          61377
            setSound : $f025          61477
             setTile : $efe5          61413
             setTone : $f005          61445
            set_QByt : $e17c          57724
            set_Word : $e174          57716
           sHEX2TEXT : $fb06          64262
         sHEX2TEXT_1 : $fb10          64272
         sHEX2TEXT_2 : $fb12          64274
        sMONITORMENU : $f30f          62223
       sMONITORSTART : $f2ed          62189
        sMON_PORT_RD : $c000          49152
        sMON_PORT_WR : $ecdf          60639
      sMonProcessCmd : $f357          62295
             sPUTSTR : $f91c          63772
AS09 Assembler for M6809 [1.42].                                     Page   22
--------------------------------- merge.a09 ----------------------------------

             sRbInit : $f322          62242
             sRbRead : $f332          62258
          sRbReadCmd : $f32c          62252
           sROMcheck : $fa2d          64045
       sROMcheckdone : $fa63          64099
             sStrlen : $fa76          64118
           sTEXT2HEX : $fb13          64275
         sTEXT2HEX_1 : $fb1b          64283
        sTEXT2HEX_11 : $fb23          64291
         sTEXT2HEX_2 : $fb25          64293
           sWLSL4bit : $fa80          64128
                 TAN : $9801          38913
              TEMPPT : $000b             11
              TEMPTR : $000f             15
              TINPTR : $002f             47
              TMPLOC : $0003              3
              TMPTR1 : $0011             17
            TOK_DATA : $0086            134
            TOK_ELSE : $0084            132
          TOK_EQUALS : $00b5            181
          TOK_FF_USR : $ff83          65411
              TOK_FN : $00b7            183
              TOK_GO : $0081            129
         TOK_GREATER : $00b4            180
       TOK_HIGH_EXEC : $00a5            165
              TOK_IF : $0085            133
           TOK_INKEY : $0098            152
           TOK_INPUT : $0089            137
            TOK_LEFT : $0095            149
             TOK_MID : $0097            151
           TOK_MINUS : $00ae            174
             TOK_NOT : $00aa            170
            TOK_PLUS : $00ad            173
           TOK_PRINT : $0087            135
             TOK_REM : $0082            130
          TOK_SNGL_Q : $0083            131
            TOK_STEP : $00ab            171
             TOK_SUB : $00a8            168
             TOK_TAB : $00a6            166
            TOK_THEN : $00a9            169
              TOK_TO : $00a7            167
           TOK_USING : $00b8            184
             TOK_USR : $0083            131
              TOPRAM : $0071            113
              TOSCRN : $8076          32886
              TRCFLG : $008c            140
              TRELFL : $003f             63
               TROFF : $9b26          39718
                TRON : $9b25          39717
              TXTTAB : $0019             25
            totalClu : $fff3            -13
                UART : $d000          53248
           UART_Init : $f0ac          61612
            UartRead : $f0cb          61643
          USB_COM_RD : $c000          49152
          USB_COM_WR : $c800          51200
              USRADR : $008d            141
              USRJMP : $009b            155
                USR0 : $00a3            163
            unusedSe : $ffe9            -23
                 VAB : $0088            136
                 VAC : $0089            137
AS09 Assembler for M6809 [1.42].                                     Page   23
--------------------------------- merge.a09 ----------------------------------

                 VAD : $008a            138
                 VAE : $008b            139
                 VAL : $8f47          36679
              VALTYP : $0006              6
              VARDES : $003b             59
              VARNAM : $0037             55
               VARPT : $9b32          39730
              VARPTR : $0039             57
              VARTAB : $001b             27
                 VCF : $008f            143
                 VDA : $009a            154
                 VD1 : $0091            145
                 VD3 : $0093            147
                 VD5 : $0095            149
                 VD7 : $0097            151
                 VD8 : $0098            152
                 VD9 : $0099            153
             VERSION : $ece3          60643
                 V4A : $004a             74
                 V4B : $004b             75
                 V4D : $004d             77
                 V40 : $0040             64
                 V41 : $0041             65
                 V42 : $0042             66
                 V43 : $0043             67
                 V44 : $0044             68
                 V45 : $0045             69
                 V46 : $0046             70
                 V47 : $0047             71
                 V48 : $0048             72
            V_SdHigh : $ffff             -1
              WrAddr : $0000              0
              WrData : $0002              2
            WriteEEP : $f936          63798
            WrRepeat : $0003              3
             waitCTS : $f0ea          61674
            waitdata : $f0d6          61654
        waitSendDone : $f0e2          61666
              XVEC15 : $9cb9          40121
              XVEC19 : $9c58          40024
               XVEC9 : $a08d          41101
                ZERO : $0074            116
          _APL_init0 : $ee37          60983
          _APL_init1 : $ee62          61026
          _APL_init2 : $ee6e          61038
          _APL_init3 : $ee77          61047
          _APL_init4 : $ee7d          61053
  _APL_KeyboardData1 : $ef2f          61231
  _APL_KeyboardData2 : $ef39          61241
  _APL_OutputStream1 : $eeed          61165
  _APL_OutputStream2 : $eef1          61169
  _APL_OutputStream5 : $ef0e          61198
      _BASICprocess0 : $eeb5          61109
      _BASICprocess1 : $eeb9          61113
      _BASICprocess2 : $eebb          61115
               _firq : $fb7b          64379
              _firq0 : $fb7f          64383
            _GLOBALS : $0260            608
     _getCheckSum160 : $fa6a          64106
       _getKeyboard1 : $ef54          61268
       _getKeyboard2 : $ef58          61272
               _irq0 : $fb43          64323
AS09 Assembler for M6809 [1.42].                                     Page   24
--------------------------------- merge.a09 ----------------------------------

               _irq1 : $fb51          64337
               _irq2 : $fb61          64353
              _irq22 : $fb6e          64366
               _irq3 : $fb70          64368
              _loop1 : $edc7          60871
              _loop2 : $edd6          60886
           _msDelay0 : $fb29          64297
               _nmi0 : $fb87          64391
          _no_change : $f958          63832
            _putstr0 : $fa8d          64141
            _putstr1 : $fa96          64150
     _sAPLgetOutput1 : $ef14          61204
     _sAPLgetOutput2 : $ef1e          61214
        _sCMDbasdone : $f8bc          63676
           _sCMDbas0 : $f8a0          63648
           _sCMDbas1 : $f8ad          63661
         _sCMDbpdone : $f7dd          63453
      _sCMDbpInvalid : $f7a2          63394
            _sCMDbp1 : $f7a7          63399
            _sCMDbp2 : $f7be          63422
         _sCMDewdone : $f5a7          62887
     _sCMDewInvalid0 : $f543          62787
     _sCMDewInvalid1 : $f541          62785
     _sCMDewInvalid2 : $f53f          62783
     _sCMDewInvalid3 : $f53d          62781
            _sCMDew1 : $f549          62793
        _sCMDexe_rd0 : $f3dd          62429
        _sCMDexe_rd1 : $f3e3          62435
        _sCMDexe_rd2 : $f3f1          62449
        _sCMDexe_wr1 : $f474          62580
        _sCMDexe_wr2 : $f482          62594
        _sCMDextrEnd : $f8fb          63739
          _sCMDextr0 : $f8db          63707
         _sCMDgodone : $f713          63251
      _sCMDgoInvalid : $f6f1          63217
            _sCMDgo0 : $f6f6          63222
            _sCMDgo1 : $f70a          63242
           _sCMDhelp : $f3a9          62377
         _sCMDldbas0 : $f86a          63594
         _sCMDldbas1 : $f86d          63597
         _sCMDldbas2 : $f87e          63614
         _sCMDlddone : $f6c0          63168
      _sCMDldInvalid : $f638          63032
            _sCMDld0 : $f63e          63038
           _sCMDld00 : $f625          63013
           _sCMDld01 : $f648          63048
            _sCMDld1 : $f695          63125
            _sCMDld2 : $f6bd          63165
        _sCMDqbpdone : $f838          63544
           _sCMDqbp0 : $f82a          63530
           _sCMDqbp1 : $f832          63538
         _sCMDrddone : $f419          62489
      _sCMDrdinvalid : $f3d2          62418
        _sCMDstpdone : $f753          63315
     _sCMDstpInvalid : $f731          63281
           _sCMDstp0 : $f736          63286
         _sCMDwrdone : $f4ae          62638
      _sCMDwrInvalid : $f461          62561
            _sCMDwr1 : $f46e          62574
           _sCursor1 : $ef87          61319
           _sExtrEnd : $f919          63769
        _sExtrNByte0 : $f901          63745
AS09 Assembler for M6809 [1.42].                                     Page   25
--------------------------------- merge.a09 ----------------------------------

       _sendCtnData1 : $f064          61540
            _setGVpt : $af77          44919
     _sMonProcessCmd : $f39a          62362
           _sRbRead1 : $f349          62281
          _sRbRead11 : $f350          62288
           _sRbRead2 : $f354          62292
           _sRbRead3 : $f356          62294
             _sROMok : $fa5c          64092
        _sstrlenDone : $fa7f          64127
           _sstrlen1 : $fa77          64119
             _strcmp : $aa49          43593
             _strcpy : $aa27          43559
             _strlen : $a9f4          43508
              _swi10 : $fbf9          64505
              _swi12 : $fc93          64659
          _UartRead1 : $f0d5          61653
            _u32_add : $a8da          43226
            _u32_and : $a6f9          42745
            _u32_dec : $a8ac          43180
            _u32_div : $a720          42784
            _u32_equ : $a990          43408
            _u32_hig : $a9bb          43451
            _u32_inc : $a929          43305
            _u32_low : $a957          43351
            _u32_mul : $a78c          42892
            _u32_sub : $a870          43120
          _WriteEEP1 : $f944          63812
          _WriteEEP2 : $f94d          63821
          _WriteEEP5 : $f96f          63855
          _waitdata1 : $f0d7          61655
          _waitdata2 : $f0e1          61665
              _00001 : $ecaa          60586
              _00009 : $ecc4          60612
              _00020 : $ecda          60634
              _09000 : $ecc9          60617
              _09001 : $ecd1          60625
              _09009 : $ecd9          60633
                 _10 : $a98c          43404
                _100 : $b43a          46138
                _101 : $b44f          46159
                _102 : $b568          46440
                _103 : $b4db          46299
                _104 : $b4af          46255
                _105 : $b565          46437
                _106 : $b565          46437
                _107 : $b56d          46445
                _108 : $bc4f          48207
                _109 : $b7ca          47050
                 _11 : $a987          43399
                _110 : $b5e6          46566
                _111 : $b61c          46620
                _112 : $b619          46617
                _113 : $b649          46665
                _114 : $b698          46744
                _115 : $b66b          46699
                _116 : $b698          46744
                _117 : $b7c7          47047
                _118 : $b6cc          46796
                _119 : $b7bb          47035
                 _12 : $a9b7          43447
                _120 : $b754          46932
                _121 : $bc4c          48204
AS09 Assembler for M6809 [1.42].                                     Page   26
--------------------------------- merge.a09 ----------------------------------

                _122 : $bc4c          48204
                _123 : $b814          47124
                _124 : $b7e1          47073
                _125 : $b801          47105
                _126 : $b835          47157
                _127 : $b908          47368
                _128 : $b885          47237
                _129 : $b8ed          47341
                 _13 : $a9f0          43504
                _130 : $bc4c          48204
                _131 : $b91c          47388
                _132 : $bb2e          47918
                _133 : $b933          47411
                _134 : $bb1a          47898
                _135 : $b979          47481
                _136 : $bb1a          47898
                _137 : $b980          47488
                _138 : $bb09          47881
                _139 : $b9b5          47541
                 _14 : $a9eb          43499
                _140 : $bb09          47881
                _141 : $b9cd          47565
                _142 : $ba00          47616
                _143 : $b9d1          47569
                _144 : $b9f7          47607
                _145 : $bae8          47848
                _146 : $bbff          48127
                _147 : $bbf8          48120
                _148 : $bbff          48127
                _149 : $bc23          48163
                 _15 : $aa20          43552
                _150 : $bc4f          48207
                _151 : $bcc3          48323
                _152 : $be97          48791
                _153 : $be8d          48781
                _154 : $bcc7          48327
                _155 : $bceb          48363
                _156 : $bd8e          48526
                _157 : $bd63          48483
                _158 : $bd07          48391
                _159 : $bd5a          48474
                 _16 : $a9fe          43518
                _160 : $bd3a          48442
                _161 : $bd5a          48474
                _162 : $be8d          48781
                _163 : $be69          48745
                _164 : $be2e          48686
                _165 : $be58          48728
                _166 : $bed5          48853
                _167 : $bf6b          49003
                _168 : $bf17          48919
                _169 : $bf44          48964
                 _17 : $aa47          43591
                _170 : $bf6b          49003
                _171 : $bfc3          49091
                _172 : $bf88          49032
                _173 : $bfb9          49081
                _174 : $bfa9          49065
                _175 : $bfd5          49109
                _176 : $e040          57408
                _177 : $e005          57349
                _178 : $e036          57398
AS09 Assembler for M6809 [1.42].                                     Page   27
--------------------------------- merge.a09 ----------------------------------

                _179 : $e026          57382
                 _18 : $aa3f          43583
                _180 : $e052          57426
                _181 : $e162          57698
                _182 : $e168          57704
                _183 : $e27e          57982
                _184 : $e246          57926
                _185 : $e275          57973
                _186 : $e268          57960
                _187 : $e2b6          58038
                _188 : $e336          58166
                _189 : $e332          58162
                 _19 : $aa2d          43565
                _190 : $e35c          58204
                _191 : $e358          58200
                _192 : $e382          58242
                _193 : $e37e          58238
                _194 : $e3be          58302
                _195 : $e3aa          58282
                _196 : $e3db          58331
                _197 : $e3eb          58347
                _198 : $e52f          58671
                _199 : $e412          58386
                  _2 : $a78a          42890
                 _20 : $aa80          43648
                _200 : $e508          58632
                _201 : $e48a          58506
                _202 : $e4ff          58623
                _203 : $e4ff          58623
                _204 : $e56b          58731
                _205 : $e546          58694
                _206 : $e562          58722
                _207 : $e562          58722
                _208 : $e57c          58748
                _209 : $e5ac          58796
                 _21 : $aa4d          43597
                _210 : $e580          58752
                _211 : $e5a3          58787
                _212 : $e5d0          58832
                _213 : $e5b1          58801
                _214 : $e5c7          58823
                _215 : $e636          58934
                _216 : $e5dc          58844
                _217 : $e62d          58925
                _218 : $e611          58897
                _219 : $e62d          58925
                 _22 : $aa7e          43646
                _220 : $e62d          58925
                _221 : $e611          58897
                _222 : $e69b          59035
                _223 : $e63a          58938
                _224 : $e692          59026
                _225 : $e67d          59005
                _226 : $e692          59026
                _227 : $e8fa          59642
                _228 : $e8a7          59559
                _229 : $e89d          59549
                 _23 : $ab04          43780
                _230 : $e6d4          59092
                _231 : $e832          59442
                _232 : $e6e9          59113
                _233 : $e825          59429
AS09 Assembler for M6809 [1.42].                                     Page   28
--------------------------------- merge.a09 ----------------------------------

                _234 : $e825          59429
                _235 : $e724          59172
                _236 : $e819          59417
                _237 : $e755          59221
                _238 : $e819          59417
                _239 : $e7ab          59307
                 _24 : $aaed          43757
                _240 : $e772          59250
                _241 : $e7a1          59297
                _242 : $e7a1          59297
                _243 : $e819          59417
                _244 : $e89d          59549
                _245 : $e89d          59549
                _246 : $e898          59544
                _247 : $e8fa          59642
                _248 : $e93a          59706
                _249 : $e96d          59757
                 _25 : $aafb          43771
                _250 : $e9ea          59882
                _251 : $e9be          59838
                _252 : $e9cf          59855
                _253 : $eca6          60582
                _254 : $e9fd          59901
                _255 : $ec38          60472
                _256 : $ea13          59923
                _257 : $ec2b          60459
                _258 : $ea4d          59981
                _259 : $ec2b          60459
                 _26 : $ab67          43879
                _260 : $ea52          59986
                _261 : $ec1f          60447
                _262 : $ea7b          60027
                _263 : $ec1f          60447
                _264 : $eace          60110
                _265 : $ea9a          60058
                _266 : $eac0          60096
                _267 : $eac0          60096
                _268 : $ec1f          60447
                _269 : $eb2f          60207
                 _27 : $ab52          43858
                _270 : $ebac          60332
                _271 : $ec1f          60447
                _272 : $ebac          60332
                _273 : $ec15          60437
                _274 : $eca3          60579
                _275 : $ec9c          60572
                 _28 : $ab34          43828
                 _29 : $ab45          43845
                  _3 : $a732          42802
                 _30 : $ac7a          44154
                 _31 : $ac19          44057
                 _32 : $ac19          44057
                 _33 : $ac02          44034
                 _34 : $ac64          44132
                 _35 : $ac6e          44142
                 _36 : $acb1          44209
                 _37 : $aca4          44196
                 _38 : $aca8          44200
                 _39 : $ad06          44294
                  _4 : $a76a          42858
                 _40 : $acfe          44286
                 _41 : $acda          44250
AS09 Assembler for M6809 [1.42].                                     Page   29
--------------------------------- merge.a09 ----------------------------------

                 _42 : $acfe          44286
                 _43 : $ad59          44377
                 _44 : $ad51          44369
                 _45 : $ad1f          44319
                 _46 : $ad51          44369
                 _47 : $ada8          44456
                 _48 : $ada0          44448
                 _49 : $ad5e          44382
                  _5 : $a8aa          43178
                 _50 : $ada0          44448
                 _51 : $ae04          44548
                 _52 : $adeb          44523
                 _53 : $ade3          44515
                 _54 : $adbd          44477
                 _55 : $ade3          44515
                 _56 : $ae04          44548
                 _57 : $ae48          44616
                 _58 : $ae40          44608
                 _59 : $ae1b          44571
                  _6 : $a8d8          43224
                 _60 : $ae40          44608
                 _61 : $ae63          44643
                 _62 : $ae8b          44683
                 _63 : $ae67          44647
                 _64 : $ae7f          44671
                 _65 : $aed6          44758
                 _66 : $aece          44750
                 _67 : $aea9          44713
                 _68 : $aece          44750
                 _69 : $af11          44817
                  _7 : $a927          43303
                 _70 : $aeee          44782
                 _71 : $af05          44805
                 _72 : $af42          44866
                 _73 : $af6d          44909
                 _74 : $af4b          44875
                 _75 : $af6b          44907
                 _76 : $afa5          44965
                 _77 : $b3b1          46001
                 _78 : $b0a5          45221
                 _79 : $b0a2          45218
                  _8 : $a91b          43291
                 _80 : $b3a2          45986
                 _81 : $b3a2          45986
                 _82 : $b0b9          45241
                 _83 : $b24e          45646
                 _84 : $b170          45424
                 _85 : $b10b          45323
                 _86 : $b151          45393
                 _87 : $b22d          45613
                 _88 : $b3a2          45986
                 _89 : $b39e          45982
                  _9 : $a955          43349
                 _90 : $b2a4          45732
                 _91 : $b2cf          45775
                 _92 : $b315          45845
                 _93 : $b3a2          45986
                 _94 : $b3b1          46001
                 _95 : $b3cc          46028
                 _96 : $b3ef          46063
                 _97 : $b407          46087
                 _98 : $b44f          46159
AS09 Assembler for M6809 [1.42].                                     Page   30
--------------------------------- merge.a09 ----------------------------------

                 _99 : $b43a          46138
            __6809__ : $0001              1

1796 labels used

14713 lines read, no errors in pass 1.
AS09 Assembler for M6809 [1.42].                                     Page   31
--------------------------------- merge.a09 ----------------------------------

                        
                        ; SBC system hardware version 1.0, clock 8.0 MHz
                        ; for AS09 Assembler for M6809 [1.42]
                        
                        ;{ ---------------------------------------------------
                        ;-----------------------CSRAM-------------------------
0000 =                  RAM_ORG				equ		$0000
7fff =                  RAM_END				equ		$7FFF 	; max 32KB size
                        
                        ;-----------------------CS0_1-------------------------
8000 =                  ROM1_ORG			equ		$8000 	; second SBC ROM, 16K section b
                        
                        ;-----------------------CS2---------------------------
c000 =                  USB_COM_RD			equ		$c000
c800 =                  USB_COM_WR			equ		$c800
d000 =                  UART				equ		$d000
d800 =                  PORTA				equ		$d800
d801 =                  CRA					equ		$d801
d802 =                  PORTB				equ		$d802
d803 =                  CRB					equ		$d803
                        
                        ;-----------------------CS3---------------------------
e000 =                  ROM0_ORG  			equ		$e000  	; first SBC ROM, 8K section 
fff0 =                  ROM_Integrity		equ		$fff0 	; SBC ROM0 checksum data ch
fff2 =                  INT_VECTOR			equ		$fff2
                        ;}
                        
                        
                        ******************************************************
                        ;
                        ; Microsoft Color Computer Basic
                        
                        		  direct 0			  ; assembler parameter for optimizatio
                        		  
0008 =                  BS        equ  $8             ; BACKSPACE CODE
000a =                  LF        equ  $A             ; LINE FEED CODE
000d =                  CR        equ  $D             ; ENTER CODE
001b =                  ESC       equ  $1B            ; ESCAPE CODE
0020 =                  SPACE     equ  $20            ; SPACE (BLANK) CODE
003a =                  STKBUF    equ  58             ; STACK BUFFER ROOM
00fa =                  LBUFMX    equ  250            ; MAX NUMBER OF CHARS IN
00fa =                  MAXLIN    equ  $FA            ; MAXIMUM MS BYTE OF LIN
                        * PSEUDO OPS
0021 =                  SKP1      equ  $21            ; OP CODE OF BRN - SKIP 
008c =                  SKP2      equ  $8C            ; OP CODE OF CMPX # - SK
0086 =                  SKP1LD    equ  $86            ; OP CODE OF LDA # - SKI
                        *                             ; AND LOAD THE VALUE OF 
                        *                             ; IS USUALLY USED TO LOA
0000 =                            org  0
0000 : 00               ENDFLG    rmb  1              ; STOP/END FLAG: POSITIV
0001 : 00               CHARAC    rmb  1              ; TERMINATOR FLAG 1
0002 : 00               ENDCHR    rmb  1              ; TERMINATOR FLAG 2
0003 : 00               TMPLOC    rmb  1              ; SCRATCH VARIABLE
0004 : 00               IFCTR     rmb  1              ; IF COUNTER - HOW MANY 
0005 : 00               DIMFLG    rmb  1              ; *DV* ARRAY FLAG 0=EVAL
0006 : 00               VALTYP    rmb  1              ; *DV* *PV TYPE FLAG: 0=
0007 : 00               GARBFL    rmb  1              ; *TV STRING SPACE HOUSE
0008 : 00               ARYDIS    rmb  1              ; DISABLE ARRAY SEARCH: 
0009 : 00               INPFLG    rmb  1              ; *TV INPUT FLAG: READ=0
000a : 00               RELFLG    rmb  1              ; *TV RELATIONAL OPERATO
000b : 0000             TEMPPT    rmb  2              ; *PV TEMPORARY STRING S
000d : 0000             LASTPT    rmb  2              ; *PV ADDR OF LAST USED 
AS09 Assembler for M6809 [1.42].                                     Page   32
--------------------------------- merge.a09 ----------------------------------

000f : 0000             TEMPTR    rmb  2              ; TEMPORARY POINTER
0011 : 0000             TMPTR1    rmb  2              ; TEMPORARY DESCRIPTOR S
0013 : 00000000         FPA2      rmb  4              ; FLOATING POINT ACCUMUL
0017 : 0000             BOTSTK    rmb  2              ; BOTTOM OF STACK AT LAS
0019 : 0000             TXTTAB    rmb  2              ; *PV BEGINNING OF BASIC
001b : 0000             VARTAB    rmb  2              ; *PV START OF VARIABLES
001d : 0000             ARYTAB    rmb  2              ; *PV START OF ARRAYS
001f : 0000             ARYEND    rmb  2              ; *PV END OF ARRAYS (+1)
0021 : 0000             FRETOP    rmb  2              ; *PV START OF STRING ST
0023 : 0000             STRTAB    rmb  2              ; *PV START OF STRING VA
0025 : 0000             FRESPC    rmb  2              ; UTILITY STRING POINTER
0027 : 0000             MEMSIZ    rmb  2              ; *PV TOP OF STRING SPAC
0029 : 0000             OLDTXT    rmb  2              ; SAVED LINE NUMBER DURI
002b : 0000             BINVAL    rmb  2              ; BINARY VALUE OF A CONV
002d : 0000             OLDPTR    rmb  2              ; SAVED INPUT PTR DURING
002f : 0000             TINPTR    rmb  2              ; TEMPORARY INPUT POINTE
0031 : 0000             DATTXT    rmb  2              ; *PV 'DATA' STATEMENT L
0033 : 0000             DATPTR    rmb  2              ; *PV 'DATA' STATEMENT A
0035 : 0000             DATTMP    rmb  2              ; DATA POINTER FOR 'INPU
0037 : 0000             VARNAM    rmb  2              ; *TV TEMP STORAGE FOR A
0039 : 0000             VARPTR    rmb  2              ; *TV POINTER TO A VARIA
003b : 0000             VARDES    rmb  2              ; TEMP POINTER TO A VARI
003d : 0000             RELPTR    rmb  2              ; POINTER TO RELATIONAL 
003f : 00               TRELFL    rmb  1              ; TEMPORARY RELATIONAL O
                        * FLOATING POINT ACCUMULATORS #3,4 & 5 ARE MOSTLY
                        * USED AS SCRATCH PAD VARIABLES.
                        ** FLOATING POINT ACCUMULATOR #3 :PACKED: ($40-$44)
0040 : 00               V40       rmb  1
0041 : 00               V41       rmb  1
0042 : 00               V42       rmb  1
0043 : 00               V43       rmb  1
0044 : 00               V44       rmb  1
                        ** FLOATING POINT ACCUMULATOR #4 :PACKED: ($45-$49)
0045 : 00               V45       rmb  1
0046 : 00               V46       rmb  1
0047 : 00               V47       rmb  1
0048 : 0000             V48       rmb  2
                        ** FLOATING POINT ACCUMULATOR #5 :PACKED: ($4A-$4E)
004a : 00               V4A       rmb  1
004b : 0000             V4B       rmb  2
004d : 0000             V4D       rmb  2
                        ** FLOATING POINT ACCUMULATOR #0
004f : 00               FP0EXP    rmb  1              ; *PV FLOATING POINT ACC
0050 : 00000000         FPA0      rmb  4              ; *PV FLOATING POINT ACC
0054 : 00               FP0SGN    rmb  1              ; *PV FLOATING POINT ACC
0055 : 00               COEFCT    rmb  1              ; POLYNOMIAL COEFFICIENT
0056 : 0000000000       STRDES    rmb  5              ; TEMPORARY STRING DESCR
005b : 00               FPCARY    rmb  1              ; FLOATING POINT CARRY B
                        ** FLOATING POINT ACCUMULATOR #1
005c : 00               FP1EXP    rmb  1              ; *PV FLOATING POINT ACC
005d : 00000000         FPA1      rmb  4              ; *PV FLOATING POINT ACC
0061 : 00               FP1SGN    rmb  1              ; *PV FLOATING POINT ACC
0062 : 00               RESSGN    rmb  1              ; SIGN OF RESULT OF FLOA
0063 : 00               FPSBYT    rmb  1              ; FLOATING POINT SUB BYT
0064 : 0000             COEFPT    rmb  2              ; POLYNOMIAL COEFFICIENT
0066 : 0000             LSTTXT    rmb  2              ; CURRENT LINE POINTER D
0068 : 0000             CURLIN    rmb  2              ; *PV CURRENT LINE # OF 
006a : 00               DEVCFW    rmb  1              ; *TV TAB FIELD WIDTH
006b : 00               DEVLCF    rmb  1              ; *TV TAB ZONE
006c : 00               DEVPOS    rmb  1              ; *TV PRINT POSITION
006d : 00               DEVWID    rmb  1              ; *TV PRINT WIDTH
006e : 00               DEVNUM 	  rmb  1			  ; *PV DEVICE NUMBER: -3=DLOAD, -2
AS09 Assembler for M6809 [1.42].                                     Page   33
--------------------------------- merge.a09 ----------------------------------

006f : 0000             BasicSavReg_S rmb 2
0071 : 0000             TOPRAM    rmb  2              ; *PV TOP OF RAM
0073 : 00               IKEYIM    rmb  1              ; *TV INKEY$ RAM IMAGE
0074 : 0000             ZERO      rmb  2              ; *PV DUMMY - THESE TWO 
                        * THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM
0076 : 00               LPTCFW    rmb  1              ; 16
0077 : 00               LPTLCF    rmb  1              ; 112
0078 : 00               LPTWID    rmb  1              ; 132
0079 : 00               LPTPOS    rmb  1              ; 0
007a : 0000             EXECJP    rmb  2              ; LB4AA
                        
                        * THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM
                        * BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE
                        * INTERPRETED IS STORED AT CHARAD.
007c : 0c84             GETNCH    inc  <CHARAD+1      ; *PV INCREMENT LS BYTE 
007e : 2602                       bne  GETCCH         ; *PV BRANCH IF NOT ZERO
0080 : 0c83                       inc  <CHARAD        ; *PV INCREMENT MS BYTE 
0082 : b6               GETCCH    fcb  $B6            ; *PV OP CODE OF lda EXT
0083 : 0000             CHARAD    rmb  2              ; *PV THESE 2 BYTES CONT
                        *         *    CHARACTER WHICH THE BASIC INTERPRETER I
                        *         *    PROCESSING
0085 : 7e8243                     jmp  BROMHK         ; JUMP BACK INTO THE BAS
                        
0088 : 00               VAB       rmb  1              ; = LOW ORDER FOUR BYTES
0089 : 00               VAC       rmb  1              ; = OF A FLOATING POINT 
008a : 00               VAD       rmb  1              ; = THESE BYTES ARE USE 
008b : 00               VAE       rmb  1              ; = BY THE RND STATEMENT
                        
                        * EXTENDED BASIC VARIABLES
008c : 00               TRCFLG    rmb  1              ; *PV TRACE FLAG 0=OFF E
008d : 0000             USRADR    rmb  2              ; *PV ADDRESS OF THE STA
                        
                        * EXTENDED BASIC SCRATCH PAD VARIABLES
008f : 0000             VCF       rmb  2
0091 : 0000             VD1       rmb  2
0093 : 0000             VD3       rmb  2
0095 : 0000             VD5       rmb  2
0097 : 00               VD7       rmb  1
0098 : 00               VD8       rmb  1
0099 : 00               VD9       rmb  1
009a : 00               VDA       rmb  1
009b : 000000           USRJMP    rmb  3              ; JUMP ADDRESS FOR BASIC
009e : 00               RVSEED    rmb  1              ; * FLOATING POINT RANDO
009f : 00000000                   rmb  4              ; * MANTISSA: INITIALLY 
                        
                        **** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)
00a3 : 0000             USR0      rmb  2              ; USR 0 VECTOR
00a5 : 0000                       rmb  2              ; USR 1
00a7 : 0000                       rmb  2              ; USR 2
00a9 : 0000                       rmb  2              ; USR 3
00ab : 0000                       rmb  2              ; USR 4
00ad : 0000                       rmb  2              ; USR 5
00af : 0000                       rmb  2              ; USR 6
00b1 : 0000                       rmb  2              ; USR 7
00b3 : 0000                       rmb  2              ; USR 8
00b5 : 0000                       rmb  2              ; USR 9
                        
00b7 : 00000000000000.. STRSTK    rmb  8*5            ; STRING DESCRIPTOR STAC
00df : 0000             LINHDR    rmb  2              ; LINE INPUT BUFFER HEAD
00e1 : 00000000000000.. LINBUF    rmb  LBUFMX+1       ; BASIC LINE INPUT BUFFE
01dc : 00000000000000.. STRBUF    rmb  41             ; STRING BUFFER
0205 : 0000             F_PTR     rmb  2              ; POINTER TO THE FILE ST
AS09 Assembler for M6809 [1.42].                                     Page   34
--------------------------------- merge.a09 ----------------------------------

0207 : 00               PROGST    rmb  1              ; START OF PROGRAM SPACE
                        
7cff =                  BasicRAMend			equ	$7cff ; RAM section reserved for BAS
c882 =                  CSum16_ROM1			equ $C882 ; BASIC ROM CheckSum16
                        
8000 =                            org  ROM1_ORG
8000 : c882             		  dw	CSum16_ROM1
8002 :                  BASIC_ORG
                        * JUMP TO BASIC COLD START AT START OF ROM FOR CONVENI
8002 : 1a50             		  orcc #%01010000	  ; ensure init in case of softwar
8004 : 4f               		  clra
8005 : 1f8b             		  tfr  a,dp
8007 : 7e808b           		  lbra RESVEC
                        
                        ; context switching to let run BASIC in parallel
800a : 347f             EXITBAS	  pshs d,x,y,u,cc,dp
800c : 10df6f           		  sts  BasicSavReg_S
800f : be7ff0           		  ldx  BasicCallBack
8012 : cc801a           		  ldd  #ENTRYBAS
8015 : fd7ff0           		  std  BasicCallBack
8018 : 6e84             		  jmp  ,x			  ; EXIT BASIC
801a : 10de6f           ENTRYBAS  lds  BasicSavReg_S  ; ENTRY BASIC
801d : 35ff             		  puls d,x,y,u,cc,dp,pc
                        
                        * CONSOLE IN
801f : fc0205           LA171     ldd  F_PTR		  ; check if file reading open		
8022 : 2726             		  beq  LA173
                        		  
8024 : 3430               		  pshs x,y		  ; Note for generated asm from C: the
                        *		returnStatus = FILE_GetCh(srcFilePtr);
8026 : 3406             		  pshs	d
8028 : bdb456           		  lbsr	FILE_Get
802b : 3262             		  leas	2,s
                        		  
                        * 		if(returnStatus == EOF) {
802d : c11a             		  cmpb	#$1a
802f : 2611             		  bne	LA172  		  
                        * 			FILE_Close(srcFilePtr);
8031 : fc0205           		  ldd	F_PTR
8034 : 3406             		  pshs	d
8036 : bdb3b7           		  lbsr	FILE_Clo
8039 : 3262             		  leas	2,s
803b : 7f0205           		  clr   F_PTR		
803e : 7f0207           		  clr   F_PTR+2
8041 : 5f               		  clrb
                        *		}
8042 : 3530             LA172	  puls	x,y
8044 : 1f98             		  tfr  b,a
8046 : 847f             		  anda #$7F
8048 : 2604             		  bne  LA174
                        
804a : 8d03             LA173	  bsr  KEYIN          ; GET A CHARACTER FROM CON
804c : 27fc             		  beq  LA173          ; LOOP IF NO KEY DOWN
804e : 39               LA174     rts
                        
                        *
                        * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A
                        * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DO
                        *
                        *
804f :                  LA1C1
804f : 8db9             KEYIN     bsr  EXITBAS
AS09 Assembler for M6809 [1.42].                                     Page   35
--------------------------------- merge.a09 ----------------------------------

8051 : 3404             		  pshs b
8053 : bdede6           		  jsr  APLgetChar
8056 : 1f98             		  tfr  b,a
8058 : 847f             		  anda #$7F
805a : 3584                       puls b,pc
                        		  
                        
                        * CONSOLE OUT
805c : 3406             PUTCHR    pshs d              ; PRESERVE ACCD		
805e : 0d6e             		  tst  DEVNUM		  ; CHECK DEVICE NUMBER		  
8060 : 2714             		  beq  TOSCRN		  ; BRANCH IF SCREEN				  
                        		  
8062 : 3436             		  pshs d,x,y		  
8064 : 1f89             		  tfr  a,b	  		  ; char in ACCB
8066 : 3406             		  pshs d		
8068 : fc0205           		  ldd  F_PTR
806b : 3406             		  pshs d
806d : bdb574           		  lbsr FILE_Put	  	  ; Note for BASIC ASM -> C : the
8070 : 3264             		  leas 4,s
8072 : 3536             		  puls d,x,y
8074 : 2003             		  bra  PUTEXIT
                        
8076 : bdede9           TOSCRN	  jsr  APLsendChar          
8079 : 810d             PUTEXIT	  cmpa #CR            ; IS IT CARRIAGE RETURN?
807b : 2708                       beq  NEWLINE        ; YES
807d : 0c79                       inc  LPTPOS         ; INCREMENT CHARACTER CO
807f : 9679                       lda  LPTPOS         ; CHECK FOR END OF LINE 
8081 : 9178                       cmpa LPTWID         ; AT END OF LINE PRINTER
8083 : 2502                       blo  PUTEND         ; NO
8085 : 0f79             NEWLINE   clr  LPTPOS         ; RESET CHARACTER COUNTE
8087 : 8d81             PUTEND    bsr  EXITBAS
8089 : 3586             		  puls d,pc           ; RESTORE ACCD
                                  
                        
                        *
808b :                  RESVEC
                        
                        * COLD START ENTRY
                        
808b : fe7ff0           		  ldu  BasicCallBack  ; preserve the BasicCallBack b
808e : 8e0208           		  ldx  #PROGST+1      ; POINT X TO CLEAR 1ST 1K OF R
8091 : 6f83             LA077     clr  ,--x           ; MOVE POINTER DOWN TWO-
8093 : 3001             		  leax 1,x            ; ADVANCE POINTER ONE
8095 : 26fa                       bne  LA077          ; KEEP GOING IF NOT AT B
8097 : 8e0207                     ldx  #PROGST        ; SET TO START OF PROGRA
809a : 6f80                       clr  ,x+            ; CLEAR 1ST BYTE OF BASI
809c : 9f19                       stx  TXTTAB         ; BEGINNING OF BASIC PRO
809e : 8e7cff           		  ldx  #BasicRAMend   ; end of BASIC allocated memor
80a1 : ff7ff0           		  stu  BasicCallBack  ; restore the BasicCallBack
80a4 : 9f71             		  stx  TOPRAM         ; SAVE ABSOLUTE TOP OF RAM
80a6 : 9f27                       stx  MEMSIZ         ; SAVE TOP OF STRING SPA
80a8 : 9f23                       stx  STRTAB         ; SAVE START OF STRING V
80aa : 3089ff38                   leax -200,x         ; CLEAR 200 - DEFAULT ST
80ae : 9f21                       stx  FRETOP         ; SAVE START OF STRING S
80b0 : 1f14                       tfr  x,s            ; PUT STACK THERE
80b2 : 8e80e4                     ldx  #LA10D         ; POINT X TO ROM SOURCE 
80b5 : ce0076                     ldu  #LPTCFW        ; POINT U TO RAM DESTINA
80b8 : c612                       ldb  #18            ; MOVE 18 BYTES
80ba : bd81df                     jsr  LA59A          ; MOVE 18 BYTES FROM ROM
80bd : 8639                       lda  #$39
80bf : 97de                       sta  LINHDR-1       ; PUT rts IN LINHDR-1
80c1 : bd856c                     jsr  LAD19          ; G0 DO A 'NEW'
AS09 Assembler for M6809 [1.42].                                     Page   36
--------------------------------- merge.a09 ----------------------------------

                        * EXTENDED BASIC INITIALISATION
80c4 : 8e00a3                     ldx  #USR0          ; INITIALIZE ADDRESS OF 
80c7 : 9f8d                       stx  USRADR         ; USR JUMP TABLE
                        * DISK BASIC INITIALISATION
80c9 : 0f6e             		  clr  DEVNUM		  ; DEFAULT SCREEN
80cb : 7f0205           		  clr  F_PTR
80ce : 7f0207           		  clr  F_PTR+2
                        * INITIALIZE THE USR CALLS TO 'FC ERROR'
80d1 : ce8c7d                     ldu  #LB44A         ; ADDRESS OF 'FC ERROR' 
80d4 : c60a                       ldb  #10            ; 10 USR CALLS IN EX BAS
80d6 : ef81             L8031     stu  ,x++           ; STORE 'FC' ERROR AT US
80d8 : 5a                         decb                ; FINISHED ALL 10?
80d9 : 26fb                       bne  L8031          ; NO
                        		  		  
80db : 8e8113                     ldx  #LA147-1       ; POINT X TO COLOR BASIC
80de : bd91a9                     jsr  LB99C          ; PRINT 'COLOR BASIC'
80e1 : 7e84ce           LA0F3     jmp  LAC73          ; GO TO MAIN LOOP OF BAS
                        
                        *
                        * THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIR
80e4 : 10               LA10D     fcb  16             ; TAB FIELD WIDTH
80e5 : 40                         fcb  64             ; LAST TAB ZONE
80e6 : 50                         fcb  80             ; PRINTER WIDTH
80e7 : 00                         fcb  0              ; LINE PRINTER POSITION
80e8 : 8c7d                       fdb  LB44A          ; ARGUMENT OF EXEC COMMA
                        * LINE INPUT ROUTINE
80ea : 0c84                       inc  CHARAD+1
80ec : 2602                       bne  LA123
80ee : 0c83                       inc  CHARAD
80f0 : b60000           LA123     lda  >0000
80f3 : 7e8243                     jmp  BROMHK
                        *
                        * THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1
80f6 : 7e8c7d                     jmp  LB44A          ; USR ADDRESS FOR 8K BAS
80f9 : 80                         fcb  $80            ; *RANDOM SEED
80fa : 4fc7                       fdb  $4FC7          ; *RANDON SEED OF MANTIS
80fc : 5259                       fdb  $5259          ; *.811635157
                        * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE
80fe : 39               COMVEC    fcb  57             ; 57 BASIC COMMANDS
80ff : 82a1                       fdb  LAA66          ; POINTS TO RESERVED WOR
8101 : 83c8                       fdb  LAB67          ; POINTS TO JUMP TABLE F
8103 : 1d                         fcb  29             ; 29 BASIC SECONDARY COM
8104 : 835b                       fdb  LAB1A          ; POINTS TO SECONDARY FU
8106 : 8252                       fdb  LAA29          ; POINTS TO SECONDARY FU
8108 : 0000                       fdb  0              ; NO MORE TABLES (RES WO
810a : 0000                       fdb  0              ; NO MORE TABLES
810c : 0000                       fdb  0              ; NO MORE TABLES
810e : 0000                       fdb  0              ; NO MORE TABLES
8110 : 0000                       fdb  0              ; NO MORE TABLES
8112 : 0000                       fdb  0              ; NO MORE TABLES (SECOND
                        
                        * COPYRIGHT MESSAGES
8114 : 36383039204449.. LA147     fcc  "6809 DISK EXT COLOR BASIC"
812d : 0d                         fcb  CR
812e : 28432920313938..           fcc  "(C) 1982 BY MICROSOFT"
8143 : 0d0d             LA156     fcb  CR,CR
8145 : 00               LA165     fcb  $00
                        
                        
8146 : 3416             LA35F     pshs x,b,a          ; SAVE REGISTERS
8148 : 9e76                       ldx  LPTCFW         ; TAB FIELD WIDTH AND TA
814a : dc78                       ldd  LPTWID         ; PRINTER WIDTH AND POSI
AS09 Assembler for M6809 [1.42].                                     Page   37
--------------------------------- merge.a09 ----------------------------------

814c : 9f6a             LA37C     stx  DEVCFW         ; SAVE TAB FIELD WIDTH A
814e : d76c                       stb  DEVPOS         ; SAVE PRINT POSITION
8150 : 976d                       sta  DEVWID         ; SAVE PRINT WIDTH
8152 : 3596                       puls a,b,x,pc       ; RESTORE REGISTERS
                        
                        * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASI
                        * EXIT WITH BREAK KEY: CARRY = 1
                        * EXIT WITH ENTER KEY: CARRY = 0
8154 :                  LA38D
8154 : 0f73             LA390     clr  IKEYIM         ; RESET BREAK CHECK KEY 
8156 : 8e00e2                     ldx  #LINBUF+1      ; INPUT LINE BUFFER
8159 : c601                       ldb  #1             ; ACCB CHAR COUNTER: SET
815b : bd801f           LA39A     jsr  LA171          ; GO GET A CHARACTER FRO
815e : 8108                       cmpa #BS            ; BACKSPACE
8160 : 2607                       bne  LA3B4          ; NO
8162 : 5a                         decb                ; YES - DECREMENT CHAR C
8163 : 27ef                       beq  LA390          ; BRANCH IF BACK AT STAR
8165 : 301f                       leax -1,x           ; DECREMENT BUFFER POINT
8167 : 2034                       bra  LA3E8          ; ECHO CHAR TO SCREEN
8169 : 8115             LA3B4     cmpa #$15           ; SHIFT RIGHT ARROW?
816b : 260a                       bne  LA3C2          ; NO
                        * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LIN
816d : 5a               LA3B8     decb                ; DEC CHAR CTR
816e : 27e4                       beq  LA390          ; GO BACK TO START IF CH
8170 : 8608                       lda  #BS            ; BACKSPACE?
8172 : bd805c                     jsr  PUTCHR         ; SEND TO CONSOLE OUT (S
8175 : 20f6                       bra  LA3B8          ; KEEP GOING
8177 : 8103             LA3C2     cmpa #3             ; BREAK KEY?
8179 : 1a01                       orcc #1             ; SET CARRY FLAG
817b : 2705                       beq  LA3CD          ; BRANCH IF BREAK KEY DO
817d : 810d             LA3C8     cmpa #CR            ; ENTER KEY?
817f : 260d                       bne  LA3D9          ; NO
8181 : 4f               LA3CC     clra                ; CLEAR CARRY FLAG IF EN
8182 : 3401             LA3CD     pshs cc             ; SAVE CARRY FLAG
8184 : bd916a                     jsr  LB958          ; SEND CR TO SCREEN
8187 : 6f84                       clr  ,x             ; MAKE LAST BYTE IN INPU
8189 : 8e00e1                     ldx  #LINBUF        ; RESET INPUT BUFFER POI
818c : 3581             		  puls cc,pc          ; RESTORE CARRY FLAG
                        
                        * INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER
818e : 8120             LA3D9     cmpa #$20           ; IS IT CONTROL CHAR?
8190 : 25c9                       blo  LA39A          ; BRANCH IF CONTROL CHAR
8192 : 817b                       cmpa #'z'+1         ; *
8194 : 24c5                       bcc  LA39A          ; * IGNORE IF > LOWER CA
8196 : c1fa                       cmpb #LBUFMX        ; HAVE 250 OR MORE CHARA
8198 : 24c1                       bcc  LA39A          ; YES, IGNORE ANY MORE
819a : a780                       sta  ,x+            ; PUT IT IN INPUT BUFFER
819c : 5c                         incb                ; INCREMENT CHARACTER CO
819d : bd805c           LA3E8     jsr  PUTCHR         ; ECHO IT TO SCREEN
81a0 : 20b9                       bra  LA39A          ; GO SET SOME MORE
                        
                        
                        * EXEC
81a2 : 2705             EXEC      beq  LA545          ; BRANCH IF NO ARGUMENT
81a4 : bd8f6e                     jsr  LB73D          ; EVALUATE ARGUMENT - AR
81a7 : 9f7a                       stx  EXECJP         ; STORE X TO EXEC JUMP A
81a9 : 6e9f007a         LA545     jmp  [EXECJP]       ; GO DO IT
                        
                        * BREAK CHECK
81ad : 7e8653           LA549     jmp  LADEB          ; GO DO BREAK KEY CHECK
                        
                        * THIS ROUTINE EVALUATES AN ARGUMENT
AS09 Assembler for M6809 [1.42].                                     Page   38
--------------------------------- merge.a09 ----------------------------------

                        * AND MAKES SURE IT IS WITHIN LIMITS OF VIDEO DISPLAY 
81b0 : bd8c17           LA554	  jsr  LB3E4		  ; EVALUATE EXPRESSION AND RETURN
81b3 : 1083027f         		  cmpd #639			  ; ONLY 512 VIDEO DISPLAY LOCATIONS (
81b7 : 10220ac2         		  lbhi LB44A		  ; BRANCH IF > 511 TO ‘ILLEGAL FUNC
81bb : 3404             		  pshs b  			  ; SAVE LOWER PART 0-31 (5-BIT)
81bd : 58               		  lslb				  ; SHIFT 3-BIT VER VALUE TO ACCA
81be : 49               		  rola
81bf : 58               		  lslb
81c0 : 49               		  rola
81c1 : 58               		  lslb
81c2 : 49               		  rola				  ; VER VALUE IN ACCA
81c3 : 3504             		  puls b
81c5 : c41f             		  andb #$1F			  ; KEEP HOR VALUE
81c7 : bdee11           		  jsr APLsetXY 		  ; GET CHARACTER LOCATION (VER IN 
81ca : 39               		  rts
                        		
                        * INKEY$
81cb : 9673             INKEY     lda  IKEYIM         ; WAS A KEY DOWN IN THE 
81cd : 2603                       bne  LA56B          ; YES
81cf : bd804f                     jsr  KEYIN          ; GO GET A KEY
81d2 : 0f73             LA56B     clr  IKEYIM         ; CLEAR INKEY RAM IMAGE
81d4 : 9753                       sta  FPA0+3         ; STORE THE KEY IN FPA0
81d6 : 10260ce7                   lbne LB68F          ; CONVERT FPA0+3 TO A ST
81da : 9756                       sta  STRDES         ; SET LENGTH OF STRING =
81dc : 7e8ecd                     jmp  LB69B          ; PUT A NULL STRING ONTO
                        
                        * MOVE ACCB BYTES FROM (X) TO (U)
81df : a680             LA59A     lda  ,x+            ; GET BYTE FROM X
81e1 : a7c0                       sta  ,u+            ; STORE IT AT U
81e3 : 5a                         decb                ; MOVED ALL BYTES?
81e4 : 26f9                       bne  LA59A          ; NO
81e6 : 39               LA5A1     rts
                        
                        ** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BAS
                        ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTE
                        ** FOLLOWING THE END OF THE NAME
81e7 : 9d82             LA5C7     jsr  GETCCH         ; GET CURRENT INPUT CHAR
81e9 : 27fb             LA5C9     beq  LA5A1          ; RETURN IF END OF LINE
81eb : 7e8ab0                     jmp  LB277          ; SYNTAX ERROR IF ANY MO
                        
                        * SET  ; SET(x,y,col)
81ee : 8d19             SET       bsr LA8C1			; GET ABSOLUTE SCREEN POSITION O
81f0 : 3406             		  pshs d 			; SAVE CHARACTER LOCATION
81f2 : bd8f69           		  jsr LB738			; SYNTAX CHECK FOR COMMA - RETURN EXPR
81f5 : 5d               		  tstb				; VALID ARGUMENT?
81f6 : 2704             		  beq LA6C6			; IF ARGUMENT <1, USE DEFAULT
81f8 : c107             		  cmpb #7			; VALID ARGUMENT?
81fa : 2302             		  bls LA6C7			; ILLEGAL COLOR - ‘ILLEGAL FUNCTION 
81fc : c602             LA6C6	  ldb #2			; GREEN DEFAULT VALUE
81fe :                  LA6C7	  					; THE COLOR IN ACCB IS IGNORED
81fe : bd8aa0           		  jsr LB267		    ; SYNTAX CHECK FOR ‘)‘
8201 : 3504             		  puls b			; REGET CHARACTER LOCATION (HOR IN ACCB)
8203 : 3502             		  puls a			; REGET CHARACTER LOCATION (VER IN ACCA)
8205 : bdee11           		  jsr APLsetXY
8208 : 39               		  rts
                        
                        *** THIS ROUTINE WILL CHECK SYNTAX AND CHECK FOR LEGAL
                        *** OF SET,RESET & POINT HORIZONTAL AND VERTICAL PARAM
                        *** AND RETURN THEIR ABSOLUTE SCREEN ADDRESS IN THE X 
                        *** WHICH OF THE FOUR PIXELS OF THE GRAPHIC BLOCK SELE
                        *** IS RETURNED IN GRBLOK.
8209 : bd8aa3           LA8C1 	  jsr LB26A			; SYNTAX CHECK FOR "("
AS09 Assembler for M6809 [1.42].                                     Page   39
--------------------------------- merge.a09 ----------------------------------

820c : bd8f3c           		  jsr LB70B			; EVALUATE EXPRESSION - RETURN VALUE I
                        		  ;cmpb #63			; ONLY 64 HORIZONTAL GRAPHIC BLOCKS
                        		  ;bhi LA948		; ‘ILLEGAL FUNCTION CALL’
820f : 3404             		  pshs b			; SAVE HOR COORD
8211 : bd8f69           		  jsr LB738			; SYNTAX CHECK FOR COMMA AND EVALUATE 
8214 : 3502             		  puls a			; KEEP VERT COORD IN ACCB, GET HOR COORD 
                        		  ;cmpb #31
8216 :                  LA8D5 	  ;bhi LA948		; ‘ILLEGAL FUNCTION CALL’		  
8216 : 39               		  rts
                        		  
                        * CLS  ; CLS "color" [the color values are: 1 red, 2 g
8217 : 270a             CLS		  beq LA928			; BRANCH IF NO ARGUMENT
8219 : bd8f3c           		  jsr LB70B			; CALCULATE ARGUMENT, RETURN VALUE IN 
821c : 5d               		  tstb				; VALID ARGUMENT?
821d : 2704             		  beq LA928			; IF ARGUMENT <1, USE DEFAULT
821f : c107             		  cmpb #7			; VALID ARGUMENT?
8221 : 2302             		  bls LA937			; IF ARGUMENT >7, USE DEFAULT
8223 : c602             LA928	  ldb #2			; GREEN DEFAULT VALUE
8225 : bdedfb           LA937	  jsr APLclearscreen
8228 : 39                         rts
                        
8229 : bd8aa6           LA93F 	  jsr LB26D			; SYNTAX CHECK FOR A COMMA
822c : bd8f3c           LA942 	  jsr LB70B			; EVALUATE EXPRESSION, RETURN VAL
822f : 5d               		  tstb				; SET FLAGS
8230 : 2610             		  bne LA950			; RETURN IF NON ZERO
8232 : 3261             		  leas 1,s			; CLEAR PUSHED VALUE
8234 : 7e8c7d           LA948	  jmp LB44A			; ‘ILLEGAL FUNCTION CALL’ IF Z
                        
                        * SOUND  ; SOUND tone,duration [tone and duration are 
8237 : 8df3             SOUND     bsr LA942			; EVALUATE EXPRESSION (FREQuENCY
8239 : 3404             		  pshs b			; SAVE IT
823b : 8dec             		  lbsr LA93F		; EVALUATE EXPRESSION (SOUND LENGTH), 
823d : 3502             		  puls a			; SAVE FREQuENCY IN ACCa, LENGTH OF SOUND
823f : bdee02           		  jsr  APLsound
8242 : 39               LA950	  rts  
                        
                        * SET CARRY IF NUMERIC - RETURN WITH
                        * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END
                        * OF BASIC LINE OR SUB LINE
8243 : 813a             BROMHK    cmpa #'9'+1         ; IS THIS CHARACTER >=(A
8245 : 240a                       bhs  LAA28          ; BRANCH IF > 9; Z SET I
8247 : 8120                       cmpa #SPACE         ; SPACE?
8249 : 2602                       bne  LAA24          ; NO - SET CARRY IF NUME
824b : 0e7c                       jmp  GETNCH         ; IF SPACE, GET NECT CHA
824d : 8030             LAA24     suba #'0'           ; * SET CARRY IF
824f : 80d0                       suba #-'0'          ; * CHARACTER > ASCII 0
8251 : 39               LAA28     rts
                        
                        * DISPATCH TABLE FOR SECONDARY FUNCTIONS
                        * TOKENS ARE PRECEEDED BY $FF
                        * FIRST SET ALWAYS HAS ONE PARAMETER
8252 :                  FUNC_TAB
8252 : 9487             LAA29     fdb  SGN            ; SGN
8254 : 94fb                       fdb  INT            ; INT
8256 : 94a0                       fdb  ABS            ; ABS
8258 : 009b                       fdb  USRJMP         ; USR
0083 =                  TOK_USR   equ  $83			  ; (LL01-FUNC_TAB)/2+$7F
ff83 =                  TOK_FF_USR equ  $ff83		  ; (LL01-FUNC_TAB)/2+$FF7F
825a : 972c             LL01      fdb  RND            ; RND
825c : 9781                       fdb  SIN            ; SIN
825e : 8f81                       fdb  PEEK           ; PEEK
8260 : 8eb3                       fdb  LEN            ; LEN
AS09 Assembler for M6809 [1.42].                                     Page   40
--------------------------------- merge.a09 ----------------------------------

8262 : 8d30                       fdb  STR            ; STR$
8264 : 8f47                       fdb  VAL            ; VAL
8266 : 8ed2                       fdb  ASC            ; ASC
8268 : 8ebe                       fdb  CHR            ; CHR$
826a : 982f                       fdb  ATN            ; ATN
826c : 97f9                       fdb  COS            ; COS
826e : 9801                       fdb  TAN            ; TAN
8270 : 9970                       fdb  EXP            ; EXP
8272 : 99a2                       fdb  FIX            ; FIX
8274 : 98c5                       fdb  LOG            ; LOG
8276 : 9b2a                       fdb  POS            ; POS
8278 : 98ff                       fdb  SQR            ; SQR
827a : 9ff9                       fdb  HEXDOL         ; HEX$
                        * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
827c : 8edd                       fdb  LEFT           ; LEFT$
0095 =                  TOK_LEFT  equ  $95 			  ; ((LL02-FUNC_TAB)/2)+$7F
827e : 8ef9             LL02      fdb  RIGHT          ; RIGHT$
8280 : 8f00                       fdb  MID            ; MID$
0097 =                  TOK_MID   equ  $97			  ; (LL03-FUNC_TAB)/2+$7F
                        * REMAINING FUNCTIONS
8282 : 81cb             LL03      fdb  INKEY          ; INKEY$
0098 =                  TOK_INKEY equ  $98			  ;(LL04-FUNC_TAB)/2+$7F
8284 : 8d21             LL04      fdb  MEM            ; MEM
8286 : 9b32                       fdb  VARPT          ; VARPTR
8288 : 9bf2                       fdb  INSTR          ; INSTR
828a : 9bc2                       fdb  STRING         ; STRING$
001d =                  NUM_SEC_FNS equ  $1d	      ; (LL05-FUNC_TAB)/2
828c :                  LL05
                        
                        * THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESS
                        * AND LOGICAL OPERATORS - THE NEGATION OPERATORS DO NO
                        * S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREAT
                        * EXPRESSION EVALUATION ROUTINE. THEY ARE:
                        * UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGAT
                        * THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, 
                        * A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSI
                        *
828c : 79               LAA51     fcb  $79
828d : 91d2                       fdb  LB9C5          ; +
828f : 79                         fcb  $79
8290 : 91c9                       fdb  LB9BC          ; -
8292 : 7b                         fcb  $7B
8293 : 92d9                       fdb  LBACC          ; *
8295 : 7b                         fcb  $7B
8296 : 939e                       fdb  LBB91          ; /
8298 : 7f                         fcb  $7F
8299 : 9908                       fdb  L8489          ; EXPONENTIATION
829b : 50                         fcb  $50
829c : 8b08                       fdb  LB2D5          ; AND
829e : 46                         fcb  $46
829f : 8b07                       fdb  LB2D4          ; OR
                        
                        * THIS IS THE RESERVED WORD TABLE
                        * FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS
82a1 : 464f             LAA66     fcc  "FO"           ; 80
82a3 : d2                         fcb  $80+'R'
82a4 : 47                         fcc  "G"            ; 81
82a5 : cf                         fcb  $80+'O'
0081 =                  TOK_GO    equ  $81
82a6 : 5245                       fcc  "RE"           ; 82
82a8 : cd                         fcb  $80+'M'
82a9 : a7                         fcb  $80+$27        ; 83 + '''
AS09 Assembler for M6809 [1.42].                                     Page   41
--------------------------------- merge.a09 ----------------------------------

82aa : 454c53                     fcc  "ELS"          ; 84
82ad : c5                         fcb  $80+'E'
82ae : 49                         fcc  "I"            ; 85
82af : c6                         fcb  $80+'F'
82b0 : 444154                     fcc  "DAT"          ; 86
82b3 : c1                         fcb  $80+'A'
82b4 : 5052494e                   fcc  "PRIN"         ; 87
82b8 : d4                         fcb  $80+'T'
82b9 : 4f                         fcc  "O"            ; 88
82ba : ce                         fcb  $80+'N'
82bb : 494e5055                   fcc  "INPU"         ; 89
82bf : d4                         fcb  $80+'T'
82c0 : 454e                       fcc  "EN"           ; 8A
82c2 : c4                         fcb  $80+'D'
82c3 : 4e4558                     fcc  "NEX"          ; 8B
82c6 : d4                         fcb  $80+'T'
82c7 : 4449                       fcc  "DI"           ; 8C
82c9 : cd                         fcb  $80+'M'
82ca : 524541                     fcc  "REA"          ; 8D
82cd : c4                         fcb  $80+'D'
82ce : 5255                       fcc  "RU"           ; 8E
82d0 : ce                         fcb  $80+'N'
82d1 : 524553544f52               fcc  "RESTOR"       ; 8F
82d7 : c5                         fcb  $80+'E'
82d8 : 5245545552                 fcc  "RETUR"        ; 90
82dd : ce                         fcb  $80+'N'
82de : 53544f                     fcc  "STO"          ; 91
82e1 : d0                         fcb  $80+'P'
82e2 : 504f4b                     fcc  "POK"          ; 92
82e5 : c5                         fcb  $80+'E'
82e6 : 434f4e                     fcc  "CON"          ; 93
82e9 : d4                         fcb  $80+'T'
82ea : 4c4953                     fcc  "LIS"          ; 94
82ed : d4                         fcb  $80+'T'
82ee : 434c4541                   fcc  "CLEA"         ; 95
82f2 : d2                         fcb  $80+'R'
82f3 : 4e45                       fcc  "NE"           ; 96
82f5 : d7                         fcb  $80+'W'
82f6 : 5345                       fcc  "SE"           ; 97
82f8 : d4                         fcb  $80+'T'
82f9 : 434c             		  fcc  "CL"           ; 98
82fb : d3                         fcb  $80+'S'
82fc : 534f554e         		  fcc  "SOUN"         ; 99
8300 : c4                         fcb  $80+'D'
8301 : 455845           		  fcc  "EXE"          ; 9A
8304 : c3                         fcb  $80+'C'
8305 : 4445                       fcc  "DE"           ; 9B
8307 : cc                         fcb  $80+'L'
8308 : 454449                     fcc  "EDI"          ; 9C
830b : d4                         fcb  $80+'T'
830c : 54524f                     fcc  "TRO"          ; 9D
830f : ce                         fcb  $80+'N'
8310 : 54524f46                   fcc  "TROF"         ; 9E
8314 : c6                         fcb  $80+'F'
8315 : 4445                       fcc  "DE"           ; 9F
8317 : c6                         fcb  $80+'F'
8318 : 4c494e                     fcc  "LIN"          ; A0
831b : c5                         fcb  $80+'E'
831c : 52454e55                   fcc  "RENU"         ; A1
8320 : cd                         fcb  $80+'M'          
8321 : 4449                       fcc  "DI"           ; A2
8323 : d2                         fcb  $80+'R'
AS09 Assembler for M6809 [1.42].                                     Page   42
--------------------------------- merge.a09 ----------------------------------

8324 : 4b494c                     fcc  "KIL"          ; A3
8327 : cc                         fcb  $80+'L'
8328 : 4c4f41                     fcc  "LOA"          ; A4
832b : c4                         fcb  $80+'D'
832c : 534156                     fcc  "SAV"          ; A5
832f : c5                         fcb  $80+'E'          
                        * END OF EXECUTABLE COMMANDS. THE REMAINDER OF THE TAB
8330 : 544142                     fcc  "TAB"          ; A6
8333 : a8                         fcb  $80+'('
00a6 =                  TOK_TAB   equ  $A6
8334 : 54                         fcc  "T"            ; A7
8335 : cf                         fcb  $80+'O'
00a7 =                  TOK_TO    equ  $A7
8336 : 5355                       fcc  "SU"           ; A8
8338 : c2                         fcb  $80+'B'
00a8 =                  TOK_SUB   equ  $A8
8339 : 544845                     fcc  "THE"          ; A9
833c : ce                         fcb  $80+'N'
00a9 =                  TOK_THEN  equ  $A9
833d : 4e4f                       fcc  "NO"           ; AA
833f : d4                         fcb  $80+'T'
00aa =                  TOK_NOT   equ  $AA
8340 : 535445                     fcc  "STE"          ; AB
8343 : d0                         fcb  $80+'P'
00ab =                  TOK_STEP  equ  $AB
8344 : 4f46                       fcc  "OF"           ; AC
8346 : c6                         fcb  $80+'F'
8347 : ab                         fcb  '+'+$80        ; AD
00ad =                  TOK_PLUS  equ  $AD
8348 : ad                         fcb  $80+'-'        ; AE
00ae =                  TOK_MINUS equ  $AE
8349 : aa                         fcb  $80+'*'        ; AF
834a : af                         fcb  $80+'/'        ; B0
834b : de                         fcb  $80+'^'        ; B1
834c : 414e                       fcc  "AN"           ; B2
834e : c4                         fcb  $80+'D'
834f : 4f                         fcc  "O"            ; B3
8350 : d2                         fcb  $80+'R'
8351 : be                         fcb  $80+'>'        ; B4
00b4 =                  TOK_GREATER equ  $B4
8352 : bd                         fcb  $80+'='        ; B5
00b5 =                  TOK_EQUALS equ  $B5
8353 : bc                         fcb  $80+'<'        ; B6
8354 : 46                         fcc  "F"            ; B7
8355 : ce                         fcb  $80+'N'
00b7 =                  TOK_FN    equ  $B7
8356 : 5553494e                   fcc  "USIN"         ; B8
835a : c7                         fcb  $80+'G'
00b8 =                  TOK_USING equ  $B8
                        *
                        
                        * FIRST SET ALWAYS HAS ONE PARAMETER
835b : 5347             LAB1A     fcc  "SG"           ; 80
835d : ce                         fcb  $80+'N'
835e : 494e                       fcc  "IN"           ; 81
8360 : d4                         fcb  $80+'T'
8361 : 4142                       fcc  "AB"           ; 82
8363 : d3                         fcb  $80+'S'
8364 : 5553                       fcc  "US"           ; 83
8366 : d2                         fcb  $80+'R'
8367 : 524e                       fcc  "RN"           ; 84
8369 : c4                         fcb  $80+'D'
AS09 Assembler for M6809 [1.42].                                     Page   43
--------------------------------- merge.a09 ----------------------------------

836a : 5349                       fcc  "SI"           ; 85
836c : ce                         fcb  $80+'N'
836d : 504545                     fcc  "PEE"          ; 86
8370 : cb                         fcb  $80+'K'
8371 : 4c45                       fcc  "LE"           ; 87
8373 : ce                         fcb  $80+'N'
8374 : 535452                     fcc  "STR"          ; 88
8377 : a4                         fcb  $80+'$'
8378 : 5641                       fcc  "VA"           ; 89
837a : cc                         fcb  $80+'L'
837b : 4153                       fcc  "AS"           ; 8A
837d : c3                         fcb  $80+'C'
837e : 434852                     fcc  "CHR"          ; 8B
8381 : a4                         fcb  $80+'$'
8382 : 4154                       fcc  "AT"           ; 8C
8384 : ce                         fcb  $80+'N'
8385 : 434f                       fcc  "CO"           ; 8D
8387 : d3                         fcb  $80+'S'
8388 : 5441                       fcc  "TA"           ; 8E
838a : ce                         fcb  $80+'N'
838b : 4558                       fcc  "EX"           ; 8F
838d : d0                         fcb  $80+'P'
838e : 4649                       fcc  "FI"           ; 90
8390 : d8                         fcb  $80+'X'
8391 : 4c4f                       fcc  "LO"           ; 91
8393 : c7                         fcb  $80+'G'
8394 : 504f                       fcc  "PO"           ; 92
8396 : d3                         fcb  $80+'S'
8397 : 5351                       fcc  "SQ"           ; 93
8399 : d2                         fcb  $80+'R'
839a : 484558                     fcc  "HEX"          ; 94
839d : a4                         fcb  $80+'$'
                        * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
839e : 4c454654                   fcc  "LEFT"         ; 95
83a2 : a4                         fcb  $80+'$'
83a3 : 5249474854                 fcc  "RIGHT"        ; 96
83a8 : a4                         fcb  $80+'$'
83a9 : 4d4944                     fcc  "MID"          ; 97
83ac : a4                         fcb  $80+'$'
                        * REMAINING FUNCTIONS
83ad : 494e4b4559                 fcc  "INKEY"        ; 98
83b2 : a4                         fcb  $80+'$'
83b3 : 4d45                       fcc  "ME"           ; 99
83b5 : cd                         fcb  $80+'M'
83b6 : 5641525054                 fcc  "VARPT"        ; 9A
83bb : d2                         fcb  $80+'R'
83bc : 494e5354                   fcc  "INST"         ; 9B
83c0 : d2                         fcb  $80+'R'
83c1 : 535452494e47               fcc  "STRING"       ; 9C
83c7 : a4                         fcb  $80+'$'
                        
                        *
                        * DISPATCH TABLE FOR COMMANDS TOKEN #
83c8 :                  CMD_TAB
83c8 : 859a             LAB67     fdb  FOR            ; 80
83ca : 86e3                       fdb  GO             ; 81
83cc : 8740                       fdb  REM            ; 82
0082 =                  TOK_REM   equ  $82			  ; (LL06-CMD_TAB)/2+$7F
83ce : 8740             LL06      fdb  REM            ; 83 (')
0083 =                  TOK_SNGL_Q equ $83			  ; (LL07-CMD_TAB)/2+$7F
83d0 : 8740             LL07      fdb  REM            ; 84 (ELSE)
0084 =                  TOK_ELSE  equ  $84			  ; (LL08-CMD_TAB)/2+$7F
AS09 Assembler for M6809 [1.42].                                     Page   44
--------------------------------- merge.a09 ----------------------------------

83d2 : 8771             LL08	  fdb  IF             ; 85
0085 =                  TOK_IF    equ  $85			  ; (LL09-CMD_TAB)/2+$7F
83d4 : 873d             LL09      fdb  DATA           ; 86
0086 =                  TOK_DATA  equ  $86			  ; (LL10-CMD_TAB)/2+$7F
83d6 : 911b             LL10      fdb  PRINT          ; 87
0087 =                  TOK_PRINT equ  $87			  ; (LL11-CMD_TAB)/2+$7F
83d8 : 879f             LL11      fdb  ON             ; 88
83da : 884c                       fdb  INPUT          ; 89
0089 =                  TOK_INPUT equ  $89			  ; (LL12-CMD_TAB)/2+$7F
83dc : 866a             LL12      fdb  END            ; 8A
83de : 8931                       fdb  NEXT           ; 8B
83e0 : 8b81                       fdb  DIM            ; 8C
83e2 : 8886                       fdb  READ           ; 8D
83e4 : 86d8                       fdb  RUN            ; 8E
83e6 : 864c                       fdb  RESTOR         ; 8F
83e8 : 871d                       fdb  RETURN         ; 90
83ea : 866e                       fdb  STOP           ; 91
83ec : 8f88                       fdb  POKE           ; 92
83ee : 8693                       fdb  CONT           ; 93
83f0 : 8f8f                       fdb  LIST           ; 94
83f2 : 86a4                       fdb  CLEAR          ; 95
83f4 : 856a                       fdb  NEW            ; 96
83f6 : 81ee                       fdb  SET            ; 97
83f8 : 8217             		  fdb  CLS            ; 98
83fa : 8237             		  fdb  SOUND          ; 99
83fc : 81a2             		  fdb  EXEC           ; 9A
83fe : 9d9e                       fdb  DEL            ; 9B
8400 : 99b1                       fdb  EDIT           ; 9C
8402 : 9b25             		  fdb  TRON           ; 9D
8404 : 9b26                       fdb  TROFF          ; 9E
8406 : 9ce4                       fdb  DEF            ; 9F
8408 : a48c                       fdb  LINE           ; A0
840a : 9e28                       fdb  RENUM          ; A1    
840c : a495                       fdb  DIR            ; A2
840e : a4a0                       fdb  KILL           ; A3
8410 : a4ab                       fdb  LOAD           ; A4
8412 : a4b7                       fdb  SAVE           ; A5		  
00a5 =                  TOK_HIGH_EXEC equ  $a5 ; (LABAF-CMD_TAB)/2+$7F
                        
                        * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY
8414 : 4e46             LABAF     fcc  "NF"           ; 0 NEXT WITHOUT FOR
8416 : 534e                       fcc  "SN"           ; 1 SYNTAX ERROR
8418 : 5247                       fcc  "RG"           ; 2 RETURN WITHOUT GOSUB
841a : 4f44                       fcc  "OD"           ; 3 OUT OF DATA
841c : 4643                       fcc  "FC"           ; 4 ILLEGAL FUNCTION CAL
841e : 4f56                       fcc  "OV"           ; 5 OVERFLOW
8420 : 4f4d                       fcc  "OM"           ; 6 OUT OF MEMORY
8422 : 554c                       fcc  "UL"           ; 7 UNDEFINED LINE NUMBE
8424 : 4253                       fcc  "BS"           ; 8 BAD SUBSCRIPT
8426 : 4444                       fcc  "DD"           ; 9 REDIMENSIONED ARRAY
8428 : 2f30                       fcc  "/0"           ; 10 DIVISION BY ZERO
842a : 4944                       fcc  "ID"           ; 11 ILLEGAL DIRECT STAT
842c : 544d                       fcc  "TM"           ; 12 TYPE MISMATCH
842e : 4f53                       fcc  "OS"           ; 13 OUT OF STRING SPACE
8430 : 4c53                       fcc  "LS"           ; 14 STRING TOO LONG
8432 : 5354                       fcc  "ST"           ; 15 STRING FORMULA TOO 
8434 : 434e                       fcc  "CN"           ; 16 CAN'T CONTINUE
8436 : 4644                       fcc  "FD"           ; 17 BAD FILE DATA
8438 : 414f                       fcc  "AO"           ; 18 FILE ALREADY OPEN
843a : 444e                       fcc  "DN"           ; 19 DEVICE NUMBER ERROR
843c : 494f                       fcc  "IO"           ; 20 I/O ERROR
843e : 464d                       fcc  "FM"           ; 21 BAD FILE MODE
AS09 Assembler for M6809 [1.42].                                     Page   45
--------------------------------- merge.a09 ----------------------------------

8440 : 4e4f                       fcc  "NO"           ; 22 FILE NOT OPEN
8442 : 4945                       fcc  "IE"           ; 23 INPUT PAST END OF F
8444 : 4453                       fcc  "DS"           ; 24 DIRECT STATEMENT IN
                        * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC
8446 : 5546             L890B     fcc  "UF"           ; 25 UNDEFINED FUNCTION 
8448 : 4e45             L890D     fcc  "NE"           ; 26 FILE NOT FOUND
                        
844a : 204552524f52     LABE1     fcc  " ERROR"
8450 : 00                         fcb  $00
8451 : 20494e20         LABE8     fcc  " IN "
8455 : 00                         fcb  $00
8456 : 0d               LABED     fcb  CR
8457 : 4f4b             LABEE     fcc  "OK"
8459 : 0d00                       fcb  CR,$00
845b : 0d               LABF2     fcb  CR
845c : 425245414b                 fcc  "BREAK"
8461 : 00                         fcb  $00
                        
                        * SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DA
                        * THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEI
                        * SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT D
                        * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DA
                        * WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DA
                        * IS CONSIDERED 'GOSUB/RETURN'
8462 : 3064             LABF9     leax 4,s            ; POINT X TO 3RD ADDRESS
                        *         FIRST TWO RETURN ADDRESSES ON THE STACK
8464 : c612             LABFB     ldb  #18            ; 18 BYTES SAVED ON STAC
8466 : 9f0f                       stx  TEMPTR         ; SAVE POINTER
8468 : a684                       lda  ,x             ; GET 1ST BYTE
846a : 8080                       suba #$80           ; * CHECK FOR TYPE OF ST
846c : 2615                       bne  LAC1A          ; * BRANCH IF NOT 'FOR/N
846e : ae01                       ldx  1,x            ; = GET INDEX VARIABLE D
8470 : 9f11                       stx  TMPTR1         ; = POINTER AND SAVE IT 
8472 : 9e3b                       ldx  VARDES         ; GET INDEX VARIABLE BEI
8474 : 2709                       beq  LAC16          ; BRANCH IF DEFAULT INDE
                        *                             ; FIRST 'FOR/NEXT' DATA 
                        *                             ; IF NO INDEX VARIABLE A
8476 : 9c11                       cmpx TMPTR1         ; DOES THE STACK INDEX M
                        *                             ; BEING SEARCHED FOR?
8478 : 2709                       beq  LAC1A          ; YES
847a : 9e0f                       ldx  TEMPTR         ; * RESTORE INITIAL POIN
847c : 3a                         abx                 ; * 18 TO IT AND LOOK FO
847d : 20e5                       bra  LABFB          ; * NEXT BLOCK OF DATA
847f : 9e11             LAC16     ldx  TMPTR1         ; = GET 1ST INDEX VARIAB
8481 : 9f3b                       stx  VARDES         ; = SAVE AS 'NEXT' INDEX
8483 : 9e0f             LAC1A     ldx  TEMPTR         ; POINT X TO START OF 'F
8485 : 4d                         tsta                ; SET ZERO FLAG IF 'FOR/
8486 : 39                         rts
                        * CHECK FOR MEMORY SPACE FOR NEW TOP OF
                        * ARRAYS AND MOVE ARRAYS TO NEW LOCATION
8487 : 8d17             LAC1E     bsr  LAC37          ; ACCD = NEW BOTTOM OF F
                        *                             ; ROOM FOR THE STACK?
                        * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND
                        * SAVE FINAL VALUE OF U IN V45
8489 : de41             LAC20     ldu  V41            ; POINT U TO DESTINATION
848b : 3341                       leau 1,u            ; ADD ONE TO U - COMPENS
848d : 9e43                       ldx  V43            ; POINT X TO SOURCE ADDR
848f : 3001                       leax 1,x            ; ADD ONE - COMPENSATE F
8491 : a682             LAC28     lda  ,-x            ; GRAB A BYTE FROM SOURC
8493 : 3602                       pshu a              ; MOVE IT TO DESTINATION
8495 : 9c47                       cmpx V47            ; DONE?
8497 : 26f8                       bne  LAC28          ; NO - KEEP MOVING BYTES
AS09 Assembler for M6809 [1.42].                                     Page   46
--------------------------------- merge.a09 ----------------------------------

8499 : df45                       stu  V45            ; SAVE FINAL DESTINATION
849b : 39               LAC32     rts
                        * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB
                        * BYTES IN FREE RAM - OM ERROR IF NOT
849c : 4f               LAC33     clra                ; * ACCD CONTAINS NUMBER
849d : 58                         aslb                ; * BYTES TO PUT ON STAC
849e : d31f                       addd ARYEND         ; END OF PROGRAM AND VAR
84a0 : c3003a           LAC37     addd #STKBUF        ; ADD STACK BUFFER - ROO
84a3 : 2508                       bcs  LAC44          ; BRANCH IF GREATER THAN
84a5 : 10df17                     sts  BOTSTK         ; CURRENT NEW BOTTOM OF 
84a8 : 109317                     cmpd BOTSTK         ; ARE WE GOING TO BE BEL
84ab : 25ee                       bcs  LAC32          ; YES - NO ERROR
84ad : c60c             LAC44     ldb  #6*2           ; OUT OF MEMORY ERROR
                        
                        * ERROR SERVICING ROUTINE
84af : bd8586           LAC46     jsr  LAD33          ; RESET STACK, STRING ST
84b2 : bd916e                     jsr  LB95C          ; SEND A CR TO SCREEN
84b5 : bd91bc                     jsr  LB9AF          ; SEND A '?' TO SCREEN
84b8 : 8e8414                     ldx  #LABAF         ; POINT TO ERROR TABLE
84bb : 3a               LAC60     abx                 ; ADD MESSAGE NUMBER OFF
84bc : 8d37                       bsr  LACA0          ; * GET TWO CHARACTERS F
84be : 8d35                       bsr  LACA0          ; * SEND TO CONSOLE OUT 
84c0 : 8e8449                     ldx  #LABE1-1       ; POINT TO "ERROR" MESSA
84c3 : bd91a9           LAC68     jsr  LB99C          ; PRINT MESSAGE POINTED 
84c6 : 9668                       lda  CURLIN         ; GET CURRENT LINE NUMBE
84c8 : 4c                         inca                ; TEST FOR DIRECT MODE
84c9 : 2703                       beq  LAC73          ; BRANCH IF DIRECT MODE
84cb : bd95d2                     jsr  LBDC5          ; PRINT 'IN ****'
                        
                        * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE
84ce : bd916e           LAC73     jsr  LB95C          ; MOVE CURSOR TO START O
84d1 : bdedf5                     jsr  APLcurBlinking ; SET THE BLINKING CURSO
84d4 : 8e8456           		  ldx  #LABED         ; POINT X TO 'OK', CR MESSAGE
84d7 : bd91a9                     jsr  LB99C          ; PRINT 'OK', CR
84da : bd8154           LAC7C     jsr  LA390          ; GO GET AN INPUT LINE
84dd : ceffff                     ldu  #$FFFF         ; THE LINE NUMBER FOR DI
84e0 : df68                       stu  CURLIN         ; SAVE IT IN CURLIN
84e2 : 25f6                       bcs  LAC7C          ; BRANCH IF LINE INPUT T
84e4 : 9f83                       stx  CHARAD         ; SAVE (X) AS CURRENT IN
                        *         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. TH
                        *         LINE JUST ENTERED WILL BE INTERPRETED
84e6 : 9d7c                       jsr  GETNCH         ; GET NEXT CHARACTER FRO
84e8 : 27f0                       beq  LAC7C          ; NO LINE INPUT - GET AN
84ea : 250e                       bcs  LACA5          ; BRANCH IF NUMER1C - TH
                        *         THE  STATEMENT ENTEREd, SO THIS STATEMENT
                        *         WILL BE MERGED INTO THE BASIC PROGRAM
84ec : bdedf8                     jsr  APLcurOff	  ; STOP THE BLINKING CURSOR	
84ef : bd9048           		  jsr  LB821          ; GO CRUNCH LINE
84f2 : 7e8621                     jmp  LADC0          ; GO EXECUTE THE STATEME
                        *
84f5 : a680             LACA0     lda  ,x+            ; GET A CHARACTER
84f7 : 7e91be                     jmp  LB9B1          ; SEND TO CONSOLE OUT
                        * TAKE A LINE FROM THE LINE INPUT BUFFER
                        * AND INSERT IT INTO THE BASIC PROGRAM
84fa : bd87c4           LACA5     jsr  LAF67          ; CONVERT LINE NUMBER TO
84fd : 9e2b             LACA8     ldx  BINVAL         ; GET CONVERTED LINE NUM
84ff : 9fdf                       stx  LINHDR         ; STORE IT IN LINE INPUT
8501 : bd9048                     jsr  LB821          ; GO CRUNCH THE LINE
8504 : d703                       stb  TMPLOC         ; SAVE LINE LENGTH
8506 : 8d4c                       bsr  LAD01          ; FIND OUT WHERE TO INSE
8508 : 2512                       bcs  LACC8          ; RANCH IF LINE NUMBER D
850a : dc47                       ldd  V47            ; GET ABSOLUTE ADDRESS O
AS09 Assembler for M6809 [1.42].                                     Page   47
--------------------------------- merge.a09 ----------------------------------

850c : a384                       subd ,x             ; SUBTRACT ADDRESS OF NE
850e : d31b                       addd VARTAB         ; * ADD TO CURRENT END O
8510 : dd1b                       std  VARTAB         ; * THE LENGTH OF THIS L
8512 : ee84                       ldu  ,x             ; POINT U TO ADDRESS OF 
                        * DELETE OLD LINE FROM BASIC PROGRAM
8514 : 3702             LACC0     pulu a              ; GET A BYTE FROM WHAT'S
8516 : a780                       sta  ,x+            ; MOVE IT DOWN
8518 : 9c1b                       cmpx VARTAB         ; COMPARE TO END OF BASI
851a : 26f8                       bne  LACC0          ; BRANCH IF NOT AT END
851c : 96e1             LACC8     lda  LINBUF         ; * CHECK TO SEE IF THER
851e : 271c                       beq  LACE9          ; * THE BUFFER AND BRANC
8520 : dc1b                       ldd  VARTAB         ; = SAVE CURRENT END OF
8522 : dd43                       std  V43            ; = PROGRAM IN V43
8524 : db03                       addb TMPLOC         ; * ADD LENGTH OF CRUNCH
8526 : 8900                       adca #0             ; * PROPOGATE CARRY AND 
8528 : dd41                       std  V41            ; * OF PROGRAM IN V41
852a : bd8487                     jsr  LAC1E          ; = MAKE SURE THERE'S EN
852d : ce00dd                     ldu  #LINHDR-2      ; POINT U TO LINE TO BE 
8530 : 3702             LACDD     pulu a              ; GET A BYTE FROM NEW LI
8532 : a780                       sta  ,x+            ; INSERT IT IN PROGRAM
8534 : 9c45                       cmpx V45            ; * COMPARE TO ADDRESS O
8536 : 26f8                       bne  LACDD          ; * LINE AND BRANCH IF N
8538 : 9e41                       ldx  V41            ; = GET AND SAVE
853a : 9f1b                       stx  VARTAB         ; = END OF PROGRAM
853c : 8d36             LACE9     bsr  LAD21          ; RESET INPUT POINTER, C
853e : 8d02                       bsr  LACEF          ; ADJUST START OF NEXT L
8540 : 2098                       bra  LAC7C          ; EENTER BASIC'S INPUT L
                        * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BAS
8542 : 9e19             LACEF     ldx  TXTTAB         ; POINT X TO START OF PR
8544 : ec84             LACF1     ldd  ,x             ; GET ADDRESS OF NEXT LI
8546 : 2721                       beq  LAD16          ; RETURN IF END OF PROGR
8548 : 3304                       leau 4,x            ; POINT U TO START OF BA
854a : a6c0             LACF7     lda  ,u+            ; * SKIP THROUGH THE LIN
854c : 26fc                       bne  LACF7          ; * ZERO (END OF LINE) I
854e : ef84                       stu  ,x             ; SAVE THE NEW START OF 
8550 : ae84                       ldx  ,x             ; POINT X TO START OF NE
8552 : 20f0                       bra  LACF1          ; KEEP GOING
                        *
                        * FIND A LINE NUMBER IN THE BASIC PROGRAM
                        * RETURN WITH CARRY SET IF NO MATCH FOUND
8554 : dc2b             LAD01     ldd  BINVAL         ; GET THE LINE NUMBER TO
8556 : 9e19                       ldx  TXTTAB         ; BEGINNING OF PROGRAM
8558 : ee84             LAD05     ldu  ,x             ; GET ADDRESS OF NEXT LI
855a : 2709                       beq  LAD12          ; BRANCH IF END OF PROG
855c : 10a302                     cmpd 2,x            ; IS IT A MATCH?
855f : 2306                       bls  LAD14          ; CARRY SET IF LOWER; CA
8561 : ae84                       ldx  ,x             ; X = ADDRESS OF NEXT LI
8563 : 20f3                       bra  LAD05          ; KEEP LOOPING FOR LINE 
8565 : 1a01             LAD12     orcc #1             ; SET CARRY FLAG
8567 : 9f47             LAD14     stx  V47            ; SAVE MATCH LINE NUMBER
                        *                             ; WHERE IT SHOULD HAVE B
8569 : 39               LAD16     rts
                        
                        * NEW
856a : 26fb             NEW       bne  LAD14          ; BRANCH IF ARGUMENT GIV
856c : 9e19             LAD19     ldx  TXTTAB         ; GET START OF BASIC
856e : 6f80                       clr  ,x+            ; * PUT 2 ZERO BYTES THE
8570 : 6f80                       clr  ,x+            ; * THE BASIC PROGRAM
8572 : 9f1b                       stx  VARTAB         ; AND THE NEXT ADDRESS I
8574 : 9e19             LAD21     ldx  TXTTAB         ; GET START OF BASIC
8576 : bd8718                     jsr  LAEBB          ; PUT INPUT POINTER ONE 
                        * ERASE ALL VARIABLES
AS09 Assembler for M6809 [1.42].                                     Page   48
--------------------------------- merge.a09 ----------------------------------

8579 : 9e27             LAD26     ldx  MEMSIZ         ; * RESET START OF STRIN
857b : 9f23                       stx  STRTAB         ; * TO TOP OF STRING SPA
857d : bd864c                     jsr  RESTOR         ; RESET 'DATA' POINTER T
8580 : 9e1b                       ldx  VARTAB         ; * GET START OF VARIABL
8582 : 9f1d                       stx  ARYTAB         ; * TO RESET START OF AR
8584 : 9f1f                       stx  ARYEND         ; RESET END OF ARRAYS
8586 : 8e00b7           LAD33     ldx  #STRSTK        ; * RESET STRING STACK P
8589 : 9f0b                       stx  TEMPPT         ; * BOTTOM OF STRING STA
858b : aee4                       ldx  ,s             ; GET RETURN ADDRESS OFF
858d : 10de21                     lds  FRETOP         ; RESTORE STACK POINTER
8590 : 6fe2                       clr  ,-s            ; PUT A ZERO BYTE ON STA
                        *                             ; FOR/NEXT DATA FROM THE
8592 : 0f2d                       clr  OLDPTR         ; RESET 'CONT' ADDRESS S
8594 : 0f2e                       clr  OLDPTR+1       ; 'CAN'T CONTINUE'
8596 : 0f08                       clr  ARYDIS         ; CLEAR THE ARRAY DISABL
8598 : 6e84                       jmp  ,x             ; RETURN TO CALLING ROUT
                        *                             ; SINCE THE STACK WAS RE
                        *
                        * FOR
                        *
                        * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR
                        * EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE
                        * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);
                        *         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=F
                        *         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO
                        * 9-13=FP VALUE OF 'TO' PARAMETER;
                        * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE 
                        *         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
859a : 8680             FOR       lda  #$80           ; * SAVE THE DISABLE ARR
859c : 9708                       sta  ARYDIS         ; * DO NOT ALLOW THE IND
859e : bd87e6                     jsr  LET            ; SET INDEX VARIABLE TO 
85a1 : bd8462                     jsr  LABF9          ; SEARCH THE STACK FOR '
85a4 : 3262                       leas 2,s            ; PURGE RETURN ADDRESS O
85a6 : 2604                       bne  LAD59          ; BRANCH IF INDEX VARIAB
85a8 : 9e0f                       ldx  TEMPTR         ; GET (ADDRESS + 18) OF 
85aa : 3285                       leas b,x            ; MOVE THE STACK POINTER
                        * MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
                        * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY
                        * ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
                        * THIS POINT ON THE STACK
85ac : c609             LAD59     ldb  #$09           ; * CHECK FOR ROOM FOR 1
85ae : bd849c                     jsr  LAC33          ; * IN FREE RAM
85b1 : bd8745                     jsr  LAEE8          ; GET ADDR OF END OF SUB
85b4 : dc68                       ldd  CURLIN         ; GET CURRENT LINE NUMBE
85b6 : 3416                       pshs x,b,a          ; SAVE LINE ADDR AND LIN
85b8 : c6a7                       ldb  #TOK_TO        ; TOKEN FOR 'TO'
85ba : bd8aa8                     jsr  LB26F          ; SYNTAX CHECK FOR 'TO'
85bd : bd897c                     jsr  LB143          ; 'TM' ERROR IF INDEX VA
85c0 : bd897a                     jsr  LB141          ; EVALUATE EXPRESSION
                        *
85c3 : d654                       ldb  FP0SGN         ; GET FPA0 MANTISSA SIGN
85c5 : ca7f                       orb  #$7F           ; FORM A MASK TO SAVE DA
85c7 : d450                       andb FPA0           ; PUT THE MANTISSA SIGN 
85c9 : d750                       stb  FPA0           ; SAVE THE PACKED HIGH O
85cb : 108e85d2                   ldy  #LAD7F         ; LOAD FOLLOWING ADDRESS
85cf : 7e8a23                     jmp  LB1EA          ; ADDRESS - PUSH FPA0 ON
85d2 : 8e92d2           LAD7F     ldx  #LBAC5         ; POINT X TO FLOATING PO
85d5 : bd9421                     jsr  LBC14          ; MOVE (X) TO FPA0
85d8 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
85da : 81ab                       cmpa #TOK_STEP      ; STEP TOKEN
85dc : 2605                       bne  LAD90          ; BRANCH IF NO 'STEP' VA
85de : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
AS09 Assembler for M6809 [1.42].                                     Page   49
--------------------------------- merge.a09 ----------------------------------

85e0 : bd897a                     jsr  LB141          ; EVALUATE NUMERIC EXPRE
85e3 : bd947a           LAD90     jsr  LBC6D          ; CHECK STATUS OF FPA0
85e6 : bd8a1f                     jsr  LB1E6          ; SAVE STATUS AND FPA0 O
85e9 : dc3b                       ldd  VARDES         ; * GET DESCRIPTOR POINT
85eb : 3406                       pshs b,a            ; * VARIABLE AND SAVE IT
85ed : 8680                       lda  #$80           ; = GET THE 'FOR' FLAG A
85ef : 3402                       pshs a              ; = SAVE IT ON THE STACK
                        *
                        * MAIN COMMAND INTERPRETATION LOOP
85f1 : 8d60             LAD9E     bsr  LADEB          ; CHECK FOR KEYBOARD BRE
85f3 : 9e83                       ldx  CHARAD         ; GET BASIC'S INPUT POIN
85f5 : 9f2f                       stx  TINPTR         ; SAVE IT
85f7 : a680                       lda  ,x+            ; GET CURRENT INPUT CHAR
85f9 : 2707                       beq  LADB4          ; BRANCH IF END OF LINE
85fb : 813a                       cmpa #':'            ; CHECK FOR LINE SEPARA
85fd : 2722                       beq  LADC0          ; BRANCH IF COLON
85ff : 7e8ab0           LADB1     jmp  LB277          ; 'SYNTAX ERROR'-IF NOT 
8602 : a681             LADB4     lda  ,x++           ; GET MS BYTE OF ADDRESS
8604 : 9700                       sta  ENDFLG         ; SAVE IN STOP/END FLAG 
                        *                             ; NEXT LINE ADDRESS IS <
                        *                             ; AN END IF ADDRESS > $8
8606 : 2772                       beq LAE15           ; BRANCH TO 'STOP' - END
8608 : ec80                       ldd  ,x+            ; GET CURRENT LINE NUMBE
860a : dd68                       std  CURLIN         ; SAVE IN CURLIN
860c : 9f83                       stx  CHARAD         ; SAVE ADDRESS OF FIRST 
                        * EXTENDED BASIC TRACE
860e : 968c                       lda  TRCFLG         ; TEST THE TRACE FLAG
8610 : 270f                       beq  LADC0          ; BRANCH IF TRACE OFF
8612 : 865b                       lda  #$5B           ; <LEFT HAND MARKER FOR 
8614 : bd805c                     jsr  PUTCHR         ; OUTPUT A CHARACTER
8617 : 9668                       lda  CURLIN         ; GET MS BYTE OF LINE NU
8619 : bd95d9                     jsr  LBDCC          ; CONVERT ACCD TO DECIMA
861c : 865d                       lda  #$5D           ; > RIGHT HAND MARKER FO
861e : bd805c                     jsr  PUTCHR         ; OUTPUT A CHARACTER
                        * END OF EXTENDED BASIC TRACE
8621 : 9d7c             LADC0     jsr  GETNCH         ; GET A CHARACTER FROM B
8623 : 8d02                       bsr  LADC6          ; GO PROCESS COMMAND
8625 : 20ca                       bra  LAD9E          ; GO BACK TO MAIN LOOP
8627 : 2729             LADC6     beq  LADEA          ; RETURN IF END OF LINE 
8629 : 4d                         tsta                ; CHECK FOR TOKEN - BIT 
862a : 102a01b8                   lbpl LET            ; BRANCH IF NOT A TOKEN 
                        * 
862e : 81ff                       cmpa #$FF           ; SECONDARY TOKEN
8630 : 270f                       beq  SECTOK
8632 : 81a5                       cmpa #TOK_HIGH_EXEC ; SKIPF TOKEN - HIGHEST 
8634 : 22c9                       bhi  LADB1          ; 'SYNTAX ERROR' IF NON-
8636 : be8101                     ldx  COMVEC+3       ; GET ADDRESS OF BASIC'S
8639 : 48               LADD4     asla                ; X2 (2 BYTE/JUMP ADDRES
863a : 1f89                       tfr  a,b            ; SAVE COMMAND OFFSET IN
863c : 3a                         abx                 ; NON X POINTS TO COMMAN
863d : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHAR
                        *
                        * HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
863f : 6e94                       jmp  [,x]           ; GO DO A COMMAND
8641 :                  SECTOK
                        * THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTA
                        * THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHEC
8641 : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHAR
8643 : 8197                       cmpa #TOK_MID       ; TOKEN FOR "MID$"
8645 : 10271501                   lbeq L86D6          ; PROCESS MID$ REPLACEME
8649 : 7e8ab0                     jmp  LB277          ; SYNTAX ERROR
                        
AS09 Assembler for M6809 [1.42].                                     Page   50
--------------------------------- merge.a09 ----------------------------------

                        *
                        * RESTORE
864c : 9e19             RESTOR    ldx  TXTTAB         ; BEGINNING OF PROGRAM A
864e : 301f                       leax -1,x           ; MOVE TO ONE BYTE BEFOR
8650 : 9f33             LADE8     stx  DATPTR         ; SAVE NEW DATA POINTER
8652 : 39               LADEA     rts
                        *
                        * BREAK CHECK
8653 : bd804f           LADEB     jsr  LA1C1          ; GET A KEYSTROKE ENTRY
8656 : 270a                       beq  LADFA          ; RETURN IF NO INPUT
8658 : 8103             LADF0     cmpa #3             ; CONTROL C? (BREAK)
865a : 2712                       beq  STOP           ; YES
865c : 8113                       cmpa #$13           ; CONTROL S? (PAUSE)
865e : 2703                       beq  LADFB          ; YES
8660 : 9773                       sta  IKEYIM         ; SAVE KEYSTROKE IN INKE
8662 : 39               LADFA     rts
8663 : bd804f           LADFB     jsr  KEYIN          ; GET A KEY
8666 : 27fb                       beq  LADFB          ; BRANCH IF NO KEY DOWN
8668 : 20ee                       bra  LADF0          ; CONTINUE - DO A BREAK 
                        *
                        * END
866a : 9d82             END       jsr  GETCCH         ; GET CURRENT INPUT CHAR
866c : 2002                       bra  LAE0B
                        *
                        * STOP
866e : 1a01             STOP      orcc #$01           ; SET CARRY FLAG
8670 : 2631             LAE0B     bne  LAE40          ; BRANCH IF ARGUMENT EXI
8672 : 9e83                       ldx  CHARAD         ; * SAVE CURRENT POSITIO
8674 : 9f2f                       stx  TINPTR         ; * BASIC'S INPUT POINTE
8676 : 0600             LAE11     ror  ENDFLG         ; ROTATE CARRY INTO BIT 
8678 : 3262                       leas 2,s            ; PURGE RETURN ADDRESS O
867a : 9e68             LAE15     ldx  CURLIN         ; GET CURRENT LINE NUMBE
867c : 8cffff                     cmpx #$FFFF         ; DIRECT MODE?
867f : 2706                       beq  LAE22          ; YES
8681 : 9f29                       stx  OLDTXT         ; SAVE CURRENT LINE NUMB
8683 : 9e2f                       ldx  TINPTR         ; * GET AND SAVE CURRENT
8685 : 9f2d                       stx  OLDPTR         ; * OF BASIC'S INPUT POI
8687 :                  LAE22
8687 : 8e845a                     ldx  #LABF2-1       ; POINT TO CR, 'BREAK' M
868a : 0d00                       tst  ENDFLG         ; CHECK STOP/END FLAG
868c : 102afe3e                   lbpl LAC73          ; BRANCH TO MAIN LOOP OF
8690 : 7e84c3                     jmp  LAC68          ; PRINT 'BREAK AT ####' 
                        *                             ; BASIC'S MAIN LOOP IF '
                        
                        * CONT
8693 : 260e             CONT      bne  LAE40          ; RETURN IF ARGUMENT GIV
8695 : c620                       ldb  #2*16          ; 'CAN'T CONTINUE' ERROR
8697 : 9e2d                       ldx  OLDPTR         ; GET CONTINUE ADDRESS (
8699 : 1027fe12                   lbeq LAC46          ; 'CN' ERROR IF CONTINUE
869d : 9f83                       stx  CHARAD         ; RESET BASIC'S INPUT PO
869f : 9e29                       ldx  OLDTXT         ; GET LINE NUMBER
86a1 : 9f68                       stx  CURLIN         ; RESET CURRENT LINE NUM
86a3 : 39               LAE40     rts
                        *
                        * CLEAR
86a4 : 272c             CLEAR     beq  LAE6F          ; BRANCH IF NO ARGUMENT
86a6 : bd8c19                     jsr  LB3E6          ; EVALUATE ARGUMENT
86a9 : 3406                       pshs b,a            ; SAVE AMOUNT OF STRING 
86ab : 9e27                       ldx  MEMSIZ         ; GET CURRENT TOP OF CLE
86ad : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
86af : 270c                       beq  LAE5A          ; BRANCH IF NO NEW TOP O
86b1 : bd8aa6                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
AS09 Assembler for M6809 [1.42].                                     Page   51
--------------------------------- merge.a09 ----------------------------------

86b4 : bd8f6e                     jsr  LB73D          ; EVALUATE EXPRESSlON; R
86b7 : 301f                       leax -1,x           ; X = TOP OF CLEARED SPA
86b9 : 9c71                       cmpx TOPRAM         ; COMPARE TO TOP OF RAM
86bb : 2218                       bhi  LAE72          ; 'OM' ERROR IF > TOP OF
86bd : 1f10             LAE5A     tfr  x,d            ; ACCD = TOP OF CLEARED 
86bf : a3e1                       subd ,s++           ; SUBTRACT OUT AMOUNT OF
86c1 : 2512                       bcs  LAE72          ; 'OM' ERROR IF FREE MEM
86c3 : 1f03                       tfr  d,u            ; U = BOTTOM OF CLEARED 
86c5 : 83003a                     subd #STKBUF        ; SUBTRACT OUT STACK BUF
86c8 : 250b                       bcs  LAE72          ; 'OM' ERROR IF FREE MEM
86ca : 931b                       subd VARTAB         ; SUBTRACT OUT START OF 
86cc : 2507                       bcs  LAE72          ; 'OM' ERROR IF FREE MEM
86ce : df21                       stu  FRETOP         ; SAVE NEW BOTTOM OF CLE
86d0 : 9f27                       stx  MEMSIZ         ; SAVE NEW TOP OF CLEARE
86d2 : 7e8579           LAE6F     jmp  LAD26          ; ERASE ALL VARIABLES, I
86d5 : 7e84ad           LAE72     jmp  LAC44          ; 'OM' ERROR
                        *
                        * RUN
86d8 : 9d82             RUN       jsr  GETCCH         ; * GET CURRENT INPUT CH
86da : 1027fe96                   lbeq LAD21          ; * IF NO LINE NUMBER
86de : bd8579                     jsr  LAD26          ; ERASE ALL VARIABLES
86e1 : 2019                       bra  LAE9F          ; 'GOTO' THE RUN ADDRESS
                        *
                        * GO
86e3 : 1f89             GO        tfr  a,b            ; SAVE INPUT CHARACTER I
86e5 : 9d7c             LAE88     jsr  GETNCH         ; GET A CHARACTER FROM B
86e7 : c1a7                       cmpb #TOK_TO        ; 'TO' TOKEN
86e9 : 2716                       beq  LAEA4          ; BRANCH IF GOTO
86eb : c1a8                       cmpb #TOK_SUB       ; 'SUB' TOKEN
86ed : 2645                       bne  LAED7          ; 'SYNTAX ERROR' IF NEIT
86ef : c603                       ldb  #3             ; =ROOM FOR 6
86f1 : bd849c                     jsr  LAC33          ; =BYTES ON STACK?
86f4 : de83                       ldu  CHARAD         ; * SAVE CURRENT BASIC I
86f6 : 9e68                       ldx  CURLIN         ; * NUMBER AND SUB TOKEN
86f8 : 86a8                       lda  #TOK_SUB       ; *
86fa : 3452                       pshs u,x,a          ; *
86fc : 8d03             LAE9F     bsr  LAEA4          ; GO DO A 'GOTO'
86fe : 7e85f1                     jmp  LAD9E          ; JUMP BACK TO BASIC'S M
                        * GOTO
8701 : 9d82             LAEA4     jsr  GETCCH         ; GET CURRENT INPUT CHAR
8703 : bd87c4                     jsr  LAF67          ; GET LINE NUMBER TO BIN
8706 : 8d40                       bsr  LAEEB          ; ADVANCE BASIC'S POINTE
8708 : 3001                       leax $01,x          ; POINT TO START OF NEXT
870a : dc2b                       ldd  BINVAL         ; GET THE LINE NUMBER TO
870c : 109368                     cmpd CURLIN         ; COMPARE TO CURRENT LIN
870f : 2202                       bhi  LAEB6          ; IF REO'D LINE NUMBER I
                        *              ; DON'T START LOOKING FROM
                        *              ; START OF PROGRAM
8711 : 9e19                       ldx  TXTTAB         ; BEGINNING OF PROGRAM
8713 : bd8558           LAEB6     jsr  LAD05          ; GO FIND A LINE NUMBER
8716 : 2517                       bcs  LAED2          ; 'UNDEFINED LINE NUMBER
8718 : 301f             LAEBB     leax -1,x           ; MOVE BACK TO JUST BEFO
871a : 9f83                       stx  CHARAD         ; RESET BASIC'S INPUT PO
871c : 39               LAEBF     rts
                        *
                        * RETURN
871d : 26fd             RETURN    bne  LAEBF          ; EXIT ROUTINE IF ARGUME
871f : 86ff                       lda  #$FF           ; * PUT AN ILLEGAL VARIA
8721 : 973b                       sta  VARDES         ; * VARDES WHICH WILL CA
                        *              ; STACK TO BE IGNORED
8723 : bd8462                     jsr  LABF9          ; CHECK FOR RETURN DATA 
8726 : 1f14                       tfr  x,s            ; RESET STACK POINTER - 
AS09 Assembler for M6809 [1.42].                                     Page   52
--------------------------------- merge.a09 ----------------------------------

                        *              ; FROM THE STACK
8728 : 8128                       cmpa #TOK_SUB-$80   ; SUB TOKEN - $80
872a : 270b                       beq  LAEDA          ; BRANCH IF 'RETURN' FRO
872c : c604                       ldb  #2*2           ; ERROR #2 'RETURN WITHO
872e : 8c                         fcb  SKP2           ; SKIP TWO BYTES
872f : c60e             LAED2     ldb  #7*2           ; ERROR #7 'UNDEFINED LI
8731 : 7e84af                     jmp  LAC46          ; JUMP TO ERROR HANDLER
8734 : 7e8ab0           LAED7     jmp  LB277          ; 'SYNTAX ERROR'
8737 : 3552             LAEDA     puls a,x,u          ; * RESTORE VALUES OF CU
8739 : 9f68                       stx  CURLIN         ; * BASIC'S INPUT POINTE
873b : df83                       stu  CHARAD         ; * AND LOAD ACCA WITH S
                        *
                        * DATA
873d : 8d06             DATA      bsr  LAEE8          ; MOVE INPUT POINTER TO 
873f : 8c                         fcb  SKP2           ; SKIP 2 BYTES
                        
                        * REM, ELSE
8740 :                  ELSE
8740 : 8d06             REM       bsr  LAEEB          ; MOVE INPUT POINTER TO 
8742 : 9f83                       stx  CHARAD         ; RESET BASIC'S INPUT PO
8744 : 39               LAEE7     rts
                        * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE
8745 : c63a             LAEE8     ldb  #':'            ; COLON = SUBLINE TERMI
8747 : 86               LAEEA     fcb  SKP1LD         ; SKPILD SKIP ONE BYTE; 
                        * ADVANCE BASIC'S INPUT POINTER TO END OF
                        * LINE - RETURN ADDRESS OF END OF LINE+1 IN X
8748 : 5f               LAEEB     clrb                ; 0 = LINE TERMINATOR CH
8749 : d701                       stb  CHARAC         ; TEMP STORE PRIMARY TER
874b : 5f                         clrb                ; 0 (END OF LINE) = ALTE
874c : 9e83                       ldx  CHARAD         ; LOAD X W/BASIC'S INPUT
874e : 1f98             LAEF1     tfr  b,a            ; * CHANGE TERMINATOR CH
8750 : d601                       ldb  CHARAC         ; * FROM ACCB TO CHARAC 
                        *         IN   CHARAC
8752 : 9701                       sta  CHARAC         ; SWAP PRIMARY AND SECON
8754 : a684             LAEF7     lda  ,x             ; GET NEXT INPUT CHARACT
8756 : 27ec                       beq  LAEE7          ; RETURN IF 0 (END OF LI
8758 : 3404                       pshs b              ; SAVE TERMINATOR ON STA
875a : a1e0                       cmpa ,s+            ; COMPARE TO INPUT CHARA
875c : 27e6                       beq  LAEE7          ; RETURN IF EQUAL
875e : 3001                       leax 1,x            ; MOVE POINTER UP ONE
8760 : 8122                       cmpa #'"'            ; CHECK FOR DOUBLE QUOT
8762 : 27ea                       beq  LAEF1          ; BRANCH IF " - TOGGLE T
8764 : 4c                         inca                ; * CHECK FOR $FF AND BR
8765 : 2602                       bne  LAF0C          ; * NOT SECONDARY TOKEN
8767 : 3001                       leax 1,x            ; MOVE INPUT POINTER 1 M
8769 : 8186             LAF0C     cmpa #TOK_IF+1      ; TOKEN FOR IF?
876b : 26e7                       bne  LAEF7          ; NO - GET ANOTHER INPUT
876d : 0c04                       inc  IFCTR          ; INCREMENT IF COUNTER -
                        *                             ; 'IF' STATEMENTS ARE NE
876f : 20e3                       bra  LAEF7          ; GET ANOTHER INPUT CHAR
                        
                        * IF
8771 : bd897a           IF        jsr  LB141          ; EVALUATE NUMERIC EXPRE
8774 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
8776 : 8181                       cmpa #TOK_GO        ; TOKEN FOR GO
8778 : 2705                       beq  LAF22          ; TREAT 'GO' THE SAME AS
877a : c6a9                       ldb  #TOK_THEN      ; TOKEN FOR THEN
877c : bd8aa8                     jsr  LB26F          ; DO A SYNTAX CHECK ON A
877f : 964f             LAF22     lda  FP0EXP         ; CHECK FOR TRUE/FALSE -
8781 : 2613                       bne  LAF39          ; BRANCH IF CONDITION TR
8783 : 0f04                       clr  IFCTR          ; CLEAR FLAG - KEEP TRAC
                        *                             ; TO SEARCH FOR IN NESTE
AS09 Assembler for M6809 [1.42].                                     Page   53
--------------------------------- merge.a09 ----------------------------------

8785 : 8db6             LAF28     bsr  DATA           ; MOVE BASIC'S POINTER T
8787 : 4d                         tsta                ; * CHECK TO SEE IF END 
8788 : 27ba                       beq  LAEE7          ; * AND RETURN IF END OF
878a : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHARACTER
878c : 8184                       cmpa #TOK_ELSE      ; TOKEN FOR ELSE
878e : 26f5                       bne  LAF28          ; IGNORE ALL DATA EXCEPT
                        *                             ; END OF LINE (ZERO BYTE
8790 : 0a04                       dec  IFCTR          ; CHECK TO SEE IF YOU MU
8792 : 2af1                       bpl  LAF28          ; BRANCH TO SEARCH ANOTH
8794 : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHARACTER
8796 : 9d82             LAF39     jsr  GETCCH         ; GET CURRENT INPUT CHAR
8798 : 1025ff65                   lbcs LAEA4          ; BRANCH TO 'GOTO' IF NU
879c : 7e8627                     jmp  LADC6          ; RETURN TO MAIN INTERPR
                        
                        * ON
879f : bd8f3c           ON        jsr  LB70B          ; EVALUATE EXPRESSION
87a2 : c681                       ldb  #TOK_GO        ; TOKEN FOR GO
87a4 : bd8aa8                     jsr  LB26F          ; SYNTAX CHECK FOR GO
87a7 : 3402                       pshs a              ; SAVE NEW TOKEN (TO,sUB
87a9 : 81a8                       cmpa #TOK_SUB       ; TOKEN FOR SUB?
87ab : 2704                       beq  LAF54          ; YES
87ad : 81a7                       cmpa #TOK_TO        ; TOKEN FOR TO?
87af : 2683             LAF52     lbne LAED7          ; 'SYNTAX' ERROR IF NOT 
87b1 : 0a53             LAF54     dec  FPA0+3         ; DECREMENT IS BYTE OF M
                        *                             ; IS THE ARGUMENT OF THE
87b3 : 2605                       bne  LAF5D          ; BRANCH IF NOT AT THE P
87b5 : 3504                       puls b              ; GET BACK THE TOKEN FOL
87b7 : 7e86e5                     jmp  LAE88          ; GO DO A 'GOTO' OR 'GOS
87ba : 9d7c             LAF5D     jsr  GETNCH         ; GET A CHARACTER FROM B
87bc : 8d06                       bsr  LAF67          ; CONVERT BASIC LINE NUM
87be : 812c                       cmpa #','           ; IS CHARACTER FOLLOWING
87c0 : 27ef                       beq  LAF54          ; YES
87c2 : 3584                       puls b,pc           ; IF NOT, FALL THROUGH T
87c4 : 9e74             LAF67     ldx  ZERO           ; DEFAULT LINE NUMBER OF
87c6 : 9f2b                       stx  BINVAL         ; SAVE IT IN BINVAL
                        *
                        * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINV
                        *
87c8 : 2461             LAF6B     bcc  LAFCE          ; RETURN IF NOT NUMERIC 
87ca : 8030                       suba #'0'            ; MASK OFF ASCII
87cc : 9701                       sta  CHARAC         ; SAVE DIGIT IN VO1
87ce : dc2b                       ldd  BINVAL         ; GET ACCUMULATED LINE N
87d0 : 8118                       cmpa #24            ; LARGEST LINE NUMBER IS
                        *         (24*256+255)*10+9
87d2 : 22db                       bhi  LAF52          ; 'SYNTAX' ERROR IF TOO 
                        * MULT ACCD X 10
87d4 : 58                         aslb                ; *
87d5 : 49                         rola                ; * TIMES 2
87d6 : 58                         aslb                ; =
87d7 : 49                         rola                ; = TIMES 4
87d8 : d32b                       addd BINVAL         ; ADD 1 = TIMES 5
87da : 58                         aslb                ; *
87db : 49                         rola                ; * TIMES 10
87dc : db01                       addb CHARAC         ; ADD NEXT DIGIT
87de : 8900                       adca #0             ; PROPAGATE CARRY
87e0 : dd2b                       std  BINVAL         ; SAVE NEW ACCUMULATED L
87e2 : 9d7c                       jsr  GETNCH         ; GET NEXT CHARACTER FRO
87e4 : 20e2                       bra  LAF6B          ; LOOP- PROCESS NEXT DIG
                        *
                        * LET (EXBAS)
                        * EVALUATE A NON-TOKEN EXPRESSION
                        * TARGET = REPLACEMENT
AS09 Assembler for M6809 [1.42].                                     Page   54
--------------------------------- merge.a09 ----------------------------------

87e6 : bd8b8a           LET       jsr  LB357          ; FIND TARGET VARIABLE D
87e9 : 9f3b                       stx  VARDES         ; SAVE DESCRIPTOR ADDRES
87eb : c6b5                       ldb  #TOK_EQUALS    ; TOKEN FOR "="
87ed : bd8aa8                     jsr  LB26F          ; DO A SYNTAX CHECK FOR 
87f0 : 9606                       lda  VALTYP         ; * GET VARIABLE TYPE AN
87f2 : 3402                       pshs a              ; * SAVE ON THE STACK
87f4 : bd898f                     jsr  LB156          ; EVALUATE EXPRESSION
87f7 : 3502                       puls a              ; * REGET VARIABLE TYPE 
87f9 : 46                         rora                ; * SET CARRY IF STRING
87fa : bd8981                     jsr  LB148          ; TYPE CHECK-TM ERROR IF
                        *                             ; BOTH SIDES OF EQUALS S
87fd : 10270c3f                   lbeq LBC33          ; GO PUT FPA0 INTO VARIA
                        * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT
                        * FPA0+2 INTO THE STRING SPACE. TRANSFER THE
                        * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES
                        * DON'T MOVE THE STRING IF IT IS ALREADY IN THE
                        * STRING SPACE. REMOVE DESCRIPTOR FROM STRING
                        * STACK IF IT IS LAST ONE ON THE STACK
8801 : 9e52             LAFA4     ldx  FPA0+2         ; POINT X TO DESCRIPTOR 
8803 : dc21                       ldd  FRETOP         ; LOAD ACCD WITH START O
8805 : 10a302                     cmpd 2,x            ; IS THE STRING IN STRIN
8808 : 2411                       bcc  LAFBE          ; BRANCH IF IT'S NOT IN 
880a : 9c1b                       cmpx VARTAB         ; COMPARE DESCRIPTOR ADD
880c : 250d                       bcs  LAFBE          ; BRANCH IF DESCRIPTOR A
880e : e684             LAFB1     ldb  ,x             ; GET LENGTH OF REPLACEM
8810 : bd8d40                     jsr  LB50D          ; RESERVE ACCB BYTES OF 
8813 : 9e4d                       ldx  V4D            ; GET DESCRIPTOR ADDRESS
8815 : bd8e75                     jsr  LB643          ; MOVE STRING INTO STRIN
8818 : 8e0056                     ldx  #STRDES        ; POINT X TO TEMP STRING
881b : 9f4d             LAFBE     stx  V4D            ; SAVE STRING DESCRIPTOR
881d : bd8ea7                     jsr  LB675          ; REMOVE STRING DESCRIPT
                        *              ; ON STRING STACK
8820 : de4d                       ldu  V4D            ; POINT U TO REPLACEMENT
8822 : 9e3b                       ldx  VARDES         ; GET TARGET DESCRIPTOR 
8824 : 3726                       pulu a,b,y          ; GET LENGTH AND START O
8826 : a784                       sta  ,x             ; * SAVE STRING LENGTH A
8828 : 10af02                     sty  2,x            ; * TARGET DESCRIPTOR LO
882b : 39               LAFCE     rts
                        
882c : 3f5245444f       LAFCF     fcc  "?REDO"        ; ?REDO MESSAGE
8831 : 0d00                       fcb  CR,$00
                        
8833 :                  LAFD6
8833 : 7e84af           LAFDC     jmp  LAC46          ; jmp TO ERROR HANDLER
8836 : 9609             LAFDF     lda  INPFLG         ; = GET THE INPUT FLAG A
8838 : 2707                       beq  LAFEA          ; = IF 'INPUT'
883a : 9e31                       ldx  DATTXT         ; * GET LINE NUMBER WHER
883c : 9f68                       stx  CURLIN         ; * AND USE IT AS THE CU
883e : 7e8ab0                     jmp  LB277          ; 'SYNTAX ERROR'
8841 : 8e882b           LAFEA     ldx  #LAFCF-1       ; * POINT X TO '?REDO' A
8844 : bd91a9                     jsr  LB99C          ; * IT ON THE SCREEN
8847 : 9e2f                       ldx  TINPTR         ; = GET THE SAVED ABSOLU
8849 : 9f83                       stx  CHARAD         ; = INPUT POINTER AND RE
884b : 39                         rts
                        *
                        * INPUT
884c : c616             INPUT     ldb  #11*2          ; 'ID' ERROR
884e : 9e68                       ldx  CURLIN         ; GET CURRENT LINE NUMBE
8850 : 3001                       leax 1,x            ; ADD ONE
8852 : 27df                       beq  LAFDC          ; 'ID' ERROR BRANCH IF D
8854 : 8d01                       bsr  LB00F          ; GET SOME INPUT DATA - 
8856 : 39                         rts
AS09 Assembler for M6809 [1.42].                                     Page   55
--------------------------------- merge.a09 ----------------------------------

8857 : 8122             LB00F     cmpa #'"'           ; CHECK FOR PROMPT STRIN
8859 : 260b                       bne  LB01E          ; BRANCH IF NO PROMPT ST
885b : bd8a7d                     jsr  LB244          ; PUT PROMPT STRING ON S
885e : c63b                       ldb  #';'           ; *
8860 : bd8aa8                     jsr  LB26F          ; * DO A SYNTAX CHECK FO
8863 : bd91ac                     jsr  LB99F          ; PRINT MESSAGE TO CONSO
8866 : 8e00e1           LB01E     ldx  #LINBUF        ; POINT TO BASIC'S LINE 
8869 : 6f84                       clr  ,x             ; CLEAR 1ST BYTE - FLAG 
                        *              ; IN LINE BUFFER
886b : 8d06                       bsr  LB02F          ; INPUT A STRING TO LINE
886d : c62c                       ldb  #','           ; * INSERT A COMMA AT TH
886f : e784                       stb  ,x             ; * OF THE LINE INPUT BU
8871 : 2016                       bra  LB049
                        * FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
8873 : bd91bc           LB02F     jsr  LB9AF          ; SEND A "?" TO CONSOLE 
8876 : bd91b9                     jsr  LB9AC          ; SEND A 'SPACE' TO CONS
8879 : bd8154           LB035     jsr  LA390          ; GO READ IN A BASIC LIN
887c : 2405                       bcc  LB03F          ; BRANCH IF ENTER KEY EN
887e : 3264                       leas 4,s            ; PURGE TWO RETURN ADDRE
8880 : 7e8676                     jmp  LAE11          ; GO DO A 'STOP' IF BREA
8883 : c62e             LB03F     ldb  #2*23          ; 'INPUT PAST END OF FIL
8885 : 39                         rts
                        *
                        * READ
8886 : 9e33             READ      ldx  DATPTR         ; GET 'READ' START ADDRE
8888 : 86                         fcb  SKP1LD         ; SKIP ONE BYTE - lda #*
8889 : 4f               LB049     clra                ; 'INPUT' ENTRY POINT: I
888a : 9709                       sta  INPFLG         ; SET INPUT FLAG; 0 = IN
888c : 9f35                       stx  DATTMP         ; SAVE 'READ' START ADDR
888e : bd8b8a           LB04E     jsr  LB357          ; EVALUATE A VARIABLE
8891 : 9f3b                       stx  VARDES         ; SAVE DESCRIPTOR ADDRES
8893 : 9e83                       ldx  CHARAD         ; * GET BASIC'S INPUT PO
8895 : 9f2b                       stx  BINVAL         ; * AND SAVE IT
8897 : 9e35                       ldx  DATTMP         ; GET 'READ' ADDRESS STA
8899 : a684                       lda  ,x             ; GET A CHARACTER FROM T
889b : 2609                       bne  LB069          ; BRANCH IF NOT END OF L
889d : 9609                       lda  INPFLG         ; * CHECK INPUT FLAG AND
889f : 2651                       bne  LB0B9          ; * IF LOOKING FOR DATA 
                        * NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
                        * NOT COMING FROM SCREEN
88a1 : bd91bc                     jsr  LB9AF          ; SEND A '?' TO CONSOLE 
88a4 : 8dcd                       bsr  LB02F          ; FILL INPUT BUFFER FROM
88a6 : 9f83             LB069     stx  CHARAD         ; RESET BASIC'S INPUT PO
88a8 : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
88aa : d606                       ldb  VALTYP         ; * CHECK VARIABLE TYPE 
88ac : 2723                       beq  LB098          ; * BRANCH IF NUMERIC
                        * READ/INPUT A STRING VARIABLE
88ae : 9e83                       ldx  CHARAD         ; LOAD X WITH CURRENT BA
88b0 : 9701                       sta  CHARAC         ; SAVE CURRENT INPUT CHA
88b2 : 8122                       cmpa #'"'           ; CHECK FOR STRING DELIM
88b4 : 270e                       beq  LB08B          ; BRANCH IF STRING DELIM
88b6 : 301f                       leax -1,x           ; BACK UP POINTER
88b8 : 4f                         clra                ; * ZERO = END OF LINE C
88b9 : 9701                       sta  CHARAC         ; * SAVE AS TERMINATOR
88bb : bd8146                     jsr  LA35F          ; SET UP PRINT PARAMETER
88be : 863a                       lda  #':'           ; END OF SUBLINE CHARACT
88c0 : 9701                       sta  CHARAC         ; SAVE AS TERMINATOR I
88c2 : 862c                       lda  #','           ; COMMA
88c4 : 9702             LB08B     sta  ENDCHR         ; SAVE AS TERMINATOR 2
88c6 : bd8d51                     jsr  LB51E          ; STRIP A STRING FROM TH
88c9 : bd8a82                     jsr  LB249          ; MOVE INPUT POINTER TO 
88cc : bd8801                     jsr  LAFA4          ; PUT A STRING INTO THE 
AS09 Assembler for M6809 [1.42].                                     Page   56
--------------------------------- merge.a09 ----------------------------------

88cf : 2006                       bra  LB09E          ; CHECK FOR ANOTHER DATA
                        * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM
88d1 : bd951f           LB098     jsr  LBD12          ; CONVERT AN ASCII STRIN
88d4 : bd9440                     jsr  LBC33          ; PACK FPA0 AND STORE IT
                        *                             ; INPUT OR READ DATA ITE
88d7 : 9d82             LB09E     jsr  GETCCH         ; GET CURRENT INPUT CHAR
88d9 : 2706                       beq  LB0A8          ; BRANCH IF END OF LINE
88db : 812c                       cmpa #','            ; CHECK FOR A COMMA
88dd : 1026ff52                   lbne LAFD6          ; BAD FILE DATA' ERROR O
88e1 : 9e83             LB0A8     ldx  CHARAD         ; * GET CURRENT INPUT
88e3 : 9f35                       stx  DATTMP         ; * POINTER (USED AS A D
88e5 : 9e2b                       ldx  BINVAL         ; * RESET INPUT POINTER 
88e7 : 9f83                       stx  CHARAD         ; * READ STATEMENT
88e9 : 9d82                       jsr  GETCCH         ; GET CURRENT CHARACTER 
88eb : 2721                       beq  LB0D5          ; BRANCH IF END OF LINE 
88ed : bd8aa6                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
88f0 : 209c                       bra  LB04E          ; GET ANOTHER INPUT OR R
                        * SEARCH FROM ADDRESS IN X FOR
                        * 1ST OCCURENCE OF THE TOKEN FOR DATA
88f2 : 9f83             LB0B9     stx  CHARAD         ; RESET BASIC'S INPUT PO
88f4 : bd8745                     jsr  LAEE8          ; SEARCH FOR END OF CURR
88f7 : 3001                       leax 1,x            ; MOVE X ONE PAST END OF
88f9 : 4d                         tsta                ; CHECK FOR END OF LINE
88fa : 260a                       bne  LB0CD          ; BRANCH IF END OF SUBLI
88fc : c606                       ldb  #2*3           ; 'OUT OF DATA' ERROR
88fe : ee81                       ldu  ,x++           ; GET NEXT 2 CHARACTERS
8900 : 2741                       beq  LB10A          ; 'OD' ERROR IF END OF P
8902 : ec81                       ldd  ,x++           ; GET BASIC LINE NUMBER 
8904 : dd31                       std  DATTXT         ; SAVE IT IN DATTXT
8906 : a684             LB0CD     lda  ,x             ; GET AN INPUT CHARACTER
8908 : 8186                       cmpa #TOK_DATA      ; DATA TOKEN?
890a : 26e6                       bne  LB0B9          ; NO - KEEP LOOKING
890c : 2098                       bra  LB069          ; YES
                        * EXIT READ AND INPUT COMMANDS
890e : 9e35             LB0D5     ldx  DATTMP         ; GET DATA POINTER
8910 : d609                       ldb  INPFLG         ; * CHECK INPUT FLAG
8912 : 1026fd3a                   lbne LADE8          ; * SAVE NEW DATA POINTE
8916 : a684                       lda  ,x             ; = CHECK NEXT CHARACTER
8918 : 2706                       beq  LB0E7          ; =
891a : 8e8920                     ldx  #LB0E8-1       ; POINT X TO '?EXTRA IGN
891d : 7e91a9                     jmp  LB99C          ; PRINT THE MESSAGE
8920 : 39               LB0E7     rts
                        
8921 : 3f455854524120.. LB0E8     fcc  "?EXTRA IGNORED" ; ?EXTRA IGNORED MESSA
                        
                        
892f : 0d00                       fcb  CR,$00
                        
                        * NEXT
8931 : 2604             NEXT      bne  LB0FE          ; BRANCH IF ARGUMENT GIV
8933 : 9e74                       ldx  ZERO           ; X = 0: DEFAULT FOR NO 
8935 : 2003                       bra  LB101
8937 : bd8b8a           LB0FE     jsr  LB357          ; EVALUATE AN ALPHA EXPR
893a : 9f3b             LB101     stx  VARDES         ; SAVE VARIABLE DESCRIPT
893c : bd8462                     jsr  LABF9          ; GO SCAN FOR 'FOR/NEXT'
893f : 2704                       beq  LB10C          ; BRANCH IF DATA FOUND
8941 : c600                       ldb  #0             ; 'NEXT WITHOUT FOR' ERR
8943 : 2047             LB10A     bra  LB153          ; PROCESS ERROR
8945 : 1f14             LB10C     tfr  x,s            ; POINT S TO START OF 'F
8947 : 3003                       leax 3,x            ; POINT X TO FP VALUE OF
8949 : bd9421                     jsr  LBC14          ; COPY A FP NUMBER FROM 
894c : a668                       lda  8,s            ; GET THE DIRECTION OF S
AS09 Assembler for M6809 [1.42].                                     Page   57
--------------------------------- merge.a09 ----------------------------------

894e : 9754                       sta  FP0SGN         ; SAVE IT AS THE SIGN OF
8950 : 9e3b                       ldx  VARDES         ; POINT (X) TO INDEX VAR
8952 : bd91cf                     jsr  LB9C2          ; ADD (X) TO FPA0 (STEP 
8955 : bd9440                     jsr  LBC33          ; PACK FPA0 AND STORE IT
                        *                             ; CONTAINED IN VARDES
8958 : 3069                       leax 9,s            ; POINT (X) TO TERMINAL 
895a : bd94a3                     jsr  LBC96          ; COMPARE CURRENT INDEX 
895d : e068                       subb 8,s            ; ACCB = 0 IF TERMINAL V
                        *                             ; STEP IS POSITIVE AND C
                        *                             ; STEP IS NEGATIVE AND C
895f : 270c                       beq  LB134          ; BRANCH IF 'FOR/NEXT' L
8961 : ae6e                       ldx  14,s           ; * GET LINE NUMBER AND
8963 : 9f68                       stx  CURLIN         ; * BASIC POINTER OF
8965 : aee810                     ldx  16,s           ; * STATEMENT FOLLOWING 
8968 : 9f83                       stx  CHARAD         ; * PROPER FOR STATEMENT
896a : 7e85f1           LB131     jmp  LAD9E          ; JUMP BACK TO COMMAND I
896d : 32e812           LB134     leas 18,s           ; PULL THE 'FOR-NEXT' DA
8970 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
8972 : 812c                       cmpa #','            ; CHECK FOR ANOTHER ARG
8974 : 26f4                       bne  LB131          ; RETURN IF NONE
8976 : 9d7c                       jsr  GETNCH         ; GET NEXT CHARACTER FRO
8978 : 8dbd                       bsr  LB0FE          ; bsr SIMULATES A CALL T
                        
                        
897a : 8d13             LB141     bsr  LB156          ; EVALUATE EXPRESSION AN
897c : 1cfe             LB143     andcc #$FE          ; CLEAR CARRY FLAG
897e : 7d               LB145     fcb  $7D            ; OP CODE OF tst $1A01 -
                        *              ; NOT CHANGE CARRY FLAG)
897f : 1a01             LB146     orcc #1             ; SET CARRY
                        
                        * STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VA
                        * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN V
                        * IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP
                        * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERI
                        * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRI
8981 : 0d06             LB148     tst  VALTYP         ; TEST TYPE FLAG; DO NOT
8983 : 2503                       bcs  LB14F          ; BRANCH IF STRING
8985 : 2a99                       bpl  LB0E7          ; RETURN ON PLUS
8987 : 8c                         fcb  SKP2           ; SKIP 2 BYTES - 'TM' ER
8988 : 2b96             LB14F     bmi  LB0E7          ; RETURN ON MINUS
898a : c618                       ldb  #12*2          ; 'TYPE M1SMATCH' ERROR
898c : 7e84af           LB153     jmp  LAC46          ; PROCESS ERROR
                        * EVALUATE EXPRESSION
898f : 8d6e             LB156     bsr  LB1C6          ; BACK UP INPUT POINTER
8991 : 4f               LB158     clra                ; END OF OPERATION PRECE
8992 : 8c                         fcb  SKP2           ; SKIP TWO BYTES
8993 : 3404             LB15A     pshs b              ; SAVE FLAG (RELATIONAL 
8995 : 3402                       pshs a              ; SAVE FLAG (PRECEDENCE 
8997 : c601                       ldb  #1             ; *
8999 : bd849c                     jsr  LAC33          ; * SEE IF ROOM IN FREE 
899c : bd8a5c                     jsr  LB223          ; GO EVALUATE AN EXPRESS
899f : 0f3f                       clr  TRELFL         ; RESET RELATIONAL OPERA
89a1 : 9d82             LB168     jsr  GETCCH         ; GET CURRENT INPUT CHAR
                        * CHECK FOR RELATIONAL OPERATORS
89a3 : 80b4             LB16A     suba #TOK_GREATER   ; TOKEN FOR >
89a5 : 2513                       bcs  LB181          ; BRANCH IF LESS THAN RE
89a7 : 8103                       cmpa #3             ; *
89a9 : 240f                       bcc  LB181          ; * BRANCH IF GREATER TH
89ab : 8101                       cmpa #1             ; SET CARRY IF '>'
89ad : 49                         rola                ; CARRY TO BIT 0
89ae : 983f                       eora TRELFL         ; * CARRY SET IF
89b0 : 913f                       cmpa TRELFL         ; * TRELFL = ACCA
AS09 Assembler for M6809 [1.42].                                     Page   58
--------------------------------- merge.a09 ----------------------------------

89b2 : 2564                       bcs  LB1DF          ; BRANCH IF SYNTAX ERROR
89b4 : 973f                       sta  TRELFL         ; BIT 0: >, BIT 1 =, BIT
89b6 : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHARACTER
89b8 : 20e9                       bra  LB16A          ; CHECK FOR ANOTHER RELA
                        *
89ba : d63f             LB181     ldb  TRELFL         ; GET RELATIONAL OPERATO
89bc : 2633                       bne  LB1B8          ; BRANCH IF RELATIONAL C
89be : 1024006b                   lbcc LB1F4          ; BRANCH IF > RELATIONAL
89c2 : 8b07                       adda #7             ; SEVEN ARITHMETIC/LOGIC
89c4 : 2467                       bcc  LB1F4          ; BRANCH IF NOT ARITHMET
89c6 : 9906                       adca VALTYP         ; ADD CARRY, NUMERIC FLA
89c8 : 10270475                   lbeq LB60F          ; BRANCH IF VALTYP = FF,
                        *                             ; CONCATENATE TWO STRING
89cc : 89ff                       adca #-1            ; RESTORE ARITHMETIC/LOG
89ce : 3402                       pshs a              ; * STORE OPERATOR NUMBE
89d0 : 48                         asla                ; * THEN ADD THE STORED 
89d1 : abe0                       adda ,s+            ; * X 3; 3 BYTE/TABLE EN
89d3 : 8e828c                     ldx  #LAA51         ; JUMP TABLE FOR ARITHME
89d6 : 3086                       leax a,x            ; POINT X TO PROPER TABL
89d8 : 3502             LB19F     puls a              ; GET PRECEDENCE FLAG FR
89da : a184                       cmpa ,x             ; COMPARE TO CURRENT OPE
89dc : 2455                       bcc  LB1FA          ; BRANCH IF STACK OPERAT
89de : 8d9c                       bsr  LB143          ; 'TM' ERROR IF VARIABLE
                        
                        * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE TH
89e0 : 3402             LB1A7     pshs a              ; SAVE PRECEDENCE FLAG
89e2 : 8d29                       bsr  LB1D4          ; PUSH OPERATOR ROUTINE 
89e4 : 9e3d                       ldx  RELPTR         ; GET POINTER TO ARITHME
                        *                             ; LAST CALCULATED OPERAT
89e6 : 3502                       puls a              ; GET PRECEDENCE FLAG OF
89e8 : 261d                       bne  LB1CE          ; BRANCH IF NOT END OF O
89ea : 4d                         tsta                ; CHECK TYPE OF PRECEDEN
89eb : 1027006a                   lbeq LB220          ; BRANCH IF END OF EXPRE
89ef : 204b                       bra  LB203          ; EVALUATE AN OPERATION
                        
89f1 : 0806             LB1B8     asl  VALTYP         ; BIT 7 OF TYPE FLAG TO 
89f3 : 59                         rolb                ; SHIFT RELATIONAL FLAG 
89f4 : 8d09                       bsr  LB1C6          ; MOVE THE INPUT POINTER
89f6 : 8e8a04                     ldx  #LB1CB         ; POINT X TO RELATIONAL 
89f9 : d73f                       stb  TRELFL         ; SAVE RELATIONAL COMPAR
89fb : 0f06                       clr  VALTYP         ; SET VARIABLE TYPE TO N
89fd : 20d9                       bra  LB19F          ; PERFORM OPERATION OR S
                        
89ff : 9e83             LB1C6     ldx  CHARAD         ; * GET BASIC'S INPUT PO
8a01 : 7e8718                     jmp  LAEBB          ; * MOVE IT BACK ONE
                        * RELATIONAL COMPARISON JUMP TABLE
8a04 : 64               LB1CB     fcb  $64            ; RELATIONAL COMPARISON 
8a05 : 8b27             LB1CC     fdb  LB2F4          ; JUMP ADDRESS
                        
8a07 : a184             LB1CE     cmpa ,x             ; COMPARE PRECEDENCE OF 
                        *         NEXT TO BE DONE OPERATION
8a09 : 2431                       bcc  LB203          ; EVALUATE OPERATION IF 
8a0b : 20d3                       bra  LB1A7          ; PUSH OPERATION DATA ON
                        
                        * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK
8a0d : ec01             LB1D4     ldd  1,x            ; GET ADDRESS OF OPERATO
8a0f : 3406                       pshs b,a            ; SAVE IT ON THE STACK
8a11 : 8d08                       bsr  LB1E2          ; PUSH FPA0 ONTO STACK
8a13 : d63f                       ldb  TRELFL         ; GET BACK RELATIONAL OP
8a15 : 7e8993                     jmp  LB15A          ; EVALUATE ANOTHER EXPRE
8a18 : 7e8ab0           LB1DF     jmp  LB277          ; 'SYNTAX ERROR'
                        * PUSH FPA0 ONTO THE STACK. ,s   = EXPONENT
AS09 Assembler for M6809 [1.42].                                     Page   59
--------------------------------- merge.a09 ----------------------------------

                        * 1-2,s =HIGH ORDER MANTISSA 3-4,s = LOW ORDER MANTISS
                        * 5,s = SIGN RETURN WITH PRECEDENCE CODE IN ACCA
8a1b : d654             LB1E2     ldb  FP0SGN         ; GET SIGN OF FPA0 MANTI
8a1d : a684                       lda  ,x             ; GET PRECEDENCE CODE TO
8a1f : 3520             LB1E6     puls y              ; GET RETURN ADDRESS FRO
8a21 : 3404                       pshs b              ; SAVE ACCB ON STACK
8a23 : d64f             LB1EA     ldb  FP0EXP         ; * PUSH FPA0 ONTO THE S
8a25 : 9e50                       ldx  FPA0           ; *
8a27 : de52                       ldu  FPA0+2         ; *
8a29 : 3454                       pshs u,x,b          ; *
8a2b : 6ea4                       jmp  ,y             ; JUMP TO ADDRESS IN Y
                        
                        * BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALL
8a2d : 9e74             LB1F4     ldx  ZERO           ; POINT X TO DUMMY VALUE
8a2f : a6e0                       lda  ,s+            ; GET PRECEDENCE FLAG FR
8a31 : 2726                       beq  LB220          ; BRANCH IF END OF EXPRE
8a33 : 8164             LB1FA     cmpa #$64           ; * CHECK FOR RELATIONAL
8a35 : 2703                       beq  LB201          ; * AND BRANCH IF RELATI
8a37 : bd897c                     jsr  LB143          ; 'TM' ERROR IF VARIABLE
8a3a : 9f3d             LB201     stx  RELPTR         ; SAVE POINTER TO OPERAT
8a3c : 3504             LB203     puls b              ; GET RELATIONAL OPERATO
8a3e : 815a                       cmpa #$5A           ; CHECK FOR 'NOT' OPERAT
8a40 : 2719                       beq  LB222          ; RETURN IF 'NOT' - NO R
8a42 : 817d                       cmpa #$7D           ; CHECK FOR NEGATION (UN
8a44 : 2715                       beq  LB222          ; RETURN IF NEGATION - N
                        
                        * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON
                        * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRE
                        * WILL EVALUATE THE OPERATION. THE rts AT END OF ROUTI
                        * TO EVALUATING ROUTINE.
8a46 : 54                         lsrb                ; = ROTATE VALTYP BIT IN
8a47 : d70a                       stb  RELFLG         ; = FLAG AND SAVE NEW RE
8a49 : 3552                       puls a,x,u          ; * PULL A FP VALUE OFF 
8a4b : 975c                       sta  FP1EXP         ; * AND SAVE IT IN FPA1
8a4d : 9f5d                       stx  FPA1           ; *
8a4f : df5f                       stu  FPA1+2         ; *
8a51 : 3504                       puls b              ; = GET MANTISSA SIGN AN
8a53 : d761                       stb  FP1SGN         ; = SAVE IT IN FPA1
8a55 : d854                       eorb FP0SGN         ; EOR IT WITH FPA1 MANTI
8a57 : d762                       stb  RESSGN         ; SAVE IT IN RESULT SIGN
8a59 : d64f             LB220     ldb  FP0EXP         ; GET EXPONENT OF FPA0
8a5b : 39               LB222     rts
                        
8a5c : bd9cb9           LB223     jsr  XVEC15         ; CALL EXTENDED BASIC AD
8a5f : 0f06                       clr  VALTYP         ; INITIALIZE TYPE FLAG T
8a61 : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHAR
8a63 : 2403                       bcc  LB22F          ; BRANCH IF NOT NUMERIC
8a65 : 7e951f           LB22C     jmp  LBD12          ; CONVERT ASCII STRING T
                        *         RETURN RESULT IN FPA0
                        * PROCESS A NON NUMERIC FIRST CHARACTER
8a68 : bd8bd5           LB22F     jsr  LB3A2          ; SET CARRY IF NOT ALPHA
8a6b : 2450                       bcc  LB284          ; BRANCH IF ALPHA CHARAC
8a6d : 812e                       cmpa #'.'           ; IS IT '.' (DECIMAL POI
8a6f : 27f4                       beq  LB22C          ; CONVERT ASCII STRING T
8a71 : 81ae                       cmpa #TOK_MINUS     ; MINUS TOKEN
8a73 : 2740                       beq  LB27C          ; YES - GO PROCESS THE M
8a75 : 81ad                       cmpa #TOK_PLUS      ; PLUS TOKEN
8a77 : 27e3                       beq  LB223          ; YES - GET ANOTHER CHAR
8a79 : 8122                       cmpa #'"'           ; STRING DELIMITER?
8a7b : 260a                       bne  LB24E          ; NO
8a7d : 9e83             LB244     ldx  CHARAD         ; CURRENT BASIC POINTER 
8a7f : bd8d4b                     jsr  LB518          ; SAVE STRING ON STRING 
AS09 Assembler for M6809 [1.42].                                     Page   60
--------------------------------- merge.a09 ----------------------------------

8a82 : 9e64             LB249     ldx  COEFPT         ; * GET ADDRESS OF END O
8a84 : 9f83                       stx  CHARAD         ; * PUT BASIC'S INPUT PO
8a86 : 39                         rts
8a87 : 81aa             LB24E     cmpa #TOK_NOT       ; NOT TOKEN?
8a89 : 260d                       bne  LB25F          ; NO
                        * PROCESS THE NOT OPERATOR
8a8b : 865a                       lda  #$5A           ; 'NOT' PRECEDENCE FLAG
8a8d : bd8993                     jsr  LB15A          ; PROCESS OPERATION FOLL
8a90 : bd8c20                     jsr  INTCNV         ; CONVERT FPA0 TO INTEGE
8a93 : 43                         coma                ; * 'NOT' THE INTEGER
8a94 : 53                         comb                ; *
8a95 : 7e8d27                     jmp  GIVABF         ; CONVERT ACCD TO FLOATI
8a98 : 4c               LB25F     inca                ; CHECK FOR TOKENS PRECE
8a99 : 272e                       beq  LB290          ; IT WAS PRECEEDED BY $F
8a9b : 8d06             LB262     bsr  LB26A          ; SYNTAX CHECK FOR A '('
8a9d : bd898f                     jsr  LB156          ; EVALUATE EXPRESSIONS W
                        *         HIGHEST PRECEDENCE
8aa0 : c629             LB267     ldb  #')'           ; SYNTAX CHECK FOR ')'
8aa2 : 8c                         fcb  SKP2           ; SKIP 2 BYTES
8aa3 : c628             LB26A     ldb  #'('           ; SYNTAX CHECK FOR '('
8aa5 : 8c                         fcb  SKP2           ; SKIP 2 BYTES
8aa6 : c62c             LB26D     ldb  #','            ; SYNTAX CHECK FOR COMM
8aa8 : e19f0083         LB26F     cmpb [CHARAD]       ; * COMPARE ACCB TO CURR
8aac : 2602                       bne  LB277          ; * CHARACTER - SYNTAX E
8aae : 0e7c                       jmp  GETNCH         ; GET A CHARACTER FROM B
8ab0 : c602             LB277     ldb  #2*1           ; SYNTAX ERROR
8ab2 : 7e84af                     jmp  LAC46          ; JUMP TO ERROR HANDLER
                        
                        * PROCESS THE MINUS (UNARY) OPERATOR
8ab5 : 867d             LB27C     lda  #$7D           ; MINUS (UNARY) PRECEDEN
8ab7 : bd8993                     jsr  LB15A          ; PROCESS OPERATION FOLL
8aba : 7e96f6                     jmp  LBEE9          ; CHANGE SIGN OF FPA0 MA
                        
                        * EVALUATE ALPHA EXPRESSION
8abd : bd8b8a           LB284     jsr  LB357          ; FIND THE DESCRIPTOR AD
8ac0 : 9f52             LB287     stx  FPA0+2         ; SAVE DESCRIPTOR ADDRES
8ac2 : 9606                       lda  VALTYP         ; TEST VARIABLE TYPE
8ac4 : 2695                       bne  LB222          ; RETURN IF STRING
8ac6 : 7e9421                     jmp  LBC14          ; COPY A FP NUMBER FROM 
                        
                        * EVALUATING A SECONDARY TOKEN
8ac9 : 9d7c             LB290     jsr  GETNCH         ; GET AN INPUT CHARACTER
8acb : 1f89                       tfr  a,b            ; SAVE IT IN ACCB
8acd : 58                         aslb                ; X2 & BET RID OF BIT 7
8ace : 9d7c                       jsr  GETNCH         ; GET ANOTHER INPUT CHAR
8ad0 : c138                       cmpb #(NUM_SEC_FNS-1)*2 ; 29 SECONDARY FUNCT
8ad2 : 2302                       bls  LB29F          ; BRANCH IF COLOR BASIC 
8ad4 : 20da                       bra  LB277          ; SYNTAX ERROR
8ad6 : 3404             LB29F     pshs b              ; SAVE TOKEN OFFSET ON S
8ad8 : c12a             		  cmpb #(TOK_LEFT-$80)*2 ; CHECK FOR TOKEN WITH AN A
8ada : 251e             		  bcs  LB2C7          ; DO SECONDARIES STRING$ OR LE
8adc : c130                       cmpb #(TOK_INKEY-$80)*2 ; *
8ade : 241c                       bcc  LB2C9          ; * DO SECONDARIES $92 (
8ae0 : 8dc1                       bsr  LB26A          ; SYNTAX CHECK FOR A '('
8ae2 : a6e4                       lda  ,s             ; GET TOKEN NUMBER
                        * DO SECONDARIES (LEFT$, RIGHT$, MID$)
8ae4 : bd898f                     jsr  LB156          ; EVALUATE FIRST STRING 
8ae7 : 8dbd                       bsr  LB26D          ; SYNTAX CHECK FOR A COM
8ae9 : bd897f                     jsr  LB146          ; 'TM' ERROR IF NUMERIC 
8aec : 3502                       puls a              ; GET TOKEN OFFSET FROM 
8aee : de52                       ldu  FPA0+2         ; POINT U TO STRING DESC
8af0 : 3442                       pshs u,a            ; SAVE TOKEN OFFSET AND 
AS09 Assembler for M6809 [1.42].                                     Page   61
--------------------------------- merge.a09 ----------------------------------

8af2 : bd8f3c                     jsr  LB70B          ; EVALUATE FIRST NUMERIC
8af5 : 3502                       puls a              ; GET TOKEN OFFSET FROM 
8af7 : 3406                       pshs b,a            ; SAVE TOKEN OFFSET AND 
8af9 : 8e                         fcb  $8E            ; OP CODE OF ldx# - SKlP
8afa : 8d9f             LB2C7     bsr  LB262          ; SYNTAX CHECK FOR A '('
8afc : 3504             LB2C9     puls b              ; GET TOKEN OFFSET
8afe : be8106                     ldx  COMVEC+8       ; GET SECONDARY FUNCTION
8b01 : 3a               LB2CE     abx                 ; ADD IN COMMAND OFFSET
                        *
                        * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION
8b02 : ad94                       jsr  [,x]           ; GO DO AN SECONDARY FUN
8b04 : 7e897c                     jmp  LB143          ; 'TM' ERROR IF VARIABLE
                        
                        * LOGICAL OPERATOR 'OR' JUMPS HERE
8b07 : 86               LB2D4     fcb  SKP1LD         ; SKIP ONE BYTE - 'OR' F
                        
                        * LOGICAL OPERATOR 'AND' JUMPS HERE
8b08 : 4f               LB2D5     clra                ; AND FLAG = 0
8b09 : 9703                       sta  TMPLOC         ; AND/OR FLAG
8b0b : bd8c20                     jsr  INTCNV         ; CONVERT FPA0 INTO AN I
8b0e : dd01                       std  CHARAC         ; TEMP SAVE ACCD
8b10 : bd9457                     jsr  LBC4A          ; MOVE FPA1 TO FPA0
8b13 : bd8c20                     jsr  INTCNV         ; CONVERT FPA0 INTO AN I
8b16 : 0d03                       tst  TMPLOC         ; CHECK AND/OR FLAG
8b18 : 2606                       bne  LB2ED          ; BRANCH IF OR
8b1a : 9401                       anda CHARAC         ; * 'AND' ACCD WITH FPA0
8b1c : d402                       andb ENDCHR         ; * STORED IN ENDCHR
8b1e : 2004                       bra  LB2F1          ; CONVERT TO FP
8b20 : 9a01             LB2ED     ora  CHARAC         ; * 'OR' ACCD WITH FPA0 
8b22 : da02                       orb  ENDCHR         ; * STORED IN CHARAC
8b24 : 7e8d27           LB2F1     jmp  GIVABF         ; CONVERT THE VALUE IN A
                        
                        * RELATIONAL COMPARISON PROCESS HANDLER
8b27 : bd8981           LB2F4     jsr  LB148          ; 'TM' ERROR IF TYPE MIS
8b2a : 2610                       bne  LB309          ; BRANCH IF STRING VARIA
8b2c : 9661                       lda  FP1SGN         ; * 'PACK' THE MANTISSA
8b2e : 8a7f                       ora  #$7F           ; * SIGN OF FPA1 INTO
8b30 : 945d                       anda FPA1           ; * BIT 7 OF THE
8b32 : 975d                       sta  FPA1           ; * MANTISSA MS BYTE
8b34 : 8e005c                     ldx  #FP1EXP        ; POINT X TO FPA1
8b37 : bd94a3                     jsr  LBC96          ; COMPARE FPA0 TO FPA1
8b3a : 2036                       bra  LB33F          ; CHECK TRUTH OF RELATIO
                        
                        * RELATIONAL COMPARISON OF STRINGS
8b3c : 0f06             LB309     clr  VALTYP         ; SET VARIABLE TYPE TO N
8b3e : 0a3f                       dec  TRELFL         ; REMOVE STRING TYPE FLA
                        *                             ; DESIRED RELATIONAL COM
8b40 : bd8e89                     jsr  LB657          ; GET LENGTH AND ADDRESS
                        *                             ; DESCRIPTOR ADDRESS IS 
8b43 : d756                       stb  STRDES         ; * SAVE LENGTH AND ADDR
8b45 : 9f58                       stx  STRDES+2       ; * DESCRIPTOR (STRING B
8b47 : 9e5f                       ldx  FPA1+2         ; = RETURN LENGTH AND AD
8b49 : bd8e8b                     jsr  LB659          ; = WHOSE DESCRIPTOR ADD
8b4c : 9656                       lda  STRDES         ; LOAD ACCA WITH LENGTH 
8b4e : 3404                       pshs b              ; SAVE LENGTH A ON STACK
8b50 : a0e0                       suba ,s+            ; SUBTRACT LENGTH A FROM
8b52 : 2707                       beq  LB328          ; BRANCH IF STRINGS OF E
8b54 : 8601                       lda  #1             ; ; TRUE FLAG
8b56 : 2403                       bcc  LB328          ; TRUE IF LENGTH B > LEN
8b58 : d656                       ldb  STRDES         ; LOAD ACCB WITH LENGTH 
8b5a : 40                         nega                ; SET FLAG = FALSE (1FF)
8b5b : 9754             LB328     sta  FP0SGN         ; SAVE TRUE/FALSE FLAG
AS09 Assembler for M6809 [1.42].                                     Page   62
--------------------------------- merge.a09 ----------------------------------

8b5d : de58                       ldu  STRDES+2       ; POINT U TO START OF ST
8b5f : 5c                         incb                ; COMPENSATE FOR THE DEC
                        * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING
8b60 : 5a               LB32D     decb                ; DECREMENT SHORTER STRI
8b61 : 2604                       bne  LB334          ; BRANCH IF ALL OF STRIN
8b63 : d654                       ldb  FP0SGN         ; GET TRUE/FALSE FLAB
8b65 : 200b                       bra  LB33F          ; CHECK TRUTH OF RELATIO
8b67 : a680             LB334     lda  ,x+            ; GET A BYTE FROM STRING
8b69 : a1c0                       cmpa ,u+            ; COMPARE TO STRING B
8b6b : 27f3                       beq  LB32D          ; CHECK ANOTHER CHARACTE
8b6d : c6ff                       ldb  #$FF           ; FALSE FLAG IF STRING A
8b6f : 2401                       bcc  LB33F          ; BRANCH IF STRING A > S
8b71 : 50                         negb                ; SET FLAG = TRUE
                        
                        * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA
8b72 : cb01             LB33F     addb #1             ; CONVERT $FF,0,1 TO 0,1
8b74 : 59                         rolb                ; NOW IT'S 1,2,4 FOR > =
8b75 : d40a                       andb RELFLG         ; 'AND' THE ACTUAL COMPA
8b77 :                  COMPARISON
8b77 : 2702                       beq  LB348          ; BRANCH IF FALSE (NO MA
8b79 : c6ff                       ldb  #$FF           ; TRUE FLAG
8b7b : 7e9489           LB348     jmp  LBC7C          ; CONVERT ACCB INTO FP N
                        
                        * DIM
8b7e : bd8aa6           LB34B     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
8b81 : c601             DIM       ldb  #1             ; DIMENSION FLAG
8b83 : 8d08                       bsr  LB35A          ; SAVE ARRAY SPACE FOR T
8b85 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
8b87 : 26f5                       bne  LB34B          ; KEEP DIMENSIONING IF N
8b89 : 39                         rts
                        * EVALUATE A VARIABLE - RETURN X AND
                        * VARPTR POINTING TO VARIABLE DESCRIPTOR
                        * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO
                        * BYTES ARE THE VARIABLE NAME AND THE NEXT 5
                        * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE
                        * FIRST BYTE OF VARlABLE NAME IS SET, THE
                        * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF
                        * THE SECOND BYTE OF VARIABLE NAME IS SET, THE
                        * VARIABLE IS A STRING, OTHERWISE THE VARIABLE
                        * IS NUMERIC.
                        * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS
                        * INSERTED INTO THE VARIABLE SPACE
8b8a : 5f               LB357     clrb                ; DIMENSION FLAG = 0; DO
8b8b : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
8b8d : d705             LB35A     stb  DIMFLG         ; SAVE ARRAY FLAG
                        * ENTRY POINT FOR DEF FN VARIABLE SEARCH
8b8f : 9737             LB35C     sta  VARNAM         ; SAVE INPUT CHARACTER
8b91 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
8b93 : 8d40                       bsr  LB3A2          ; SET CARRY IF NOT ALPHA
8b95 : 1025ff17                   lbcs LB277          ; SYNTAX ERROR IF NOT AL
8b99 : 5f                         clrb                ; DEFAULT 2ND VARIABLE C
8b9a : d706                       stb  VALTYP         ; SET VARIABLE TYPE TO N
8b9c : 9d7c                       jsr  GETNCH         ; GET ANOTHER CHARACTER 
8b9e : 2504                       bcs  LB371          ; BRANCH IF NUMERIC (2ND
                        *                             ; VARIABLE MAY BE NUMERI
8ba0 : 8d33                       bsr  LB3A2          ; SET CARRY IF NOT ALPHA
8ba2 : 250a                       bcs  LB37B          ; BRANCH IF NOT ALPHA
8ba4 : 1f89             LB371     tfr  a,b            ; SAVE 2ND CHARACTER IN 
                        * READ INPUT CHARACTERS UNTIL A NON ALPHA OR
                        * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS
                        * IN VARIABLE NAME AFTER THE 1ST TWO
8ba6 : 9d7c             LB373     jsr  GETNCH         ; GET AN INPUT CHARACTER
AS09 Assembler for M6809 [1.42].                                     Page   63
--------------------------------- merge.a09 ----------------------------------

8ba8 : 25fc                       bcs  LB373          ; BRANCH IF NUMERIC
8baa : 8d29                       bsr  LB3A2          ; SET CARRY IF NOT ALPHA
8bac : 24f8                       bcc  LB373          ; BRANCH IF ALPHA
8bae : 8124             LB37B     cmpa #'$'           ; CHECK FOR A STRING VAR
8bb0 : 2606                       bne  LB385          ; BRANCH IF IT IS NOT A 
8bb2 : 0306                       com  VALTYP         ; SET VARIABLE TYPE TO S
8bb4 : cb80                       addb #$80           ; SET BIT 7 OF 2ND CHARA
8bb6 : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHARACTER
8bb8 : d738             LB385     stb  VARNAM+1       ; SAVE 2ND CHARACTER IN 
8bba : 9a08                       ora  ARYDIS         ; OR IN THE ARRAY DISABL
                        *              ; DON'T SEARCH FOR VARIABLES IN THE ARR
8bbc : 8028                       suba #'('           ; IS THIS AN ARRAY VARIA
8bbe : 10270075                   lbeq LB404          ; BRANCH IF IT IS
8bc2 : 0f08                       clr  ARYDIS         ; RESET THE ARRAY DISABL
8bc4 : 9e1b                       ldx  VARTAB         ; POINT X TO THE START O
8bc6 : dc37                       ldd  VARNAM         ; GET VARIABLE IN QUESTI
8bc8 : 9c1d             LB395     cmpx ARYTAB         ; COMPARE X TO THE END O
8bca : 2712                       beq  LB3AB          ; BRANCH IF END OF VARIA
8bcc : 10a381                     cmpd ,x++           ; * COMPARE VARIABLE IN 
8bcf : 273e                       beq  LB3DC          ; * VARIABLE AND BRANCH 
8bd1 : 3005                       leax 5,x            ; = MOVE POINTER TO NEXT
8bd3 : 20f3                       bra  LB395          ; = KEEP LOOKING
                        
                        * SET CARRY IF NOT UPPER CASE ALPHA
8bd5 : 8141             LB3A2     cmpa #'A'           ; * CARRY SET IF < 'A'
8bd7 : 2504                       bcs  LB3AA          ; *
8bd9 : 805b                       suba #'Z'+1         ; =
                        *         suba #-('Z'+1)      ; = CARRY CLEAR IF <= 'Z
8bdb : 80a5                       fcb  $80,$A5
8bdd : 39               LB3AA     rts
                        * PUT A NEW VARIABLE IN TABLE OF VARIABLES
8bde : 8e0074           LB3AB     ldx  #ZERO          ; POINT X TO ZERO LOCATI
8be1 : eee4                       ldu  ,s             ; GET CURRENT RETURN ADD
8be3 : 11838ac0                   cmpu #LB287         ; DID WE COME FROM 'EVAL
8be7 : 2728                       beq  LB3DE          ; YES - RETURN A ZERO VA
8be9 : dc1f                       ldd  ARYEND         ; * GET END OF ARRAYS AD
8beb : dd43                       std  V43            ; * SAVE IT AT V43
8bed : c30007                     addd #7             ; = ADD 7 TO END OF ARRA
8bf0 : dd41                       std  V41            ; = VARIABLE = 7 BYTES) 
8bf2 : 9e1d                       ldx  ARYTAB         ; * GET END OF VARIABLES
8bf4 : 9f47                       stx  V47            ; *
8bf6 : bd8487                     jsr  LAC1E          ; MAKE A SEVEN BYTE SLOT
                        *         TOP  OF VARIABLES
8bf9 : 9e41                       ldx  V41            ; = GET NEW END OF ARRAY
8bfb : 9f1f                       stx  ARYEND         ; =
8bfd : 9e45                       ldx  V45            ; * GET NEW END OF VARIA
8bff : 9f1d                       stx  ARYTAB         ; *
8c01 : 9e47                       ldx  V47            ; GET OLD END OF VARIABL
8c03 : dc37                       ldd  VARNAM         ; GET NEW VARIABLE NAME
8c05 : ed81                       std  ,x++           ; SAVE VARIABLE NAME
8c07 : 4f                         clra                ; * ZERO OUT THE FP VALU
8c08 : 5f                         clrb                ; * VARIABLE OR THE LENG
8c09 : ed84                       std  ,x             ; * OF A STRING VARIABLE
8c0b : ed02                       std  2,x            ; *
8c0d : a704                       sta  4,x            ; *
8c0f : 9f39             LB3DC     stx  VARPTR         ; STORE ADDRESS OF VARIA
8c11 : 39               LB3DE     rts
                        *
8c12 : 9080000000       LB3DF     fcb  $90,$80,$00,$00,$00 ; * FLOATING POINT 
                        *                             ; SMALLEST SIGNED TWO BY
                        *
8c17 : 9d7c             LB3E4     jsr  GETNCH         ; GET AN INPUT CHARACTER
AS09 Assembler for M6809 [1.42].                                     Page   64
--------------------------------- merge.a09 ----------------------------------

8c19 : bd897a           LB3E6     jsr  LB141          ; GO EVALUATE NUMERIC EX
8c1c : 9654             LB3E9     lda  FP0SGN         ; GET FPA0 MANTISSA SIGN
8c1e : 2b5d                       bmi  LB44A          ; 'FC' ERROR IF NEGATIVE
                        
                        
8c20 : bd897c           INTCNV    jsr  LB143          ; 'TM' ERROR IF STRING V
8c23 : 964f                       lda  FP0EXP         ; GET FPA0 EXPONENT
8c25 : 8190                       cmpa #$90           ; * COMPARE TO 32768 - L
8c27 : 2508                       bcs  LB3FE          ; * BRANCH IF FPA0 < 327
8c29 : 8e8c12                     ldx  #LB3DF         ; POINT X TO FP VALUE OF
8c2c : bd94a3                     jsr  LBC96          ; COMPARE -32768 TO FPA0
8c2f : 264c                       bne  LB44A          ; 'FC' ERROR IF NOT =
8c31 : bd94d5           LB3FE     jsr  LBCC8          ; CONVERT FPA0 TO A TWO 
8c34 : dc52                       ldd  FPA0+2         ; GET THE INTEGER
8c36 : 39                         rts
                        * EVALUATE AN ARRAY VARIABLE
8c37 : dc05             LB404     ldd  DIMFLG         ; GET ARRAY FLAG AND VAR
8c39 : 3406                       pshs b,a            ; SAVE THEM ON STACK
8c3b : 12                         nop                 ; DEAD SPACE CAUSED BY 1
8c3c : 5f                         clrb                ; RESET DIMENSION COUNTE
8c3d : 9e37             LB40A     ldx  VARNAM         ; GET VARIABLE NAME
8c3f : 3414                       pshs x,b            ; SAVE VARIABLE NAME AND
8c41 : 8dd4                       bsr  LB3E4          ; EVALUATE EXPRESSION (D
8c43 : 3534                       puls b,x,y          ; PULL OFF VARIABLE NAME
                        *                             ; ARRAY FLAG
8c45 : 9f37                       stx  VARNAM         ; SAVE VARIABLE NAME AND
8c47 : de52                       ldu  FPA0+2         ; GET DIMENSION LENGTH
8c49 : 3460                       pshs u,y            ; SAVE DIMENSION LENGTH,
8c4b : 5c                         incb                ; INCREASE DIMENSION COU
8c4c : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
8c4e : 812c                       cmpa #','           ; CHECK FOR ANOTHER DIME
8c50 : 27eb                       beq  LB40A          ; BRANCH IF MORE
8c52 : d703                       stb  TMPLOC         ; SAVE DIMENSION COUNTER
8c54 : bd8aa0                     jsr  LB267          ; SYNTAX CHECK FOR A ')'
8c57 : 3506                       puls a,b            ; * RESTORE VARIABLE TYP
8c59 : dd05                       std  DIMFLG         ; * FLAG - LEAVE DIMENSI
8c5b : 9e1d                       ldx  ARYTAB         ; GET START OF ARRAYS
8c5d : 9c1f             LB42A     cmpx ARYEND         ; COMPARE TO END OF ARRA
8c5f : 2721                       beq  LB44F          ; BRANCH IF NO MATCH FOU
8c61 : dc37                       ldd  VARNAM         ; GET VARIABLE IN QUESTI
8c63 : 10a384                     cmpd ,x             ; COMPARE TO CURRENT VAR
8c66 : 2706                       beq  LB43B          ; BRANCH IF =
8c68 : ec02                       ldd  2,x            ; GET OFFSET TO NEXT ARR
8c6a : 308b                       leax d,x            ; ADD TO CURRENT POINTER
8c6c : 20ef                       bra  LB42A          ; KEEP SEARCHING
8c6e : c612             LB43B     ldb  #2*9           ; 'REDIMENSIONED ARRAY' 
8c70 : 9605                       lda  DIMFLG         ; * TEST ARRAY FLAG - IF
8c72 : 260b                       bne  LB44C          ; * TO REDIMENSION AN AR
8c74 : d603                       ldb  TMPLOC         ; GET NUMBER OF DIMENSIO
8c76 : e104                       cmpb 4,x            ; COMPARE TO THIS ARRAYS
8c78 : 2759                       beq  LB4A0          ; BRANCH IF =
8c7a : c610             LB447     ldb  #8*2           ; 'BAD SUBSCRIPT'
8c7c : 8c                         fcb  SKP2           ; SKIP TWO BYTES
8c7d : c608             LB44A     ldb  #4*2           ; 'ILLEGAL FUNCTION CALL
8c7f : 7e84af           LB44C     jmp  LAC46          ; JUMP TO ERROR SERVICIN
                        
                        * INSERT A NEW ARRAY INTO ARRAY VARIABLES
                        * EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-
                        * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS TH
                        * NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFI
                        * AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LEN
                        * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIM
AS09 Assembler for M6809 [1.42].                                     Page   65
--------------------------------- merge.a09 ----------------------------------

                        * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIM
                        * SION 2;... 4+N,5+N:LENGTH OF DIMENSION N.
                        
8c82 : cc0005           LB44F     ldd  #5             ; * 5 BYTES/ARRAY ENTRY 
8c85 : dd64                       std  COEFPT         ; *
8c87 : dc37                       ldd  VARNAM         ; = GET NAME OF ARRAY AN
8c89 : ed84                       std  ,x             ; = FIRST 2 BYTES OF DES
8c8b : d603                       ldb  TMPLOC         ; GET NUMBER OF DIMENSIO
8c8d : e704                       stb  4,x            ; * 5TH BYTE OF DESCRIPT
8c8f : bd849c                     jsr  LAC33          ; CHECK FOR ROOM FOR DES
8c92 : 9f41                       stx  V41            ; TEMPoraRILY SAVE DESCR
8c94 : c60b             LB461     ldb  #11            ; * DEFAULT DIMENSION VA
8c96 : 4f                         clra                ; *
8c97 : 0d05                       tst  DIMFLG         ; = CHECK ARRAY FLAG AND
8c99 : 2705                       beq  LB46D          ; = NOT DIMENSIONING AN 
8c9b : 3506                       puls a,b            ; GET DIMENSION LENGTH
8c9d : c30001                     addd #1             ; ADD ONE (X(0) HAS A LE
8ca0 : ed05             LB46D     std  5,x            ; SAVE LENGTH OF ARRAY D
8ca2 : 8d5d                       bsr  LB4CE          ; MULTIPLY ACCUM ARRAY S
                        *                             ; OF NEW DIMENSION
8ca4 : dd64                       std  COEFPT         ; TEMP STORE NEW CURRENT
8ca6 : 3002                       leax 2,x            ; BUMP POINTER UP TWO
8ca8 : 0a03                       dec  TMPLOC         ; * DECREMENT DIMENSION 
8caa : 26e8                       bne  LB461          ; * NOT DONE WITH ALL DI
8cac : 9f0f                       stx  TEMPTR         ; SAVE ADDRESS OF (END O
8cae : d30f                       addd TEMPTR         ; ADD TOTAL SIZE OF NEW 
8cb0 : 1025f7f9                   lbcs LAC44          ; 'OM' ERROR IF > $FFFF
8cb4 : 1f01                       tfr  d,x            ; SAVE END OF ARRAY IN X
8cb6 : bd84a0                     jsr  LAC37          ; MAKE SURE THERE IS ENO
8cb9 : 830035                     subd #STKBUF-5      ; SUBTRACT OUT THE (STAC
8cbc : dd1f                       std  ARYEND         ; SAVE NEW END OF ARRAYS
8cbe : 4f                         clra                ; ZERO = TERMINATOR BYTE
8cbf : 301f             LB48C     leax -1,x           ; * STORE TWO TERMINATOR
8cc1 : a705                       sta  5,x            ; * THE END OF THE ARRAY
8cc3 : 9c0f                       cmpx TEMPTR         ; *
8cc5 : 26f8                       bne  LB48C          ; *
8cc7 : 9e41                       ldx  V41            ; GET ADDRESS OF START O
8cc9 : 961f                       lda  ARYEND         ; GET MSB OF END OF ARRA
8ccb : 9341                       subd V41            ; SUBTRACT OUT ADDRESS O
8ccd : ed02                       std  2,x            ; SAVE LENGTH OF (ARRAY 
8ccf : 9605                       lda  DIMFLG         ; * GET ARRAY FLAG AND B
8cd1 : 262d                       bne  LB4CD          ; * BACK IF DIMENSIONING
                        * CALCULATE POINTER TO CORRECT ELEMENT
8cd3 : e604             LB4A0     ldb  4,x            ; GET THE NUMBER OF DIME
8cd5 : d703                       stb  TMPLOC         ; TEMPoraRILY SAVE
8cd7 : 4f                         clra                ; * INITIALIZE POINTER
8cd8 : 5f                         clrb                ; * TO ZERO
8cd9 : dd64             LB4A6     std  COEFPT         ; SAVE ACCUMULATED POINT
8cdb : 3506                       puls a,b            ; * PULL DIMENSION ARGUM
8cdd : dd52                       std  FPA0+2         ; * STACK AND SAVE IT
8cdf : 10a305                     cmpd 5,x            ; COMPARE TO STORED 'DIM
8ce2 : 243a                       bcc  LB4EB          ; 'BS' ERROR IF > = "DIM
8ce4 : de64                       ldu  COEFPT         ; * GET ACCUMULATED POIN
8ce6 : 2704                       beq  LB4B9          ; * BRANCH IF 1ST DIMENS
8ce8 : 8d17                       bsr  LB4CE          ; = MULTIPLY ACCUMULATED
8cea : d352                       addd FPA0+2         ; = LENGTH AND ADD TO CU
8cec : 3002             LB4B9     leax 2,x            ; MOVE POINTER TO NEXT D
8cee : 0a03                       dec  TMPLOC         ; * DECREMENT DIMENSION 
8cf0 : 26e7                       bne  LB4A6          ; * BRANCH IF ANY DIMENS
                        * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE
8cf2 : ede3                       std  ,--s
8cf4 : 58                         aslb
AS09 Assembler for M6809 [1.42].                                     Page   66
--------------------------------- merge.a09 ----------------------------------

8cf5 : 49                         rola                ; TIMES 2
8cf6 : 58                         aslb
8cf7 : 49                         rola                ; TIMES 4
8cf8 : e3e1                       addd ,s++           ; TIMES 5
8cfa : 308b                       leax d,x            ; ADD OFFSET TO START OF
8cfc : 3005                       leax 5,x            ; ADJUST POINTER FOR SIZ
8cfe : 9f39                       stx  VARPTR         ; SAVE POINTER TO ARRAY 
8d00 : 39               LB4CD     rts
                        * MULTIPLY 2 BYTE NUMBER IN 5,x BY THE 2 BYTE NUMBER
                        * IN COEFPT. RETURN RESULT IN ACCd, BS ERROR IF > $FFF
8d01 : 8610             LB4CE     lda  #16            ; 16 SHIFTS TO DO A MULT
8d03 : 9745                       sta  V45            ; SHIFT COUNTER
8d05 : ec05                       ldd  5,x            ; * GET SIZE OF DIMENSIO
8d07 : dd17                       std  BOTSTK         ; * AND SAVE IT
8d09 : 4f                         clra                ; * ZERO
8d0a : 5f                         clrb                ; * ACCD
8d0b : 58               LB4D8     aslb                ; = SHIFT ACCB LEFT
8d0c : 49                         rola                ; = ONE BIT
8d0d : 250f                       bcs  LB4EB          ; 'BS' ERROR IF CARRY
8d0f : 0865                       asl  COEFPT+1       ; * SHIFT MULTIPLICAND L
8d11 : 0964                       rol  COEFPT         ; * BIT - ADD MULTIPLIER
8d13 : 2404                       bcc  LB4E6          ; * IF CARRY <> 0
8d15 : d317                       addd BOTSTK         ; ADD MULTIPLIER TO ACCD
8d17 : 2505                       bcs  LB4EB          ; 'BS' ERROR IF CARRY (>
8d19 : 0a45             LB4E6     dec  V45            ; * DECREMENT SHIFT COUN
8d1b : 26ee                       bne  LB4D8          ; * IF NOT DONE
8d1d : 39                         rts
8d1e : 7e8c7a           LB4EB     jmp  LB447          ; 'BS' ERROR
                        *
                        * MEM
                        * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE
                        * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK
                        * FOR WHICH MEM DOES NOT ALLOW.
                        *
8d21 : 1f40             MEM       tfr  s,d            ; PUT STACK POINTER INTO
8d23 : 931f                       subd ARYEND         ; SUBTRACT END OF ARRAYS
8d25 : 21                         fcb  SKP1           ; SKIP ONE BYTE
                        *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0
8d26 : 4f               LB4F3     clra                ; CLEAR MS BYTE OF ACCD
                        * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMB
8d27 : 0f06             GIVABF    clr  VALTYP         ; SET VARIABLE TYPE TO N
8d29 : dd50                       std  FPA0           ; SAVE ACCD IN TOP OF FA
8d2b : c690                       ldb  #$90           ; EXPONENT REQUIRED IF T
                        *         OF   FPA0 ARE TO BE TREATED AS AN INTEGER IN
8d2d : 7e948f                     jmp  LBC82          ; CONVERT THE REST OF FP
                        
                        * STR$
8d30 : bd897c           STR       jsr  LB143          ; 'TM' ERROR IF STRING V
8d33 : ce01de                     ldu  #STRBUF+2      ; *CONVERT FP NUMBER TO 
8d36 : bd95e9                     jsr  LBDDC          ; *THE STRING BUFFER
8d39 : 3262                       leas 2,s            ; PURGE THE RETURN ADDRE
8d3b : 8e01dd                     ldx  #STRBUF+1      ; *POINT X TO STRING BUF
8d3e : 200b                       bra  LB518          ; *THE STRING IN THE STR
                        * RESERVE ACCB BYTES OF STRING SPACE. RETURN START
                        * ADDRESS IN (X) AND FRESPC
8d40 : 9f4d             LB50D     stx  V4D            ; SAVE X IN V4D
8d42 : 8d5c             LB50F     bsr  LB56D          ; RESERVE ACCB BYTES IN 
8d44 : 9f58             LB511     stx  STRDES+2       ; SAVE NEW STRING ADDRES
8d46 : d756                       stb  STRDES         ; SAVE LENGTH OF RESERVE
8d48 : 39                         rts
8d49 : 301f             LB516     leax -1,x           ; MOVE POINTER BACK ONE
                        * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO
AS09 Assembler for M6809 [1.42].                                     Page   67
--------------------------------- merge.a09 ----------------------------------

                        * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR EN
                        * THE RESULTING STRING IS STORED IN THE STRING SPACE
                        * ONLY IF THE START OF THE STRING IS <= STRBUF+2
8d4b : 8622             LB518     lda  #'"'           ; * INITIALIZE
8d4d : 9701                       sta  CHARAC         ; * TERMINATORS
8d4f : 9702             LB51A     sta  ENDCHR         ; * TO "
8d51 : 3001             LB51E     leax 1,x            ; MOVE POINTER UP ONE
8d53 : 9f62                       stx  RESSGN         ; TEMPORARILY SAVE START
8d55 : 9f58                       stx  STRDES+2       ; SAVE START OF STRING I
8d57 : c6ff                       ldb  #-1            ; INITIALIZE CHARACTER C
8d59 : 5c               LB526     incb                ; INCREMENT CHARACTER CO
8d5a : a680                       lda  ,x+            ; GET CHARACTER
8d5c : 270c                       beq  LB537          ; BRANCH IF END OF LINE
8d5e : 9101                       cmpa CHARAC         ; * CHECK FOR TERMINATOR
8d60 : 2704                       beq  LB533          ; * IN CHARAC AND ENDCHR
8d62 : 9102                       cmpa ENDCHR         ; * DON'T MOVE POINTER B
8d64 : 26f3                       bne  LB526          ; * ONE IF TERMINATOR IS
8d66 : 8122             LB533     cmpa #'"'           ; = COMPARE CHARACTER TO
8d68 : 2702                       beq  LB539          ; = & DON'T MOVE POINTER
8d6a : 301f             LB537     leax -1,x           ; MOVE POINTER BACK ONE
8d6c : 9f64             LB539     stx  COEFPT         ; SAVE END OF STRING ADD
8d6e : d756                       stb  STRDES         ; SAVE STRING LENGTH IN 
8d70 : de62                       ldu  RESSGN         ; GET INITlAL STRING STA
8d72 : 118301de                   cmpu #STRBUF+2      ; COMPARE TO START OF ST
8d76 : 2207             LB543     bhi  LB54C          ; BRANCH IF > START OF S
8d78 : 8dc6                       bsr  LB50D          ; GO RESERVE SPACE FOR T
8d7a : 9e62                       ldx  RESSGN         ; POINT X TO THE BEGINNI
8d7c : bd8e77                     jsr  LB645          ; MOVE (B) BYTES FROM (X
                        *                             [FRESPC] - MOVE STRING D
                        * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA
                        * ON THE STRING STACK. SET VARIABLE TYPE TO STRING
8d7f : 9e0b             LB54C     ldx  TEMPPT         ; GET NEXT AVAILABLE STR
8d81 : 8c00df                     cmpx #LINHDR        ; COMPARE TO TOP OF STRI
8d84 : 2605                       bne  LB558          ; FORMULA O.K.
8d86 : c61e                       ldb  #15*2          ; STRING FORMULA TOO COM
8d88 : 7e84af           LB555     jmp  LAC46          ; JUMP TO ERROR SERVICIN
8d8b : 9656             LB558     lda  STRDES         ; * GET LENGTH OF STRING
                        *         sta  ,x             ; * IN BYTE 0 OF DESCRIP
8d8d : a700                       fcb  $A7,$00
8d8f : dc58                       ldd  STRDES+2       ; = GET START ADDRESS OF
8d91 : ed02                       std  2,x            ; = AND SAVE IN BYTES 2,
8d93 : 86ff                       lda  #$FF           ; * VARIABLE TYPE = STRI
8d95 : 9706                       sta  VALTYP         ; * SAVE IN VARIABLE TYP
8d97 : 9f0d                       stx  LASTPT         ; = SAVE START OF DESCRI
8d99 : 9f52                       stx  FPA0+2         ; = ADDRESS IN LASTPT AN
8d9b : 3005                       leax 5,x            ; 5 BYTES/STRING DESCRIP
8d9d : 9f0b                       stx  TEMPPT         ; NEXT AVAILABLE STRING 
8d9f : 39                         rts
                        * RESERVE ACCB BYTES IN STRING STORAGE SPACE
                        * RETURN WITH THE STARTING ADDRESS OF THE
                        * RESERVED STRING SPACE IN (X) AND FRESPC
8da0 : 0f07             LB56D     clr  GARBFL         ; CLEAR STRING REORGANIZ
8da2 : 4f               LB56F     clra                ; * PUSH THE LENGTH OF T
8da3 : 3406                       pshs b,a            ; * STRING ONTO THE STAC
8da5 : dc23                       ldd  STRTAB         ; GET START OF STRING VA
8da7 : a3e0                       subd ,s+            ; SUBTRACT STRING LENGTH
8da9 : 109321                     cmpd FRETOP         ; COMPARE TO START OF ST
8dac : 250a                       bcs  LB585          ; IF BELOW START, THEN R
8dae : dd23                       std  STRTAB         ; SAVE NEW START OF STRI
8db0 : 9e23                       ldx  STRTAB         ; GET START OF STRING VA
8db2 : 3001                       leax 1,x            ; ADD ONE
8db4 : 9f25                       stx  FRESPC         ; SAVE START ADDRESS OF 
AS09 Assembler for M6809 [1.42].                                     Page   68
--------------------------------- merge.a09 ----------------------------------

8db6 : 3584                       puls b,pc           ; RESTORE NUMBER OF BYTE
8db8 : c61a             LB585     ldb  #2*13          ; OUT OF STRING SPACE' E
8dba : 0307                       com  GARBFL         ; TOGGLE REORGANIZATiON 
8dbc : 27ca                       beq  LB555          ; ERROR IF FRESHLY REORG
8dbe : 8d04                       bsr  LB591          ; GO REORGANIZE STRING S
8dc0 : 3504                       puls b              ; GET BACK THE NUMBER OF
8dc2 : 20de                       bra  LB56F          ; TRY TO RESERVE ACCB BY
                        * REORGANIZE THE STRING SPACE
8dc4 : 9e27             LB591     ldx  MEMSIZ         ; GET THE TOP OF STRING 
8dc6 : 9f23             LB593     stx  STRTAB         ; SAVE TOP OF UNORGANIZE
8dc8 : 4f                         clra                ; * ZERO OUT ACCD
8dc9 : 5f                         clrb                ; * AND RESET VARIABLE
8dca : dd4b                       std  V4B            ; * POINTER TO 0
8dcc : 9e21                       ldx  FRETOP         ; POINT X TO START OF ST
8dce : 9f47                       stx  V47            ; SAVE POINTER IN V47
8dd0 : 8e00b7                     ldx  #STRSTK        ; POINT X TO START OF ST
8dd3 : 9c0b             LB5A0     cmpx TEMPPT         ; COMPARE TO ADDRESS OF 
8dd5 : 2704                       beq  LB5A8          ; BRANCH IF TOP OF STRIN
8dd7 : 8d32                       bsr  LB5D8          ; CHECK FOR STRING IN UN
8dd9 : 20f8                       bra  LB5A0          ; KEEP CHECKING
8ddb : 9e1b             LB5A8     ldx  VARTAB         ; GET THE END OF BASIC P
8ddd : 9c1d             LB5AA     cmpx ARYTAB         ; COMPARE TO END OF VARI
8ddf : 2704                       beq  LB5B2          ; BRANCH IF AT TOP OF VA
8de1 : 8d22                       bsr  LB5D2          ; CHECK FOR STRING IN UN
8de3 : 20f8                       bra  LB5AA          ; KEEP CHECKING VARIABLE
8de5 : 9f41             LB5B2     stx  V41            ; SAVE ADDRESS OF THE EN
8de7 : 9e41             LB5B4     ldx  V41            ; GET CURRENT ARRAY POIN
8de9 : 9c1f             LB5B6     cmpx ARYEND         ; COMPARE TO THE END OF 
8deb : 2735                       beq  LB5EF          ; BRANCH IF AT END OF AR
8ded : ec02                       ldd  2,x            ; GET LENGTH OF ARRAY AN
8def : d341                       addd V41            ; * ADD TO CURRENT ARRAY
8df1 : dd41                       std  V41            ; * AND SAVE IT
8df3 : a601                       lda  1,x            ; GET 1ST CHARACTER OF V
8df5 : 2af0                       bpl  LB5B4          ; BRANCH IF NUMERIC ARRA
8df7 : e604                       ldb  4,x            ; GET THE NUMBER OF DIME
8df9 : 58                         aslb                ; MULTIPLY BY 2
8dfa : cb05                       addb #5             ; ADD FIVE BYTES (VARIAB
                        *                             ; LENGTH, NUMBER DIMENSI
8dfc : 3a                         abx                 ; X NOW POINTS TO START 
8dfd : 9c41             LB5CA     cmpx V41            ; AT END OF THIS ARRAY?
8dff : 27e8                       beq  LB5B6          ; YES - CHECK FOR ANOTHE
8e01 : 8d08                       bsr  LB5D8          ; CHECK FOR STRING LOCAT
                        *                             ; UNORGANIZED STRING SPA
8e03 : 20f8                       bra  LB5CA          ; KEEP CHECKING ELEMENTS
8e05 : a601             LB5D2     lda  1,x            ; GET F1RST BYTE OF VARI
8e07 : 3002                       leax 2,x            ; MOVE POINTER TO DESCRI
8e09 : 2a14                       bpl  LB5EC          ; BRANCH IF VARIABLE IS 
                        * SEARCH FOR STRING - ENTER WITH X POINTING TO
                        * THE STRING DESCRIPTOR. IF STRING IS STORED
                        * BETWEEN V47 AND STRTAb, SAVE DESCRIPTOR POINTER
                        * IN V4B AND RESET V47 TO STRING ADDRESS
8e0b : e684             LB5D8     ldb  ,x             ; GET THE LENGTH OF THE 
8e0d : 2710                       beq  LB5EC          ; BRANCH IF NULL - NO ST
8e0f : ec02                       ldd  2,x            ; GET STARTING ADDRESS O
8e11 : 109323                     cmpd STRTAB         ; COMPARE TO THE START O
8e14 : 2209                       bhi  LB5EC          ; BRANCH IF THIS STRING 
                        *              ; THE STRING VARIABLES
8e16 : 109347                     cmpd V47            ; COMPARE TO START OF ST
8e19 : 2304                       bls  LB5EC          ; BRANCH IF NOT STORED I
8e1b : 9f4b                       stx  V4B            ; SAVE VARIABLE POINTER 
8e1d : dd47                       std  V47            ; SAVE STRING STARTING A
8e1f : 3005             LB5EC     leax 5,x            ; MOVE TO NEXT VARIABLE 
AS09 Assembler for M6809 [1.42].                                     Page   69
--------------------------------- merge.a09 ----------------------------------

8e21 : 39               LB5EE     rts
8e22 : 9e4b             LB5EF     ldx  V4B            ; GET ADDRESS OF THE DES
                        *              ; STRING WHICH IS STORED IN THE HIGHEST
                        *              ; THE UNORGANIZED STRING SPACE
8e24 : 27fb                       beq  LB5EE          ; BRANCH IF NONE FOUND A
8e26 : 4f                         clra                ; CLEAR MS BYTE OF LENGT
8e27 : e684                       ldb  ,x             ; GET LENGTH OF STRING
8e29 : 5a                         decb                ; SUBTRACT ONE
8e2a : d347                       addd V47            ; ADD LENGTH OF STRING T
8e2c : dd43                       std  V43            ; SAVE AS MOVE STARTING 
8e2e : 9e23                       ldx  STRTAB         ; POINT X TO THE START O
8e30 : 9f41                       stx  V41            ; SAVE AS MOVE ENDING AD
8e32 : bd8489                     jsr  LAC20          ; MOVE STRING FROM CURRE
                        *              ; TOP OF UNORGANIZED STRING SPACE
8e35 : 9e4b                       ldx  V4B            ; POINT X TO STRING DESC
8e37 : dc45                       ldd  V45            ; * GET NEW STARTING ADD
8e39 : ed02                       std  2,x            ; * SAVE IT IN DESCRIPTO
8e3b : 9e45                       ldx  V45            ; GET NEW TOP OF UNORGAN
8e3d : 301f                       leax -1,x           ; MOVE POINTER BACK ONE
8e3f : 2085                       jmp  LB593          ; JUMP BACK AND REORGANI
                        
                        
8e41 : dc52             LB60F     ldd  FPA0+2         ; * GET DESCRIPTOR ADDRE
8e43 : 3406                       pshs b,a            ; * AND SAVE IT ON THE S
8e45 : bd8a5c                     jsr  LB223          ; GET DESCRIPTOR ADDRESS
8e48 : bd897f                     jsr  LB146          ; 'TM' ERROR IF NUMERIC 
8e4b : 3510                       puls x              ; * POINT X TO STRING A 
8e4d : 9f62                       stx  RESSGN         ; * ADDRESS AND SAVE IT 
8e4f : e684                       ldb  ,x             ; GET LENGTH OF STRING A
8e51 : 9e52                       ldx  FPA0+2         ; POINT X TO DESCRIPTOR 
8e53 : eb84                       addb ,x             ; ADD LENGTH OF STRING B
8e55 : 2405                       bcc  LB62A          ; BRANCH IF LENGTH < 256
8e57 : c61c                       ldb  #2*14          ; 'STRING TOO LONG' ERRO
8e59 : 7e84af                     jmp  LAC46          ; JUMP TO ERROR SERVICIN
8e5c : bd8d40           LB62A     jsr  LB50D          ; RESERVE ROOM IN STRING
8e5f : 9e62                       ldx  RESSGN         ; GET DESCRIPTOR ADDRESS
8e61 : e684                       ldb  ,x             ; GET LENGTH OF STRING A
8e63 : 8d10                       bsr  LB643          ; MOVE STRING A INTO RES
8e65 : 9e4d                       ldx  V4D            ; GET DESCRIPTOR ADDRESS
8e67 : 8d22                       bsr  LB659          ; GET LENGTH AND ADDRESS
8e69 : 8d0c                       bsr  LB645          ; MOVE STRING B INTO RES
8e6b : 9e62                       ldx  RESSGN         ; POINT X TO DESCRIPTOR 
8e6d : 8d1c                       bsr  LB659          ; DELETE STRING A IF LAS
8e6f : bd8d7f                     jsr  LB54C          ; PUT STRING DESCRIPTOR 
8e72 : 7e89a1                     jmp  LB168          ; BRANCH BACK TO EXPRESS
                        
                        * MOVE (B) BYTES FROM 2,x TO FRESPC
8e75 : ae02             LB643     ldx  2,x            ; POINT X TO SOURCE ADDR
8e77 : de25             LB645     ldu  FRESPC         ; POINT U TO DESTINATION
8e79 : 5c                         incb                ; COMPENSATION FOR THE D
8e7a : 2004                       bra  LB64E          ; GO MOVE THE BYTES
                        * MOVE B BYTES FROM (X) TO (U)
8e7c : a680             LB64A     lda  ,x+            ; * GET A SOURCE BYTE AN
8e7e : a7c0                       sta  ,u+            ; * TO THE DESTINATION
8e80 : 5a               LB64E     decb                ; DECREMENT BYTE COUNTER
8e81 : 26f9                       bne  LB64A          ; BRANCH IF ALL BYTES NO
8e83 : df25                       stu  FRESPC         ; SAVE ENDING ADDRESS IN
8e85 : 39                         rts
                        * RETURN LENGTH (ACCB) AND ADDRESS (X) OF
                        * STRING WHOSE DESCRIPTOR IS IN FPA0+2
                        * DELETE THE STRING IF IT IS THE LAST ONE
                        * PUT ON THE STRING STACK. REMOVE STRING FROM STRING
AS09 Assembler for M6809 [1.42].                                     Page   70
--------------------------------- merge.a09 ----------------------------------

                        * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.
8e86 : bd897f           LB654     jsr  LB146          ; 'TM' ERROR IF VARIABLE
8e89 : 9e52             LB657     ldx  FPA0+2         ; GET ADDRESS OF SELECTE
8e8b : e684             LB659     ldb  ,x             ; GET LENGTH OF STRING
8e8d : 8d18                       bsr  LB675          ; * CHECK TO SEE IF THIS
8e8f : 2613                       bne  LB672          ; * THE LAST ONE PUT ON 
                        *                             ; * BRANCH IF NOT
8e91 : ae07                       ldx  5+2,x          ; GET START ADDRESS OF S
8e93 : 301f                       leax -1,x           ; MOVE POINTER DOWN ONE
8e95 : 9c23                       cmpx STRTAB         ; COMPARE TO START OF ST
8e97 : 2608                       bne  LB66F          ; BRANCH IF THIS STRING 
                        *                             ; OF STRING VARIABLES
8e99 : 3404                       pshs b              ; SAVE LENGTH; ACCA WAS 
8e9b : d323                       addd STRTAB         ; * ADD THE LENGTH OF TH
8e9d : dd23                       std  STRTAB         ; * TO THE START OF STRI
                        *                             ; * REMOVE THE STRING FR
8e9f : 3504                       puls b              ; RESTORE LENGTH
8ea1 : 3001             LB66F     leax 1,x            ; ADD ONE TO POINTER
8ea3 : 39                         rts
8ea4 : ae02             LB672     ldx  2,x            ; *POINT X TO ADDRESS OF
8ea6 : 39                         rts                 ; *ON THE STRING STACK
                        * REMOVE STRING FROM STRING STACK. ENTER WITH X
                        * POINTING TO A STRING DESCRIPTOR - DELETE THE
                        * STRING FROM STACK IF IT IS ON TOP OF THE
                        * STACK. IF THE STRING IS DELETEd, SET THE ZERO FLAG
8ea7 : 9c0d             LB675     cmpx LASTPT         ; *COMPARE TO LAST USED 
8ea9 : 2607                       bne  LB680          ; *ON THE STRING STACK, 
                        *                             ; *ADDRESS NOT ON THE ST
8eab : 9f0b                       stx  TEMPPT         ; SAVE LAST USED DESCRIP
8ead : 301b                       leax -5,x           ; * MOVE LAST USED DESCR
8eaf : 9f0d                       stx  LASTPT         ; * AND SAVE AS THE LAST
8eb1 : 4f                         clra                ; SET ZERO FLAG
8eb2 : 39               LB680     rts
                        
                        * LEN
8eb3 : 8d03             LEN       bsr  LB686          ; POINT X TO PROPER STRI
8eb5 : 7e8d26           LB683     jmp  LB4F3          ; CONVERT ACCB TO FP NUM
                        * POINT X TO STRING ADDRESS LOAD LENGTH INTO
                        * ACCB. ENTER WITH THE STRING DESCRIPTOR IN
                        * BOTTOM TWO BYTES OF FPA0
8eb8 : 8dcc             LB686     bsr  LB654          ; GET LENGTH AND ADDRESS
8eba : 0f06                       clr  VALTYP         ; SET VARIABLE TYPE TO N
8ebc : 5d                         tstb                ; SET FLAGS ACCORDING TO
8ebd : 39                         rts
                        
                        * CHR$
8ebe : bd8f3f           CHR       jsr  LB70E          ; CONVERT FPA0 TO AN INT
8ec1 : c601             LB68F     ldb  #1             ; * RESERVE ONE BYTE IN
8ec3 : bd8da0                     jsr  LB56D          ; * THE STRING SPACE
8ec6 : 9653                       lda  FPA0+3         ; GET ASCII STRING VALUE
8ec8 : bd8d44                     jsr  LB511          ; SAVE RESERVED STRING D
8ecb : a784                       sta  ,x             ; SAVE THE STRING (IT'S 
8ecd : 3262             LB69B     leas 2,s            ; PURGE THE RETURN ADDRE
8ecf : 7e8d7f           LB69D     jmp  LB54C          ; PUT TEMP DESCRIPTOR DA
                        
                        
8ed2 : 8d02             ASC       bsr  LB6A4          ; PUT 1ST CHARACTER OF S
8ed4 : 20df                       bra  LB683          ; CONVERT ACCB INTO FP N
8ed6 : 8de0             LB6A4     bsr  LB686          ; POINT X TO STRING DESC
8ed8 : 275d                       beq  LB706          ; 'FC' ERROR IF NULL STR
8eda : e684                       ldb  ,x             ; GET FIRST BYTE OF STRI
8edc : 39                         rts
AS09 Assembler for M6809 [1.42].                                     Page   71
--------------------------------- merge.a09 ----------------------------------

                        
                        
8edd : 8d47             LEFT      bsr  LB6F5          ; GET ARGUMENTS FROM STA
8edf : 4f               LB6AD     clra                ; CLEAR STRING POINTER O
8ee0 : e184             LB6AE     cmpb ,x             ; * COMPARE LENGTH PARAM
8ee2 : 2303                       bls  LB6B5          ; * STRING AND BRANCH IF
                        *                             ; >= LENGTH PARAMETER
8ee4 : e684                       ldb  ,x             ; USE LENGTH OF STRING O
8ee6 : 4f                         clra                ; CLEAR STRING POINTER O
8ee7 : 3406             LB6B5     pshs b,a            ; PUSH PARAMETERS ONTO S
8ee9 : bd8d42                     jsr  LB50F          ; RESERVE ACCB BYTES IN 
8eec : 9e4d                       ldx  V4D            ; POINT X TO STRING DESC
8eee : 8d9b                       bsr  LB659          ; GET ADDRESS OF OLD STR
8ef0 : 3504                       puls b              ; * PULL STRING POINTER 
8ef2 : 3a                         abx                 ; * AND ADD IT TO STRING
8ef3 : 3504                       puls b              ; PULL LENGTH PARAMETER 
8ef5 : 8d80                       jsr  LB645          ; MOVE ACCB BYTES FROM (
8ef7 : 20d6                       bra  LB69D          ; PUT TEMP STRING DESCRI
                        
                        * RIGHT$
8ef9 : 8d2b             RIGHT     bsr  LB6F5          ; GET ARGUMENTS FROM STA
8efb : a084                       suba ,x             ; ACCA=LENGTH PARAMETER 
8efd : 40                         nega                ; NOW ACCA = LENGTH OF O
8efe : 20e0                       bra  LB6AE          ; PUT NEW STRING IN THE 
                        
                        * MID$
8f00 : c6ff             MID       ldb  #$FF           ; * GET DEFAULT VALUE OF
8f02 : d753                       stb  FPA0+3         ; * SAVE IT IN FPA0
8f04 : 9d82                       jsr  GETCCH         ; GET CURRENT CHARACTER 
8f06 : 8129                       cmpa #')'           ; ARGUMENT DELIMITER?
8f08 : 2705                       beq  LB6DE          ; YES - NO LENGTH PARAME
8f0a : bd8aa6                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
8f0d : 8d2d                       bsr  LB70B          ; EVALUATE NUMERIC EXPRE
8f0f : 8d15             LB6DE     bsr  LB6F5          ; GET ARGUMENTS FROM STA
8f11 : 2724                       beq  LB706          ; 'FC' ERROR IF NULL STR
8f13 : 5f                         clrb                ; CLEAR LENGTH COUNTER (
8f14 : 4a                         deca                ; *SUOTRACT ONE FROM POS
8f15 : a184                       cmpa ,x             ; *ROUTINES EXPECT 1ST P
                        *                             ; *AND COMPARE IT TO LEN
8f17 : 24ce                       bcc  LB6B5          ; IF POSITION > LENGTH O
                        *                             ; STRING WILL BE A NULL 
8f19 : 1f89                       tfr  a,b            ; SAVE ABSOLUTE POSITION
8f1b : e084                       subb ,x             ; ACCB=POSITION-LENGTH O
8f1d : 50                         negb                ; NOW ACCB=LENGTH OF OLD
8f1e : d153                       cmpb FPA0+3         ; *IF THE AMOUNT OF OLD 
8f20 : 23c5                       bls  LB6B5          ; *POSITION IS <= THE LE
                        * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION
                        * INSTEAD OF THE LENGTH PARAMETER
8f22 : d653                       ldb  FPA0+3         ; GET LENGTH OF NEW STRI
8f24 : 20c1                       bra  LB6B5          ; PUT NEW STRING IN STRI
                        * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY 
                        * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR 
8f26 : bd8aa0           LB6F5     jsr  LB267          ; SYNTAX CHECK FOR A ")"
8f29 : eee4                       ldu  ,s             ; LOAD THE RETURN ADDRES
8f2b : ae65                       ldx  5,s            ; * GET ADDRESS OF STRIN
8f2d : 9f4d                       stx  V4D            ; * SAVE IT IN V4D
8f2f : a664                       lda  4,s            ; = PUT LENGTH OF STRING
8f31 : e664                       ldb  4,s            ; = BOTH ACCA AND ACCB
8f33 : 3267                       leas 7,s            ; REMOVE DESCRIPTOR AND 
8f35 : 1f35                       tfr  u,pc           ; JUMP TO ADDRESS IN U R
8f37 : 7e8c7d           LB706     jmp  LB44A          ; 'ILLEGAL FUNCTION CALL
                        * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN
AS09 Assembler for M6809 [1.42].                                     Page   72
--------------------------------- merge.a09 ----------------------------------

                        * ACCB - 'FC' ERROR IF EXPRESSION > 255
8f3a : 9d7c             LB709     jsr  GETNCH         ; GET NEXT BASIC INPUT C
8f3c : bd897a           LB70B     jsr  LB141          ; EVALUATE A NUMERIC EXP
8f3f : bd8c1c           LB70E     jsr  LB3E9          ; CONVERT FPA0 TO INTEGE
8f42 : 4d                         tsta                ; TEST MS BYTE OF INTEGE
8f43 : 26f2                       bne  LB706          ; 'FC' ERROR IF EXPRESSI
8f45 : 0e82                       jmp  GETCCH         ; GET CURRENT INPUT CHAR
                        
                        * VAL
8f47 : bd8eb8           VAL       jsr  LB686          ; POINT X TO STRING ADDR
8f4a : 102702f8                   lbeq LBA39          ; IF NULL STRING SET FPA
8f4e : de83                       ldu  CHARAD         ; SAVE INPUT POINTER IN 
8f50 : 9f83                       stx  CHARAD         ; POINT INPUT POINTER TO
8f52 : 3a                         abx                 ; MOVE POINTER TO END OF
8f53 : a684                       lda  ,x             ; GET LAST BYTE OF STRIN
8f55 : 3452                       pshs u,x,a          ; SAVE INPUT POINTER, ST
                        *         ADDRESS AND CHARACTER
8f57 : 6f84                       clr  ,x             ; CLEAR STRING TERMINATO
8f59 : 9d82                       jsr  GETCCH         ; GET CURRENT CHARACTER 
8f5b : bd951f                     jsr  LBD12          ; CONVERT AN ASCII STRIN
8f5e : 3552                       puls a,x,u          ; RESTORE CHARACTERS AND
8f60 : a784                       sta  ,x             ; REPLACE STRING TERMINA
8f62 : df83                       stu  CHARAD         ; RESTORE INPUT CHARACTE
8f64 : 39                         rts
                        
8f65 : 8d07             LB734     bsr  LB73D          ; * EVALUATE AN EXPRESSI
8f67 : 9f2b                       stx  BINVAL         ; * THE VALUE IN X; STOR
8f69 : bd8aa6           LB738     jsr  LB26D          ; SYNTAX CHECK FOR A COM
8f6c : 20ce                       bra  LB70B          ; EVALUATE EXPRESSION IN
                        * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 
                        
8f6e : bd897a           LB73D     jsr  LB141          ; EVALUATE NUMERIC EXPRE
8f71 : 9654             LB740     lda  FP0SGN         ; GET SIGN OF FPA0 MANTI
8f73 : 2bc2                       bmi  LB706          ; ILLEGAL FUNCTION CALL'
8f75 : 964f                       lda  FP0EXP         ; GET EXPONENT OF FPA0
8f77 : 8190                       cmpa #$90           ; COMPARE TO LARGEST POS
8f79 : 22bc                       bhi  LB706          ; ILLEGAL FUNCTION CALL'
8f7b : bd94d5                     jsr  LBCC8          ; SHIFT BINARY POINT TO 
8f7e : 9e52                       ldx  FPA0+2         ; LOAD X WITH LOWER TWO 
8f80 : 39                         rts
                        
                        * PEEK
8f81 : 8dee             PEEK      bsr  LB740          ; CONVERT FPA0 TO INTEGE
8f83 : e684                       ldb  ,x             ; GET THE VALUE BEING 'P
8f85 : 7e8d26                     jmp  LB4F3          ; CONVERT ACCB INTO A FP
                        
                        * POKE
8f88 : 8ddb             POKE      bsr  LB734          ; EVALUATE 2 EXPRESSIONS
8f8a : 9e2b                       ldx  BINVAL         ; GET THE ADDRESS TO BE 
8f8c : e784                       stb  ,x             ; STORE THE DATA IN THAT
8f8e : 39                         rts
                        
                        * LIST
8f8f : 3401             LIST      pshs cc             ; SAVE ZERO FLAG ON STAC
8f91 : bd87c4                     jsr  LAF67          ; CONVERT DECIMAL LINE N
8f94 : bd8554                     jsr  LAD01          ; * FIND RAM ADDRESS OF 
8f97 : 9f66                       stx  LSTTXT         ; * SAVE IT IN LSTTXT
8f99 : 3501                       puls cc             ; GET ZERO FLAG FROM STA
8f9b : 2712                       beq  LB784          ; BRANCH IF END OF LINE
8f9d : 9d82                       jsr  GETCCH         ; GET CURRENT CHARACTER 
8f9f : 2713                       beq  LB789          ; BRANCH IF END OF LINE
8fa1 : 81ae                       cmpa #TOK_MINUS     ; MINUS TOKEN (IS IT A R
AS09 Assembler for M6809 [1.42].                                     Page   73
--------------------------------- merge.a09 ----------------------------------

8fa3 : 2609                       bne  LB783          ; NO - RETURN
8fa5 : 9d7c                       jsr  GETNCH         ; GET NEXT CHARACTER FRO
8fa7 : 2706                       beq  LB784          ; BRANCH IF END OF LINE
8fa9 : bd87c4                     jsr  LAF67          ; GET ENDING LINE NUMBER
8fac : 2706                       beq  LB789          ; BRANCH IF LEGAL LINE N
8fae : 39               LB783     rts
                        * LIST THE ENTIRE PROGRAM
8faf : ceffff           LB784     ldu  #$FFFF         ; * SET THE DEFAULT ENDI
8fb2 : df2b                       stu  BINVAL         ; * TO $FFFF
8fb4 : 9e66             LB789     ldx  LSTTXT         ; POINT X TO STARTING LI
8fb6 : bd916e           LB78D     jsr  LB95C          ; MOVE CURSOR TO START O
8fb9 : bd81ad                     jsr  LA549          ; CHECK FOR A BREAK OR P
8fbc : ec84                       ldd  ,x             ; GET ADDRESS OF NEXT BA
8fbe : 2609                       bne  LB79F          ; BRANCH IF NOT END OF P
8fc0 :                  LB797
8fc0 : 0d6e                       tst  DEVNUM		  ; null value when screen as o
8fc2 : 26ea             		  bne  LB783          ; return from call for disk fo
8fc4 : 3262             		  leas 2,s            ; PURGE RETURN ADDRESS FROM TH
8fc6 : 7e84ce           		  jmp  LAC73          ; RETURN TO BASIC'S MAIN INPUT
8fc9 : 9f66             LB79F     stx  LSTTXT         ; SAVE NEW STARTING LINE
8fcb : ec02                       ldd  2,x            ; * GET THE LINE NUMBER 
8fcd : 10932b                     cmpd BINVAL         ; * COMPARE IT TO ENDING
8fd0 : 22ee                       bhi  LB797          ; EXIT IF LINE NUMBER > 
8fd2 : bd95d9                     jsr  LBDCC          ; PRINT THE NUMBER IN AC
8fd5 : bd91b9                     jsr  LB9AC          ; SEND A SPACE TO CONSOL
8fd8 : 9e66                       ldx  LSTTXT         ; GET RAM ADDRESS OF THI
8fda : 8d10                       bsr  LB7C2          ; UNCRUNCH A LINE
8fdc : ae9f0066                   ldx  [LSTTXT]       ; POINT X TO START OF NE
8fe0 : ce00e2                     ldu  #LINBUF+1      ; POINT U TO BUFFER FULL
8fe3 : a6c0             LB7B9     lda  ,u+            ; GET A BYTE FROM THE BU
8fe5 : 27cf                       beq  LB78D          ; BRANCH IF END OF BUFFE
8fe7 : bd91be                     jsr  LB9B1          ; SEND CHARACTER TO CONS
8fea : 20f7                       bra  LB7B9          ; GET ANOTHER CHARACTER
                        
                        * UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
8fec : 3004             LB7C2     leax 4,x            ; MOVE POINTER PAST ADDR
8fee : 108e00e2                   ldy  #LINBUF+1      ; UNCRUNCH LINE INTO LIN
8ff2 : a680             LB7CB     lda  ,x+            ; GET A CHARACTER
8ff4 : 2751                       beq  LB820          ; BRANCH IF END OF LINE
8ff6 : 2b15                       bmi  LB7E6          ; BRANCH IF IT'S A TOKEN
8ff8 : 813a                       cmpa #':'           ; CHECK FOR END OF SUB L
8ffa : 260d                       bne  LB7E2          ; BRNCH IF NOT END OF SU
8ffc : e684                       ldb  ,x             ; GET CHARACTER FOLLOWIN
8ffe : c184                       cmpb #TOK_ELSE      ; TOKEN FOR ELSE?
9000 : 27f0                       beq  LB7CB          ; YES - DON'T PUT IT IN 
9002 : c183                       cmpb #TOK_SNGL_Q    ; TOKEN FOR REMARK?
9004 : 27ec                       beq  LB7CB          ; YES - DON'T PUT IT IN 
9006 : 8c                         fcb  SKP2           ; SKIP TWO BYTES
9007 : 8621             LB7E0     lda  #'!'           ; EXCLAMATION POINT
9009 : 8d30             LB7E2     bsr  LB814          ; PUT CHARACTER IN BUFFE
900b : 20e5                       bra  LB7CB          ; GET ANOTHER CHARACTER
                        
900d : ce80f4           LB7E6     ldu  #COMVEC-10     ; FIRST DO COMMANDS
9010 : 81ff                       cmpa #$FF           ; CHECK FOR SECONDARY TO
9012 : 2604                       bne  LB7F1          ; BRANCH IF NON SECONDAR
9014 : a680                       lda  ,x+            ; GET SECONDARY TOKEN
9016 : 3345                       leau 5,u            ; BUMP IT UP TO SECONDAR
9018 : 847f             LB7F1     anda #$7F           ; MASK OFF BIT 7 OF TOKE
901a : 334a             LB7F3     leau 10,u           ; MOVE TO NEXT COMMAND T
901c : 6dc4                       tst  ,u             ; IS THIS TABLE ENABLED?
901e : 27e7                       beq  LB7E0          ; NO - ILLEGAL TOKEN
9020 : a0c4                       suba ,u             ; SUBTRACT THE NUMBER OF
AS09 Assembler for M6809 [1.42].                                     Page   74
--------------------------------- merge.a09 ----------------------------------

9022 : 2af6                       bpl  LB7F3          ; BRANCH IF TOKEN NOT IN
9024 : abc4                       adda ,u             ; RESTORE TOKEN NUMBER R
9026 : ee41                       ldu  1,u            ; POINT U TO COMMAND DIC
9028 : 4a               LB801     deca                ; DECREMENT TOKEN NUMBER
9029 : 2b06                       bmi  LB80A          ; BRANCH IF THIS IS THE 
                        * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN
902b : 6dc0             LB804     tst  ,u+            ; GRAB A BYTE
902d : 2afc                       bpl  LB804          ; BRANCH IF BIT 7 NOT SE
902f : 20f7                       bra  LB801          ; GO SEE IF THIS IS THE 
9031 : a6c4             LB80A     lda  ,u             ; GET A CHARACTER FROM D
9033 : 8d06                       bsr  LB814          ; PUT CHARACTER IN BUFFE
9035 : 6dc0                       tst  ,u+            ; CHECK FOR START OF NEX
9037 : 2af8                       bpl  LB80A          ; BRANCH IF NOT DONE WIT
9039 : 20b7                       bra  LB7CB          ; GO GET ANOTHER CHARACT
903b : 108c01db         LB814     cmpy #LINBUF+LBUFMX ; TEST FOR END OF LINE I
903f : 2406                       bcc  LB820          ; BRANCH IF AT END OF BU
9041 : 847f                       anda #$7F           ; MASK OFF BIT 7
9043 : a7a0                       sta  ,y+            ; * SAVE CHARACTER IN BU
9045 : 6fa4                       clr  ,y             ; * CLEAR NEXT CHARACTER
9047 : 39               LB820     rts
                        *
                        * CRUNCH THE LINE THAT THE INPUT POINTER IS
                        * POINTING TO INTO THE LINE INPUT BUFFER
                        * RETURN LENGTH OF CRUNCHED LINE IN ACCD
                        *
9048 : 9e83             LB821     ldx  CHARAD         ; GET BASIC'S INPUT POIN
904a : ce00e1                     ldu  #LINBUF        ; POINT X TO LINE INPUT 
904d : 0f43             LB829     clr  V43            ; CLEAR ILLEGAL TOKEN FL
904f : 0f44                       clr  V44            ; CLEAR DATA FLAG
9051 : a680             LB82D     lda  ,x+            ; GET INPUT CHAR
9053 : 2721                       beq  LB852          ; BRANCH IF END OF LINE
9055 : 0d43                       tst  V43            ; * CHECK ILLEGAL TOKEN 
9057 : 270f                       beq  LB844          ; * PROCESSING AN ILLEGA
9059 : bd8bd5                     jsr  LB3A2          ; SET CARRY IF NOT UPPER
905c : 2418                       bcc  LB852          ; BRANCH IF UPPER CASE A
905e : 8130                       cmpa #'0'            ; * DON'T CRUNCH ASCII 
9060 : 2504                       blo  LB842          ; * BRANCH IF NOT NUMERI
9062 : 8139                       cmpa #'9'           ; *
9064 : 2310                       bls  LB852          ; * BRANCH IF NUMERIC
                        * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC
9066 : 0f43             LB842     clr  V43            ; CLEAR ILLEGAL TOKEN FL
9068 : 8120             LB844     cmpa #SPACE         ; SPACE?
906a : 270a                       beq  LB852          ; DO NOT REMOVE SPACES
906c : 9742                       sta  V42            ; SAVE INPUT CHARACTER A
906e : 8122                       cmpa #'"'           ; CHECK FOR STRING DELIM
9070 : 2738                       beq  LB886          ; BRANCH IF STRING
9072 : 0d44                       tst  V44            ; * CHECK DATA FLAG AND 
9074 : 2719                       beq  LB86B          ; * DO NOT CRUNCH DATA
9076 : a7c0             LB852     sta  ,u+            ; SAVE CHARACTER IN BUFF
9078 : 2706                       beq  LB85C          ; BRANCH IF END OF LINE
907a : 813a                       cmpa #':'           ; * CHECK FOR END OF SUB
907c : 27cf                       beq  LB829          ; * AND RESET FLAGS IF E
907e : 20d1             LB85A     bra  LB82D          ; GO GET ANOTHER CHARACT
9080 : 6fc0             LB85C     clr  ,u+            ; * DOUBLE ZERO AT END O
9082 : 6fc0                       clr  ,u+            ; *
9084 : 1f30                       tfr  u,d            ; SAVE ADDRESS OF END OF
9086 : 8300df                     subd #LINHDR        ; LENGTH OF LINE IN ACCD
9089 : 8e00e0                     ldx  #LINBUF-1      ; * SET THE INPUT POINTE
908c : 9f83                       stx  CHARAD         ; * THE START OF THE CRU
908e : 39                         rts                 ; EXIT 'CRUNCH'
908f : 813f             LB86B     cmpa #'?'           ; CHECK FOR "?" - PRINT 
9091 : 2604                       bne  LB873          ; BRANCH IF NOT PRINT AB
AS09 Assembler for M6809 [1.42].                                     Page   75
--------------------------------- merge.a09 ----------------------------------

9093 : 8687                       lda  #TOK_PRINT     ; * GET THE PRINT TOKEN 
9095 : 20df                       bra  LB852          ; * IN BUFFER
9097 : 8127             LB873     cmpa #$27           ; #''' APOSTROPHE IS SAM
9099 : 2613                       bne  LB88A          ; BRANCH IF NOT REMARK
909b : cc3a83                     ldd  #$3A00+TOK_SNGL_Q ; COLON, REM TOKEN
909e : edc1                       std  ,u++           ; SAVE IN BUFFER
90a0 : 0f42             LB87C     clr  V42            ; SET DELIMITER = 0 (END
90a2 : a680             LB87E     lda  ,x+            ; SCAN TILL WE MATCH [V4
90a4 : 27d0                       beq  LB852          ; BRANCH IF END OF LINE
90a6 : 9142                       cmpa V42            ; DELIMITER?
90a8 : 27cc                       beq  LB852          ; BRANCH OUT IF SO
90aa : a7c0             LB886     sta  ,u+            ; DON'T CRUNCH REMARKS O
90ac : 20f4                       bra  LB87E          ; GO GET MORE STRING OR 
90ae : 8130             LB88A     cmpa #'0'            ; * LESS THAN ASCII ZER
90b0 : 2504                       bcs  LB892          ; * BRANCH IF SO
90b2 : 813c                       cmpa #';'+1         ; = CHECK FOR NUMERIC VA
90b4 : 25c0                       bcs  LB852          ; = AND INSERT IN BUFFER
90b6 : 301f             LB892     leax -1,x           ; MOVE INPUT POINTER BAC
90b8 : 3450                       pshs u,x            ; SAVE POINTERS TO INPUT
90ba : 0f41                       clr  V41            ; TOKEN FLAG 0 = COMMANd
90bc : ce80f4                     ldu  #COMVEC-10     ; POINT U TO COMMAND INT
                        *                             ; TABLE FOR BASIC - 10
90bf : 0f42             LB89B     clr  V42            ; INITIALIZE V42 AS TOKE
90c1 : 334a             LB89D     leau 10,u           ; MOVE TO NEXT COMMAND I
90c3 : a6c4                       lda  ,u             ; GET NUMBER OF COMMANDS
90c5 : 2731                       beq  LB8D4          ; GO DO SECONDARY FUNCTI
90c7 : 10ae41                     ldy  1,u            ; POINT Y TO COMMAND DIC
90ca : aee4             LB8A6     ldx  ,s             ; GET POINTER TO INPUT S
90cc : e6a0             LB8A8     ldb  ,y+            ; GET A BYTE FROM DICTIO
90ce : e080                       subb ,x+            ; SUBTRACT INPUT CHARACT
90d0 : 27fa                       beq  LB8A8          ; LOOP IF SAME
90d2 : c180                       cmpb #$80           ; LAST CHAR IN RESERVED 
                        *                             ; BIT 7 SET, SO IF WE HA
                        *                             ; THEN IT IS A GOOD COMP
90d4 : 2638                       bne  LB8EA          ; BRANCH IF NO MATCH - C
90d6 : 3262                       leas 2,s            ; DELETE OLD INPUT POINT
90d8 : 3540                       puls u              ; GET POINTER TO OUTPUT 
90da : da42                       orb  V42            ; OR IN THE TABLE POSITI
                        *                             ; - NOTE THAT B ALREADY 
90dc : 9641                       lda  V41            ; * CHECK TOKEN FLAG AND
90de : 2606                       bne  LB8C2          ; * IF SECONDARY
90e0 : c184                       cmpb #TOK_ELSE      ; IS IT ELSE TOKEN?
90e2 : 2606                       bne  LB8C6          ; NO
90e4 : 863a                       lda  #':'           ; PUT A COLON (SUBLINE) 
90e6 : edc1             LB8C2     std  ,u++           ; SECONDARY TOKENS PRECE
90e8 : 2094                       bra  LB85A          ; GO PROCESS MORE INPUT 
90ea : e7c0             LB8C6     stb  ,u+            ; SAVE THIS TOKEN
90ec : c186                       cmpb #TOK_DATA      ; DATA TOKEN?
90ee : 2602                       bne  LB8CE          ; NO
90f0 : 0c44                       inc  V44            ; SET DATA FLAG
90f2 : c182             LB8CE     cmpb #TOK_REM       ; REM TOKEN?
90f4 : 27aa                       beq  LB87C          ; YES
90f6 : 2086             LB8D2     lbra LB85A          ; GO PROCESS MORE INPUT 
                        * CHECK FOR A SECONDARY TOKEN
90f8 : ce80f9           LB8D4     ldu  #COMVEC-5      ; NOW DO SECONDARY FUNCT
90fb : 0341                       com  V41            ; TOGGLE THE TOKEN FLAG
90fd : 26c0                       bne  LB89B          ; BRANCH IF NOW CHECKING
                        
                        * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CR
                        * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN
90ff : 3550                       puls x,u            ; RESTORE INPUT AND OUTP
9101 : a680                       lda  ,x+            ; * MOVE THE FIRST CHARA
AS09 Assembler for M6809 [1.42].                                     Page   76
--------------------------------- merge.a09 ----------------------------------

9103 : a7c0                       sta  ,u+            ; * ILLEGAL TOKEN
9105 : bd8bd5                     jsr  LB3A2          ; SET CARRY IF NOT ALPHA
9108 : 25ec                       bcs  LB8D2          ; BRANCH IF NOT ALPHA
910a : 0343                       com  V43            ; SET ILLEGAL TOKEN FLAG
910c : 20e8                       bra  LB8D2          ; PROCESS MORE INPUT CHA
910e : 0c42             LB8EA     inc  V42            ; INCREMENT TOKEN COUNTE
9110 : 4a                         deca                ; DECR COMMAND COUNTER
9111 : 27ae                       beq  LB89D          ; GET ANOTHER COMMAND TA
9113 : 313f                       leay -1,y           ; MOVE POINTER BACK ONE
9115 : e6a0             LB8F1     ldb  ,y+            ; * GET TO NEXT
9117 : 2afc                       bpl  LB8F1          ; * RESERVED WORD
9119 : 20af                       bra  LB8A6          ; GO SEE IF THIS WORD IS
                        
                        * PRINT
911b : 274d             PRINT     beq  LB958          ; BRANCH IF NO ARGUMENT
911d : 8d01                       bsr  LB8FE          ; CHECK FOR ALL PRINT OP
911f : 39                         rts
                        
9120 : 8140             LB8FE	cmpa #'@'	; CHECK FOR PRINT @
9122 : 2605             		bne	LB907	; NOT PRINT @
9124 : bd81b0           LB902	jsr	LA554	; MOVE CURSOR TO PROPER PRINT LOCATION
9127 : 2004             LB905	bra	LB911	; GO PRINT THE DATA
9129 : 8123             LB907	cmpa #'#'	; CHECK FOR PRINT NUMBER
912b : 2607             		bne	LB918	; NOT PRINT#
                        		;jsr	LA5A5	; CHECK FOR A VALID DEVICE NUMBER
                        		;jsr	LA406	; CHECK FOR A VALID OUTPUT FILE
912d : 9d82             LB911	jsr	GETCCH	; GET CURRENT INPUT CHARACTER
912f : 2739             		beq	LB958	; BRANCH IF END OF LINE
9131 : bd8aa6           		jsr	LB26D	; SYNTAX CHECK FOR COMMA
                        
9134 : bda08d           LB918     jsr  XVEC9          ; CALL EXTENDED BASIC AD
9137 : 273e             LB91B     beq  LB965          ; RETURN IF END OF LINE
9139 : 81a6             LB91D     cmpa #TOK_TAB       ; TOKEN FOR TAB( ?
913b : 2753                       beq  LB97E          ; YES
913d : 812c                       cmpa #','           ; COMMA?
913f : 2737                       beq  LB966          ; YES - ADVANCE TO NEXT 
9141 : 813b                       cmpa #';'           ; SEMICOLON?
9143 : 2760                       beq  LB997          ; YES - DO NOT ADVANCE C
9145 : bd898f                     jsr  LB156          ; EVALUATE EXPRESSION
9148 : 9606                       lda  VALTYP         ; * GET VARIABLE TYPE AN
914a : 3402                       pshs a              ; * SAVE IT ON THE STACK
914c : 2606                       bne  LB938          ; BRANCH IF STRING VARIA
914e : bd95e6                     jsr  LBDD9          ; CONVERT FP NUMBER TO A
9151 : bd8d49                     jsr  LB516          ; PARSE A STRING FROM (X
                        *                             ; DESCRIPTOR ON STRING S
9154 : 8d56             LB938     bsr  LB99F          ; PRINT STRING POINTED T
9156 : 3504                       puls b              ; GET VARIABLE TYPE BACK
9158 : bd8146                     jsr  LA35F          ; SET UP TAB WIDTH ZONE,
915b : 5d               LB949     tstb                ; CHECK CURRENT PRINT PO
915c : 2608                       bne  LB954          ; BRANCH IF NOT AT START
915e : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
9160 : 812c                       cmpa #','            ; COMMA?
9162 : 2714                       beq  LB966          ; SKIP TO NEXT TAB FIELD
9164 : 8d53                       bsr  LB9AC          ; SEND A SPACE TO CONSOL
9166 : 9d82             LB954     jsr  GETCCH         ; GET CURRENT INPUT CHAR
9168 : 26cf                       bne  LB91D          ; BRANCH IF NOT END OF L
916a : 860d             LB958     lda  #CR            ; * SEND A CR TO
916c : 2050                       bra  LB9B1          ; * CONSOLE OUT
916e : bd8146           LB95C     jsr  LA35F          ; SET UP TAB WIDTH, ZONE
9171 : 27f7                       beq  LB958          ; BRANCH IF WIDTH = ZERO
9173 : 966c                       lda  DEVPOS         ; GET PRINT POSITION
9175 : 26f3                       bne  LB958          ; BRANCH IF NOT AT START
AS09 Assembler for M6809 [1.42].                                     Page   77
--------------------------------- merge.a09 ----------------------------------

9177 : 39               LB965     rts
                        * SKIP TO NEXT TAB FIELD
9178 : bd8146           LB966     jsr  LA35F          ; SET UP TAB WIDTH, ZONE
917b : 270a                       beq  LB975          ; BRANCH IF LINE WIDTH =
917d : d66c                       ldb  DEVPOS         ; GET CURRENT POSITION
917f : d16b                       cmpb DEVLCF         ; COMPARE TO LAST TAB ZO
9181 : 2506                       bcs  LB977          ; BRANCH IF < LAST TAB Z
9183 : 8de5                       bsr  LB958          ; SEND A CARRIAGE RETURN
9185 : 201e                       bra  LB997          ; GET MORE DATA
9187 : d66c             LB975     ldb  DEVPOS         ; *
9189 : d06a             LB977     subb DEVCFW         ; * SUBTRACT TAB FIELD W
918b : 24fc                       bcc  LB977          ; * POSITION UNTIL CARRY
918d : 50                         negb                ; * REMAINDER LEAVES THE
                        *              ; * TAB ZONE IN ACCB
918e : 2010                       bra  LB98E          ; GO ADVANCE TO NEXT TAB
                        
                        * PRINT TAB(
9190 : bd8f3a           LB97E     jsr  LB709          ; EVALUATE EXPRESSION - 
9193 : 8129                       cmpa #')'           ; * 'SYNTAX' ERROR IF NO
9195 : 1026f917                   lbne LB277          ; *
9199 : bd8146                     jsr  LA35F          ; SET UP TAB WIDTH, ZONE
919c : d06c                       subb DEVPOS         ; GET DIFFERENCE OF PRIN
919e : 2305                       bls  LB997          ; BRANCH IF TAB POSITION
91a0 :                  LB98E
91a0 : 8d17             LB992     bsr  LB9AC          ; SEND A SPACE TO CONSOL
91a2 : 5a                         decb                ; DECREMENT DIFFERENCE C
91a3 : 26fb                       bne  LB992          ; BRANCH UNTIL CURRENT P
91a5 : 9d7c             LB997     jsr  GETNCH         ; GET NEXT CHARACTER FRO
91a7 : 208e                       jmp  LB91B          ; LOOK FOR MORE PRINT DA
                        * COPY A STRING FROM (X) TO CONSOLE OUT
91a9 : bd8d4b           LB99C     jsr  LB518          ; PARSE A STRING FROM X 
91ac : bd8e89           LB99F     jsr  LB657          ; GET LENGTH OF STRING A
91af : 5c                         incb                ; COMPENSATE FOR DECB BE
91b0 : 5a               LB9A3     decb                ; DECREMENT COUNTER
91b1 : 27c4                       beq  LB965          ; EXIT ROUTINE
91b3 : a680                       lda  ,x+            ; GET A CHARACTER FROM X
91b5 : 8d07                       bsr  LB9B1          ; SEND TO CONSOLE OUT
91b7 : 20f7                       bra  LB9A3          ; KEEP LOOPING
91b9 : 8620             LB9AC     lda  #SPACE         ; SPACE TO CONSOLE OUT
91bb : 8c                         fcb  SKP2           ; SKIP NEXT TWO BYTES
91bc : 863f             LB9AF     lda  #'?'           ; QUESTION MARK TO CONSO
91be : 7e805c           LB9B1     jmp  PUTCHR         ; JUMP TO CONSOLE OUT
                        
                        * FLOATING POINT MATH PACKAGE
                        
                        * ADD .5 TO FPA0
91c1 : 8e96cd           LB9B4     ldx  #LBEC0         ; FLOATING POINT CONstaN
91c4 : 2009                       bra  LB9C2          ; ADD .5 TO FPA0
                        * SUBTRACT FPA0 FROM FP NUMBER POINTED
                        * TO BY (X), LEAVE RESULT IN FPA0
91c6 : bd933c           LB9B9     jsr  LBB2F          ; COPY PACKED FP DATA FR
                        
                        * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 
                        * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 I
91c9 : 0354             LB9BC     com  FP0SGN         ; CHANGE MANTISSA SIGN O
91cb : 0362                       com  RESSGN         ; REVERSE RESULT SIGN FL
91cd : 2003                       bra  LB9C5          ; GO ADD FPA1 AND FPA0
                        * ADD FP NUMBER POINTED TO BY
                        * (X) TO FPA0 - LEAVE RESULT IN FPA0
91cf : bd933c           LB9C2     jsr  LBB2F          ; UNPACK PACKED FP DATA 
                        *         FPA1; RETURN EXPONENT OF FPA1 IN ACCA
                        
AS09 Assembler for M6809 [1.42].                                     Page   78
--------------------------------- merge.a09 ----------------------------------

                        * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO
                        
91d2 : 5d               LB9C5     tstb                ; CHECK EXPONENT OF FPA0
91d3 : 10270280                   lbeq LBC4A          ; COPY FPA1 TO FPA0 IF F
91d7 : 8e005c                     ldx  #FP1EXP        ; POINT X TO FPA1
91da : 1f89             LB9CD     tfr  a,b            ; PUT EXPONENT OF FPA1 I
91dc : 5d                         tstb                ; CHECK EXPONENT
91dd : 276c                       beq LBA3E           ; RETURN IF EXPONENT = 0
91df : d04f                       subb FP0EXP         ; SUBTRACT EXPONENT OF F
91e1 : 2769                       beq LBA3F           ; BRANCH IF EXPONENTS AR
91e3 : 250a                       bcs  LB9E2          ; BRANCH IF EXPONENT FPA
91e5 : 974f                       sta  FP0EXP         ; REPLACE FPA0 EXPONENT 
91e7 : 9661                       lda  FP1SGN         ; * REPLACE FPA0 MANTISS
91e9 : 9754                       sta  FP0SGN         ; * WITH FPA1 MANTISSA S
91eb : 8e004f                     ldx  #FP0EXP        ; POINT X TO FPA0
91ee : 50                         negb                ; NEGATE DIFFERENCE OF E
91ef : c1f8             LB9E2     cmpb #-8            ; TEST DIFFERENCE OF EXP
91f1 : 2f59                       ble  LBA3F          ; BRANCH IF DIFFERENCE O
91f3 : 4f                         clra                ; CLEAR OVERFLOW BYTE
91f4 : 6401                       lsr  1,x            ; SHIFT MS BYTE OF MANTI
91f6 : bd92c7                     jsr  LBABA          ; GO SHIFT MANTISSA OF (
91f9 : d662             LB9EC     ldb  RESSGN         ; GET SIGN FLAG
91fb : 2a0b                       bpl  LB9FB          ; BRANCH IF FPA0 AND FPA
91fd : 6301                       com  1,x            ; * COMPLEMENT MANTISSA 
91ff : 6302                       com  2,x            ; * TO BY (X) THE
9201 : 6303                       com  3,x            ; * adca BELOW WILL
9203 : 6304                       com  4,x            ; * CONVERT THIS OPERATI
9205 : 43                         coma                ; * INTO A NEG (MANTISSA
9206 : 8900                       adca #0             ; ADD ONE TO ACCA - coma
                        * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA
                        *
                        * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0
9208 : 9763             LB9FB     sta  FPSBYT         ; SAVE FPA SUB BYTE
920a : 9653                       lda  FPA0+3         ; * ADD LS BYTE
920c : 9960                       adca FPA1+3         ; * OF MANTISSA
920e : 9753                       sta  FPA0+3         ; SAVE IN FPA0 LSB
9210 : 9652                       lda  FPA0+2         ; * ADD NEXT BYTE
9212 : 995f                       adca FPA1+2         ; * OF MANTISSA
9214 : 9752                       sta  FPA0+2         ; SAVE IN FPA0
9216 : 9651                       lda  FPA0+1         ; * ADD NEXT BYTE
9218 : 995e                       adca FPA1+1         ; * OF MANTISSA
921a : 9751                       sta  FPA0+1         ; SAVE IN FPA0
921c : 9650                       lda  FPA0           ; * ADD MS BYTE
921e : 995d                       adca FPA1           ; * OF MANTISSA
9220 : 9750                       sta  FPA0           ; SAVE IN FPA0
9222 : 5d                         tstb                ; TEST SIGN FLAG
9223 : 2a44                       bpl  LBA5C          ; BRANCH IF FPA0 & FPA1 
9225 : 2502             LBA18     bcs  LBA1C          ; BRANCH IF POSITIVE MAN
9227 : 8d5d                       bsr  LBA79          ; NEGATE FPA0 MANTISSA
                        
                        * NORMALIZE FPA0
9229 : 5f               LBA1C     clrb                ; CLEAR TEMPORARY EXPONE
922a : 9650             LBA1D     lda  FPA0           ; TEST MSB OF MANTISSA
922c : 262e                       bne  LBA4F          ; BRANCH IF <> 0
922e : 9651                       lda  FPA0+1         ; * IF THE MSB IS
9230 : 9750                       sta  FPA0           ; * 0, THEN SHIFT THE
9232 : 9652                       lda  FPA0+2         ; * MANTISSA A WHOLE BYT
9234 : 9751                       sta  FPA0+1         ; * AT A TIME. THIS
9236 : 9653                       lda  FPA0+3         ; * IS FASTER THAN ONE
9238 : 9752                       sta  FPA0+2         ; * BIT AT A TIME
923a : 9663                       lda  FPSBYT         ; * BUT USES MORE MEMORY
923c : 9753                       sta  FPA0+3         ; * FPSBYT, THE CARRY IN
AS09 Assembler for M6809 [1.42].                                     Page   79
--------------------------------- merge.a09 ----------------------------------

923e : 0f63                       clr  FPSBYT         ; * BYTE, REPLACES THE M
9240 : cb08                       addb #8             ; SHIFTING ONE BYTE = 8 
9242 : c128                       cmpb #5*8           ; CHECK FOR 5 SHIFTS
9244 : 2de4                       blt  LBA1D          ; BRANCH IF < 5 SHIFTS, 
9246 : 4f               LBA39     clra                ; A ZERO EXPONENT = 0 FL
9247 : 974f             LBA3A     sta  FP0EXP         ; ZERO OUT THE EXPONENT
9249 : 9754                       sta  FP0SGN         ; ZERO OUT THE MANTISSA 
924b : 39               LBA3E     rts
924c : 8d6d             LBA3F     bsr LBAAE           ; SHIFT FPA0 MANTISSA TO
924e : 5f                         clrb                ; CLEAR CARRY FLAG
924f : 20a8                       bra  LB9EC
                        * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7
                        * OF MATISSA MS BYTE = 1
9251 : 5c               LBA44     incb                ; ADD ONE TO EXPONENT AC
9252 : 0863                       asl  FPSBYT         ; SHIFT SUB BYTE ONE LEF
9254 : 0953                       rol  FPA0+3         ; SHIFT LS BYTE
9256 : 0952                       rol  FPA0+2         ; SHIFT NS BYTE
9258 : 0951                       rol  FPA0+1         ; SHIFT NS BYTE
925a : 0950                       rol  FPA0           ; SHIFT MS BYTE
925c : 2af3             LBA4F     bpl  LBA44          ; BRANCH IF NOT YET NORM
925e : 964f                       lda  FP0EXP         ; GET CURRENT EXPONENT
9260 : 3404                       pshs b              ; SAVE EXPONENT MODIFIER
9262 : a0e0                       suba ,s+            ; SUBTRACT ACCUMULATED E
9264 : 974f                       sta  FP0EXP         ; SAVE AS NEW EXPONENT
9266 : 23de                       bls  LBA39          ; SET FPA0 = 0 IF THE NO
                        *         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE
                        *         SIZE OF THE EXPONENT
9268 : 8c                         fcb  SKP2           ; SKIP 2 BYTES
9269 : 2508             LBA5C     bcs  LBA66          ; BRANCH IF MANTISSA OVE
926b : 0863                       asl  FPSBYT         ; SUB BYTE BIT 7 TO CARR
                        *                             ; FLAG (TRUNCATE THE RES
926d : 8600                       lda  #0             ; clra, BUT DO NOT CHANG
926f : 9763                       sta  FPSBYT         ; CLEAR THE SUB BYTE
9271 : 200c                       bra  LBA72          ; GO ROUND-OFF RESULT
9273 : 0c4f             LBA66     inc  FP0EXP         ; INCREMENT EXPONENT - M
9275 : 2728                       beq  LBA92          ; OVERFLOW ERROR IF CARR
9277 : 0650                       ror  FPA0           ; * SHIFT MANTISSA
9279 : 0651                       ror  FPA0+1         ; * ONE TO
927b : 0652                       ror  FPA0+2         ; * THE RIGHT -
927d : 0653                       ror  FPA0+3         ; * DIVIDE BY TWO
927f : 2404             LBA72     bcc  LBA78          ; BRANCH IF NO ROUND-OFF
9281 : 8d0d                       bsr  LBA83          ; ADD ONE TO MANTISSA - 
9283 : 27ee                       beq  LBA66          ; BRANCH iF OVERFLOW - M
9285 : 39               LBA78     rts
                        * NEGATE FPA0 MANTISSA
9286 : 0354             LBA79     com  FP0SGN         ; TOGGLE SIGN OF MANTISS
9288 : 0350             LBA7B     com  FPA0           ; * COMPLEMENT ALL 4 MAN
928a : 0351                       com  FPA0+1         ; *
928c : 0352                       com  FPA0+2         ; *
928e : 0353                       com  FPA0+3         ; *
                        * ADD ONE TO FPA0 MANTISSA
9290 : 9e52             LBA83     ldx  FPA0+2         ; * GET BOTTOM 2 MANTISS
9292 : 3001                       leax 1,x            ; * BYTES, ADD ONE TO
9294 : 9f52                       stx  FPA0+2         ; * THEM AND SAVE THEM
9296 : 2606                       bne  LBA91          ; BRANCH IF NO OVERFLOW
9298 : 9e50                       ldx  FPA0           ; * IF OVERFLOW ADD ONE
929a : 3001                       leax 1,x            ; * TO TOP 2 MANTISSA
929c : 9f50                       stx  FPA0           ; * BYTES AND SAVE THEM
929e : 39               LBA91     rts
929f : c60a             LBA92     ldb  #2*5           ; OV' OVERFLOW ERROR
92a1 : 7e84af                     jmp  LAC46          ; PROCESS AN ERROR
92a4 : 8e0012           LBA97     ldx  #FPA2-1        ; POINT X TO FPA2
AS09 Assembler for M6809 [1.42].                                     Page   80
--------------------------------- merge.a09 ----------------------------------

                        * SHIFT FPA POINTED TO BY (X) TO
                        * THE RIGHT -(B) TIMES. EXIT WITH
                        * ACCA CONTAINING DATA SHIFTED OUT
                        * TO THE RIGHT (SUB BYTE) AND THE DATA
                        * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY
92a7 : a604             LBA9A     lda  4,x            ; GET LS BYTE OF MANTISS
92a9 : 9763                       sta  FPSBYT         ; SAVE IN FPA SUB BYTE
92ab : a603                       lda  3,x            ; * SHIFT THE NEXT THREE
92ad : a704                       sta  4,x            ; * MANTISSA RIGHT ONE C
92af : a602                       lda  2,x            ; *
92b1 : a703                       sta  3,x            ; *
92b3 : a601                       lda  1,x            ; *
92b5 : a702                       sta  2,x            ; *
92b7 : 965b                       lda  FPCARY         ; GET THE CARRY IN BYTE
92b9 : a701                       sta  1,x            ; STORE AS THE MS MANTIS
92bb : cb08             LBAAE     addb #8             ; ADD 8 TO DIFFERENCE OF
92bd : 2fe8                       ble  LBA9A          ; BRANCH IF EXPONENT DIF
92bf : 9663                       lda  FPSBYT         ; GET FPA SUB BYTE
92c1 : c008                       subb #8             ; CAST OUT THE 8 ADDED I
92c3 : 270c                       beq  LBAC4          ; BRANCH IF EXPONENT DIF
                        
                        
92c5 : 6701             LBAB8     asr  1,x            ; * SHIFT MANTISSA AND S
92c7 : 6602             LBABA     ror  2,x            ; *
92c9 : 6603                       ror  3,x            ; *
92cb : 6604                       ror  4,x            ; *
92cd : 46                         rora                ; *
92ce : 5c                         incb                ; ADD ONE TO EXPONENT DI
92cf : 26f4                       bne  LBAB8          ; BRANCH IF EXPONENTS NO
92d1 : 39               LBAC4     rts
92d2 : 8100000000       LBAC5     fcb  $81,$00,$00,$00,$00 ; FLOATING POINT CO
                        
                        * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY
                        * FPA0 BY (X) - RETURN PRODUCT IN FPA0
92d7 : 8d63             LBACA     bsr  LBB2F          ; MOVE PACKED FPA FROM (
92d9 : 2760             LBACC     beq  LBB2E          ; BRANCH IF EXPONENT OF 
92db : 8d78                       bsr  LBB48          ; CALCULATE EXPONENT OF 
                        * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE
                        * HIGH ORDER BYTES OF PRODUCT IN FPA0. THE
                        * LOW ORDER FOUR BYTES OF THE PRODUCT WILL
                        * BE STORED IN VAB-VAE.
92dd : 8600             LBAD0     lda  #0             ; * ZERO OUT MANTISSA OF
92df : 9713                       sta  FPA2           ; *
92e1 : 9714                       sta  FPA2+1         ; *
92e3 : 9715                       sta  FPA2+2         ; *
92e5 : 9716                       sta  FPA2+3         ; *
92e7 : d653                       ldb  FPA0+3         ; GET LS BYTE OF FPA0
92e9 : 8d22                       bsr  LBB00          ; MULTIPLY BY FPA1
92eb : d663                       ldb  FPSBYT         ; * TEMPORARILY SAVE SUB
92ed : d78b                       stb  VAE            ; *
92ef : d652                       ldb  FPA0+2         ; GET NUMBER 3 MANTISSA 
92f1 : 8d1a                       bsr  LBB00          ; MULTIPLY BY FPA1
92f3 : d663                       ldb  FPSBYT         ; * TEMPORARILY SAVE SUB
92f5 : d78a                       stb  VAD            ; *
92f7 : d651                       ldb  FPA0+1         ; GET NUMBER 2 MANTISSA 
92f9 : 8d12                       bsr  LBB00          ; MULTIPLY BY FPA1
92fb : d663                       ldb  FPSBYT         ; * TEMPORARILY SAVE SUB
92fd : d789                       stb  VAC            ; *
92ff : d650                       ldb  FPA0           ; GET MS BYTE OF FPA0 MA
9301 : 8d0c                       bsr  LBB02          ; MULTIPLY BY FPA1
9303 : d663                       ldb  FPSBYT         ; * TEMPORARILY SAVE SUB
9305 : d788                       stb  VAB            ; *
AS09 Assembler for M6809 [1.42].                                     Page   81
--------------------------------- merge.a09 ----------------------------------

9307 : bd9418                     jsr  LBC0B          ; COPY MANTISSA FROM FPA
930a : 7e9229                     jmp  LBA1C          ; NORMALIZE FPA0
930d : 2795             LBB00     lbeq LBA97          ; SHIFT FPA2 ONE BYTE TO
930f : 43               LBB02     coma                ; SET CARRY FLAG
                        * MULTIPLY FPA1 MANTISSA BY ACCB AND
                        * ADD PRODUCT TO FPA2 MANTISSA
9310 : 9613             LBB03     lda  FPA2           ; GET FPA2 MS BYTE
9312 : 56                         rorb                ; ROTATE CARRY FLAG INTO
                        *         DATA BIT INTO CARRY
9313 : 2726                       beq  LBB2E          ; BRANCH WHEN 8 SHIFTS D
9315 : 2416                       bcc  LBB20          ; DO NOT ADD FPA1 IF DAT
9317 : 9616                       lda  FPA2+3         ; * ADD MANTISSA LS BYTE
9319 : 9b60                       adda FPA1+3         ; *
931b : 9716                       sta  FPA2+3         ; *
931d : 9615                       lda  FPA2+2         ; = ADD MANTISSA NUMBER 
931f : 995f                       adca FPA1+2         ; =
9321 : 9715                       sta  FPA2+2         ; =
9323 : 9614                       lda  FPA2+1         ; * ADD MANTISSA NUMBER 
9325 : 995e                       adca FPA1+1         ; *
9327 : 9714                       sta  FPA2+1         ; *
9329 : 9613                       lda  FPA2           ; = ADD MANTISSA MS BYTE
932b : 995d                       adca FPA1           ; =
932d : 46               LBB20     rora                ; * ROTATE CARRY INTO MS
932e : 9713                       sta  FPA2           ; *
9330 : 0614                       ror  FPA2+1         ; = ROTATE FPA2 ONE BIT 
9332 : 0615                       ror  FPA2+2         ; =
9334 : 0616                       ror  FPA2+3         ; =
9336 : 0663                       ror  FPSBYT         ; =
9338 : 4f                         clra                ; CLEAR CARRY FLAG
9339 : 20d5                       bra  LBB03          ; KEEP LOOPING
933b : 39               LBB2E     rts
                        * UNPACK A FP NUMBER FROM (X) TO FPA1
933c : ec01             LBB2F     ldd  1,x            ; GET TWO MSB BYTES OF M
                        *         FPA  POINTED TO BY X
933e : 9761                       sta  FP1SGN         ; SAVE PACKED MANTISSA S
9340 : 8a80                       ora  #$80           ; FORCE BIT 7 OF MSB MAN
9342 : dd5d                       std  FPA1           ; SAVE 2 MSB BYTES IN FP
9344 : d661                       ldb  FP1SGN         ; * GET PACKED MANTISSA 
9346 : d854                       eorb FP0SGN         ; * SIGN - NEW SIGN POSI
9348 : d762                       stb  RESSGN         ; * NEG IF BOTH OLD SIGN
                        *                             ; * MANTISSA SIGN BYTE
934a : ec03                       ldd  3,x            ; = GET 2 LSB BYTES OF M
934c : dd5f                       std  FPA1+2         ; = AND PUT IN FPA1
934e : a684                       lda  ,x             ; * GET EXPONENT FROM (X
9350 : 975c                       sta  FP1EXP         ; * PUT IN EXPONENT OF F
9352 : d64f                       ldb  FP0EXP         ; GET EXPONENT OF FPA0
9354 : 39                         rts
                        * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1
                        * ENTER WITH EXPONENT OF FPA1 IN ACCA
9355 : 4d               LBB48     tsta                ; TEST EXPONENT OF FPA1
9356 : 2716                       beq  LBB61          ; PURGE RETURN ADDRESS &
9358 : 9b4f                       adda FP0EXP         ; ADD FPA1 EXPONENT TO F
935a : 46                         rora                ; ROTATE CARRY INTO BIT 
935b : 49                         rola                ; SET OVERFLOW FLAG
935c : 2810                       bvc  LBB61          ; BRANCH IF EXPONENT TOO
935e : 8b80                       adda #$80           ; ADD $80 BIAS TO EXPONE
9360 : 974f                       sta  FP0EXP         ; SAVE NEW EXPONENT
9362 : 270c                       beq  LBB63          ; SET FPA0
9364 : 9662                       lda  RESSGN         ; GET MANTISSA SIGN
9366 : 9754                       sta  FP0SGN         ; SAVE AS MANTISSA SIGN 
9368 : 39                         rts
                        * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0
AS09 Assembler for M6809 [1.42].                                     Page   82
--------------------------------- merge.a09 ----------------------------------

                        * = IS NEGATIVE THEN FPA0 = 0
9369 : 9654             LBB5C     lda  FP0SGN         ; GET MANTISSA SIGN OF F
936b : 43                         coma                ; CHANGE SIGN OF FPA0 MA
936c : 2002                       bra  LBB63
936e : 3262             LBB61     leas 2,s            ; PURGE RETURN ADDRESS F
9370 : 102afed2         LBB63     lbpl LBA39          ; ZERO FPA0 MANTISSA SIG
9374 : 7e929f           LBB67     jmp  LBA92          ; 'OV' OVERFLOW ERROR
                        * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0
9377 : bd946c           LBB6A     jsr  LBC5F          ; TRANSFER FPA0 TO FPA1
937a : 270d                       beq  LBB7C          ; BRANCH IF EXPONENT = 0
937c : 8b02                       adda #2             ; ADD 2 TO EXPONENT (TIM
937e : 25f4                       bcs  LBB67          ; 'OV' ERROR IF EXPONENT
9380 : 0f62                       clr  RESSGN         ; CLEAR RESULT SIGN BYTE
9382 : bd91da                     jsr  LB9CD          ; ADD FPA1 TO FPA0 (TIME
9385 : 0c4f                       inc  FP0EXP         ; ADD ONE TO EXPONENT (T
9387 : 27eb                       beq  LBB67          ; 'OV' ERROR IF EXPONENT
9389 : 39               LBB7C     rts
938a : 8420000000       LBB7D     fcb  $84,$20,$00,$00,$00 ; FLOATING POINT CO
                        * DIVIDE FPA0 BY 10
938f : bd946c           LBB82     jsr  LBC5F          ; MOVE FPA0 TO FPA1
9392 : 8e938a                     ldx  #LBB7D         ; POINT TO FLOATING POIN
9395 : 5f                         clrb                ; ZERO MANTISSA SIGN BYT
9396 : d762             LBB89     stb  RESSGN         ; STORE THE QUOTIENT MAN
9398 : bd9421                     jsr  LBC14          ; UNPACK AN FP NUMBER FR
939b : 8c                         fcb  SKP2           ; SKIP TWO BYTES
                        * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0
939c : 8d9e             LBB8F     bsr  LBB2F          ; GET FP NUMBER FROM (X)
                        
                        * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY 
                        * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY tsta)
                        
                        * DIVIDE FPA1 BY FPA0
939e : 2773             LBB91     beq  LBC06          ; '/0' DIVIDE BY ZERO ER
93a0 : 004f                       neg  FP0EXP         ; GET EXPONENT OF RECIPR
93a2 : 8db1                       bsr  LBB48          ; CALCULATE EXPONENT OF 
93a4 : 0c4f                       inc  FP0EXP         ; INCREMENT EXPONENT
93a6 : 27cc                       beq  LBB67          ; 'OV' OVERFLOW ERROR
93a8 : 8e0013                     ldx  #FPA2          ; POINT X TO MANTISSA OF
                        *                             ; TEMPORARY QUOTIENT IN 
93ab : c604                       ldb  #4             ; 5 BYTE DIVIDE
93ad : d703                       stb  TMPLOC         ; SAVE BYTE COUNTER
93af : c601                       ldb  #1             ; SHIFT COUNTER-AND TEMP
                        * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -
                        * SET CARRY FLAG IF FPA1 >= FPA0
93b1 : 9650             LBBA4     lda  FPA0           ; * COMPARE THE TWO MS B
93b3 : 915d                       cmpa FPA1           ; * OF FPA0 AND FPA1 AND
93b5 : 2613                       bne  LBBBD          ; * BRANCH IF <>
93b7 : 9651                       lda  FPA0+1         ; = COMPARE THE NUMBER 2
93b9 : 915e                       cmpa FPA1+1         ; = BYTES AND
93bb : 260d                       bne  LBBBD          ; = BRANCH IF <>
93bd : 9652                       lda  FPA0+2         ; * COMPARE THE NUMBER 3
93bf : 915f                       cmpa FPA1+2         ; * BYTES AND
93c1 : 2607                       bne  LBBBD          ; * BRANCH IF <>
93c3 : 9653                       lda  FPA0+3         ; = COMPARE THE LS BYTES
93c5 : 9160                       cmpa FPA1+3         ; = AND BRANCH
93c7 : 2601                       bne  LBBBD          ; = IF <>
93c9 : 43                         coma                ; SET CARRY FLAG IF FPA0
93ca : 1fa8             LBBBD     tfr  cc,a           ; SAVE CARRY FLAG STATUS
                        *         CLEAR IF FPA0 > FPA1
93cc : 59                         rolb                ; ROTATE CARRY INTO TEMP
93cd : 240a                       bcc  LBbcc          ; CARRY WILL BE SET AFTE
93cf : e780                       stb  ,x+            ; SAVE TEMPORARY QUOTIEN
AS09 Assembler for M6809 [1.42].                                     Page   83
--------------------------------- merge.a09 ----------------------------------

93d1 : 0a03                       dec  TMPLOC         ; DECREMENT BYTE COUNTER
93d3 : 2b34                       bmi  LBBFC          ; BRANCH IF DONE
93d5 : 272e                       beq  LBBF8          ; BRANCH IF LAST BYTE
93d7 : c601                       ldb  #1             ; RESET SHIFT COUNTER AN
93d9 : 1f8a             LBbcc     tfr  a,cc           ; RESTORE CARRY FLAG AND
93db : 250e                       bcs  LBBDE          ; BRANCH IF FPA0 =< FPA1
93dd : 0860             LBBD0     asl  FPA1+3         ; * SHIFT FPA1 MANTISSA 
93df : 095f                       rol  FPA1+2         ; *
93e1 : 095e                       rol  FPA1+1         ; *
93e3 : 095d                       rol  FPA1           ; *
93e5 : 25e3                       bcs  LBBBD          ; BRANCH IF CARRY - ADD 
93e7 : 2bc8                       bmi  LBBA4          ; IF MSB OF HIGH ORDER M
                        *         SET, CHECK THE MAGNITUDES OF FPA0, FPA1
93e9 : 20df                       bra  LBBBD          ; CARRY IS CLEAR, CHECK 
                        * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1
93eb : 9660             LBBDE     lda  FPA1+3         ; * SUBTRACT THE LS BYTE
93ed : 9053                       suba FPA0+3         ; *
93ef : 9760                       sta  FPA1+3         ; *
93f1 : 965f                       lda  FPA1+2         ; = THEN THE NEXT BYTE
93f3 : 9252                       sbca FPA0+2         ; =
93f5 : 975f                       sta  FPA1+2         ; =
93f7 : 965e                       lda  FPA1+1         ; * AND THE NEXT
93f9 : 9251                       sbca FPA0+1         ; *
93fb : 975e                       sta  FPA1+1         ; *
93fd : 965d                       lda  FPA1           ; = AND FINALLY, THE MS 
93ff : 9250                       sbca FPA0           ; =
9401 : 975d                       sta  FPA1           ; =
9403 : 20d8                       bra  LBBD0          ; GO SHIFT FPA1
9405 : c640             LBBF8     ldb  #$40           ; USE ONLY TWO BITS OF T
9407 : 20d0                       bra  LBbcc          ; GO SHIFT THE LAST BYTE
9409 : 56               LBBFC     rorb                ; * SHIFT CARRY (ALWAYS 
940a : 56                         rorb                ; * BIT 5 AND MOVE
940b : 56                         rorb                ; * BITS 1,0 TO BITS 7,6
940c : d763                       stb  FPSBYT         ; SAVE SUB BYTE
940e : 8d08                       bsr  LBC0B          ; MOVE MANTISSA OF FPA2 
9410 : 7e9229                     jmp  LBA1C          ; NORMALIZE FPA0
9413 : c614             LBC06     ldb  #2*10          ; /0' ERROR
9415 : 7e84af                     jmp  LAC46          ; PROCESS THE ERROR
                        * COPY MANTISSA FROM FPA2 TO FPA0
9418 : 9e13             LBC0B     ldx  FPA2           ; * MOVE TOP 2 BYTES
941a : 9f50                       stx  FPA0           ; *
941c : 9e15                       ldx  FPA2+2         ; = MOVE BOTTOM 2 BYTES
941e : 9f52                       stx  FPA0+2         ; =
9420 : 39                         rts
                        * COPY A PACKED FP NUMBER FROM (X) TO FPA0
9421 : 3402             LBC14     pshs a              ; SAVE ACCA
9423 : ec01                       ldd  1,x            ; GET TOP TWO MANTISSA B
9425 : 9754                       sta  FP0SGN         ; SAVE MS BYTE OF MANTIS
9427 : 8a80                       ora  #$80           ; UNPACK MS BYTE
9429 : dd50                       std  FPA0           ; SAVE UNPACKED TOP 2 MA
942b : 0f63                       clr  FPSBYT         ; CLEAR MANTISSA SUB BYT
942d : e684                       ldb  ,x             ; GET EXPONENT TO ACCB
942f : ae03                       ldx  3,x            ; * MOVE LAST 2
9431 : 9f52                       stx  FPA0+2         ; * MANTISSA BYTES
9433 : d74f                       stb  FP0EXP         ; SAVE EXPONENT
9435 : 3582                       puls a,pc           ; RESTORE ACCA AND RETUR
                        
9437 : 8e0045           LBC2A     ldx  #V45           ; POINT X TO MANTISSA OF
943a : 2006                       bra  LBC35          ; MOVE FPA0 TO FPA4
943c : 8e0040           LBC2F     ldx  #V40           ; POINT X TO MANTISSA OF
943f : 8c                         fcb  SKP2           ; SKIP TWO BYTES
9440 : 9e3b             LBC33     ldx  VARDES         ; POINT X TO VARIABLE DE
AS09 Assembler for M6809 [1.42].                                     Page   84
--------------------------------- merge.a09 ----------------------------------

                        * PACK FPA0 AND MOVE IT TO ADDRESS IN X
9442 : 964f             LBC35     lda  FP0EXP         ; * COPY EXPONENT
9444 : a784                       sta  ,x             ; *
9446 : 9654                       lda  FP0SGN         ; GET MANTISSA SIGN BIT
9448 : 8a7f                       ora  #$7F           ; MASK THE BOTTOM 7 BITS
944a : 9450                       anda FPA0           ; AND BIT 7 OF MANTISSA 
944c : a701                       sta  1,x            ; SAVE MS BYTE
944e : 9651                       lda  FPA0+1         ; * MOVE 2ND MANTISSA BY
9450 : a702                       sta  2,x            ; *
9452 : de52                       ldu  FPA0+2         ; = MOVE BOTTOM 2 MANTIS
9454 : ef03                       stu  3,x            ; =
9456 : 39                         rts
                        * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA
9457 : 9661             LBC4A     lda  FP1SGN         ; * COPY MANTISSA SIGN F
9459 : 9754             LBC4C     sta  FP0SGN         ; * FPA1 TO FPA0
945b : 9e5c                       ldx  FP1EXP         ; = COPY EXPONENT + MS B
945d : 9f4f                       stx  FP0EXP         ; = FPA1 TO FPA0
945f : 0f63                       clr  FPSBYT         ; CLEAR MANTISSA SUB BYT
9461 : 965e                       lda  FPA1+1         ; * COPY 2ND MANTISSA BY
9463 : 9751                       sta  FPA0+1         ; * FROM FPA1 TO FPA0
9465 : 9654                       lda  FP0SGN         ; GET MANTISSA SIGN
9467 : 9e5f                       ldx  FPA1+2         ; * COPY 3RD AND 4TH MAN
9469 : 9f52                       stx  FPA0+2         ; * FROM FPA1 TO FPA0
946b : 39                         rts
                        * TRANSFER FPA0 TO FPA1
946c : dc4f             LBC5F     ldd  FP0EXP         ; * TRANSFER EXPONENT & 
946e : dd5c                       std  FP1EXP         ; *
9470 : 9e51                       ldx  FPA0+1         ; = TRANSFER MIDDLE TWO 
9472 : 9f5e                       stx  FPA1+1         ; =
9474 : 9e53                       ldx  FPA0+3         ; * TRANSFER BOTTOM TWO 
9476 : 9f60                       stx  FPA1+3         ; *
9478 : 4d                         tsta                ; SET FLAGS ACCORDING TO
9479 : 39                         rts
                        * CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,
                        * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = PO
947a : d64f             LBC6D     ldb  FP0EXP         ; GET EXPONENT
947c : 2708                       beq  LBC79          ; BRANCH IF FPA0 = 0
947e : d654             LBC71     ldb  FP0SGN         ; GET SIGN OF MANTISSA
9480 : 59               LBC73     rolb                ; BIT 7 TO CARRY
9481 : c6ff                       ldb  #$FF           ; NEGATIVE FLAG
9483 : 2501                       bcs  LBC79          ; BRANCH IF NEGATIVE MAN
9485 : 50                         negb                ; ACCB = 1 IF POSITIVE M
9486 : 39               LBC79     rts
                        
                        * SGN
9487 : 8df1             SGN       bsr  LBC6D          ; SET ACCB ACCORDING TO 
                        * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POIN
9489 : d750             LBC7C     stb  FPA0           ; SAVE ACCB IN FPA0
948b : 0f51                       clr  FPA0+1         ; CLEAR NUMBER 2 MANTISS
948d : c688                       ldb  #$88           ; EXPONENT REQUIRED IF F
948f : 9650             LBC82     lda  FPA0           ; GET MS BYTE OF MANTISS
9491 : 8080                       suba #$80           ; SET CARRY IF POSITIVE 
9493 : d74f             LBC86     stb  FP0EXP         ; SAVE EXPONENT
9495 : dc74                       ldd  ZERO           ; * ZERO OUT ACCD AND
9497 : dd52                       std  FPA0+2         ; * BOTTOM HALF OF FPA0
9499 : 9763                       sta  FPSBYT         ; CLEAR SUB BYTE
949b : 9754                       sta  FP0SGN         ; CLEAR SIGN OF FPA0 MAN
949d : 7e9225                     jmp  LBA18          ; GO NORMALIZE FPA0
                        
                        * ABS
94a0 : 0f54             ABS       clr  FP0SGN         ; FORCE MANTISSA SIGN OF
94a2 : 39                         rts
AS09 Assembler for M6809 [1.42].                                     Page   85
--------------------------------- merge.a09 ----------------------------------

                        * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO
                        * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN
                        * ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF
                        * FPA0 > (X); ACCB = $FF IF FPA0 < (X)
94a3 : e684             LBC96     ldb  ,x             ; CHECK EXPONENT OF (X)
94a5 : 27d3                       beq  LBC6D          ; BRANCH IF FPA = 0
94a7 : e601                       ldb  1,x            ; GET MS BYTE OF MANTISS
94a9 : d854                       eorb FP0SGN         ; EOR WITH SIGN OF FPA0
94ab : 2bd1                       bmi  LBC71          ; BRANCH IF SIGNS NOT =
                        * COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).
                        * FPA0 IS NORMALIZEd, (X) IS PACKED.
94ad : d64f             LBCA0     ldb  FP0EXP         ; * GET EXPONENT OF
94af : e184                       cmpb ,x             ; * FPA0, COMPARE TO EXP
94b1 : 261d                       bne  LBCC3          ; * (X) AND BRANCH IF <>
94b3 : e601                       ldb  1,x            ; * GET MS BYTE OF (X), 
94b5 : ca7f                       orb  #$7F           ; * THE SIGN BIT - 'AND'
94b7 : d450                       andb FPA0           ; * BITS OF FPA0 INTO AC
94b9 : e101                       cmpb 1,x            ; = COMPARE THE BOTTOM 7
94bb : 2613                       bne  LBCC3          ; = MS BYTE AND BRANCH I
94bd : d651                       ldb  FPA0+1         ; * COMPARE 2ND BYTE
94bf : e102                       cmpb 2,x            ; * OF MANTISSa,
94c1 : 260d                       bne  LBCC3          ; * BRANCH IF <>
94c3 : d652                       ldb  FPA0+2         ; = COMPARE 3RD BYTE
94c5 : e103                       cmpb 3,x            ; = OF MANTISSa,
94c7 : 2607                       bne  LBCC3          ; = BRANCH IF <>
94c9 : d653                       ldb  FPA0+3         ; * SUBTRACT LS BYTE
94cb : e004                       subb 4,x            ; * OF (X) FROM LS BYTE 
94cd : 2601                       bne  LBCC3          ; * FPA0, BRANCH IF <>
94cf : 39                         rts                 ; RETURN IF FP (X) = FPA
94d0 : 56               LBCC3     rorb                ; SHIFT CARRY TO BIT 7; 
94d1 : d854                       eorb FP0SGN         ; TOGGLE SIZE COMPARISON
94d3 : 20ab                       bra  LBC73          ; GO SET ACCB ACCORDING 
                        * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BIN
                        * OF THE leasT SIGNIFICANT BYTE OF THE MANTISSA
94d5 : d64f             LBCC8     ldb  FP0EXP         ; GET EXPONENT OF FPA0
94d7 : 273d                       beq  LBD09          ; ZERO MANTISSA IF FPA0 
94d9 : c0a0                       subb #$A0           ; SUBTRACT $A0 FROM FPA0
                        *                             ; THE NUMBER OF SHIFTS R
                        *                             ; THE EXPONENT OF FPA0 I
                        *                             ; WILL BE TO THE RIGHT O
94db : 9654                       lda  FP0SGN         ; TEST SIGN OF FPA0 MANT
94dd : 2a05                       bpl  LBCD7          ; BRANCH IF POSITIVE
94df : 035b                       com  FPCARY         ; COMPLEMENT CARRY IN BY
94e1 : bd9288                     jsr  LBA7B          ; NEGATE MANTISSA OF FPA
94e4 : 8e004f           LBCD7     ldx  #FP0EXP        ; POINT X TO FPA0
94e7 : c1f8                       cmpb #-8            ; EXPONENT DIFFERENCE < 
94e9 : 2e06                       bgt  LBCE4          ; YES
94eb : bd92bb                     jsr  LBAAE          ; SHIFT FPA0 RIGHT UNTIL
94ee : 0f5b                       clr  FPCARY         ; CLEAR CARRY IN BYTE
94f0 : 39                         rts
94f1 : 0f5b             LBCE4     clr  FPCARY         ; CLEAR CARRY IN BYTE
94f3 : 9654                       lda  FP0SGN         ; * GET SIGN OF FPA0 MAN
94f5 : 49                         rola                ; * ROTATE IT INTO THE C
94f6 : 0650                       ror  FPA0           ; ROTATE CARRY (MANTISSA
                        *                             ; OF LS BYTE OF MANTISSA
94f8 : 7e92c7                     jmp  LBABA          ; DE-NORMALIZE FPA0
                        
                        * INT
                        * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS 
                        * TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EX
                        * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE F
                        * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUS
AS09 Assembler for M6809 [1.42].                                     Page   86
--------------------------------- merge.a09 ----------------------------------

                        * ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.
                        *
94fb : d64f             INT       ldb  FP0EXP         ; GET EXPONENT OF FPA0
94fd : c1a0                       cmpb #$A0           ; LARGEST POSSIBLE INTEG
94ff : 241d                       bcc  LBD11          ; RETURN IF FPA0 >= 3276
9501 : 8dd2                       bsr  LBCC8          ; SHIFT THE BINARY POINT
                        *                             ; LS BYTE OF THE FPA0 MA
9503 : d763                       stb  FPSBYT         ; ACCB = 0: ZERO OUT THE
9505 : 9654                       lda  FP0SGN         ; GET MANTISSA SIGN
9507 : d754                       stb  FP0SGN         ; FORCE MANTISSA SIGN TO
9509 : 8080                       suba #$80           ; SET CARRY IF MANTISSA
950b : 86a0                       lda  #$A0           ; * GET DENORMALIZED EXP
950d : 974f                       sta  FP0EXP         ; * SAVE IT IN FPA0 EXPO
950f : 9653                       lda  FPA0+3         ; = GET LS BYTE OF FPA0 
9511 : 9701                       sta  CHARAC         ; = SAVE IT IN CHARAC
9513 : 7e9225                     jmp  LBA18          ; NORMALIZE FPA0
                        
9516 : d750             LBD09     stb  FPA0           ; * LOAD MANTISSA OF FPA
9518 : d751                       stb  FPA0+1         ; *
951a : d752                       stb  FPA0+2         ; *
951c : d753                       stb  FPA0+3         ; *
951e : 39               LBD11     rts                 ; *
                        
                        * CONVERT ASCII STRING TO FLOATING POINT
951f : 9e74             LBD12     ldx  ZERO           ; (X) = 0
9521 : 9f54                       stx  FP0SGN         ; * ZERO OUT FPA0 & THE 
9523 : 9f4f                       stx  FP0EXP         ; *
9525 : 9f51                       stx  FPA0+1         ; *
9527 : 9f52                       stx  FPA0+2         ; *
9529 : 9f47                       stx  V47            ; INITIALIZE EXPONENT & 
952b : 9f45                       stx  V45            ; INITIALIZE RIGHT DECIM
952d : 2564                       bcs  LBD86          ; IF CARRY SET (NUMERIC 
                        *         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE 
952f : bd9c58                     jsr  XVEC19         ; CALL EXTENDED BASIC AD
9532 : 812d             LBD25     cmpa #'-'           ; * CHECK FOR A LEADING 
9534 : 2604                       bne  LBD2D          ; * IF NO MINUS SIGN
9536 : 0355                       com  COEFCT         ; TOGGLE SIGN; 0 = +; FF
9538 : 2004                       bra  LBD31          ; INTERPRET THE REST OF 
953a : 812b             LBD2D     cmpa #'+'           ; * CHECK FOR LEADING PL
953c : 2604                       bne  LBD35          ; * IF NOT A PLUS SIGN
953e : 9d7c             LBD31     jsr  GETNCH         ; GET NEXT INPUT CHARACT
9540 : 2551                       bcs  LBD86          ; BRANCH IF NUMERIC CHAR
9542 : 812e             LBD35     cmpa #'.'           ; DECIMAL POlNT?
9544 : 2728                       beq  LBD61          ; YES
9546 : 8145                       cmpa #'E'           ; "E" SHORTHAND FORM (SC
9548 : 2628                       bne  LBD65          ; NO
                        * EVALUATE EXPONENT OF EXPONENTIAL FORMAT
954a : 9d7c                       jsr  GETNCH         ; GET NEXT INPUT CHARACT
954c : 2564                       bcs  LBDA5          ; BRANCH IF NUMERIC
954e : 81ae                       cmpa #TOK_MINUS     ; MINUS TOKEN?
9550 : 270e                       beq  LBD53          ; YES
9552 : 812d                       cmpa #'-'           ; ASCII MINUS?
9554 : 270a                       beq  LBD53          ; YES
9556 : 81ad                       cmpa #TOK_PLUS      ; PLUS TOKEN?
9558 : 2708                       beq  LBD55          ; YES
955a : 812b                       cmpa #'+'           ; ASCII PLUS?
955c : 2704                       beq  LBD55          ; YES
955e : 2006                       bra  LBD59          ; BRANCH IF NO SIGN FOUN
9560 : 0348             LBD53     com  V48            ; SET EXPONENT SIGN FLAG
                        * STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT T
9562 : 9d7c             LBD55     jsr  GETNCH         ; GET NEXT INPUT CHARACT
9564 : 254c                       bcs  LBDA5          ; IF NUMERIC CHARACTER, 
AS09 Assembler for M6809 [1.42].                                     Page   87
--------------------------------- merge.a09 ----------------------------------

9566 : 0d48             LBD59     tst  V48            ; * CHECK EXPONENT SIGN 
9568 : 2708                       beq  LBD65          ; * AND BRANCH IF POSITI
956a : 0047                       neg  V47            ; NEGATE VALUE OF EXPONE
956c : 2004                       bra  LBD65
956e : 0346             LBD61     com  V46            ; *TOGGLE DECIMAL PT FLA
9570 : 26cc                       bne  LBD31          ; *CHARACTER IF <> 0 - T
                        *         IF   SECOND DECIMAL POINT
                        * ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47
9572 : 9647             LBD65     lda  V47            ; * GET EXPONENT, SUBTRA
9574 : 9045                       suba V45            ; * PLACES TO THE RIGHT 
9576 : 9747                       sta  V47            ; * AND RESAVE IT.
9578 : 2712                       beq  LBD7F          ; EXIT ROUTINE IF ADJUST
957a : 2a09                       bpl  LBD78          ; BRANCH IF POSITIVE EXP
957c : bd938f           LBD6F     jsr  LBB82          ; DIVIDE FPA0 BY 10
957f : 0c47                       inc  V47            ; INCREMENT EXPONENT COU
9581 : 26f9                       bne  LBD6F          ; KEEP MULTIPLYING
9583 : 2007                       bra  LBD7F          ; EXIT ROUTINE
9585 : bd9377           LBD78     jsr  LBB6A          ; MULTIPLY FPA0 BY 10
9588 : 0a47                       dec  V47            ; DECREMENT EXPONENT COU
958a : 26f9                       bne  LBD78          ; KEEP MULTIPLYING
958c : 9655             LBD7F     lda  COEFCT         ; GET THE SIGN FLAG
958e : 2a8e                       lbpl  LBD11         ; RETURN IF POSITIVE
9590 : 7e96f6                     jmp  LBEE9          ; TOGGLE MANTISSA SIGN O
                        *MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT
9593 : d645             LBD86     ldb  V45            ; *GET THE RIGHT DECIMAL
9595 : d046                       subb V46            ; *THE DECIMAL POINT FLA
9597 : d745                       stb  V45            ; *FLAG=0, NOTHING HAPPE
                        *                             -1, THEN RIGHT DECIMAL C
9599 : 3402                       pshs a              ; SAVE NEW DIGIT ON STAC
959b : bd9377                     jsr  LBB6A          ; MULTIPLY FPA0 BY 10
959e : 3504                       puls b              ; GET NEW DIGIT BACK
95a0 : c030                       subb #'0'            ; MASK OFF ASCII
95a2 : 8d02                       bsr  LBD99          ; ADD ACCB TO FPA0
95a4 : 2098                       bra  LBD31          ; GET ANOTHER CHARACTER 
95a6 : bd943c           LBD99     jsr  LBC2F          ; PACK FPA0 AND SAVE IT 
95a9 : bd9489                     jsr  LBC7C          ; CONVERT ACCB TO FP NUM
95ac : 8e0040                     ldx  #V40           ; * ADD FPA0 TO
95af : 7e91cf                     jmp  LB9C2          ; * FPA3
                        
                        
95b2 : d647             LBDA5     ldb  V47
95b4 : 58                         aslb                ; TIMES 2
95b5 : 58                         aslb                ; TIMES 4
95b6 : db47                       addb V47            ; ADD 1 = TIMES 5
95b8 : 58                         aslb                ; TIMES 10
95b9 : 8030                       suba #'0'            ; *MASK OFF ASCII FROM 
95bb : 3404                       pshs b              ; *RESULT ONTO THE STACK
95bd : abe0                       adda ,s+            ; ADD lT TO ACCB
95bf : 9747                       sta  V47            ; SAVE IN V47
95c1 : 209f                       bra  LBD55          ; INTERPRET ANOTHER CHAR
                        *
95c3 : 9b3ebc1ffd       LBDB6     fcb  $9b,$3E,$BC,$1F,$FD ; * 99999999.9
95c8 : 9e6e6b27fd       LBDBB     fcb  $9E,$6E,$6b,$27,$FD ; * 999999999
95cd : 9e6e6b2800       LBDC0     fcb  $9E,$6E,$6b,$28,$00 ; * 1E + 09
                        *
95d2 : 8e8450           LBDC5     ldx  #LABE8-1       ; POINT X TO " IN " MESS
95d5 : 8d0c                       bsr  LBDD6          ; COPY A STRING FROM (X)
95d7 : dc68                       ldd  CURLIN         ; GET CURRENT BASIC LINE
                        * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER AND PRIN
95d9 : dd50             LBDCC     std  FPA0           ; SAVE ACCD IN TOP HALF 
95db : c690                       ldb  #$90           ; REQ'D EXPONENT IF TOP 
95dd : 43                         coma                ; SET CARRY FLAG - FORCE
AS09 Assembler for M6809 [1.42].                                     Page   88
--------------------------------- merge.a09 ----------------------------------

95de : bd9493                     jsr  LBC86          ; ZERO BOTTOM HALF AND S
95e1 : 8d03                       bsr  LBDD9          ; CONVERT FP NUMBER TO A
95e3 : 7e91a9           LBDD6     jmp  LB99C          ; COPY A STRING FROM (X)
                        
                        * CONVERT FP NUMBER TO ASCII STRING
95e6 : ce01df           LBDD9     ldu  #STRBUF+3      ; POINT U TO BUFFER WHIC
                        *                             ; THE STRING TO BE STORE
95e9 : 8620             LBDDC     lda  #SPACE         ; SPACE = DEFAULT SIGN F
95eb : d654                       ldb  FP0SGN         ; GET SIGN OF FPA0
95ed : 2a02                       bpl  LBDE4          ; BRANCH IF POSITIVE
95ef : 862d                       lda  #'-'           ; ASCII MINUS SIGN
95f1 : a7c0             LBDE4     sta  ,u+            ; STORE SIGN OF NUMBER
95f3 : df64                       stu  COEFPT         ; SAVE BUFFER POINTER
95f5 : 9754                       sta  FP0SGN         ; SAVE SIGN (IN ASCII)
95f7 : 8630                       lda  #'0'            ; ASCII ZERO IF EXPONEN
95f9 : d64f                       ldb  FP0EXP         ; GET FPA0 EXPONENT
95fb : 102700c6                   lbeq LBEB8          ; BRANCH IF FPA0 = 0
95ff : 4f                         clra                ; BASE 10 EXPONENT=0 FOR
9600 : c180                       cmpb #$80           ; CHECK EXPONENT
9602 : 2208                       bhi  LBDFF          ; BRANCH IF FP NUMBER > 
                        * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE 
9604 : 8e95cd                     ldx  #LBDC0         ; POINT X TO FP 1E+09
9607 : bd92d7                     jsr  LBACA          ; MULTIPLY FPA0 BY (X)
960a : 86f7                       lda  #-9            ; BASE 10 EXPONENT = -9
960c : 9745             LBDFF     sta  V45            ; BASE 10 EXPONENT
                        * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE R
                        * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST
                        * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE
                        * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING
                        * SCIENTIFIC NOTATION
960e : 8e95c8           LBE01     ldx  #LBDBB         ; POINT X TO FP 999,999,
9611 : bd94ad                     jsr  LBCA0          ; COMPARE FPA0 TO 999,99
9614 : 2e0f                       bgt  LBE18          ; BRANCH IF > 999,999,99
9616 : 8e95c3           LBE09     ldx  #LBDB6         ; POINT X TO FP 99,999,9
9619 : bd94ad                     jsr  LBCA0          ; COMPARE FPA0 TO 99,999
961c : 2e0e                       bgt  LBE1F          ; BRANCH IF > 99,999,999
961e : bd9377                     jsr  LBB6A          ; MULTIPLY FPA0 BY 10
9621 : 0a45                       dec  V45            ; SUBTRACT ONE FROM DECI
9623 : 20f1                       bra  LBE09          ; PSEUDO - NORMALIZE SOM
9625 : bd938f           LBE18     jsr  LBB82          ; DIVIDE FPA0 BY 10
9628 : 0c45                       inc  V45            ; ADD ONE TO BASE 10 EXP
962a : 20e2                       bra  LBE01          ; PSEUDO - NORMALIZE SOM
962c : bd91c1           LBE1F     jsr  LB9B4          ; ADD .5 TO FPA0 (ROUND 
962f : bd94d5                     jsr  LBCC8          ; CONVERT FPA0 TO AN INT
9632 : c601                       ldb  #1             ; DEFAULT DECIMAL POINT 
9634 : 9645                       lda  V45            ; * GET BASE 10 EXPONENT
9636 : 8b0a                       adda #9+1           ; * (NUMBER 'NORMALIZED'
9638 : 2b09                       bmi  LBE36          ; BRANCH IF NUMBER < 1.0
963a : 810b                       cmpa #9+2           ; NINE PLACES MAY BE DIS
                        *         USING SCIENTIFIC NOTATION
963c : 2405                       bcc  LBE36          ; BRANCH IF SCIENTIFIC N
963e : 4a                         deca                ; * SUBTRACT 1 FROM MODI
963f : 1f89                       tfr  a,b            ; * AND SAVE IT IN ACCB 
9641 : 8602                       lda  #2             ; FORCE EXPONENT = 0 - D
9643 : 4a               LBE36     deca                ; * SUBTRACT TWO (WITHOU
9644 : 4a                         deca                ; * FROM BASE 10 EXPONEN
9645 : 9747                       sta  V47            ; SAVE EXPONENT - ZERO E
                        *         IN   SCIENTIFIC NOTATION
9647 : d745                       stb  V45            ; DECIMAL POINT FLAG - N
                        *         LEFT OF DECIMAL POINT
9649 : 2e0d                       bgt  LBE4B          ; BRANCH IF >= 1
964b : de64                       ldu  COEFPT         ; POINT U TO THE STRING 
AS09 Assembler for M6809 [1.42].                                     Page   89
--------------------------------- merge.a09 ----------------------------------

964d : 862e                       lda  #'.'           ; * STORE A PERIOD
964f : a7c0                       sta  ,u+            ; * IN THE BUFFER
9651 : 5d                         tstb                ; CHECK DECIMAL POINT FL
9652 : 2704                       beq  LBE4B          ; BRANCH IF NOTHING TO L
9654 : 8630                       lda  #'0'            ; * STORE A ZERO
9656 : a7c0                       sta  ,u+            ; * IN THE BUFFER
                        
                        * CONVERT FPA0 INTO A STRING OF ASCII DIGITS
9658 : 8e96d2           LBE4B     ldx  #LBEC5         ; POINT X TO FP POWER OF
965b : c680                       ldb  #0+$80         ; INITIALIZE DIGIT COUNT
                        * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 M
                        * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT 
                        * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF 
                        * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.
965d : 9653             LBE50     lda  FPA0+3         ; * ADD MANTISSA LS
965f : ab03                       adda 3,x            ; * BYTE OF FPA0
9661 : 9753                       sta  FPA0+3         ; * AND (X)
9663 : 9652                       lda  FPA0+2         ; = ADD MANTISSA
9665 : a902                       adca 2,x            ; = NUMBER 3 BYTE OF
9667 : 9752                       sta  FPA0+2         ; = FPA0 AND (X)
9669 : 9651                       lda  FPA0+1         ; * ADD MANTISSA
966b : a901                       adca 1,x            ; * NUMBER 2 BYTE OF
966d : 9751                       sta  FPA0+1         ; * FPA0 AND (X)
966f : 9650                       lda  FPA0           ; = ADD MANTISSA
9671 : a984                       adca ,x             ; = MS BYTE OF
9673 : 9750                       sta  FPA0           ; = FPA0 AND (X)
9675 : 5c                         incb                ; ADD ONE TO DIGIT COUNT
9676 : 56                         rorb                ; ROTATE CARRY INTO BIT 
9677 : 59                         rolb                ; *SET OVERFLOW FLAG AND
9678 : 28e3                       bvc  LBE50          ; *POSITIVE MANTISSA OR 
967a : 2403                       bcc  LBE72          ; BRANCH IF NEGATIVE MAN
967c : c00b                       subb #10+1          ; * TAKE THE 9'S COMPLEM
967e : 50                         negb                ; * ADDING MANTISSA
967f : cb2f             LBE72     addb #'0'-1          ; ADD ASCII OFFSET TO D
9681 : 3004                       leax 4,x            ; MOVE TO NEXT POWER OF 
9683 : 1f98                       tfr  b,a            ; SAVE DIGIT IN ACCA
9685 : 847f                       anda #$7F           ; MASK OFF BIT 7 (ADD/SU
9687 : a7c0                       sta  ,u+            ; STORE DIGIT IN STRING 
9689 : 0a45                       dec  V45            ; DECREMENT DECIMAL POIN
968b : 2604                       bne  LBE84          ; BRANCH IF NOT TIME FOR
968d : 862e                       lda  #'.'           ; * STORE DECIMAL POINT 
968f : a7c0                       sta  ,u+            ; * STRING BUFFER
9691 : 53               LBE84     comb                ; TOGGLE BIT 7 (ADD/SUBT
9692 : c480                       andb #$80           ; MASK OFF ALL BUT ADD/S
9694 : 8c96f6                     cmpx #LBEC5+36      ; COMPARE X TO END OF MA
9697 : 26c4                       bne  LBE50          ; BRANCH IF NOT AT END O
                        * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY
9699 : a6c2             LBE8C     lda  ,-u            ; GET THE LAST CHARACTER
969b : 8130                       cmpa #'0'            ; WAS IT A ZERO?
969d : 27fa                       beq  LBE8C          ; IGNORE TRAILING ZEROS 
969f : 812e                       cmpa #'.'           ; CHECK FOR DECIMAL POIN
96a1 : 2602                       bne  LBE98          ; BRANCH IF NOT DECIMAL 
96a3 : 335f                       leau -1,u           ; STEP OVER THE DECIMAL 
96a5 : 862b             LBE98     lda  #'+'           ; ASCII PLUS SIGN
96a7 : d647                       ldb  V47            ; GET SCIENTIFIC NOTATIO
96a9 : 271c                       beq  LBEBA          ; BRANCH IF NOT SCIENTIF
96ab : 2a03                       bpl  LBEA3          ; BRANCH IF POSITIVE EXP
96ad : 862d                       lda  #'-'           ; ASCII MINUS SIGN
96af : 50                         negb                ; NEGATE EXPONENT IF NEG
96b0 : a742             LBEA3     sta  2,u            ; STORE EXPONENT SIGN IN
96b2 : 8645                       lda  #'E'           ; * GET ASCII 'E' (SCIEN
96b4 : a741                       sta  1,u            ; * FLAG) AND SAVE IT IN
AS09 Assembler for M6809 [1.42].                                     Page   90
--------------------------------- merge.a09 ----------------------------------

96b6 : 862f                       lda  #'0'-1          ; INITIALIZE ACCA TO AS
                        
                        
96b8 : 4c               LBEAB     inca                ; ADD ONE TO 10'S DIGIT 
96b9 : c00a                       subb #10            ; SUBTRACT 10 FROM ACCB
96bb : 24fb                       bcc  LBEAB          ; ADD 1 TO 10'S DIGIT IF
96bd : cb3a                       addb #'9'+1         ; CONVERT UNITS DIGIT TO
96bf : ed43                       std  3,u            ; SAVE EXPONENT IN STRIN
96c1 : 6f45                       clr  5,u            ; CLEAR LAST BYTE (TERMI
96c3 : 2004                       bra  LBEBC          ; GO RESET POINTER
96c5 : a7c4             LBEB8     sta  ,u             ; STORE LAST CHARACTER
96c7 : 6f41             LBEBA     clr  1,u            ; CLEAR LAST BYTE (TERMI
                        *         PRINT SUBROUTINES)
96c9 : 8e01df           LBEBC     ldx  #STRBUF+3      ; RESET POINTER TO START
96cc : 39                         rts
                        *
96cd : 8000000000       LBEC0     fcb  $80,$00,$00,$00,$00 ; FLOATING POINT .5
                        *
                        *** TABLE OF UNNORMALIZED POWERS OF 10
96d2 : fa0a1f00         LBEC5     fcb  $Fa,$0a,$1F,$00 ; -100000000
96d6 : 00989680         LBEC9     fcb  $00,$98,$96,$80 ; 10000000
96da : fff0bdc0         LBECD     fcb  $FF,$F0,$Bd,$C0 ; -1000000
96de : 000186a0         LBED1     fcb  $00,$01,$86,$A0 ; 100000
96e2 : ffffd8f0         LBED5     fcb  $FF,$FF,$D8,$F0 ; -10000
96e6 : 000003e8         LBED9     fcb  $00,$00,$03,$E8 ; 1000
96ea : ffffff9c         LBEDD     fcb  $FF,$FF,$FF,$9C ; -100
96ee : 0000000a         LBEE1     fcb  $00,$00,$00,$0A ; 10
96f2 : ffffffff         LBEE5     fcb  $FF,$FF,$FF,$FF ; -1
                        *
                        *
96f6 : 964f             LBEE9     lda  FP0EXP         ; GET EXPONENT OF FPA0
96f8 : 2702                       beq  LBEEF          ; BRANCH IF FPA0 = 0
96fa : 0354                       com  FP0SGN         ; TOGGLE MANTISSA SIGN O
96fc : 39               LBEEF     rts
                        * EXPAND A POLYNOMIAL OF THE FORM
                        * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0
                        * AND THE X REGISTER POINTS TO A TABLE OF
                        * COEFFICIENTS A,B,C,D....
96fd : 9f64             LBEF0     stx  COEFPT         ; SAVE COEFFICIENT TABLE
96ff : bd943c                     jsr  LBC2F          ; MOVE FPA0 TO FPA3
9702 : 8d05                       bsr  LBEFC          ; MULTIPLY FPA3 BY FPA0
9704 : 8d08                       bsr  LBF01          ; EXPAND POLYNOMIAL
9706 : 8e0040                     ldx  #V40           ; POINT X TO FPA3
9709 : 7e92d7           LBEFC     jmp  LBACA          ; MULTIPLY (X) BY FPA0
                        
                        * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
                        * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
                        * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
                        * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
                        * OF PACKED FLOATING POINT NUMBERS. THE
                        * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
                        * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0...YN)
970c : 9f64             LBEFF     stx  COEFPT         ; SAVE COEFFICIENT TABLE
970e : bd9437           LBF01     jsr  LBC2A          ; MOVE FPA0 TO FPA4
9711 : 9e64                       ldx  COEFPT         ; GET THE COEFFICIENT PO
9713 : e680                       ldb  ,x+            ; GET THE TOP OF COEFFIC
9715 : d755                       stb  COEFCT         ; * USE AND STORE IT IN 
9717 : 9f64                       stx  COEFPT         ; SAVE NEW COEFFICIENT P
9719 : 8dee             LBF0C     bsr  LBEFC          ; MULTIPLY (X) BY FPA0
971b : 9e64                       ldx  COEFPT         ; *GET COEFFICIENT POINT
971d : 3005                       leax 5,x            ; *MOVE TO NEXT FP NUMBE
971f : 9f64                       stx  COEFPT         ; *SAVE NEW COEFFICIENT 
AS09 Assembler for M6809 [1.42].                                     Page   91
--------------------------------- merge.a09 ----------------------------------

9721 : bd91cf                     jsr  LB9C2          ; ADD (X) AND FPA0
9724 : 8e0045                     ldx  #V45           ; POINT (X) TO FPA4
9727 : 0a55                       dec  COEFCT         ; DECREMENT TEMP COUNTER
9729 : 26ee                       bne  LBF0C          ; BRANCH IF MORE COEFFIC
972b : 39                         rts
                        
                        * RND
972c : bd947a           RND       jsr  LBC6D          ; TEST FPA0
972f : 2b1f                       bmi  LBF45          ; BRANCH IF FPA0 = NEGAT
9731 : 2715                       beq  LBF3B          ; BRANCH IF FPA0 = 0
9733 : 8d10                       bsr  LBF38          ; CONVERT FPA0 TO AN INT
9735 : bd943c                     jsr  LBC2F          ; PACK FPA0 TO FPA3
9738 : 8d0e                       bsr  LBF3B          ; GET A RANDOM NUMBER: F
973a : 8e0040                     ldx  #V40           ; POINT (X) TO FPA3
973d : 8dca                       bsr  LBEFC          ; MULTIPLY (X) BY FPA0
973f : 8e92d2                     ldx  #LBAC5         ; POINT (X) TO FP VALUE 
9742 : bd91cf                     jsr  LB9C2          ; ADD 1.0 TO FPA0
9745 : 7e94fb           LBF38     jmp  INT            ; CONVERT FPA0 TO AN INT
                        * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.
9748 : 9e9f             LBF3B     ldx  RVSEED+1       ; * MOVE VARIABLE
974a : 9f50                       stx  FPA0           ; * RANDOM NUMBER
974c : 9ea1                       ldx  RVSEED+3       ; * SEED TO
974e : 9f52                       stx  FPA0+2         ; * FPA0
9750 : be977d           LBF45     ldx  RSEED          ; = MOVE FIXED
9753 : 9f5d                       stx  FPA1           ; = RANDOM NUMBER
9755 : be977f                     ldx  RSEED+2        ; = SEED TO
9758 : 9f5f                       stx  FPA1+2         ; = MANTISSA OF FPA0
975a : bd92dd                     jsr  LBAD0          ; MULTIPLY FPA0 X FPA1
975d : dc8a                       ldd  VAD            ; GET THE TWO LOWEST ORD
975f : c3658b                     addd #$658B         ; ADD A CONSTANT
9762 : dda1                       std  RVSEED+3       ; SAVE NEW LOW ORDER VAR
9764 : dd52                       std  FPA0+2         ; SAVE NEW LOW ORDER BYT
9766 : dc88                       ldd  VAB            ; GET 2 MORE LOW ORDER P
9768 : c9b0                       adcb #$B0           ; ADD A CONSTANT
976a : 8905                       adca #5             ; ADD A CONSTANT
976c : dd9f                       std  RVSEED+1       ; SAVE NEW HIGH ORDER VA
976e : dd50                       std  FPA0           ; SAVE NEW HIGH ORDER FP
9770 : 0f54                       clr  FP0SGN         ; FORCE FPA0 MANTISSA = 
9772 : 8680                       lda  #$80           ; * SET FPA0 BIASED EXPO
9774 : 974f                       sta  FP0EXP         ; * TO 0 1 < FPA0 < 0
9776 : 9615                       lda  FPA2+2         ; GET A BYTE FROM FPA2 (
9778 : 9763                       sta  FPSBYT         ; SAVE AS SUB BYTE
977a : 7e9229                     jmp  LBA1C          ; NORMALIZE FPA0
                        *
977d : 40e6             RSEED     fdb  $40E6          ; *CONSTANT RANDOM NUMBE
977f : 4dab                       fdb  $4DAB          ; *
                        
                        * SIN
                        * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND
                        * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ON
                        * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, TH
                        * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.
                        
                        * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES 
                        * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)
9781 : bd946c           SIN       jsr  LBC5F          ; COPY FPA0 TO FPA1
9784 : 8e97c6                     ldx  #LBFBD         ; POINT (X) TO 2*PI
9787 : d661                       ldb  FP1SGN         ; *GET MANTISSA SIGN OF 
9789 : bd9396                     jsr  LBB89          ; *AND DIVIDE FPA0 BY 2*
978c : bd946c                     jsr  LBC5F          ; COPY FPA0 TO FPA1
978f : 8db4                       bsr  LBF38          ; CONVERT FPA0 TO AN INT
9791 : 0f62                       clr  RESSGN         ; SET RESULT SIGN = POSI
AS09 Assembler for M6809 [1.42].                                     Page   92
--------------------------------- merge.a09 ----------------------------------

9793 : 965c                       lda  FP1EXP         ; *GET EXPONENT OF FPA1
9795 : d64f                       ldb  FP0EXP         ; *GET EXPONENT OF FPA0
9797 : bd91c9                     jsr  LB9BC          ; *SUBTRACT FPA0 FROM FP
                        * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUME
979a : 8e97cb                     ldx  #LBFC2         ; POINT X TO FP (.25)
979d : bd91c6                     jsr  LB9B9          ; SUBTRACT FPA0 FROM .25
97a0 : 9654                       lda  FP0SGN         ; GET MANTISSA SIGN OF F
97a2 : 3402                       pshs a              ; SAVE IT ON STACK
97a4 : 2a09                       bpl  LBFA6          ; BRANCH IF MANTISSA POS
97a6 : bd91c1                     jsr  LB9B4          ; ADD .5 (PI) TO FPA0
97a9 : 9654                       lda  FP0SGN         ; GET SIGN OF FPA0
97ab : 2b05                       bmi  LBFA9          ; BRANCH IF NEGATIVE
97ad : 030a                       com  RELFLG         ; com IF +(3*PI)/2 >= AR
97af : bd96f6           LBFA6     jsr  LBEE9          ; TOGGLE MANTISSA SIGN O
97b2 : 8e97cb           LBFA9     ldx  #LBFC2         ; POINT X TO FP (.25)
97b5 : bd91cf                     jsr  LB9C2          ; ADD .25 (PI/2) TO FPA0
97b8 : 3502                       puls a              ; GET OLD MANTISSA SIGN
97ba : 4d                         tsta                ; * BRANCH IF OLD
97bb : 2a03                       bpl  LBFB7          ; * SIGN WAS POSITIVE
97bd : bd96f6                     jsr  LBEE9          ; TOGGLE MANTISSA SIGN
97c0 : 8e97d0           LBFB7     ldx  #LBFC7         ; POINT X TO TABLE OF CO
97c3 : 7e96fd                     jmp  LBEF0          ; GO CALCULATE POLYNOMIA
                        
97c6 : 83490fdaa2       LBFBD     fcb  $83,$49,$0F,$Da,$A2 ; 6.28318531 (2*PI)
97cb : 7f00000000       LBFC2     fcb  $7F,$00,$00,$00,$00 ; .25
                        
                        
97d0 : 05               LBFC7     fcb  6-1            ; SIX COEFFICIENTS
97d1 : 84e61a2d1b       LBFC8     fcb  $84,$E6,$1a,$2d,$1B ; * -((2*PI)**11)/1
97d6 : 862807fbf8       LBFCD     fcb  $86,$28,$07,$Fb,$F8 ; * ((2*PI)**9)/9!
97db : 8799688901       LBFD2     fcb  $87,$99,$68,$89,$01 ; * -((2*PI)**7)/7!
97e0 : 872335dfe1       LBFD7     fcb  $87,$23,$35,$DF,$E1 ; * ((2*PI)**5)/5!
97e5 : 86a55de728       LBFDC     fcb  $86,$A5,$5d,$E7,$28 ; * -((2*PI)**3)/3!
97ea : 83490fdaa2       LBFE1     fcb  $83,$49,$0F,$Da,$A2 ; *
                        
97ef : a154468f13                 fcb  $A1,$54,$46,$8F,$13 ; UNUSED GARBAGE BY
97f4 : 8f524389cd                 fcb  $8F,$52,$43,$89,$CD ; UNUSED GARBAGE BY
                        * EXTENDED BASIC
                        
                        * COS
                        * THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTI
97f9 : 8e982a           COS       ldx  #L83AB         ; POINT X TO FP CONSTANT
97fc : bd91cf                     jsr  LB9C2          ; ADD FPA0 TO (X)
97ff : 2080             L837E     jmp  SIN            ; JUMP TO SIN ROUTINE
                        
                        * TAN
                        * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTI
9801 : bd943c           TAN       jsr  LBC2F          ; PACK FPA0 AND MOVE IT 
9804 : 0f0a                       clr  RELFLG         ; RESET QUADRANT FLAG
9806 : 8df7                       bsr  L837E          ; CALCULATE SIN OF ARGUM
9808 : 8e004a                     ldx  #V4A           ; POINT X TO FPA5
980b : bd9442                     jsr  LBC35          ; PACK FPA0 AND MOVE IT 
980e : 8e0040                     ldx  #V40           ; POINT X TO FPA3
9811 : bd9421                     jsr  LBC14          ; MOVE FPA3 TO FPA0
9814 : 0f54                       clr  FP0SGN         ; FORCE FPA0 MANTISSA TO
9816 : 960a                       lda  RELFLG         ; GET THE QUADRANT FLAG 
9818 : 8d0c                       bsr  L83A6          ; CALCULATE VALUE OF COS
981a : 0d4f                       tst  FP0EXP         ; CHECK EXPONENT OF FPA0
981c : 1027fa7f                   beq  LBA92          ; 'OV' ERROR IF COS(X)=0
9820 : 8e004a                     ldx  #V4A           ; POINT X TO FPA5
9823 : 7e939c           L83A3     jmp  LBB8F          ; DIVIDE (X) BY FPA0 - S
9826 : 3402             L83A6     pshs a              ; SAVE SIGN FLAG ON STAC
AS09 Assembler for M6809 [1.42].                                     Page   93
--------------------------------- merge.a09 ----------------------------------

9828 : 2085                       jmp  LBFA6          ; EXPAND POLYNOMIAL
                        
982a : 81490fdaa2       L83AB     fcb  $81,$49,$0F,$Da,$A2 ; 1.57079633 (PI/2)
                        
                        * ATN
                        * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE
                        * ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED
                        * TO EVALUATE THE EXPRESSION DEPENDING UPON
                        * WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0
                        
                        * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .
                        * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5
                        
982f : 9654             ATN       lda  FP0SGN         ; * GET THE SIGN OF THE 
9831 : 3402                       pshs a              ; * SAVE IT ON THE STACK
9833 : 2a02                       bpl  L83B8          ; BRANCH IF POSITIVE MAN
9835 : 8d24                       bsr  L83DC          ; CHANGE SIGN OF FPA0
9837 : 964f             L83B8     lda  FP0EXP         ; * GET EXPONENT OF FPA0
9839 : 3402                       pshs a              ; * SAVE IT ON THE STACK
983b : 8181                       cmpa #$81           ; IS FPAO < 1.0?
983d : 2505                       blo  L83C5          ; YES
983f : 8e92d2                     ldx  #LBAC5         ; POINT X TO FP CONSTANT
9842 : 8ddf                       bsr  L83A3          ; GET RECIPROCAL OF FPA0
9844 : 8e985f           L83C5     ldx  #L83E0         ; POINT (X) TO TAYLOR SE
9847 : bd96fd                     jsr  LBEF0          ; EXPAND POLYNOMIAL
984a : 3502                       puls a              ; GET EXPONENT OF ARGUME
984c : 8181                       cmpa #$81           ; WAS ARGUMENT < 1.0?
984e : 2506                       blo  L83D7          ; YES
9850 : 8e982a                     ldx  #L83AB         ; POINT (X) TO FP NUMBER
9853 : bd91c6                     jsr  LB9B9          ; SUBTRACT FPA0 FROM (PI
9856 : 3502             L83D7     puls a              ; * GET SIGN OF INITIAL 
9858 : 4d                         tsta                ; * AND SET FLAGS ACCORD
9859 : 2a03                       bpl  L83DF          ; RETURN IF ARGUMENT WAS
985b : 7e96f6           L83DC     jmp  LBEE9          ; CHANGE MANTISSA SIGN O
985e : 39               L83DF     rts
                        *
                        * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR A
985f : 0b               L83E0     fcb  $0B            ; TWELVE COEFFICIENTS
9860 : 76b383bdd3       L83E1     fcb  $76,$B3,$83,$Bd,$D3 ; -6.84793912E-04 1
9865 : 791ef4a6f5       L83E6     fcb  $79,$1E,$F4,$A6,$F5 ; +4.85094216E-03 1
986a : 7b83fcb010       L83EB     fcb  $7b,$83,$FC,$B0,$10 ; -0.0161117018
986f : 7c0c1f67ca       L83F0     fcb  $7C,$0C,$1F,$67,$CA ; 0.0342096381
9874 : 7cde53cbc1       L83F5     fcb  $7C,$DE,$53,$Cb,$C1 ; -0.0542791328
9879 : 7d1464704c       L83FA     fcb  $7d,$14,$64,$70,$4C ; 0.0724571965
987e : 7db7ea517a       L83FF     fcb  $7d,$B7,$Ea,$51,$7A ; -0.0898023954
9883 : 7d6330887e       L8404     fcb  $7d,$63,$30,$88,$7E ; 0.110932413
9888 : 7e9244993a       L8409     fcb  $7E,$92,$44,$99,$3A ; -0.142839808
988d : 7e4ccc91c7       L840E     fcb  $7E,$4C,$CC,$91,$C7 ; 0.199999121
9892 : 7faaaaaa13       L8413     fcb  $7F,$Aa,$Aa,$Aa,$13 ; -0.333333316
9897 : 8100000000       L8418     fcb  $81,$00,$00,$00,$00 ; 1
                        *
                        *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR
                        *
989c : 03               L841D     fcb  3              ; FOUR COEFFICIENTS
989d : 7f5e56cb79       L841E     fcb  $7F,$5E,$56,$Cb,$79 ; 0.434255942
98a2 : 80139b0b64       L8423     fcb  $80,$13,$9b,$0b,$64 ; 0.576584541
98a7 : 8076389316       L8428     fcb  $80,$76,$38,$93,$16 ; 0.961800759
98ac : 8238aa3b20       L842D     fcb  $82,$38,$Aa,$3b,$20 ; 2.88539007
                        
98b1 : 803504f334       L8432     fcb  $80,$35,$04,$F3,$34 ; 1/SQR(2)
                        
98b6 : 813504f334       L8437     fcb  $81,$35,$04,$F3,$34 ; SQR(2)
AS09 Assembler for M6809 [1.42].                                     Page   94
--------------------------------- merge.a09 ----------------------------------

                        
98bb : 8080000000       L843C     fcb  $80,$80,$00,$00,$00 ; -0.5
                        
98c0 : 80317217f8       L8441     fcb  $80,$31,$72,$17,$F8 ; LN(2)
                        *
                        * LOG - NATURAL LOGARITHM (LN)
                        
                        * THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USIN
                        * MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*
                        * NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE
                        * LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WI
                        * TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)
                        * THE TERMS OF THE LATTER EXPRESSION ARE CONstaNTS EXC
                        * LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLO
98c5 : bd947a           LOG       jsr  LBC6D          ; CHECK STATUS OF FPA0
98c8 : 102ff3b1                   ble  LB44A          ; 'FC' ERROR IF NEGATIVE
98cc : 8e98b1                     ldx  #L8432         ; POINT (X) TO FP NUMBER
98cf : 964f                       lda  FP0EXP         ; *GET EXPONENT OF ARGUM
98d1 : 8080                       suba #$80           ; *SUBTRACT OFF THE BIAS
98d3 : 3402                       pshs a              ; *SAVE IT ON THE STACK
98d5 : 8680                       lda  #$80
98d7 : 974f                       sta  FP0EXP
98d9 : bd91cf                     jsr  LB9C2          ; ADD FPA0 TO (X)
98dc : 8e98b6                     ldx  #L8437         ; POINT X TO SQR(2)
98df : bd939c                     jsr  LBB8F          ; DIVIDE SQR(2) BY FPA0
98e2 : 8e92d2                     ldx  #LBAC5         ; POINT X TO FP VALUE OF
98e5 : bd91c6                     jsr  LB9B9          ; SUBTRACT FPA0 FROM (X)
                        *         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE 
98e8 : 8e989c                     ldx  #L841D         ; POINT X TO TABLE OF CO
98eb : bd96fd                     jsr  LBEF0          ; EXPAND POLYNOMIAL
98ee : 8e98bb                     ldx  #L843C         ; POINT X TO FP VALUE OF
98f1 : bd91cf                     jsr  LB9C2          ; ADD FPA0 TO X
98f4 : 3504                       puls b              ; GET EXPONENT OF ARGUME
98f6 : bd95a6                     jsr  LBD99          ; ADD ACCB TO FPA0
98f9 : 8e98c0                     ldx  #L8441         ; POINT X TO LN(2)
98fc : 7e92d7                     jmp  LBACA          ; MULTIPLY FPA0 * LN(2)
                        
                        * SQR
98ff : bd946c           SQR       jsr  LBC5F          ; MOVE FPA0 TO FPA1
9902 : 8e96cd                     ldx  #LBEC0         ; POINT (X) TO FP NUMBER
9905 : bd9421                     jsr  LBC14          ; COPY A PACKED NUMBER F
                        
                        * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS
                        * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION
                        * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.718281
9908 : 2766             L8489     beq  EXP            ; DO A NATURAL EXPONENTI
990a : 4d                         tsta                ; *CHECK VALUE BEING EXP
990b : 2603                       bne  L8491          ; *AND BRANCH IF IT IS <
990d : 7e9247                     jmp  LBA3A          ; FPA0=0 IF RAISING ZERO
9910 : 8e004a           L8491     ldx  #V4A           ; * PACK FPA0 AND SAVE
9913 : bd9442                     jsr  LBC35          ; * IT IN FPA5 (ARGUMENT
9916 : 5f                         clrb                ; ACCB=DEFAULT RESULT SI
9917 : 9661                       lda  FP1SGN         ; *CHECK THE SIGN OF ARG
9919 : 2a10                       bpl  L84AC          ; *BRANCH IF POSITIVE
991b : bd94fb                     jsr  INT            ; CONVERT EXPONENT INTO 
991e : 8e004a                     ldx  #V4A           ; POINT X TO FPA5 (ORIGI
9921 : 9661                       lda  FP1SGN         ; GET MANTISSA SIGN OF F
9923 : bd94ad                     jsr  LBCA0          ; *COMPARE FPA0 TO (X) A
9926 : 2603                       bne  L84AC          ; *BRANCH IF NOT EQUAL
9928 : 43                         coma                ; TOGGLE FPA1 MANTISSA S
9929 : d601                       ldb  CHARAC         ; GET LS BYTE OF INTEGER
992b : bd9459           L84AC     jsr  LBC4C          ; COPY FPA1 TO FPA0; ACC
AS09 Assembler for M6809 [1.42].                                     Page   95
--------------------------------- merge.a09 ----------------------------------

992e : 3404                       pshs b              ; PUT RESULT SIGN FLAG O
9930 : 8d93                       jsr  LOG
9932 : 8e004a                     ldx  #V4A           ; POINT (X) TO FPA5
9935 : bd92d7                     jsr  LBACA          ; MULTIPLY FPA0 BY FPA5
9938 : 8d36                       bsr  EXP            ; CALCULATE E**(FPA0)
993a : 3502                       puls a              ; * GET RESULT SIGN FLAG
993c : 46                         rora                ; * AND BRANCH IF NEGATI
993d : 1025fdb5                   bcs  LBEE9          ; CHANGE SIGN OF FPA0 MA
9941 : 39                         rts
                        
                        * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION
9942 : 8138aa3b29       L84C4     fcb  $81,$38,$Aa,$3b,$29 ; 1.44269504 ( CF )
                        *
                        * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E
                        *
9947 : 07               L84C9     fcb  7              ; EIGHT COEFFICIENTS
9948 : 7134583e56       L84CA     fcb  $71,$34,$58,$3E,$56 ; 2.14987637E-05: 1
994d : 74167eb31b       L84CF     fcb  $74,$16,$7E,$B3,$1B ; 1.4352314E-04 : 1
9952 : 772feee385       L84D4     fcb  $77,$2F,$EE,$E3,$85 ; 1.34226348E-03: 1
9957 : 7a1d841c2a       L84D9     fcb  $7A,$1D,$84,$1C,$2A ; 9.61401701E-03: 1
995c : 7c6359580a       L84DE     fcb  $7C,$63,$59,$58,$0A ; 0.0555051269
9961 : 7e75fde7c6       L84E3     fcb  $7E,$75,$FD,$E7,$C6 ; 0.240226385
9966 : 8031721810       L84E8     fcb  $80,$31,$72,$18,$10 ; 0.693147186
996b : 8100000000       L84ED     fcb  $81,$00,$00,$00,$00 ; 1
                        *
                        * EXP ( E**X)
                        * THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTI
                        * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS 
                        * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFL
                        * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A 
                        * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED T
                        * THE CF MULTIPLICATION AT THE START OF THE EVALUATION
                        
9970 : 8e9942           EXP       ldx  #L84C4         ; POINT X TO THE CORRECT
9973 : bd92d7                     jsr  LBACA          ; MULTIPLY FPA0 BY (X)
9976 : bd943c                     jsr  LBC2F          ; PACK FPA0 AND STORE IT
9979 : 964f                       lda  FP0EXP         ; *GET EXPONENT OF FPA0 
997b : 8188                       cmpa #$88           ; *COMPARE TO THE MAXIMU
997d : 2503                       blo  L8504          ; BRANCH IF FPA0 < 128
997f : 7e9369           L8501     jmp  LBB5C          ; SET FPA0 = 0 OR 'OV' E
9982 : bd94fb           L8504     jsr  INT            ; CONVERT FPA0 TO INTEGE
9985 : 9601                       lda  CHARAC         ; GET LS BYTE OF INTEGER
9987 : 8b81                       adda #$81           ; * WAS THE ARGUMENT =12
9989 : 27f4                       beq  L8501          ; * THEN 'OV' ERROR; THI
                        *              ; * REQUIRED WHEN THE NEW EXPONENT IS C
998b : 4a                         deca                ; DECREMENT ONE FROM THE
998c : 3402                       pshs a              ; SAVE EXPONENT OF INTEG
998e : 8e0040                     ldx  #V40           ; POINT (X) TO FPA3
9991 : bd91c6                     jsr  LB9B9          ; SUBTRACT FPA0 FROM (X)
9994 : 8e9947                     ldx  #L84C9         ; POINT X TO COEFFICIENT
9997 : bd970c                     jsr  LBEFF          ; EVALUATE POLYNOMIAL FO
999a : 0f62                       clr  RESSGN         ; FORCE THE MANTISSA TO 
999c : 3502                       puls a              ; GET INTEGER EXPONENT F
999e : bd9355                     jsr  LBB48          ; * CALCULATE EXPONENT O
                        *              ; * INTEGER AND FRACTIONAL PARTS
99a1 : 39                         rts
                        
                        * FIX
99a2 : bd947a           FIX       jsr  LBC6D          ; CHECK STATUS OF FPA0
99a5 : 2b03                       bmi  L852C          ; BRANCH IF FPA0 = NEGAT
99a7 : 7e94fb           L8529     jmp  INT            ; CONVERT FPA0 TO INTEGE
99aa : 0354             L852C     com  FP0SGN         ; TOGGLE SIGN OF FPA0 MA
AS09 Assembler for M6809 [1.42].                                     Page   96
--------------------------------- merge.a09 ----------------------------------

99ac : 8df9                       bsr  L8529          ; CONVERT FPA0 TO INTEGE
99ae : 7e96f6                     jmp  LBEE9          ; TOGGLE SIGN OF FPA0
                        
                        * EDIT
99b1 : bd9ddc           EDIT      jsr  L89AE          ; GET LINE NUMBER FROM B
99b4 : 3262                       leas $02,s          ; PURGE RETURN ADDRESS O
99b6 : 8601             L8538     lda  #$01           ; 'LIST' FLAG
99b8 : 9798                       sta  VD8            ; SET FLAG TO LIST LINE
99ba : bd8554                     jsr  LAD01          ; GO FIND THE LINE NUMBE
99bd : 1025ed6e                   bcs  LAED2          ; ERROR #7 'UNDEFINED LI
99c1 : bd8fec                     jsr  LB7C2          ; GO UNCRUNCH LINE INTO 
99c4 : 1f20                       tfr  y,d            ; PUT ABSOLUTE ADDRESS O
99c6 : 8300e3                     subd #LINBUF+2      ; SUBTRACT OUT THE START
99c9 : d797                       stb  VD7            ; SAVE LENGTH OF LINE
99cb : dc2b             L854D     ldd  BINVAL         ; GET THE HEX VALUE OF L
99cd : bd95d9                     jsr  LBDCC          ; LIST THE LINE NUMBER O
99d0 : bd91b9                     jsr  LB9AC          ; PRINT A SPACE
99d3 : 8e00e2                     ldx  #LINBUF+1      ; POINT X TO BUFFER
99d6 : d698                       ldb  VD8            ; * CHECK TO SEE IF LINE
99d8 : 2625                       bne  L8581          ; * LISTED TO SCREEN - B
99da : 5f               L855C     clrb                ; RESET DIGIT ACCUMULATO
99db : bd9b05           L855D     jsr  L8687          ; GET KEY STROKE
99de : bda2a7                     jsr  L90AA          ; SET CARRY IF NOT NUMER
99e1 : 250b                       blo  L8570          ; BRANCH IF NOT NUMERIC
99e3 : 8030                       suba #'0'            ; MASK OFF ASCII
99e5 : 3402                       pshs a              ; SAVE IT ON STACK
99e7 : 860a                       lda  #10            ; NUMBER BEING CONVERTED
99e9 : 3d                         mul                 ; MULTIPLY ACCUMULATED V
99ea : ebe0                       addb ,s+            ; ADD DIGIT TO ACCUMULAT
99ec : 20ed                       bra  L855D          ; CHECK FOR ANOTHER DIGI
99ee : c001             L8570     subb #$01           ; * REPEAT PARAMETER IN 
99f0 : c901                       adcb #$01           ; *IS 0, THEN MAKE IT '1
99f2 : 8141                       cmpa #'A'           ; ABORT?
99f4 : 2605                       bne  L857D          ; NO
99f6 : bd916a                     jsr  LB958          ; PRINT CARRIAGE RETURN 
99f9 : 20bb                       bra  L8538          ; RESTART EDIT PROCESS -
99fb : 814c             L857D     cmpa #'L'           ; LIST?
99fd : 260b                       bne  L858C          ; NO
99ff : 8d31             L8581     bsr  L85B4          ; LIST THE LINE
9a01 : 0f98                       clr  VD8            ; RESET THE LIST FLAG TO
9a03 : bd916a                     jsr  LB958          ; PRINT CARRIAGE RETURN
9a06 : 20c3                       bra  L854D          ; GO INTERPRET ANOTHER E
9a08 : 3262             L858A     leas $02,s          ; PURGE RETURN ADDRESS O
9a0a : 810d             L858C     cmpa #CR            ; ENTER KEY?
9a0c : 260d                       bne  L859D          ; NO
9a0e : 8d22                       bsr  L85B4          ; ECHO THE LINE TO THE S
9a10 : bd916a           L8592     jsr  LB958          ; PRINT CARRIAGE RETURN
9a13 : 8e00e2                     ldx  #LINBUF+1      ; * RESET BASIC'S INPUT 
9a16 : 9f83                       stx  CHARAD         ; * TO THE LINE INPUT BU
9a18 : 7e84fd                     jmp  LACA8          ; GO PUT LINE BACK IN PR
9a1b : 8145             L859D     cmpa #'E'           ; EXIT?
9a1d : 27f1                       beq  L8592          ; YES - SAME AS ENTER EX
9a1f : 8151                       cmpa #'Q'           ; QUIT?
9a21 : 2606                       bne  L85AB          ; NO
9a23 : bd916a                     jsr  LB958          ; PRINT CARRIAGE RETURN 
9a26 : 7e84ce                     jmp  LAC73          ; GO TO COMMAND LEVEL - 
9a29 : 8d02             L85AB     bsr  L85AF          ; INTERPRET THE REMAININ
9a2b : 20ad                       bra  L855C          ; GO INTERPRET ANOTHER E
9a2d : 8120             L85AF     cmpa #SPACE         ; SPACE BAR?
9a2f : 2610                       bne  L85C3          ; NO
9a31 : 8c               L85B3     fcb  SKP2           ; SKIP TWO BYTES
                        * DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFE
AS09 Assembler for M6809 [1.42].                                     Page   97
--------------------------------- merge.a09 ----------------------------------

                        *
9a32 : c6f9             L85B4     ldb  #LBUFMX-1      ; 250 BYTES MAX IN BUFFE
9a34 : a684             L85B6     lda  ,x             ; GET A CHARACTER FROM B
9a36 : 2708                       beq  L85C2          ; EXIT IF IT'S A 0
9a38 : bd805c                     jsr  PUTCHR         ; SEND CHAR TO CONSOLE O
9a3b : 3001                       leax $01,x          ; MOVE POINTER UP ONE
9a3d : 5a                         decb                ; DECREMENT CHARACTER CO
9a3e : 26f4                       bne  L85B6          ; LOOP IF NOT DONE
9a40 : 39               L85C2     rts
9a41 : 8144             L85C3     cmpa #'D'           ; DELETE?
9a43 : 2648                       bne  L860F          ; NO
9a45 : 6d84             L85C7     tst  ,x             ; * CHECK FOR END OF LIN
9a47 : 27f7                       beq  L85C2          ; * AND BRANCH IF SO
9a49 : 8d04                       bsr  L85D1          ; REMOVE A CHARACTER
9a4b : 5a                         decb                ; DECREMENT REPEAT PARAM
9a4c : 26f7                       bne  L85C7          ; BRANCH IF NOT DONE
9a4e : 39                         rts
                        * REMOVE ONE CHARACTER FROM BUFFER
9a4f : 0a97             L85D1     dec  VD7            ; DECREMENT LENGTH OF BU
9a51 : 311f                       leay -1,x           ; POINT Y TO ONE BEFORE 
9a53 : 3121             L85D5     leay $01,y          ; INCREMENT TEMPORARY BU
9a55 : a621                       lda  $01,y          ; GET NEXT CHARACTER
9a57 : a7a4                       sta  ,y             ; PUT IT IN CURRENT POSI
9a59 : 26f8                       bne  L85D5          ; BRANCH IF NOT END OF L
9a5b : 39                         rts
9a5c : 8149             L85DE     cmpa #'I'           ;  INSERT?
9a5e : 2713                       beq  L85F5          ; YES
9a60 : 8158                       cmpa #'X'           ; EXTEND?
9a62 : 270d                       beq  L85F3          ; YES
9a64 : 8148                       cmpa #'H'           ; HACK?
9a66 : 265c                       bne  L8646          ; NO
9a68 : 6f84                       clr  ,x             ; TURN CURRENT BUFFER PO
9a6a : 1f10                       tfr  x,d            ; PUT CURRENT BUFFER POI
9a6c : 8300e3                     subd #LINBUF+2      ; SUBTRACT INITIAL POINT
9a6f : d797                       stb  VD7            ; SAVE NEW BUFFER LENGTH
9a71 : 8dbf             L85F3     bsr  L85B4          ; DISPLAY THE LINE ON TH
9a73 : bd9b05           L85F5     jsr  L8687          ; GET A KEYSTROKE
9a76 : 810d                       cmpa #CR            ; ENTER KEY?
9a78 : 278e                       beq  L858A          ; YES - INTERPRET ANOTHE
9a7a : 811b                       cmpa #ESC           ; ESCAPE?
9a7c : 2725                       beq  L8625          ; YES - RETURN TO COMMAN
9a7e : 8108                       cmpa #BS            ; BACK SPACE?
9a80 : 2622                       bne  L8626          ; NO
9a82 : 8c00e2                     cmpx #LINBUF+1      ; COMPARE POINTER TO STA
9a85 : 27ec                       beq  L85F5          ; DO NOT ALLOW BS IF AT 
9a87 : 8d45                       bsr  L8650          ; MOVE POINTER BACK ONE,
9a89 : 8dc4                       bsr  L85D1          ; REMOVE ONE CHARACTER F
9a8b : 20e6                       bra  L85F5          ; GET INSERT SUB COMMAND
9a8d : 8143             L860F     cmpa #'C'           ; CHANGE?
9a8f : 26cb                       bne  L85DE          ; NO
9a91 : 6d84             L8613     tst  ,x             ; CHECK CURRENT BUFFER C
9a93 : 270e                       beq  L8625          ; BRANCH IF END OF LINE
9a95 : bd9b05                     jsr  L8687          ; GET A KEYSTROKE
9a98 : 2502                       blo  L861E          ; BRANCH IF LEGITIMATE K
9a9a : 20f5                       bra  L8613          ; TRY AGAIN IF ILLEGAL K
9a9c : a780             L861E     sta  ,x+            ; INSERT NEW CHARACTER I
9a9e : 8d37                       bsr  L8659          ; SEND NEW CHARACTER TO 
9aa0 : 5a                         decb                ; DECREMENT REPEAT PARAM
9aa1 : 26ee                       bne  L8613          ; BRANCH IF NOT DONE
9aa3 : 39               L8625     rts
9aa4 : d697             L8626     ldb  VD7            ; GET LENGTH OF LINE
9aa6 : c1f9                       cmpb #LBUFMX-1      ; COMPARE TO MAXIMUM LEN
AS09 Assembler for M6809 [1.42].                                     Page   98
--------------------------------- merge.a09 ----------------------------------

9aa8 : 2602                       bne  L862E          ; BRANCH IF NOT AT MAXIM
9aaa : 20c7                       bra  L85F5          ; IGNORE INPUT IF LINE A
9aac : 3410             L862E     pshs x              ; SAVE CURRENT BUFFER PO
9aae : 6d80             L8630     tst  ,x+            ; * SCAN THE LINE UNTIL 
9ab0 : 26fc                       bne  L8630          ; * LINE (0) IS FOUND
9ab2 : e682             L8634     ldb  ,-x            ; DECR TEMP LINE POINTER
9ab4 : e701                       stb  $01,x          ; PUT CHARACTER BACK DOW
9ab6 : ace4                       cmpx ,s             ; HAVE WE REACHED STARTI
9ab8 : 26f8                       bne  L8634          ; NO - KEEP GOING
9aba : 3262                       leas $02,s          ; PURGE BUFFER POINTER F
9abc : a780                       sta  ,x+            ; INSERT NEW CHARACTER I
9abe : 8d17                       bsr  L8659          ; SEND A CHARACTER TO CO
9ac0 : 0c97                       inc  VD7            ; ADD ONE TO BUFFER LENG
9ac2 : 20af                       bra  L85F5          ; GET INSERT SUB COMMAND
9ac4 : 8108             L8646     cmpa #BS            ; BACKSPACE?
9ac6 : 2612                       bne  L865C          ; NO
9ac8 : 8d04             L864A     bsr  L8650          ; MOVE POINTER BACK 1, S
9aca : 5a                         decb                ; DECREMENT REPEAT PARAM
9acb : 26fb                       bne  L864A          ; LOOP UNTIL DONE
9acd : 39                         rts
9ace : 8c00e2           L8650     cmpx #LINBUF+1      ; COMPARE POINTER TO STA
9ad1 : 27d0                       beq  L8625          ; DO NOT ALLOW BS IF AT 
9ad3 : 301f                       leax -1,x           ; MOVE POINTER BACK ONE
9ad5 : 8608                       lda  #BS            ; BACK SPACE
9ad7 : 7e805c           L8659     jmp  PUTCHR         ; SEND TO CONSOLE OUT
9ada : 814b             L865C     cmpa #'K'           ; KILL?
9adc : 2705                       beq  L8665          ; YES
9ade : 8053                       suba #'S'           ; SEARCH?
9ae0 : 2701                       beq  L8665          ; YES
9ae2 : 39                         rts
9ae3 : 3402             L8665     pshs a              ; SAVE KILL/SEARCH FLAG 
9ae5 : 8d1e                       bsr  L8687          ; * GET A KEYSTROKE (TAR
9ae7 : 3402                       pshs a              ; * AND SAVE IT ON STACK
9ae9 : a684             L866B     lda  ,x             ; GET CURRENT BUFFER CHA
9aeb : 2716                       beq  L8685          ; AND RETURN IF END OF L
9aed : 6d61                       tst  $01,s          ; CHECK KILL/SEARCH FLAG
9aef : 2606                       bne  L8679          ; BRANCH IF KILL
9af1 : 8de4                       bsr  L8659          ; SEND A CHARACTER TO CO
9af3 : 3001                       leax $01,x          ; INCREMENT BUFFER POINT
9af5 : 2003                       bra  L867C          ; CHECK NEXT INPUT CHARA
9af7 : bd9a4f           L8679     jsr  L85D1          ; REMOVE ONE CHARACTER F
9afa : a684             L867C     lda  ,x             ; GET CURRENT INPUT CHAR
9afc : a1e4                       cmpa ,s             ; COMPARE TO TARGET CHAR
9afe : 26e9                       bne  L866B          ; BRANCH IF NO MATCH
9b00 : 5a                         decb                ; DECREMENT REPEAT PARAM
9b01 : 26e6                       bne  L866B          ; BRANCH IF NOT DONE
9b03 : 35a0             L8685     puls y,pc           ; THE Y PULL WILL CLEAN 
                        *
                        * GET A KEYSTRKE
9b05 : bd801f           L8687     jsr  LA171          ; CALL CONSOLE IN : DEV 
9b08 : 817f                       cmpa #$7F           ; GRAPHIC CHARACTER?
9b0a : 24f9                       bcc  L8687          ; YES - GET ANOTHER CHAR
9b0c : 815f                       cmpa #$5F           ; SHIFT UP ARROW (QUIT I
9b0e : 2602                       bne  L8694          ; NO
9b10 : 861b                       lda  #ESC           ; REPLACE W/ESCAPE CODE
9b12 : 810d             L8694     cmpa #CR            ; ENTER KEY
9b14 : 270e                       beq  L86A6          ; YES
9b16 : 811b                       cmpa #ESC           ; ESCAPE?
9b18 : 270a                       beq  L86A6          ; YES
9b1a : 8108                       cmpa #BS            ; BACKSPACE?
9b1c : 2706                       beq  L86A6          ; YES
9b1e : 8120                       cmpa #SPACE         ; SPACE
AS09 Assembler for M6809 [1.42].                                     Page   99
--------------------------------- merge.a09 ----------------------------------

9b20 : 25e3                       blo  L8687          ; GET ANOTHER CHAR IF CO
9b22 : 1a01                       orcc #$01           ; SET CARRY
9b24 : 39               L86A6     rts
                        
                        * TRON
9b25 : 86               TRON      fcb  SKP1LD         ; SKIP ONE BYTE AND lda 
                        
                        * TROFF
9b26 : 4f               TROFF     clra                ; TROFF FLAG
9b27 : 978c                       sta  TRCFLG         ; TRON/TROFF FLAG:0=TROF
9b29 : 39                         rts
                        
                        * POS
                        
9b2a : 8600             POS       lda  #0             ; GET DEVICE NUMBER
9b2c : d679                       ldb  LPTPOS         ; GET PRINT POSITION
9b2e : 1d               LA5E8     sex                 ; CONVERT ACCB TO 2 DIGI
9b2f : 7e8d27                     jmp  GIVABF         ; CONVERT ACCD TO FLOATI
                        
                        
                        * VARPTR
9b32 : bd8aa3           VARPT     jsr  LB26A          ; SYNTAX CHECK FOR '('
9b35 : dc1f                       ldd  ARYEND         ; GET ADDR OF END OF ARR
9b37 : 3406                       pshs b,a            ; SAVE IT ON STACK
9b39 : bd8b8a                     jsr  LB357          ; GET VARIABLE DESCRIPTO
9b3c : bd8aa0                     jsr  LB267          ; SYNTAX CHECK FOR ')'
9b3f : 3506                       puls a,b            ; GET END OF ARRAYS ADDR
9b41 : 1e10                       exg  x,d            ; SWAP END OF ARRAYS AND
9b43 : 9c1f                       cmpx ARYEND         ; COMPARE TO NEW END OF 
9b45 : 2651                       bne  L8724          ; 'FC' ERROR IF VARIABLE
9b47 : 7e8d27                     jmp  GIVABF         ; CONVERT VARIABLE DESCR
                        
                        * MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT
9b4a : 9d7c             L86D6     jsr  GETNCH         ; GET INPUT CHAR FROM BA
9b4c : bd8aa3                     jsr  LB26A          ; SYNTAX CHECK FOR '('
9b4f : bd8b8a                     jsr  LB357          ; * GET VARIABLE DESCRIP
9b52 : 3410                       pshs x              ; * SAVE IT ON THE STACK
9b54 : ec02                       ldd  $02,x          ; POINT ACCD TO START OF
9b56 : 109321                     cmpd FRETOP         ; COMPARE TO START OF CL
9b59 : 2304                       bls  L86EB          ; BRANCH IF <=
9b5b : 9327                       subd MEMSIZ         ; SUBTRACT OUT TOP OF CL
9b5d : 2312                       bls  L86FD          ; BRANCH IF STRING IN ST
9b5f : e684             L86EB     ldb  ,x             ; GET LENGTH OF OLDSTRIN
9b61 : bd8da0                     jsr  LB56D          ; RESERVE ACCB BYTES IN 
9b64 : 3410                       pshs x              ; SAVE RESERVED SPACE ST
9b66 : ae62                       ldx  $02,s          ; POINT X TO OLDSTRING D
9b68 : bd8e75                     jsr  LB643          ; MOVE OLDSTRING INTO ST
9b6b : 3550                       puls x,u            ; * GET OLDSTRING DESCRI
9b6d : af42                       stx  $02,u          ; * ADDRESS AND SAVE RES
9b6f : 3440                       pshs u              ; SAVE OLDSTRING DESCRIP
9b71 : bd8f69           L86FD     jsr  LB738          ; SYNTAX CHECK FOR COMMA
9b74 : 3404                       pshs b              ; SAVE POSITION PARAMETE
9b76 : 5d                         tstb                ; * CHECK POSITION PARAM
9b77 : 271f                       beq  L8724          ; * IF START OF STRING
9b79 : c6ff                       ldb  #$FF           ; DEFAULT REPLACEMENT LE
9b7b : 8129                       cmpa #')'           ; * CHECK FOR END OF MID
9b7d : 2703                       beq  L870E          ; * BRANCH IF AT END OF 
9b7f : bd8f69                     jsr  LB738          ; SYNTAX CHECK FOR COMMA
9b82 : 3404             L870E     pshs b              ; SAVE LENGTH PARAMETER 
9b84 : bd8aa0                     jsr  LB267          ; SYNTAX CHECK FOR ')'
9b87 : c6b5                       ldb  #TOK_EQUALS    ; TOKEN FOR =
9b89 : bd8aa8                     jsr  LB26F          ; SYNTAX CHECK FOR '='
AS09 Assembler for M6809 [1.42].                                     Page  100
--------------------------------- merge.a09 ----------------------------------

9b8c : 8d2e                       bsr  L8748          ; EVALUATE REPLACEMENT S
9b8e : 1f13                       tfr  x,u            ; SAVE REPLACEMENT STRIN
9b90 : ae62                       ldx  $02,s          ; POINT X TO OLOSTRING D
9b92 : a684                       lda  ,x             ; GET LENGTH OF OLDSTRIN
9b94 : a061                       suba $01,s          ; SUBTRACT POSITION PARA
9b96 : 2403                       bcc  L8727          ; INSERT REPLACEMENT STR
9b98 : 7e8c7d           L8724     jmp  LB44A          ; 'FC' ERROR IF POSITION
9b9b : 4c               L8727     inca                ; * NOW ACCA = NUMBER OF
                        *                             ; * (INCLUSIVE) OF THE P
9b9c : a1e4                       cmpa ,s
9b9e : 2402                       bcc  L872E          ; BRANCH IF NEW STRING W
9ba0 : a7e4                       sta  ,s             ; IF NOT, USE AS MUCH OF
9ba2 : a661             L872E     lda  $01,s          ; GET POSITION PARAMETER
9ba4 : 1e89                       exg  a,b            ; ACCA=LENGTH OF REPL ST
9ba6 : ae02                       ldx  $02,x          ; POINT X TO OLDSTRING A
9ba8 : 5a                         decb                ; * BASIC'S POSITION PAR
                        *                             ; * WANTS IT TO START AT
9ba9 : 3a                         abx                 ; POINT X TO POSITION IN
9baa : 4d                         tsta                ; * IF THE LENGTH OF THE
9bab : 270d                       beq  L8746          ; * THEN RETURN
9bad : a1e4                       cmpa ,s
9baf : 2302                       bls  L873F          ; ADJUSTED LENGTH PARAME
9bb1 : a6e4                       lda  ,s             ; OTHERWISE USE AS MUCH 
9bb3 : 1f89             L873F     tfr  a,b            ; SAVE NUMBER OF BYTES T
9bb5 : 1e31                       exg  u,x            ; SWAP SOURCE AND DESTIN
9bb7 : bd81df                     jsr  LA59A          ; MOVE (B) BYTES FROM (X
9bba : 3596             L8746     puls a,b,x,pc
9bbc : bd898f           L8748     jsr  LB156          ; EVALUATE EXPRESSION
9bbf : 7e8e86                     jmp  LB654          ; *'TM' ERROR IF NUMERIC
                        *                             ; *TO STRING, ACCB = LEN
                        
                        * STRING
9bc2 : bd8aa3           STRING    jsr  LB26A          ; SYNTAX CHECK FOR '('
9bc5 : bd8f3c                     jsr  LB70B          ; EVALUATE EXPRESSION; E
9bc8 : 3404                       pshs b              ; SAVE LENGTH OF STRING
9bca : bd8aa6                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
9bcd : bd898f                     jsr  LB156          ; EVALUATE EXPRESSION
9bd0 : bd8aa0                     jsr  LB267          ; SYNTAX CHECK FOR ')'
9bd3 : 9606                       lda  VALTYP         ; GET VARIABLE TYPE
9bd5 : 2605                       bne  L8768          ; BRANCH IF STRING
9bd7 : bd8f3f                     jsr  LB70E          ; CONVERT FPA0 INTO AN I
9bda : 2003                       bra  L876B          ; SAVE THE STRING IN STR
9bdc : bd8ed6           L8768     jsr  LB6A4          ; GET FIRST BYTE OF STRI
9bdf : 3404             L876B     pshs b              ; SAVE FIRST BYTE OF EXP
9be1 : e661                       ldb  $01,s          ; GET LENGTH OF STRING
9be3 : bd8d42                     jsr  LB50F          ; RESERVE ACCB BYTES IN 
9be6 : 3506                       puls a,b            ; GET LENGTH OF STRING A
9be8 : 2705                       beq  L877B          ; BRANCH IF NULL STRING
9bea : a780             L8776     sta  ,x+            ; SAVE A CHARACTER IN ST
9bec : 5a                         decb                ; DECREMENT LENGTH
9bed : 26fb                       bne  L8776          ; BRANCH IF NOT DONE
9bef : 7e8ecd           L877B     jmp  LB69B          ; PUT STRING DESCRIPTOR 
                        
                        * INSTR
9bf2 : bd8aa3           INSTR     jsr  LB26A          ; SYNTAX CHECK FOR '('
9bf5 : bd898f                     jsr  LB156          ; EVALUATE EXPRESSION
9bf8 : c601                       ldb  #$01           ; DEFAULT POSITION = 1 (
9bfa : 3404                       pshs b              ; SAVE START
9bfc : 9606                       lda  VALTYP         ; GET VARIABLE TYPE
9bfe : 2610                       bne  L879C          ; BRANCH IF STRING
9c00 : bd8f3f                     jsr  LB70E          ; CONVERT FPA0 TO INTEGE
9c03 : e7e4                       stb  ,s             ; SAVE START SEARCH VALU
AS09 Assembler for M6809 [1.42].                                     Page  101
--------------------------------- merge.a09 ----------------------------------

9c05 : 2791                       beq  L8724          ; BRANCH IF START SEARCH
9c07 : bd8aa6                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
9c0a : bd898f                     jsr  LB156          ; EVALUATE EXPRESSION - 
9c0d : bd897f                     jsr  LB146          ; 'TM' ERROR IF NUMERIC
9c10 : 9e52             L879C     ldx  FPA0+2         ; SEARCH STRING DESCRIPT
9c12 : 3410                       pshs x              ; SAVE ON THE STACK
9c14 : bd8aa6                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
9c17 : 8da3                       jsr  L8748          ; EVALUATE TARGET STRING
9c19 : 3414                       pshs x,b            ; SAVE ADDRESS AND LENGT
9c1b : bd8aa0                     jsr  LB267          ; SYNTAX CHECK FOR ')'
9c1e : ae63                       ldx  $03,s          ; * LOAD X WITH SEARCH S
9c20 : bd8e8b                     jsr  LB659          ; * AND GET THE LENGTH A
9c23 : 3404                       pshs b              ; SAVE LENGTH ON STACK
                        *
                        * AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATIO
                        * ON IT: 0,s-SEARCH LENGTH; 1,s-TARGET LENGTH; 2 3,s-T
                        * ADDRESS; 4 5,s-SEARCH DESCRIPTOR ADDRESS; 6,s-SEARCH
9c25 : e166                       cmpb $06,s          ; COMPARE LENGTH OF SEAR
9c27 : 2523                       blo  L87D9          ; POSITION; RETURN 0 IF 
9c29 : a661                       lda  $01,s          ; GET LENGTH OF TARGET S
9c2b : 271c                       beq  L87D6          ; BRANCH IF TARGET STRIN
9c2d : e666                       ldb  $06,s          ; GET START POSITION
9c2f : 5a                         decb                ; MOVE BACK ONE
9c30 : 3a                         abx                 ; POINT X TO POSITION IN
9c31 : 3184             L87BE     leay ,x             ; POINT Y TO SEARCH POSI
9c33 : ee62                       ldu  $02,s          ; POINT U TO START OF TA
9c35 : e661                       ldb  $01,s          ; LOAD ACCB WITH LENGTH 
9c37 : a6e4                       lda  ,s             ; LOAD ACCA WITH LENGTH 
9c39 : a066                       suba $06,s          ; SUBTRACT SEARCH POSITI
9c3b : 4c                         inca                ; ADD ONE
9c3c : a161                       cmpa $01,s          ; COMPARE TO TARGET LENG
9c3e : 250c                       blo  L87D9          ; RETURN 0 IF TARGET LEN
9c40 : a680             L87CD     lda  ,x+            ; GET A CHARACTER FROM S
9c42 : a1c0                       cmpa ,u+            ; COMPARE IT TO TARGET S
9c44 : 260c                       bne  L87DF          ; BRANCH IF NO MATCH
9c46 : 5a                         decb                ; DECREMENT TARGET LENGT
9c47 : 26f7                       bne  L87CD          ; CHECK ANOTHER CHARACTE
9c49 : e666             L87D6     ldb  $06,s          ; GET MATCH POSITION
9c4b : 21               L87D8     fcb  SKP1           ; SKIP NEXT BYTE
9c4c : 5f               L87D9     clrb                ; MATCH ADDRESS = 0
9c4d : 3267                       leas $07,s          ; CLEAN UP THE STACK
9c4f : 7e8d26                     jmp  LB4F3          ; CONVERT ACCB TO FP NUM
9c52 : 6c66             L87DF     inc  $06,s          ; INCREMENT SEARCH POSIT
9c54 : 3021                       leax $01,y          ; MOVE X TO NEXT SEARCH 
9c56 : 20d9                       bra  L87BE          ; KEEP LOOKING FOR A MAT
                        
                        * EXTENDED BASIC RVEC19 HOOK CODE
9c58 : 8126             XVEC19    cmpa #'&'           ; *
9c5a : 265c                       bne  L8845          ; * RETURN IF NOT HEX OR
9c5c : 3262                       leas $02,s          ; PURGE RETURN ADDRESS F
                        * PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
9c5e : 0f52             L87EB     clr  FPA0+2         ; * CLEAR BOTTOM TWO
9c60 : 0f53                       clr  FPA0+3         ; * BYTES OF FPA0
9c62 : 8e0052                     ldx  #FPA0+2        ; BYTES 2,3 OF FPA0 = (T
9c65 : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
9c67 : 814f                       cmpa #'O'
9c69 : 2712                       beq  L880A          ; YES
9c6b : 8148                       cmpa #'H'
9c6d : 2723                       beq  L881F          ; YES
9c6f : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
9c71 : 200c                       bra  L880C          ; DEFAULT TO OCTAL (&O)
9c73 : 8138             L8800     cmpa #'8'
AS09 Assembler for M6809 [1.42].                                     Page  102
--------------------------------- merge.a09 ----------------------------------

9c75 : 1022ee37                   bhi  LB277
9c79 : c603                       ldb  #$03           ; BASE 8 MULTIPLIER
9c7b : 8d2a                       bsr  L8834          ; ADD DIGIT TO TEMPORARY
                        * EVALUATE AN &O VARIABLE
9c7d : 9d7c             L880A     jsr  GETNCH         ; GET A CHARACTER FROM B
9c7f : 25f2             L880C     blo  L8800          ; BRANCH IF NUMERIC
9c81 : 0f50             L880E     clr  FPA0           ; * CLEAR 2 HIGH ORDER
9c83 : 0f51                       clr  FPA0+1         ; * BYTES OF FPA0
9c85 : 0f06                       clr  VALTYP         ; SET VARXABLE TYPE TO N
9c87 : 0f63                       clr  FPSBYT         ; ZERO OUT SUB BYTE OF F
9c89 : 0f54                       clr  FP0SGN         ; ZERO OUT MANTISSA SIGN
9c8b : c6a0                       ldb  #$A0           ; * SET EXPONENT OF FPA0
9c8d : d74f                       stb  FP0EXP         ; *
9c8f : 7e9229                     jmp  LBA1C          ; GO NORMALIZE FPA0
                        * EVALUATE AN &H VARIABLE
9c92 : 9d7c             L881F     jsr  GETNCH         ; GET A CHARACTER FROM B
9c94 : 250b                       blo  L882E          ; BRANCH IF NUMERIC
9c96 : bd8bd5                     jsr  LB3A2          ; SET CARRY IF NOT ALPHA
9c99 : 25e6                       blo  L880E          ; BRANCH IF NOT ALPHA OR
9c9b : 8147                       cmpa #'G'           ; CHECK FOR LETTERS A-F
9c9d : 24e2                       bcc  L880E          ; BRANCH IF >= G (ILLEGA
9c9f : 8007                       suba #7             ; SUBTRACT ASCII DIFFERE
9ca1 : c604             L882E     ldb  #$04           ; BASE 16 DIGIT MULTIPLI
9ca3 : 8d02                       bsr  L8834          ; ADD DIGIT TO TEMPORARY
9ca5 : 20eb                       bra  L881F          ; KEEP EVALUATING VARIAB
9ca7 : 6801             L8834     asl  $01,x          ; * MULTIPLY TEMPORARY
9ca9 : 6984                       rol  ,x             ; * ACCUMULATOR BY TWO
9cab : 1025f5f0                   bcs  LBA92          ; 'OV' OVERFLOW ERROR
9caf : 5a                         decb                ; DECREMENT SHIFT COUNTE
9cb0 : 26f5                       bne  L8834          ; MULTIPLY TEMPORARY ACC
9cb2 : 8030                       suba #'0'            ; MASK OFF ASCII
9cb4 : ab01                       adda $01,x          ; * ADD DIGIT TO TEMPORA
9cb6 : a701                       sta  $01,x          ; * ACCUMULATOR AND SAVE
9cb8 : 39               L8845     rts
                        
9cb9 : 3540             XVEC15    puls u              ; PULL RETURN ADDRESS AN
9cbb : 0f06                       clr  VALTYP         ; SET VARIABLE TYPE TO N
9cbd : 9e83                       ldx  CHARAD         ; CURRENT INPUT POINTER 
9cbf : 9d7c                       jsr  GETNCH         ; GET CHARACTER FROM BAS
9cc1 : 8126                       cmpa #'&'           ; HEX AND OCTAL VARIABLE
9cc3 : 2799                       beq  L87EB          ; PROCESS A '&' VARIABLE
9cc5 : 81b7                       cmpa #TOK_FN        ; TOKEN FOR FN
9cc7 : 275c                       beq  L88B4          ; PROCESS FN CALL
9cc9 : 81ff                       cmpa #$FF           ; CHECK FOR SECONDARY TO
9ccb : 2608                       bne  L8862          ; NOT SECONDARY
9ccd : 9d7c                       jsr  GETNCH         ; GET CHARACTER FROM BAS
9ccf : 8183                       cmpa #TOK_USR       ; TOKEN FOR USR
9cd1 : 102700a9                   lbeq L892C          ; PROCESS USR CALL
9cd5 : 9f83             L8862     stx  CHARAD         ; RESTORE BASIC'S INPUT 
9cd7 : 6ec4                       jmp  ,u             ; RETURN TO CALLING ROUT
9cd9 : 9e68             L8866     ldx  CURLIN         ; GET CURRENT LINE NUMBE
9cdb : 3001                       leax $01,x          ; IN DIRECT MODE?
9cdd : 26d9                       bne  L8845          ; RETURN IF NOT IN DIREC
9cdf : c616                       ldb  #2*11          ; 'ILLEGAL DIRECT STATEM
9ce1 : 7e84af           L886E     jmp  LAC46          ; PROCESS ERROR
                        
9ce4 : ae9f0083         DEF       ldx  [CHARAD]       ; GET TWO INPUT CHARS
9ce8 : 8cff83                     cmpx #TOK_FF_USR    ; TOKEN FOR USR
9ceb : 2774                       beq  L890F          ; BRANCH IF DEF USR
9ced : 8d23                       bsr  L88A1          ; GET DESCRIPTOR ADDRESS
9cef : 8de8                       bsr  L8866          ; DON'T ALLOW DEF FN IF 
9cf1 : bd8aa3                     jsr  LB26A          ; SYNTAX CHECK FOR '('
AS09 Assembler for M6809 [1.42].                                     Page  103
--------------------------------- merge.a09 ----------------------------------

9cf4 : c680                       ldb  #$80           ; * GET THE FLAG TO INDI
9cf6 : d708                       stb  ARYDIS         ; * AND SAVE IT IN THE A
9cf8 : bd8b8a                     jsr  LB357          ; GET VARIABLE DESCRIPTO
9cfb : 8d25                       bsr  L88B1          ; 'TM' ERROR IF STRING
9cfd : bd8aa0                     jsr  LB267          ; SYNTAX CHECK FOR ')'
9d00 : c6b5                       ldb  #TOK_EQUALS    ; TOKEN FOR '='
9d02 : bd8aa8                     jsr  LB26F          ; DO A SYNTAX CHECK FOR 
9d05 : 9e4b                       ldx  V4B            ; GET THE ADDRESS OF THE
9d07 : dc83                       ldd  CHARAD         ; * GET THE CURRENT INPU
9d09 : ed84                       std  ,x             ; * SAVE IT IN FIRST 2 B
9d0b : dc39                       ldd  VARPTR         ; = GET THE DESCRIPTOR A
9d0d : ed02                       std  $02,x          ; = VARIABLE AND SAVE IT
9d0f : 7e873d                     jmp  DATA           ; MOVE INPUT POINTER TO 
9d12 : c6b7             L88A1     ldb  #TOK_FN        ; TOKEN FOR FN
9d14 : bd8aa8                     jsr  LB26F          ; DO A SYNTAX CHECK FOR 
9d17 : c680                       ldb  #$80           ; * GET THE FLAG TO INDI
9d19 : d708                       stb  ARYDIS         ; * AND SAVE IT IN ARRAY
9d1b : 8a80                       ora  #$80           ; SET BIT 7 OF CURRENT I
9d1d : bd8b8f                     jsr  LB35C          ; * GET THE DESCRIPTOR A
9d20 : 9f4b                       stx  V4B            ; * VARIABLE AND SAVE IT
9d22 : 7e897c           L88B1     jmp  LB143          ; 'TM' ERROR IF STRING V
                        * EVALUATE AN FN CALL
9d25 : 8deb             L88B4     bsr  L88A1          ; * GET THE DESCRIPTOR O
9d27 : 3410                       pshs x              ; * VARIABLE AND SAVE IT
9d29 : bd8a9b                     jsr  LB262          ; SYNTAX CHECK FOR '(' &
9d2c : 8df4                       bsr  L88B1          ; 'TM' ERROR IF STRING V
9d2e : 3540                       puls u              ; POINT U TO FN NAME DES
9d30 : c632                       ldb  #2*25          ; 'UNDEFINED FUNCTION CA
9d32 : ae42                       ldx  $02,u          ; POINT X TO ARGUMENT VA
9d34 : 27ab                       beq  L886E          ; BRANCH TO ERROR HANDLE
9d36 : 109e83                     ldy  CHARAD         ; SAVE CURRENT INPUT POI
9d39 : eec4                       ldu  ,u             ; * POINT U TO START OF 
9d3b : df83                       stu  CHARAD         ; * SAVE IT IN INPUT POI
9d3d : a604                       lda  $04,x          ; = GET FP VALUE OF
9d3f : 3402                       pshs a              ; = ARGUMENT VARIABLE, C
9d41 : ec84                       ldd  ,x             ; = POINTER, AND ADDRESS
9d43 : ee02                       ldu  $02,x          ; = OF FN FORMULA AND SA
9d45 : 3476                       pshs u,y,x,b,a      ; = THEM ON THE STACK
9d47 : bd9442                     jsr  LBC35          ; PACK FPA0 AND SAVE IT 
9d4a : bd897a           L88D9     jsr  LB141          ; EVALUATE FN EXPRESSION
9d4d : 3576                       puls a,b,x,y,u      ; RESTORE REGISTERS
9d4f : ed84                       std  ,x             ; * GET THE FP
9d51 : ef02                       stu  $02,x          ; * VALUE OF THE ARGUMEN
9d53 : 3502                       puls a              ; * VARIABLE OFF OF THE
9d55 : a704                       sta  $04,x          ; * STACK AND RE-SAVE IT
9d57 : 9d82                       jsr  GETCCH         ; GET FINAL CHARACTER OF
9d59 : 1026ed53                   lbne LB277          ; 'SYNTAX' ERROR IF NOT 
9d5d : 109f83                     sty  CHARAD         ; RESTORE INPUT POINTER
9d60 : 39               L88EF     rts
                        
                        
                        
                        * DEF USR
9d61 : 9d7c             L890F     jsr  GETNCH         ; SKIP PAST SECOND BYTE 
9d63 : 8d09                       bsr  L891C          ; GET FN NUMBER
9d65 : 3410                       pshs x              ; SAVE FN EXEC ADDRESS S
9d67 : 8d2d                       bsr  L8944          ; CALCULATE EXEC ADDRESS
9d69 : 3540                       puls u              ; GET FN EXEC ADDRESS ST
9d6b : afc4                       stx  ,u             ; SAVE EXEC ADDRESS
9d6d : 39                         rts
9d6e : 5f               L891C     clrb                ; DEFAULT TO USR0 IF NO 
9d6f : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
AS09 Assembler for M6809 [1.42].                                     Page  104
--------------------------------- merge.a09 ----------------------------------

9d71 : 2406                       bcc  L8927          ; BRANCH IF NOT NUMERIC
9d73 : 8030                       suba #'0'            ; MASK OFF ASCII
9d75 : 1f89                       tfr  a,b            ; SAVE USR NUMBER IN ACC
9d77 : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
9d79 : 9e8d             L8927     ldx  USRADR         ; GET ADDRESS OF STORAGE
9d7b : 58                         aslb                ; X2 - 2 BYTES/USR ADDRE
9d7c : 3a                         abx                 ; ADD OFFSET TO START AD
9d7d : 39                         rts
                        * PROCESS A USR CALL
9d7e : 8dee             L892C     bsr  L891C          ; GET STORAGE LOC OF EXE
9d80 : ae84                       ldx  ,x             ; * GET EXEC ADDRESS AND
9d82 : 3410                       pshs x              ; * PUSH IT ONTO STACK
9d84 : bd8a9b                     jsr  LB262          ; SYNTAX CHECK FOR '(' &
9d87 : 8e004f                     ldx  #FP0EXP        ; POINT X TO FPA0
9d8a : 9606                       lda  VALTYP         ; GET VARIABLE TYPE
9d8c : 2707                       beq  L8943          ; BRANCH IF NUMERIC, STR
9d8e : bd8e89                     jsr  LB657          ; GET LENGTH & ADDRESS O
9d91 : 9e52                       ldx  FPA0+2         ; GET POINTER TO STRING 
9d93 : 9606                       lda  VALTYP         ; GET VARIABLE TYPE
9d95 : 39               L8943     rts                 ; JUMP TO USR ROUTINE (p
9d96 : c6b5             L8944     ldb  #TOK_EQUALS    ; TOKEN FOR '='
9d98 : bd8aa8                     jsr  LB26F          ; DO A SYNTAX CHECK FOR 
9d9b : 7e8f6e                     jmp  LB73D          ; EVALUATE EXPRESSION, R
                        
                        
                        
                        * DEL
9d9e : 1027eedb         DEL       beq  LB44A          ; 'FC' ERROR IF NO ARGUM
9da2 : bd87c4                     jsr  LAF67          ; CONVERT A DECIMAL BASi
9da5 : bd8554                     jsr  LAD01          ; FIND RAM ADDRESS OF ST
9da8 : 9f93                       stx  VD3            ; SAVE RAM ADDRESS OF ST
9daa : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
9dac : 2710                       beq  L8990          ; BRANCH IF END OF LINE
9dae : 81ae                       cmpa #TOK_MINUS     ; TOKEN FOR '-'
9db0 : 263b                       bne  L89BF          ; TERMINATE COMMAND IF L
9db2 : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
9db4 : 2704                       beq  L898C          ; IF END OF LINE, USE DE
9db6 : 8d24                       bsr  L89AE          ; * CONVERT ENDING LINE 
9db8 : 2004                       bra  L8990          ; * AND SAVE IT IN BINVA
9dba : 86ff             L898C     lda  #$FF           ; = USE $FFXX AS DEFAULT
9dbc : 972b                       sta  BINVAL         ; = LINE NUMBER - SAVE I
9dbe : de93             L8990     ldu  VD3            ; POINT U TO STARTING LI
9dc0 : 8c               L8992     fcb  SKP2           ; SKIP TWO BYTES
9dc1 : eec4             L8993     ldu  ,u             ; POINT U TO START OF NE
9dc3 : ecc4                       ldd  ,u             ; CHECK FOR END OF PROGR
9dc5 : 2706                       beq  L899F          ; BRANCH IF END OF PROGR
9dc7 : ec42                       ldd  $02,u          ; LOAD ACCD WITH THIS LI
9dc9 : 932b                       subd BINVAL         ; SUBTRACT ENDING LINE N
9dcb : 23f4                       bls  L8993          ; BRANCH IF = < ENDING L
9dcd : 9e93             L899F     ldx  VD3            ; GET STARTING LINE NUMB
9dcf : 8d15                       bsr  L89B8          ; MOVE (U) TO (X) UNTIL 
9dd1 : bd8574                     jsr  LAD21          ; RESET BASIC'S INPUT PO
9dd4 : 9e93                       ldx  VD3            ; GET STARTING LINE NUMB
9dd6 : bd8544                     jsr  LACF1          ; RECOMPUTE START OF NEX
9dd9 : 7e84ce                     jmp  LAC73          ; JUMP TO BASIC'S MAIN C
9ddc : bd87c4           L89AE     jsr  LAF67          ; GO GET LINE NUMBER CON
9ddf : 7e81e7                     jmp  LA5C7          ; MAKE SURE THERE'S NO M
9de2 : a6c0             L89B4     lda  ,u+            ; GET A BYTE FROM (U)
9de4 : a780                       sta  ,x+            ; MOVE THE BYTE TO (X)
9de6 : 11931b           L89B8     cmpu VARTAB         ; COMPARE TO END OF BASI
9de9 : 26f7                       bne  L89B4          ; BRANCH IF NOT AT END
9deb : 9f1b                       stx  VARTAB         ; SAVE (X) AS NEW END OF
AS09 Assembler for M6809 [1.42].                                     Page  105
--------------------------------- merge.a09 ----------------------------------

9ded : 39               L89BF     rts
                        
                        
9dee : bd9cd9           L89C0     jsr  L8866          ; 'BS' ERROR IF IN DIREC
9df1 : 9d7c                       jsr  GETNCH         ; GET A CHAR FROM BASIC
9df3 : 8122             L89D2     cmpa #'"'           ; CHECK FOR PROMPT STRIN
9df5 : 260b                       bne  L89E1          ; BRANCH IF NO PROMPT ST
9df7 : bd8a7d                     jsr  LB244          ; STRIP OFF PROMPT STRIN
9dfa : c63b                       ldb  #';'           ; *
9dfc : bd8aa8                     jsr  LB26F          ; * DO A SYNTAX CHECK FO
9dff : bd91ac                     jsr  LB99F          ; REMOVE PROMPT STRING F
9e02 : 327e             L89E1     leas -2,s           ; RESERVE TWO STORAGE SL
9e04 : bd8879                     jsr  LB035          ; INPUT A LINE FROM CURR
9e07 : 3262                       leas $02,s          ; CLEAN UP THE STACK
9e09 : bd8b8a                     jsr  LB357          ; SEARCH FOR A VARIABLE
9e0c : 9f3b                       stx  VARDES         ; SAVE POINTER TO VARIAB
9e0e : bd897f                     jsr  LB146          ; 'TM' ERROR IF VARIABLE
9e11 : 8e00e1                     ldx  #LINBUF        ; POINT X TO THE STRING 
9e14 : 4f                         clra                ; TERMINATOR CHARACTER 0
9e15 : bd8d4f                     jsr  LB51A          ; PARSE THE INPUT STRING
9e18 : 7e8801                     jmp  LAFA4          ; REMOVE DESCRIPTOR FROM
                        		  		  
9e1b : bd87c4           L89FC     jsr  LAF67          ; STRIP A DECIMAL NUMBER
9e1e : 9e2b                       ldx  BINVAL         ; GET BINARY VALUE
9e20 : 39                         rts
9e21 : 9e91             L8A02     ldx  VD1            ; GET CURRENT OLD NUMBER
9e23 : 9f2b             L8A04     stx  BINVAL         ; SAVE THE LINE NUMBER B
9e25 : 7e8554                     jmp  LAD01          ; GO FIND THE LINE NUMBE
                        
                        * RENUM
9e28 : bd8579           RENUM     jsr  LAD26          ; ERASE VARIABLES
9e2b : cc000a                     ldd  #10            ; DEFAULT LINE NUMBER IN
9e2e : dd95                       std  VD5            ; SAVE DEFAULT RENUMBER 
9e30 : dd8f                       std  VCF            ; SAVE DEFAULT INTERVAL
9e32 : 5f                         clrb                ; NOW ACCD = 0
9e33 : dd91                       std  VD1            ; DEFAULT LINE NUMBER OF
9e35 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
9e37 : 2406                       bcc  L8A20          ; BRANCH IF NOT NUMERIC
9e39 : 8de0                       bsr  L89FC          ; CONVERT DECIMAL NUMBER
9e3b : 9f95                       stx  VD5            ; SAVE LINE NUMBER WHERE
9e3d : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
9e3f : 271b             L8A20     beq  L8A3D          ; BRANCH IF END OF LINE
9e41 : bd8aa6                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
9e44 : 2406                       bcc  L8A2D          ; BRANCH IF NEXT CHARACT
9e46 : 8dd3                       bsr  L89FC          ; CONVERT DECIMAL NUMBER
9e48 : 9f91                       stx  VD1            ; SAVE NEW RENUMBER LINE
9e4a : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
9e4c : 270e             L8A2D     beq  L8A3D          ; BRANCH IF END OF LINE
9e4e : bd8aa6                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
9e51 : 2406                       bcc  L8A3A          ; BRANCH IF NEXT CHARACT
9e53 : 8dc6                       bsr  L89FC          ; CONVERT DECIMAL NUMBER
9e55 : 9f8f                       stx  VCF            ; SAVE NEW INTERVAL
9e57 : 2749                       beq  L8A83          ; 'FC' ERROR
9e59 : bd81e7           L8A3A     jsr  LA5C7          ; CHECK FOR MORE CHARACT
9e5c : 8dc3             L8A3D     bsr  L8A02          ; GO GET ADDRESS OF OLD 
9e5e : 9f93                       stx  VD3            ; SAVE ADDRESS
9e60 : 9e95                       ldx  VD5            ; GET NEXT RENUMBERED LI
9e62 : 8dbf                       bsr  L8A04          ; FIND THE LINE NUMBER I
9e64 : 9c93                       cmpx VD3            ; COMPARE TO ADDRESS OF 
9e66 : 253a                       blo  L8A83          ; 'FC' ERROR IF NEW ADDR
9e68 : 8d1c                       bsr  L8A67          ; MAKE SURE RENUMBERED L
9e6a : bd9efc                     jsr  L8ADD          ; CONVERT ASCII LINE NUM
AS09 Assembler for M6809 [1.42].                                     Page  106
--------------------------------- merge.a09 ----------------------------------

9e6d : bd8542                     jsr  LACEF          ; RECALCULATE NEXT LINE 
9e70 : 8daf                       bsr  L8A02          ; GET RAM ADDRESS OF FIR
9e72 : 9f93                       stx  VD3            ; SAVE IT
9e74 : 8d3a                       bsr  L8A91          ; MAKE SURE LINE NUMBERS
9e76 : 8d0f                       bsr  L8A68          ; INSERT NEW LINE NUMBER
9e78 : 8d36                       bsr  L8A91          ; INSERT NEW LINE NUMBER
9e7a : bd9f97                     jsr  L8B7B          ; CONVERT PACKED BINARY 
9e7d : bd8579                     jsr  LAD26          ; ERASE VARIABLES
9e80 : bd8542                     jsr  LACEF          ; RECALCULATE NEXT LINE 
9e83 : 7e84ce                     jmp  LAC73          ; GO BACK TO BASIC'S MAI
9e86 : 86               L8A67     fcb  SKP1LD         ; SKIP ONE BYTE - lda #$
9e87 : 4f               L8A68     clra                ; NEW LINE NUMBER FLAG -
9e88 : 9798                       sta  VD8            ; SAVE NEW LINE NUMBER F
9e8a : 9e93                       ldx  VD3            ; GET ADDRESS OF OLD LIN
9e8c : dc95                       ldd  VD5            ; GET THE CURRENT RENUMB
9e8e : 8d15                       bsr  L8A86          ; RETURN IF END OF PROGR
9e90 : 0d98             L8A71     tst  VD8            ; CHECK NEW LINE NUMBER 
9e92 : 2602                       bne  L8A77          ; BRANCH IF NOT INSERTIN
9e94 : ed02                       std  $02,x          ; STORE THE NEW LINE NUM
9e96 : ae84             L8A77     ldx  ,x             ; POINT X TO THE NEXT LI
9e98 : 8d0b                       bsr  L8A86          ; RETURN IF END OF PROGR
9e9a : d38f                       addd VCF            ; ADD INTERVAL TO CURREN
9e9c : 2504                       blo  L8A83          ; 'FC' ERROR IF LINE NUM
9e9e : 81fa                       cmpa #MAXLIN        ; LARGEST LINE NUMBER = 
9ea0 : 25ee                       blo  L8A71          ; BRANCH IF LEGAL LINE N
9ea2 : 7e8c7d           L8A83     jmp  LB44A          ; 'FC' ERROR IF LINE NUM
                        * TEST THE TWO BYTES POINTED TO BY (X).
                        * NORMAL RETURN IF <> 0. IF = 0 (END OF
                        * PROGRAM) RETURN IS PULLED OFF STACK AND
                        * YOU RETURN TO PREVIOUS SUBROUTINE CALL.
9ea5 : 3406             L8A86     pshs b,a            ; SAVE ACCD
9ea7 : ec84                       ldd  ,x             ; TEST THE 2 BYTES POINT
9ea9 : 3506                       puls a,b            ; RESTORE ACCD
9eab : 2602                       bne  L8A90          ; BRANCH IF NOT END OF P
9ead : 3262                       leas $02,s          ; PURGE RETURN ADDRESS F
9eaf : 39               L8A90     rts
9eb0 : 9e19             L8A91     ldx  TXTTAB         ; GET START OF BASIC PRO
9eb2 : 301f                       leax -1,x           ; MOVE POINTER BACK ONE
9eb4 : 3001             L8A95     leax $01,x          ; MOVE POINTER UP ONE
9eb6 : 8ded                       bsr  L8A86          ; RETURN IF END OF PROGR
9eb8 : 3003             L8A99     leax $03,x          ; SKIP OVER NEXT LINE AD
9eba : 3001             L8A9B     leax $01,x          ; MOVE POINTER TO NEXT C
9ebc : a684                       lda  ,x             ; CHECK CURRENT CHARACTE
9ebe : 27f4                       beq  L8A95          ; BRANCH IF END OF LINE
9ec0 : 9f0f                       stx  TEMPTR         ; SAVE CURRENT POINTER
9ec2 : 4a                         deca                ; =
9ec3 : 270c                       beq  L8AB2          ; =BRANCH IF START OF PA
9ec5 : 4a                         deca                ; *
9ec6 : 272a                       beq  L8AD3          ; *BRANCH IF LINE NUMBER
9ec8 : 4a                         deca                ; =
9ec9 : 26ef                       bne  L8A9B          ; =MOVE TO NEXT CHARACTE
9ecb : 8603             L8AAC     lda  #$03           ; * SET 1ST BYTE = 3 TO 
9ecd : a780                       sta  ,x+            ; * NUMBER DOESN'T CURRE
9ecf : 20e7                       bra  L8A99          ; GO GET ANOTHER CHARACT
9ed1 : ec01             L8AB2     ldd  $01,x          ; GET MS BYTE OF LINE NU
9ed3 : 6a02                       dec  $02,x          ; DECREMENT ZERO CHECK B
9ed5 : 2701                       beq  L8AB9          ; BRANCH IF MS BYTE <> 0
9ed7 : 4f                         clra                ; CLEAR MS BYTE
9ed8 : e603             L8AB9     ldb  $03,x          ; GET LS BYTE OF LINE NU
9eda : 6a04                       dec  $04,x          ; DECREMENT ZERO CHECK F
9edc : 2701                       beq  L8AC0          ; BRANCH IF IS BYTE <> 0
9ede : 5f                         clrb                ; CLEAR LS BYTE
AS09 Assembler for M6809 [1.42].                                     Page  107
--------------------------------- merge.a09 ----------------------------------

9edf : ed01             L8AC0     std  $01,x          ; SAVE BINARY LINE NUMBE
9ee1 : dd2b                       std  BINVAL         ; SAVE TRIAL LINE NUMBER
9ee3 : bd8554                     jsr  LAD01          ; FIND RAM ADDRESS OF A 
9ee6 : 9e0f             L8AC7     ldx  TEMPTR         ; GET BACK POINTER TO ST
9ee8 : 25e1                       blo  L8AAC          ; BRANCH IF NO LINE NUMB
9eea : dc47                       ldd  V47            ; GET START ADDRESS OF L
9eec : 6c80                       inc  ,x+            ; * SET 1ST BYTE = 2, TO
                        *              ; * EXISTENCE OF LINE NUMBER, SET IT = 
                        
9eee : ed84                       std  ,x             ; SAVE RAM ADDRESS OF CO
9ef0 : 20c6                       bra  L8A99          ; GO GET ANOTHER CHARACT
9ef2 : 6f84             L8AD3     clr  ,x             ; CLEAR CARRY FLAG AND 1
9ef4 : ae01                       ldx  $01,x          ; POINT X TO RAM ADDRESS
9ef6 : ae02                       ldx  $02,x          ; PUT CORRECT LINE NUMBE
9ef8 : 9f47                       stx  V47            ; SAVE IT TEMPoraRILY
9efa : 20ea                       bra  L8AC7          ; GO INSERT IT INTO BASI
9efc : 9e19             L8ADD     ldx  TXTTAB         ; GET BEGINNING OF BASIC
9efe : 2004                       bra  L8AE5
9f00 : 9e83             L8AE1     ldx  CHARAD         ; *GET CURRENT INPUT POI
9f02 : 3001                       leax $01,x          ; *AND BUMP IT ONE
9f04 : 8d9f             L8AE5     bsr  L8A86          ; RETURN IF END OF PROGR
9f06 : 3002                       leax $02,x          ; SKIP PAST NEXT LINE AD
9f08 : 3001             L8AE9     leax $01,x          ; ADVANCE POINTER BY ONE
9f0a : 9f83             L8AEB     stx  CHARAD         ; SAVE NEW BASIC INPUT P
9f0c : 9d7c             L8AED     jsr  GETNCH         ; GET NEXT CHARACTER FRO
9f0e : 4d               L8AEF     tsta                ; CHECK THE CHARACTER
9f0f : 27ef                       beq  L8AE1          ; BRANCH IF END OF LINE
9f11 : 2af9                       bpl  L8AED          ; BRANCH IF NOT A TOKEN
9f13 : 9e83                       ldx  CHARAD         ; GET CURRENT INPUT POIN
9f15 : 81ff                       cmpa #$FF           ; IS THIS A SECONDARY TO
9f17 : 27ef                       beq  L8AE9          ; YES - IGNORE IT
9f19 : 81a9                       cmpa #TOK_THEN      ; TOKEN FOR THEN?
9f1b : 2712                       beq  L8B13          ; YES
9f1d : 8184                       cmpa #TOK_ELSE      ; TOKEN FOR ELSE?
9f1f : 270e                       beq  L8B13          ; YES
9f21 : 8181                       cmpa #TOK_GO        ; TOKEN FOR GO?
9f23 : 26e7                       bne  L8AED          ; NO
9f25 : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
9f27 : 81a7                       cmpa #TOK_TO        ; TOKEN FOR TO?
9f29 : 2704                       beq  L8B13          ; YES
9f2b : 81a8                       cmpa #TOK_SUB       ; TOKEN FOR SUB?
9f2d : 26db                       bne  L8AEB          ; NO
9f2f : 9d7c             L8B13     jsr  GETNCH         ; GET A CHARACTER FROM B
9f31 : 2504                       blo  L8B1B          ; BRANCH IF NUMERIC
9f33 : 9d82             L8B17     jsr  GETCCH         ; GET CURRENT BASIC INPU
9f35 : 20d7                       bra  L8AEF          ; KEEP CHECKING THE LINE
9f37 : 9e83             L8B1B     ldx  CHARAD         ; GET CURRENT INPUT ADDR
9f39 : 3410                       pshs x              ; SAVE IT ON THE STACK
9f3b : bd87c4                     jsr  LAF67          ; CONVERT DECIMAL BASIC 
9f3e : 9e83                       ldx  CHARAD         ; GET CURRENT INPUT POIN
9f40 : a682             L8B24     lda  ,-x            ; GET PREVIOUS INPUT CHA
9f42 : bda2a7                     jsr  L90AA          ; CLEAR CARRY IF NUMERIC
9f45 : 25f9                       blo  L8B24          ; BRANCH IF NON-NUMERIC
9f47 : 3001                       leax $01,x          ; MOVE POINTER UP ONE
9f49 : 1f10                       tfr  x,d            ; NOW ACCD POINTS TO ONE
9f4b : e061                       subb $01,s          ; SUBTRACT PRE-NUMERIC P
9f4d : c005                       subb #$05           ; MAKE SURE THERE ARE AT
                        *
9f4f : 2720                       beq  L8B55          ; BRANCH IF EXACTLY 5
9f51 : 250a                       blo  L8B41          ; BRANCH IF < 5
9f53 : 3384                       leau ,x             ; TRANSFER X TO U
9f55 : 50                         negb                ; NEGATE B
AS09 Assembler for M6809 [1.42].                                     Page  108
--------------------------------- merge.a09 ----------------------------------

9f56 : 3085                       leax b,x            ; MOVE X BACK B BYTES
9f58 : bd9de6                     jsr  L89B8          ; *MOVE BYTES FROM (U) T
                        *         *U   = END OF BASIC; (I) = NEW END OF BASIC
9f5b : 2014                       bra  L8B55
                        * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER
9f5d : 9f47             L8B41     stx  V47            ; SAVE END OF NUMERIC VA
9f5f : 9e1b                       ldx  VARTAB         ; GET END OF BASIC PROGR
9f61 : 9f43                       stx  V43            ; SAVE IT
9f63 : 50                         negb                ; NEGATE B
9f64 : 3085                       leax b,x            ; ADD IT TO END OF NUMER
9f66 : 9f41                       stx  V41            ; SAVE POINTER
9f68 : 9f1b                       stx  VARTAB         ; STORE END OF BASIC PRO
9f6a : bd8487                     jsr  LAC1E          ; ACCD = TOP OF ARRAYS -
9f6d : 9e45                       ldx  V45            ; * GET AND SAVE THE
9f6f : 9f83                       stx  CHARAD         ; * NEW CURRENT INPUT PO
9f71 : 3510             L8B55     puls x              ; RESTORE POINTER TO STA
9f73 : 8601                       lda  #$01           ; NEW LINE NUMBER FLAG
9f75 : a784                       sta  ,x             ; * SAVE NEW LINE FLAG
9f77 : a702                       sta  $02,x          ; *
9f79 : a704                       sta  $04,x          ; *
9f7b : d62b                       ldb  BINVAL         ; GET MS BYTE OF BINARY 
9f7d : 2604                       bne  L8B67          ; BRANCH IF IT IS NOT ZE
9f7f : c601                       ldb  #$01           ; ; SAVE A 1 IF BYTE IS 
                        *              ; THINK IT IS THE END OF A LINE
9f81 : 6c02                       inc  $02,x          ; IF 2,x = 2, THEN PREVI
9f83 : e701             L8B67     stb  $01,x          ; SAVE MS BYTE OF BINARY
9f85 : d62c                       ldb  BINVAL+1       ; GET IS BYTE OF BINARY 
9f87 : 2604                       bne  L8B71          ; BRANCH IF NOT A ZERO B
9f89 : c601                       ldb  #$01           ; SAVE A 1 IF BYTE IS A 
9f8b : 6c04                       inc  $04,x          ; IF 4,x = 2, THEN PREVI
9f8d : e703             L8B71     stb  $03,x          ; SAVE LS BYTE OF BINARY
9f8f : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
9f91 : 812c                       cmpa #','            ; IS IT A COMMA?
9f93 : 279a                       beq  L8B13          ; YES - PROCESS ANOTHER 
9f95 : 209c                       bra  L8B17          ; NO - GO GET AND PROCES
9f97 : 9e19             L8B7B     ldx  TXTTAB         ; POINT X TO START OF BA
9f99 : 301f                       leax -1,x           ; MOVE POINTER BACK ONE
9f9b : 3001             L8B7F     leax $01,x          ; MOVE POINTER UP ONE
9f9d : ec02                       ldd  $02,x          ; GET ADDRESS OF NEXT LI
9f9f : dd68                       std  CURLIN         ; SAVE IT IN CURLIN
9fa1 : bd9ea5                     jsr  L8A86          ; RETURN IF END OF PROGR
9fa4 : 3003                       leax $03,x          ; SKIP OVER ADDRESS OF N
9fa6 : 3001             L8B8A     leax $01,x          ; MOVE POINTER UP ONE
9fa8 : a684             L8B8C     lda  ,x             ; GET CURRENT CHARACTER
9faa : 27ef                       beq  L8B7F          ; BRANCH IF END OF LINE
9fac : 4a                         deca                ; INPUT CHARACTER = 1? -
9fad : 271b                       beq  L8BAE          ; YES
9faf : 8002                       suba #$02           ; INPUT CHARACTER 3? - U
9fb1 : 26f3                       bne  L8B8A          ; NO
9fb3 : 3410                       pshs x              ; SAVE CURRENT POSITION 
9fb5 : 8e9ff4                     ldx  #L8BD9-1       ; POINT X TO 'UL' MESSAG
9fb8 : bd91a9                     jsr  LB99C          ; PRINT STRING TO THE SC
9fbb : aee4                       ldx  ,s             ; GET INPUT POINTER
9fbd : ec01                       ldd  $01,x          ; GET THE UNDEFINED LINE
9fbf : bd95d9                     jsr  LBDCC          ; CONVERT NUMBER IN ACCD
9fc2 : bd95d2                     jsr  LBDC5          ; PRINT 'IN XXXX' XXXX =
9fc5 : bd916a                     jsr  LB958          ; SEND A CR TO CONSOLE O
9fc8 : 3510                       puls x              ; GET INPUT POINTER BACK
9fca : 3410             L8BAE     pshs x              ; SAVE CURRENT POSITION 
9fcc : ec01                       ldd  $01,x          ; LOAD ACCD WITH BINARY 
9fce : dd52                       std  FPA0+2         ; SAVE IN BOTTOM 2 BYTES
9fd0 : bd9c81                     jsr  L880E          ; ADJUST REST OF FPA0 AS
AS09 Assembler for M6809 [1.42].                                     Page  109
--------------------------------- merge.a09 ----------------------------------

9fd3 : bd95e6                     jsr  LBDD9          ; CONVERT FPA0 TO ASCII,
9fd6 : 3540                       puls u              ; LOAD U WITH PREVIOUS A
9fd8 : c605                       ldb  #$05           ; EACH EXPANDED LINE NUM
9fda : 3001             L8BBE     leax $01,x          ; MOVE POINTER FORWARD O
9fdc : a684                       lda  ,x             ; GET AN ASCII BYTE
9fde : 2705                       beq  L8BC9          ; BRANCH IF END OF NUMBE
9fe0 : 5a                         decb                ; DECREMENT BYTE COUNTER
9fe1 : a7c0                       sta  ,u+            ; STORE ASCII NUMBER IN 
9fe3 : 20f5                       bra  L8BBE          ; CHECK FOR ANOTHER DIGI
9fe5 : 30c4             L8BC9     leax ,u             ; TRANSFER NEW LINE POIN
9fe7 : 5d                         tstb                ; DOES THE NEW LINE NUMB
9fe8 : 27be                       beq  L8B8C          ; YES - GO GET ANOTHER I
9fea : 31c4                       leay ,u             ; SAVE NEW LINE POINTER 
9fec : 33c5                       leau b,u            ; POINT U TO END OF 5 BY
9fee : bd9de6                     jsr  L89B8          ; MOVE BYTES FROM (U) TO
9ff1 : 30a4                       leax ,y             ; LOAD (X) WITH NEW LINE
9ff3 : 20b3                       bra  L8B8C          ; GO GET ANOTHER INPUT C
                        
9ff5 : 554c20           L8BD9     fcc  "UL "          ; UNKNOWN LINE NUMBER ME
9ff8 : 00                         fcb  0
                        
                        
9ff9 : bd8f71           HEXDOL    jsr  LB740          ; CONVERT FPA0 INTO A PO
9ffc : 8e01de                     ldx  #STRBUF+2      ; POINT TO TEMPORARY BUF
9fff : c604                       ldb  #$04           ; CONVERT 4 NIBBLES
a001 : 3404             L8BE5     pshs b              ; SAVE NIBBLE COUNTER
a003 : 5f                         clrb                ; CLEAR CARRY FLAG
a004 : 8604                       lda  #$04           ; 4 SHIFTS
a006 : 0853             L8BEA     asl  FPA0+3         ; * SHIFT BOTTOM TWO BYT
a008 : 0952                       rol  FPA0+2         ; * FPA0 LEFT ONE BIT (X
a00a : 59                         rolb                ; IF OVERFLOW, ACCB <> 0
a00b : 4a                         deca                ; * DECREMENT SHIFT COUN
a00c : 26f8                       bne  L8BEA          ; * BRANCH IF NOT DONE
a00e : 5d                         tstb                ; CHECK FOR OVERFLOW
a00f : 260a                       bne  L8BFF          ; BRANCH IF OVERFLOW
a011 : a6e4                       lda  ,s             ; * GET NIBBLE COUNTER,
a013 : 4a                         deca                ; * DECREMENT IT AND
a014 : 2705                       beq  L8BFF          ; * BRANCH IF DONE
a016 : 8c01de                     cmpx #STRBUF+2      ; DO NOT DO A CONVERSION
a019 : 270c                       beq  L8C0B          ; BYTE IS FOUND - LEADIN
a01b : cb30             L8BFF     addb #'0'            ; ADD IN ASCII ZERO
a01d : c139                       cmpb #'9'           ; COMPARE TO ASCII 9
a01f : 2302                       bls  L8C07          ; BRANCH IF < 9
a021 : cb07                       addb #7             ; ADD ASCII OFFSET IF HE
a023 : e780             L8C07     stb  ,x+            ; STORE HEX VALUE AND AD
a025 : 6f84                       clr  ,x             ; CLEAR NEXT BYTE - END 
a027 : 3504             L8C0B     puls b              ; * GET NIBBLE COUNTER,
a029 : 5a                         decb                ; * DECREMENT IT AND
a02a : 26d5                       bne  L8BE5          ; * BRANCH IF NOT DONE
a02c : 3262                       leas $02,s          ; PURGE RETURN ADDRESS O
a02e : 8e01dd                     ldx  #STRBUF+1      ; RESET POINTER
a031 : 7e8d4b                     jmp  LB518          ; SAVE STRING ON STRING 
                        * PROCESS EXCLAMATION POINT
a034 : 8601             L8E37     lda  #$01           ; * SET SPACES
a036 : 9799                       sta  VD9            ; * COUNTER = 1		 
                        * PROCESS STRING ITEM - LIST
a038 : 5a               L8E3B     decb                ; DECREMENT FORMAT STRIN
a039 : bda1d5                     jsr  L8FD8          ; SEND A '+' TO CONSOLE 
a03c : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
a03e : 10270093                   lbeq L8ED8          ; EXIT PRINT USING IF EN
a042 : d793                       stb  VD3            ; SAVE REMAINDER FORMAT 
a044 : bd898f                     jsr  LB156          ; EVALUATE EXPRESSION
AS09 Assembler for M6809 [1.42].                                     Page  110
--------------------------------- merge.a09 ----------------------------------

a047 : bd897f                     jsr  LB146          ; 'TM' ERROR IF NUMERIC 
a04a : 9e52                       ldx  FPA0+2         ; * GET ITEM - LIST DESC
a04c : 9f4d                       stx  V4D            ; * AND SAVE IT IN V4D
a04e : d699                       ldb  VD9            ; GET SPACES COUNTER
a050 : bd8edf                     jsr  LB6AD          ; PUT ACCB BYTES INTO ST
a053 : bd91ac                     jsr  LB99F          ; PRINT THE FORMATTED ST
                        * PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING 
a056 : 9e52                       ldx  FPA0+2         ; POINT X TO FORMATTED S
a058 : d699                       ldb  VD9            ; GET SPACES COUNTER
a05a : e084                       subb ,x             ; SUBTRACT LENGTH OF FOR
a05c : 5a               L8E5F     decb                ; DECREMENT DIFFERENCE
a05d : 102b014f                   lbmi L8FB3          ; GO INTERPRET ANOTHER I
a061 : bd91b9                     jsr  LB9AC          ; PAD FORMAT STRING WITH
a064 : 20f6                       bra  L8E5F          ; KEEP PADDING
                        * PERCENT SIGN - PROCESS A %SPACES% COMMAND
a066 : d793             L8E69     stb  VD3            ; * SAVE THE CURRENT FOR
a068 : 9f0f                       stx  TEMPTR         ; * COUNTER AND POINTER
a06a : 8602                       lda  #$02           ; INITIAL SPACES COUNTER
a06c : 9799                       sta  VD9            ; SAVE IN SPACES COUNTER
a06e : a684             L8E71     lda  ,x             ; GET A CHARACTER FROM F
a070 : 8125                       cmpa #'%'           ; COMPARE TO TERMINATOR 
a072 : 27c4                       beq  L8E3B          ; BRANCH IF END OF SPACE
a074 : 8120                       cmpa #' '           ; BLANK
a076 : 2607                       bne  L8E82          ; BRANCH IF ILLEGAL CHAR
a078 : 0c99                       inc  VD9            ; ADD ONE TO SPACES COUN
a07a : 3001                       leax $01,x          ; MOVE FORMAT POINTER UP
a07c : 5a                         decb                ; DECREMENT LENGTH COUNT
a07d : 26ef                       bne  L8E71          ; BRANCH IF NOT END OF F
a07f : 9e0f             L8E82     ldx  TEMPTR         ; * RESTORE CURRENT FORM
a081 : d693                       ldb  VD3            ; * AND POINTER TO POSIT
a083 : 8625                       lda  #'%'           ; SEND A '%' TO CONSOLE 
                        * ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN
a085 : bda1d5           L8E88     jsr  L8FD8          ; SEND A '+' TO CONSOLE 
a088 : bd805c                     jsr  PUTCHR         ; SEND CHARACTER TO CONS
a08b : 2029                       bra  L8EB9          ; GET NEXT CHARACTER IN 
                        
                        * PRINT RAM HOOK
a08d : 81b8             XVEC9     cmpa #TOK_USING     ; USING TOKEN
a08f : 2701                       beq  L8E95          ; BRANCH IF PRINT USING
a091 : 39                         rts
                        
                        * PRINT USING
                        * VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE
                        * BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FOR
                        * BIT 3 = PRE SIGN FORCE; BIT 2 = POST SIGN FORCE; BIT
a092 : 3262             L8E95     leas $02,s          ; PURGE RETURN ADDRESS O
a094 : bd8991                     jsr  LB158          ; EVALUATE FORMAT STRING
a097 : bd897f                     jsr  LB146          ; 'TM' ERROR IF VARIABLE
a09a : c63b                       ldb  #';'           ; CHECK FOR ITEM LIST SE
a09c : bd8aa8                     jsr  LB26F          ; SYNTAX CHECK FOR ;
a09f : 9e52                       ldx  FPA0+2         ; * GET FORMAT STRING DE
a0a1 : 9f95                       stx  VD5            ; * AND SAVE IT IN VD5
a0a3 : 2006                       bra  L8EAE          ; GO PROCESS FORMAT STRI
a0a5 : 9697             L8EA8     lda  VD7            ; *CHECK NEXT PRINT ITEM
a0a7 : 2708                       beq  L8EB4          ; *'FC' ERROR IF NO FURT
a0a9 : 9e95                       ldx  VD5            ; RESET FORMAT STRING PO
a0ab : 0f97             L8EAE     clr  VD7            ; RESET NEXT PRINT ITEM 
a0ad : e684                       ldb  ,x             ; GET LENGTH OF FORMAT S
a0af : 2603                       bne  L8EB7          ; INTERPRET FORMAT STRIN
a0b1 : 7e8c7d           L8EB4     jmp  LB44A          ; 'FC' ERROR IF FORMAT S
a0b4 : ae02             L8EB7     ldx  $02,x          ; POINT X TO START OF FO
                        * INTERPRET THE FORMAT STRING
AS09 Assembler for M6809 [1.42].                                     Page  111
--------------------------------- merge.a09 ----------------------------------

a0b6 : 0f9a             L8EB9     clr  VDA            ; CLEAR THE STATUS BYTE
a0b8 : 0f99             L8EBB     clr  VD9            ; CLEAR LEFT DIGIT COUNT
a0ba : a680                       lda  ,x+            ; GET A CHARACTER FROM F
a0bc : 8121                       cmpa #'!'           ; EXCLAMATION POINT?
a0be : 1027ff72                   beq L8E37           ; YES - STRING TYPE FORM
a0c2 : 8123                       cmpa #'#'           ; NUMBER SIGN? (DIGIT LO
a0c4 : 275b                       beq  L8F24          ; YES - NUMERIC TYPE FOR
a0c6 : 5a                         decb                ; DECREMENT FORMAT STRIN
a0c7 : 2616                       bne  L8EE2          ; BRANCH IF NOT DONE
a0c9 : bda1d5                     jsr  L8FD8          ; SEND A '+' TO CONSOLE 
a0cc : bd805c                     jsr  PUTCHR         ; SEND CHARACTER TO CONS
a0cf : 9d82             L8ED2     jsr  GETCCH         ; GET CURRENT CHARACTER 
a0d1 : 26d2                       bne  L8EA8          ; BRANCH IF NOT END OF L
a0d3 : 9697                       lda  VD7            ; GET NEXT PRINT ITEM FL
a0d5 : 2603             L8ED8     bne  L8EDD          ; BRANCH IF MORE PRINT I
a0d7 : bd916a                     jsr  LB958          ; SEND A CARRIAGE RETURN
a0da : 9e95             L8EDD     ldx  VD5            ; POINT X TO FORMAT STRI
a0dc : 7e8e8b                     jmp  LB659          ; RETURN ADDRESS AND LEN
a0df : 812b             L8EE2     cmpa #'+'           ; CHECK FOR '+' (PRE-SIG
a0e1 : 2609                       bne  L8EEF          ; NO PLUS
a0e3 : bda1d5                     jsr  L8FD8          ; SEND A '+' TO CONSOLE 
a0e6 : 8608                       lda  #$08           ; * LOAD THE STATUS BYTE
a0e8 : 979a                       sta  VDA            ; * PRE-SIGN FORCE FLAG
a0ea : 20cc                       bra  L8EBB          ; INTERPRET THE REST OF 
a0ec : 812e             L8EEF     cmpa #'.'           ; DECIMAL POINT?
a0ee : 274e                       beq  L8F41          ; YES
a0f0 : 8125                       cmpa #'%'           ; PERCENT SIGN?
a0f2 : 1027ff70                   lbeq L8E69          ; YES
a0f6 : a184                       cmpa ,x             ; COMPARE THE PRESENT FO
                        *              ; CHARACTER TO THE NEXT ONE IN THE STRI
a0f8 : 268b             L8EFB     bne  L8E88          ; NO MATCH - ILLEGAL CHA
                        * TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING
a0fa : 8124                       cmpa #'$'           ; DOLLAR SIGN?
a0fc : 2719                       beq  L8F1A          ; YES - MAKE THE DOLLAR 
a0fe : 812a                       cmpa #'*'           ; ASTERISK?
a100 : 26f6                       bne  L8EFB          ; NO - ILLEGAL CHARACTER
a102 : 969a                       lda  VDA            ; * GRAB THE STATUS BYTE
a104 : 8a20                       ora  #$20           ; * TO INDICATE THAT THE
a106 : 979a                       sta  VDA            ; * BE LEFT PADDED WITH 
a108 : c102                       cmpb #2             ; * CHECK TO SEE IF THE 
a10a : 2511                       blo  L8F20          ; * CHARACTERS IN THE FO
a10c : a601                       lda  $01,x          ; GET THE NEXT CHARACTER
a10e : 8124                       cmpa #'$'           ; CHECK FOR **$
a110 : 260b                       bne  L8F20          ; CHECK FOR MORE CHARACT
a112 : 5a                         decb                ; DECREMENT STRING LENGT
a113 : 3001                       leax $01,x          ; MOVE FORMAT STRING POI
a115 : 0c99                       inc  VD9            ; ADD ONE TO LEFT DIGIT 
                        *              ; FLOATING DOLLAR SIGN COMBINATION
a117 : 969a             L8F1A     lda  VDA            ; * GET THE STATUS BYTE 
a119 : 8a10                       ora  #$10           ; * BIT 4 TO INDICATE A
a11b : 979a                       sta  VDA            ; * FLOATING DOLLAR SIGN
a11d : 3001             L8F20     leax $01,x          ; MOVE FORMAT STRING POI
a11f : 0c99                       inc  VD9            ; ADD ONE TO LEFT DIGIT 
                        * PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT 
a121 : 0f98             L8F24     clr  VD8            ; CLEAR THE RIGHT DIGIT 
a123 : 0c99             L8F26     inc  VD9            ; ADD ONE TO LEFT DIGIT 
a125 : 5a                         decb                ; DECREMENT FORMAT STRIN
a126 : 2749                       beq  L8F74          ; BRANCH IF END OF FORMA
a128 : a680                       lda  ,x+            ; GET THE NEXT FORMAT CH
a12a : 812e                       cmpa #'.'           ; DECIMAL POINT?
a12c : 271e                       beq  L8F4F          ; YES
a12e : 8123                       cmpa #'#'           ; NUMBER SIGN?
AS09 Assembler for M6809 [1.42].                                     Page  112
--------------------------------- merge.a09 ----------------------------------

a130 : 27f1                       beq  L8F26          ; YES
a132 : 812c                       cmpa #','            ; COMMA?
a134 : 2621                       bne  L8F5A          ; NO
a136 : 969a                       lda  VDA            ; * GET THE STATUS BYTE
a138 : 8a40                       ora  #$40           ; * AND SET BIT 6 WHICH 
a13a : 979a                       sta  VDA            ; * COMMA SEPARATOR FLAG
a13c : 20e5                       bra  L8F26          ; PROCESS MORE CHARACTER
                        * PROCESS DECIMAL POINT IF NO DIGITS TO LEFT OF IT
a13e : a684             L8F41     lda  ,x             ; GET NEXT FORMAT CHARAC
a140 : 8123                       cmpa #'#'           ; IS IT A NUMBER SIGN?
a142 : 1026ff3f                   lbne L8E88          ; NO
a146 : 8601                       lda  #1             ; * SET THE RIGHT DIGIT 
a148 : 9798                       sta  VD8            ; * ALLOW ONE SPOT FOR D
a14a : 3001                       leax $01,x          ; MOVE FORMAT POINTER UP
                        * PROCESS DIGITS TO RIGHT OF DECIMAL POINT
a14c : 0c98             L8F4F     inc  VD8            ; ADD ONE TO RIGHT DIGIT
a14e : 5a                         decb                ; DECREMENT FORMAT LENGT
a14f : 2720                       beq  L8F74          ; BRANCH IF END OF FORMA
a151 : a680                       lda  ,x+            ; GET A CHARACTER FROM F
a153 : 8123                       cmpa #'#'           ; IS IT NUMBER SIGN?
a155 : 27f5                       beq  L8F4F          ; YES - KEEP CHECKING
                        * CHECK FOR EXPONENTIAL FORCE
a157 : 815e             L8F5A     cmpa #$5E           ; CHECK FOR UP ARROW
a159 : 2616                       bne  L8F74          ; NO UP ARROW
a15b : a184                       cmpa ,x             ; IS THE NEXT CHARACTER 
a15d : 2612                       bne  L8F74          ; NO
a15f : a101                       cmpa $01,x          ; AND THE NEXT CHARACTER
a161 : 260e                       bne  L8F74          ; NO
a163 : a102                       cmpa $02,x          ; HOW ABOUT THE 4TH CHAR
a165 : 260a                       bne  L8F74          ; NO, ALSO
a167 : c104                       cmpb #4             ; * CHECK TO SEE IF THE 
a169 : 2506                       blo  L8F74          ; * FORMAT STRING AND BR
a16b : c004                       subb #4             ; * MOVE POINTER UP 4 AN
a16d : 3004                       leax $04,x          ; * FOUR FROM LENGTH
a16f : 0c9a                       inc  VDA            ; INCREMENT STATUS BYTE 
                        
                        * CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMA
a171 : 301f             L8F74     leax -1,x           ; MOVE POINTER BACK ONE
a173 : 0c99                       inc  VD9            ; ADD ONE TO LEFT DIGIT 
a175 : 969a                       lda  VDA            ; * PRE-SIGN
a177 : 8508                       bita #$08           ; * FORCE AND
a179 : 2618                       bne  L8F96          ; * BRANCH IF SET
a17b : 0a99                       dec  VD9            ; DECREMENT LEFT DIGIT -
a17d : 5d                         tstb                ; * CHECK LENGTH COUNTER
a17e : 2713                       beq  L8F96          ; * IF END OF FORMAT STR
a180 : a684                       lda  ,x             ; GET NEXT FORMAT STRING
a182 : 802d                       suba #'-'           ; CHECK FOR MINUS SIGN
a184 : 2706                       beq  L8F8F          ; BRANCH IF MINUS SIGN
a186 : 81fe                       cmpa #$FE           ; * WAS cmpa #('+')-('-'
a188 : 2609                       bne  L8F96          ; BRANCH IF NO PLUS SIGN
a18a : 8608                       lda  #$08           ; GET THE PRE-SIGN FORCE
a18c : 8a04             L8F8F     ora  #$04           ; 'OR' IN POST-SIGN FORC
a18e : 9a9a                       ora  VDA            ; 'OR' IN THE STATUS BYT
a190 : 979a                       sta  VDA            ; SAVE THE STATUS BYTE
a192 : 5a                         decb                ; DECREMENT FORMAT STRIN
                        
                        * EVALUATE NUMERIC ITEM-LIST
a193 : 9d82             L8F96     jsr  GETCCH         ; GET CURRENT CHARACTER
a195 : 1027ff3c                   lbeq L8ED8          ; BRANCH IF END OF LINE
a199 : d793                       stb  VD3            ; SAVE FORMAT STRING LEN
a19b : bd897a                     jsr  LB141          ; EVALUATE EXPRESSION
a19e : 9699                       lda  VD9            ; GET THE LEFT DIGIT COU
AS09 Assembler for M6809 [1.42].                                     Page  113
--------------------------------- merge.a09 ----------------------------------

a1a0 : 9b98                       adda VD8            ; ADD IT TO THE RIGHT DI
a1a2 : 8111                       cmpa #17            ; *
a1a4 : 1022ead5                   lbhi LB44A          ; *'FC' ERROR IF MORE TH
a1a8 : bda1e2                     jsr  L8FE5          ; CONVERT ITEM-LIST TO F
a1ab : 301f                       leax -1,x           ; MOVE BUFFER POINTER BA
a1ad : bd91a9                     jsr  LB99C          ; DISPLAY THE FORMATTED 
a1b0 : 0f97             L8FB3     clr  VD7            ; RESET NEXT PRINT ITEM 
a1b2 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
a1b4 : 270d                       beq  L8FC6          ; BRANCH IF END OF LINE
a1b6 : 9797                       sta  VD7            ; SAVE CURRENT CHARACTER
a1b8 : 813b                       cmpa #';'           ; * CHECK FOR ; - ITEM-L
a1ba : 2705                       beq  L8FC4          ; * BRANCH IF SEMICOLON
a1bc : bd8aa6                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
a1bf : 2002                       bra  L8FC6          ; PROCESS NEXT PRINT ITE
a1c1 : 9d7c             L8FC4     jsr  GETNCH         ; GET NEXT INPUT CHARACT
a1c3 : 9e95             L8FC6     ldx  VD5            ; GET FORMAT STRING DESC
a1c5 : e684                       ldb  ,x             ; GET LENGTH OF FORMAT S
a1c7 : d093                       subb VD3            ; SUBTRACT AMOUNT OF FOR
a1c9 : ae02                       ldx  $02,x          ; *GET FORMAT STRING STA
a1cb : 3a                         abx                 ; *POINTER TO START OF U
a1cc : d693                       ldb  VD3            ; * GET AMOUNT OF UNUSED
a1ce : 1026fee4                   lbne L8EB9          ; * REINTERPRET FORMAT S
a1d2 : 7ea0cf                     jmp  L8ED2          ; REINTERPRET FORMAT STR
                        *         USED ON LAST PRINT ITEM
                        
                        * PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
a1d5 : 3402             L8FD8     pshs a              ; RESTORE ACCA AND RETUR
a1d7 : 862b                       lda  #'+'           ; GET ASCII PLUS SIGN
a1d9 : 0d9a                       tst  VDA            ; * CHECK THE STATUS BYT
a1db : 2703                       beq  L8FE3          ; * RETURN IF = 0
a1dd : bd805c                     jsr  PUTCHR         ; SEND A CHARACTER TO CO
a1e0 : 3582             L8FE3     puls a,pc           ; RETURN ACCA AND RETURN
                        
                        * CONVERT ITEM-LIST TO DECIMAL ASCII STRING
a1e2 : ce01e0           L8FE5     ldu  #STRBUF+4      ; POINT U TO STRING BUFF
a1e5 : c620                       ldb  #SPACE         ; BLANK
a1e7 : 969a                       lda  VDA            ; * GET THE STATUS FLAG 
a1e9 : 8508                       bita #$08           ; * CHECK FOR A PRE-SIGN
a1eb : 2702                       beq  L8FF2          ; * BRANCH IF NO PRE-SIG
a1ed : c62b                       ldb  #'+'           ; PLUS SIGN
a1ef : 0d54             L8FF2     tst  FP0SGN         ; CHECK THE SIGN OF FPA0
a1f1 : 2a04                       bpl  L8FFA          ; BRANCH IF POSITIVE
a1f3 : 0f54                       clr  FP0SGN         ; FORCE FPA0 SIGN TO BE 
a1f5 : c62d                       ldb  #'-'           ; MINUS SIGN
a1f7 : e7c0             L8FFA     stb  ,u+            ; SAVE THE SIGN IN BUFFE
a1f9 : c630                       ldb  #'0'            ; * PUT A ZERO INTO THE
a1fb : e7c0                       stb  ,u+            ; *
a1fd : 8401                       anda #$01           ; * CHECK THE EXPONENTIA
a1ff : 10260107                   lbne L910D          ; * THE STATUS BYTE - BR
a203 : 8e95cd                     ldx  #LBDC0         ; POINT X TO FLOATING PO
a206 : bd94ad                     jsr  LBCA0          ; COMPARE FPA0 TO (X)
a209 : 2b15                       bmi  L9023          ; BRANCH IF FPA0 < 1E+09
a20b : bd95e6                     jsr  LBDD9          ; CONVERT FP NUMBER TO A
a20e : a680             L9011     lda  ,x+            ; * ADVANCE POINTER TO E
a210 : 26fc                       bne  L9011          ; * ASCII STRING (ZERO B
a212 : a682             L9015     lda  ,-x            ; MOVE THE
a214 : a701                       sta  $01,x          ; ENTIRE STRING
a216 : 8c01df                     cmpx #STRBUF+3      ; UP ONE
a219 : 26f7                       bne  L9015          ; BYTE
a21b : 8625                       lda  #'%'           ; * INSERT A % SIGN AT S
a21d : a784                       sta  ,x             ; * STRING - OVERFLOW ER
a21f : 39                         rts
AS09 Assembler for M6809 [1.42].                                     Page  114
--------------------------------- merge.a09 ----------------------------------

                        
a220 : 964f             L9023     lda  FP0EXP         ; GET EXPONENT OF FPA0
a222 : 9747                       sta  V47            ; AND SAVE IT IN V74
a224 : 2703                       beq  L902C          ; BRANCH IF FPA0 = 0
a226 : bda3ca                     jsr  L91CD          ; CONVERT FPA0 TO NUMBER
                        *              ; PLACES TO LEFT OF DECIMAL POINT
a229 : 9647             L902C     lda  V47            ; GET BASE 10 EXPONENT O
a22b : 102b0081                   lbmi L90B3          ; BRANCH IF FPA0 < 100,0
a22f : 40                         nega                ; * CALCULATE THE NUMBER
a230 : 9b99                       adda VD9            ; * SUBTRACT BASE 10 EXP
a232 : 8009                       suba #$09           ; * 9 PLACES TO LEFT OF 
a234 : bda2e7                     jsr  L90EA          ; PUT ACCA ZEROES IN STR
a237 : bda460                     jsr  L9263          ; INITIALIZE DECIMAL POI
a23a : bda3ff                     jsr  L9202          ; CONVERT FPA0 TO DECIMA
a23d : 9647                       lda  V47            ; * GET BASE 10 EXPONENT
a23f : bda47e                     jsr  L9281          ; * ZEROES IN STRING BUF
a242 : 9647                       lda  V47            ; WASTED INSTRUCTION - S
a244 : bda446                     jsr  L9249          ; CHECK FOR DECIMAL POIN
a247 : 9698                       lda  VD8            ; GET THE RIGHT DIGIT CO
a249 : 2602                       bne  L9050          ; BRANCH IF RIGHT DIGlT 
a24b : 335f                       leau -1,u           ; * MOVE BUFFER POINTER 
                        *                             ; * DECIMAL POINT IF NO 
a24d : 4a               L9050     deca                ; SUBTRACT ONE (DECIMAL 
a24e : bda2e7                     jsr  L90EA          ; PUT ACCA ZEROES INTO B
a251 : bda382           L9054     jsr  L9185          ; INSERT ASTERISK PADDIN
a254 : 4d                         tsta                ; WAS THERE A POST-SIGN?
a255 : 2706                       beq  L9060          ; NO
a257 : c12a                       cmpb #'*'           ; IS THE FIRST CHARACTER
a259 : 2702                       beq  L9060          ; YES
a25b : e7c0                       stb  ,u+            ; STORE THE POST-SIGN
a25d : 6fc4             L9060     clr  ,u             ; CLEAR THE LAST CHARACT
                        *
                        * REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE
                        * STRING BUFFER TO THE LEFT OF THE DECIMAL POINT
a25f : 8e01df                     ldx  #STRBUF+3      ; POINT X TO THE START O
a262 : 3001             L9065     leax $01,x          ; MOVE BUFFER POINTER UP
a264 : 9f0f                       stx  TEMPTR         ; SAVE BUFFER POINTER IN
a266 : 963a                       lda  VARPTR+1       ; * GET ADDRESS OF DECIM
a268 : 9010                       suba TEMPTR+1       ; * CURRENT POSITION AND
a26a : 9099                       suba VD9            ; * THE RESULT WILL BE Z
                        *              ; * TO THE FIRST DIGIT OF THE FORMAT ST
a26c : 2738                       beq  L90A9          ; RETURN IF NO DIGITS TO
a26e : a684                       lda  ,x             ; GET THE CURRENT BUFFER
a270 : 8120                       cmpa #SPACE         ; SPACE?
a272 : 27ee                       beq  L9065          ; YES - ADVANCE POINTER
a274 : 812a                       cmpa #'*'           ; ASTERISK?
a276 : 27ea                       beq  L9065          ; YES - ADVANCE POINTER
a278 : 4f                         clra                ; A ZERO ON THE STACK IS
a279 : 3402             L907C     pshs a              ; PUSH A CHARACTER ONTO 
a27b : a680                       lda  ,x+            ; GET NEXT CHARACTER FRO
a27d : 812d                       cmpa #'-'           ; MINUS SIGN?
a27f : 27f8                       beq  L907C          ; YES
a281 : 812b                       cmpa #'+'           ; PLUS SIGN?
a283 : 27f4                       beq  L907C          ; YES
a285 : 8124                       cmpa #'$'           ; DOLLAR SIGN?
a287 : 27f0                       beq  L907C          ; YES
a289 : 8130                       cmpa #'0'            ; ZERO?
a28b : 260e                       bne  L909E          ; NO - ERROR
a28d : a601                       lda  $01,x          ; GET CHARACTER FOLLOWIN
a28f : 8d16                       bsr  L90AA          ; CLEAR CARRY IF NUMERIC
a291 : 2508                       blo  L909E          ; BRANCH IF NOT A NUMERI
a293 : 3502             L9096     puls a              ; * PULL A CHARACTER OFF
AS09 Assembler for M6809 [1.42].                                     Page  115
--------------------------------- merge.a09 ----------------------------------

a295 : a782                       sta  ,-x            ; * AND PUT IT BACK IN T
a297 : 26fa                       bne  L9096          ; * KEEP GOING UNTIL ZER
a299 : 20c7                       bra  L9065          ; KEEP CLEANING UP THE I
a29b : 3502             L909E     puls a              ;
a29d : 4d                         tsta                ; * THE STACK AND EXIT W
a29e : 26fb                       bne  L909E          ; * ZERO FLAG FOUND
a2a0 : 9e0f                       ldx  TEMPTR         ; GET THE STRING BUFFER 
a2a2 : 8625                       lda  #'%'           ; * PUT A % SIGN BEFORE 
a2a4 : a782                       sta  ,-x            ; * INDICATE AN ERROR
a2a6 : 39               L90A9     rts
                        *
                        * CLEAR CARRY IF NUMERIC
a2a7 : 8130             L90AA     cmpa #'0'            ; ASCII ZERO
a2a9 : 2504                       blo  L90B2          ; RETURN IF ACCA < ASCII
a2ab : 803a                       suba #$3A           ; *  #'9'+1
a2ad : 80c6                       suba #$C6           ; * #-('9'+1)  CARRY CLE
a2af : 39               L90B2     rts
                        *
                        * PROCESS AN ITEM-LIST WHICH IS < 100,000,000
a2b0 : 9698             L90B3     lda  VD8            ; GET RIGHT DIGIT COUNTE
a2b2 : 2701                       beq  L90B8          ; BRANCH IF NO FORMATTED
a2b4 : 4a                         deca                ; SUBTRACT ONE FOR DECIM
a2b5 : 9b47             L90B8     adda V47            ; *ADD THE BASE 10 EXPON
                        *         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO
                        *         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMA
a2b7 : 2b01                       bmi  L90BD          ; IF ACCA >= 0 THEN NO S
a2b9 : 4f                         clra                ; FORCE SHIFT COUNTER = 
a2ba : 3402             L90BD     pshs a              ; SAVE INITIAL SHIFT COU
a2bc : 2a0a             L90BF     bpl  L90CB          ; EXIT ROUTINE IF POSITI
a2be : 3402                       pshs a              ; SAVE SHIFT COUNTER ON 
a2c0 : bd938f                     jsr  LBB82          ; DIVIDE FPA0 BY 10 - SH
a2c3 : 3502                       puls a              ; GET SHIFT COUNTER FROM
a2c5 : 4c                         inca                ; BUMP SHIFT COUNTER UP 
a2c6 : 20f4                       bra  L90BF          ; CHECK FOR FURTHER DIVI
a2c8 : 9647             L90CB     lda  V47            ; * GET BASE 10 EXPONENT
a2ca : a0e0                       suba ,s+            ; * AND SAVE NEW BASE 10
a2cc : 9747                       sta  V47            ; * FPA0 WAS SHIFTED ABO
a2ce : 8b09                       adda #$09           ; * ADD NINE (SIGNIFICAN
a2d0 : 2b19                       bmi  L90EE          ; * ZEROES TO THE LEFT O
a2d2 : 9699                       lda  VD9            ; *DETERMINE HOW MANY FI
a2d4 : 8009                       suba #$09           ; *POINT. GET THE NUMBER
a2d6 : 9047                       suba V47            ; *POINT, SUBTRACT THE B
a2d8 : 8d0d                       bsr  L90EA          ; *(UNNORMALIZATION)-THE
a2da : bda460                     jsr  L9263          ; INITIALIZE DECIMAL POI
a2dd : 201d                       bra  L90FF          ; PROCESS THE REMAINDER 
                        *
                        * PUT (ACCA+1) ASCII ZEROES IN BUFFER
a2df : 3402             L90E2     pshs a              ; SAVE ZERO COUNTER
a2e1 : 8630                       lda  #'0'            ; * INSERT A ZERO INTO
a2e3 : a7c0                       sta  ,u+            ; * THE BUFFER
a2e5 : 3502                       puls a              ; RESTORE ZERO COUNTER
                        
                        * PUT ACCA ASCII ZEROES INTO THE BUFFER
a2e7 : 4a               L90EA     deca                ; DECREMENT ZERO COUNTER
a2e8 : 2af5                       bpl  L90E2          ; BRANCH IF NOT DONE
a2ea : 39                         rts
                        
a2eb : 9699             L90EE     lda  VD9            ; * GET THE LEFT DIGIT C
a2ed : 8df8                       bsr  L90EA          ; * THAT MANY ZEROES IN 
a2ef : bda44a                     jsr  L924D          ; PUT THE DECIMAL POINT 
a2f2 : 86f7                       lda  #-9            ; *DETERMINE HOW MANY FI
a2f4 : 9047                       suba V47            ; *AND SIGNIFICANT DATA.
AS09 Assembler for M6809 [1.42].                                     Page  116
--------------------------------- merge.a09 ----------------------------------

a2f6 : 8def                       bsr  L90EA          ; *(UNNORMALIZATION) AND
a2f8 : 0f45                       clr  V45            ; CLEAR THE DECIMAL POIN
a2fa : 0f97                       clr  VD7            ; CLEAR THE COMMA COUNTE
a2fc : bda3ff           L90FF     jsr  L9202          ; DECODE FPA0 INTO A DEC
a2ff : 9698                       lda  VD8            ; GET THE RIGHT DIGIT CO
a301 : 2602                       bne  L9108          ; BRANCH IF RIGHT DIGIT 
a303 : de39                       ldu  VARPTR         ; RESET BUFFER PTR TO TH
a305 : 9b47             L9108     adda V47            ; *ADD BASE 10 EXPONENT 
                        * *FILLER ZEROES TO BE OUTPUT ; TO THE RIGHT OF LAST S
                        *         *SIGNIFICANT DATA
a307 : 7ea24d                     jmp  L9050          ; INSERT LEADING ASTERIS
                        *
                        * FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FO
a30a : 964f             L910D     lda  FP0EXP         ; * GET EXPONENT OF FPA0
a30c : 3402                       pshs a              ; * SAVE IT ON THE STACK
a30e : 2703                       beq  L9116          ; BRANCH IF FPA0 = 0
a310 : bda3ca                     jsr  L91CD          ; *CONVERT FPA0 INTO A N
                        *         *DIGITS TO THE LEFT OF THE DECIMAL POINT
a313 : 9698             L9116     lda  VD8            ; GET THE RIGHT DIGIT CO
a315 : 2701                       beq  L911B          ; BRANCH IF NO FORMATTED
a317 : 4a                         deca                ; SUBTRACT ONE FOR THE D
a318 : 9b99             L911B     adda VD9            ; ADD TO THE LEFT DIGIT 
a31a : 7f01df                     clr  STRBUF+3       ; CLEAR BUFFER BYTE AS T
a31d : d69a                       ldb  VDA            ; * GET THE STATUS BYTE 
a31f : c404                       andb #$04           ; * POST-BYTE FORCE; BRA
a321 : 2603                       bne  L9129          ; * A POST-BYTE FORCE
a323 : 7301df                     com  STRBUF+3       ; TOGGLE BUFFER BYTE TO 
a326 : bb01df           L9129     adda STRBUF+3       ; SUBTRACT 1 IF NO POST 
a329 : 8009                       suba #$09           ; *SUBTRACT 9 (DUE TO TH
                        *         *SIGNIFICANT DIGITS TO LEFT OF DECIMAL POINT
a32b : 3402                       pshs a              ; * SAVE SHIFT COUNTER O
                        *         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE 
                        *         FORMATTED PLACES TO THE RIGHT OF THE DECIMAL
a32d : 2a0a             L9130     bpl  L913C          ; NO MORE SHIFTS WHEN AC
a32f : 3402                       pshs a              ; SAVE SHIFT COUNTER
a331 : bd938f                     jsr  LBB82          ; DIVIDE FPA0 BY 10 - SH
a334 : 3502                       puls a              ; RESTORE THE SHIFT COUN
a336 : 4c                         inca                ; ADD 1 TO SHIFT COUNTER
a337 : 20f4                       bra  L9130          ; CHECK FOR FURTHER SHIF
a339 : a6e4             L913C     lda  ,s             ; *GET THE INITIAL VALUE
a33b : 2b01                       bmi  L9141          ; *AND BRANCH IF SHIFTIN
a33d : 4f                         clra                ; RESET ACCA IF NO SHIFT
a33e : 40               L9141     nega                ; *CALCULATE THE POSITIO
a33f : 9b99                       adda VD9            ; *NEGATING SHIFT COUNTE
a341 : 4c                         inca                ; *PLUS ONE AND THE POST
a342 : bb01df                     adda STRBUF+3       ; *
a345 : 9745                       sta  V45            ; SAVE DECIMAL POINT COU
a347 : 0f97                       clr  VD7            ; CLEAR COMMA COUNTER - 
a349 : bda3ff                     jsr  L9202          ; CONVERT FPA0 INTO ASCI
a34c : 3502                       puls a              ; * GET THE INITIAL VALU
a34e : bda47e                     jsr  L9281          ; * INSERT THAT MANY ZER
a351 : 9698                       lda  VD8            ; *GET THE RIGHT DIGIT C
a353 : 2602                       bne  L915A          ; *IF NOT ZERO
a355 : 335f                       leau -1,u           ; MOVE BUFFER POINTER BA
                        
                        * CALCULATE VALUE OF EXPONENT AND PUT IN STRING BUFFER
a357 : e6e0             L915A     ldb  ,s+            ; GET ORIGINAL EXPONENT 
a359 : 2709                       beq  L9167          ; BRANCH IF EXPONENT = 0
a35b : d647                       ldb  V47            ; GET BASE 10 EXPONENT
a35d : cb09                       addb #$09           ; ADD 9 FOR 9 SIGNIFICAN
a35f : d099                       subb VD9            ; SUBTRACT LEFT DIGIT CO
a361 : f001df                     subb STRBUF+3       ; ADD ONE TO EXPONENT IF
AS09 Assembler for M6809 [1.42].                                     Page  117
--------------------------------- merge.a09 ----------------------------------

a364 : 862b             L9167     lda  #'+'           ; PLUS SIGN
a366 : 5d                         tstb                ; TEST EXPONENT
a367 : 2a03                       bpl  L916F          ; BRANCH IF POSITIVE EXP
a369 : 862d                       lda  #'-'           ; MINUS SIGN
a36b : 50                         negb                ; CONVERT EXPONENT TO PO
a36c : a741             L916F     sta  $01,u          ; PUT SIGN OF EXPONENT I
a36e : 8645                       lda  #'E'           ; * PUT AN 'E' (EXPONENT
a370 : a7c1                       sta  ,u++           ; * BUFFER AND SKIP OVER
a372 : 862f                       lda  #$2F           ; * WAS lda #'0'-1
                        *CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACC
a374 : 4c               L9177     inca                ; ADD ONE TO TENS DIGIT 
a375 : c00a                       subb #10            ; *SUBTRACT 10 FROM EXPO
a377 : 24fb                       bcc  L9177          ; * DIGIT IF NO CARRY. T
a379 : cb3a                       addb #$3A           ; WAS addb #'9'+1
a37b : edc1                       std  ,u++           ; SAVE EXPONENT IN BUFFE
a37d : 6fc4                       clr  ,u             ; CLEAR FINAL BYTE IN BU
a37f : 7ea251                     jmp  L9054          ; INSERT ASTERISK PADDIN
                        
                        * INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN
a382 : 8e01e0           L9185     ldx  #STRBUF+4      ; POINT X TO START OF PR
a385 : e684                       ldb  ,x             ; * GET SIGN BYTE OF ITE
a387 : 3404                       pshs b              ; * AND SAVE IT ON THE S
a389 : 8620                       lda  #SPACE         ; DEFAULT PAD WITH BLANK
a38b : d69a                       ldb  VDA            ; * GET STATUS BYTE AND 
a38d : c520                       bitb #$20           ; * ASTERISK LEFT PADDIN
a38f : 3504                       puls b              ; GET SIGN BYTE AGAIN
a391 : 2708                       beq  L919E          ; BRANCH IF NO PADDING
a393 : 862a                       lda  #'*'           ; PAD WITH ASTERISK
a395 : c120                       cmpb #SPACE         ; WAS THE FIRST BYTE A B
a397 : 2602                       bne  L919E          ; NO
a399 : 1f89                       tfr  a,b            ; TRANSFER PAD CHARACTER
a39b : 3404             L919E     pshs b              ; SAVE FIRST CHARACTER O
a39d : a780             L91A0     sta  ,x+            ; STORE PAD CHARACTER IN
a39f : e684                       ldb  ,x             ; GET NEXT CHARACTER IN 
a3a1 : 2710                       beq  L91B6          ; INSERT A ZERO IF END O
a3a3 : c145                       cmpb #'E'           ; * CHECK FOR AN 'E' AND
a3a5 : 270c                       beq  L91B6          ; * PUT A ZERO BEFORE IT
a3a7 : c130                       cmpb #'0'           ; * REPLACE LEADING ZERO
a3a9 : 27f2                       beq  L91A0          ; * PAD CHARACTERS
a3ab : c12c                       cmpb #','           ; * REPLACE LEADING COMM
a3ad : 27ee                       beq  L91A0          ; * WITH PAD CHARACTERS
a3af : c12e                       cmpb #'.'           ; * CHECK FOR DECIMAL PO
a3b1 : 2604                       bne  L91BA          ; * AND DON'T PUT A ZERO
a3b3 : 8630             L91B6     lda  #'0'           ; * REPLACE PREVIOUS CHA
a3b5 : a782                       sta  ,-x            ; * WITH A ZERO
a3b7 : 969a             L91BA     lda  VDA            ; * GET STATUS BYTE, CHE
a3b9 : 8510                       bita #$10           ; * FOR FLOATING $
a3bb : 2704                       beq  L91C4          ; * BRANCH IF NO FLOATIN
a3bd : c624                       ldb  #'$'           ; * STORE A $ IN
a3bf : e782                       stb  ,-x            ; * BUFFER
a3c1 : 8404             L91C4     anda #$04           ; CHECK PRE-SIGN FLAG
a3c3 : 3504                       puls b              ; GET SIGN CHARACTER
a3c5 : 2602                       bne  L91CC          ; RETURN IF POST-SIGN RE
a3c7 : e782                       stb  ,-x            ; STORE FIRST CHARACTER
a3c9 : 39               L91CC     rts
                        *
                        * CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN
                        * THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPO
a3ca : 3440             L91CD     pshs u              ; SAVE BUFFER POINTER
a3cc : 4f                         clra                ; INITIAL EXPONENT OFFSE
a3cd : 9747             L91D0     sta  V47            ; SAVE EXPONENT OFFSET
a3cf : d64f                       ldb  FP0EXP         ; GET EXPONENT OF FPA0
AS09 Assembler for M6809 [1.42].                                     Page  118
--------------------------------- merge.a09 ----------------------------------

a3d1 : c180                       cmpb #$80           ; * COMPARE TO EXPONENT 
a3d3 : 2211                       bhi  L91E9          ; * AND BRANCH IF FPA0 >
                        
                        * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1
a3d5 : 8e95cd                     ldx  #LBDC0         ; POINT X TO FP NUMBER (
a3d8 : bd92d7                     jsr  LBACA          ; MULTIPLY FPA0 BY 1E+09
a3db : 9647                       lda  V47            ; GET EXPONENT OFFSET
a3dd : 8009                       suba #$09           ; SUBTRACT 9 (BECAUSE WE
a3df : 20ec                       bra  L91D0          ; CHECK TO SEE IF > 1.0
a3e1 : bd938f           L91E4     jsr  LBB82          ; DIVIDE FPA0 BY 10
a3e4 : 0c47                       inc  V47            ; INCREMENT EXPONENT OFF
a3e6 : 8e95c8           L91E9     ldx  #LBDBB         ; POINT X TO FP NUMBER (
a3e9 : bd94ad                     jsr  LBCA0          ; COMPARE FPA0 TO X
a3ec : 2ef3                       bgt  L91E4          ; BRANCH IF FPA0 > 999,9
a3ee : 8e95c3           L91F1     ldx  #LBDB6         ; POINT X TO FP NUMBER (
a3f1 : bd94ad                     jsr  LBCA0          ; COMPARE FPA0 TO X
a3f4 : 2e07                       bgt  L9200          ; RETURN IF 999,999,999 
a3f6 : bd9377                     jsr  LBB6A          ; MULTIPLY FPA0 BY 10
a3f9 : 0a47                       dec  V47            ; DECREMENT EXPONENT OFF
a3fb : 20f1                       bra  L91F1          ; KEEP UNNORMALIZING
a3fd : 35c0             L9200     puls u,pc           ; RESTORE BUFFER POINTER
                        *
                        * CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT
                        * INTO A DECIMAL ASCII STRING IN THE BUFFER
a3ff : 3440             L9202     pshs u              ; SAVE BUFFER POINTER
a401 : bd91c1                     jsr  LB9B4          ; ADD .5 TO FPA0 (ROUND 
a404 : bd94d5                     jsr  LBCC8          ; CONVERT FPA0 TO INTEGE
a407 : 3540                       puls u              ; RESTORE BUFFER POINTER
                        *
                        * CONVERT FPA0 INTO A DECIMAL ASCII STRING
a409 : 8e96d2                     ldx  #LBEC5         ; POINT X TO UNNORMALIZE
a40c : c680                       ldb  #$80           ; INITIALIZE DIGIT COUNT
                        * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 M
                        * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSa, IT 
                        * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF 
                        * IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OC
a40e : 8d36             L9211     bsr  L9249          ; CHECK FOR COMMA INSERT
a410 : 9653             L9213     lda  FPA0+3         ; * 'ADD' A POWER OF 10 
a412 : ab03                       adda $03,x          ; * IF THE MANTISSA IS N
a414 : 9753                       sta  FPA0+3         ; * WILL BE WHAT REALLY 
a416 : 9652                       lda  FPA0+2         ; *
a418 : a902                       adca $02,x          ; *
a41a : 9752                       sta  FPA0+2         ; *
a41c : 9651                       lda  FPA0+1         ; *
a41e : a901                       adca $01,x          ; *
a420 : 9751                       sta  FPA0+1         ; *
a422 : 9650                       lda  FPA0           ; *
a424 : a984                       adca ,x             ; *
a426 : 9750                       sta  FPA0           ; *
a428 : 5c                         incb                ; ADD ONE TO DIGIT COUNT
a429 : 56                         rorb                ; ROTATE CARRY INTO BIT 
a42a : 59                         rolb                ; * SET OVERFLOW FLAG - 
a42b : 28e3                       bvc  L9213          ; * ADDING MANTISSA OR C
a42d : 2403                       bcc  L9235          ; BRANCH IF SUBTRACTING 
a42f : c00b                       subb #10+1          ; WAS subb #10+1
a431 : 50                         negb                ; * IF ADDING MANTISSA
a432 : cb2f             L9235     addb #$2F           ; WAS addb #'0'-1
a434 : 3004                       leax $04,x          ; MOVE TO NEXT POWER OF 
a436 : 1f98                       tfr  b,a            ; SAVE DIGIT IN ACCA
a438 : 847f                       anda #$7F           ; MASK OFF ADD/SUBTRACT 
a43a : a7c0                       sta  ,u+            ; STORE DIGIT IN BUFFER
a43c : 53                         comb                ; TOGGLE ADD/SUBTRACT FL
AS09 Assembler for M6809 [1.42].                                     Page  119
--------------------------------- merge.a09 ----------------------------------

a43d : c480                       andb #$80           ; MASK OFF EVERYTHING BU
a43f : 8c96f6                     cmpx #LBEE9         ; COMPARE TO END OF UNNO
a442 : 26ca                       bne  L9211          ; BRANCH IF NOT DONE
a444 : 6fc4                       clr  ,u             ; PUT A ZERO AT END OF I
                        
                        * DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA 
a446 : 0a45             L9249     dec  V45            ; DECREMENT DECIMAL POIN
a448 : 2609                       bne  L9256          ; NOT TIME FOR DECIMAL P
a44a : df39             L924D     stu  VARPTR         ; SAVE BUFFER POINTER-PO
a44c : 862e                       lda  #'.'           ; * STORE A DECIMAL
a44e : a7c0                       sta  ,u+            ; * POINT IN THE OUTPUT 
a450 : 0f97                       clr  VD7            ; * CLEAR COMMA COUNTER 
                        *                             ; * DECREMENTS BEFORE AN
a452 : 39                         rts
a453 : 0a97             L9256     dec  VD7            ; DECREMENT COMMA COUNTE
a455 : 2608                       bne  L9262          ; RETURN IF NOT TIME FOR
a457 : 8603                       lda  #$03           ; * RESET COMMA COUNTER 
a459 : 9797                       sta  VD7            ; * DIGITS BETWEEN COMMA
a45b : 862c                       lda  #','            ; * PUT A COMMA INTO
a45d : a7c0                       sta  ,u+            ; * THE BUFFER
a45f : 39               L9262     rts
                        
                        * INITIALIZE DECIMAL POINT AND COMMA COUNTERS
a460 : 9647             L9263     lda  V47            ; GET THE BASE 10 EXPONE
a462 : 8b0a                       adda #10            ; * ADD 10 (FPA0 WAS 'NO
a464 : 9745                       sta  V45            ; * OF DECIMAL POINT) - 
a466 : 4c                         inca                ; ADD ONE FOR THE DECIMA
a467 : 8003             L926A     suba #$03           ; * DIVIDE DECIMAL POINT
a469 : 24fc                       bcc  L926A          ; * THE REMAINDER IN ACC
a46b : 8b05                       adda #$05           ; CONVERT REMAINDER INTO
a46d : 9797                       sta  VD7            ; SAVE COMMA COUNTER
a46f : 969a                       lda  VDA            ; GET STATUS BYTE
a471 : 8440                       anda #$40           ; CHECK FOR COMMA FLAG
a473 : 2602                       bne  L927A          ; BRANCH IF COMMA FLAG A
a475 : 9797                       sta  VD7            ; CLEAR COMMA COUNTER - 
a477 : 39               L927A     rts
                        *
                        * INSERT ACCA ZEROES INTO THE BUFFER
a478 : 3402             L927B     pshs a              ; SAVE ZEROES COUNTER
a47a : 8dca                       bsr  L9249          ; CHECK FOR DECIMAL POIN
a47c : 3502                       puls a              ; RESTORE ZEROES COUNTER
a47e : 4a               L9281     deca                ; * DECREMENT ZEROES COU
a47f : 2b0a                       bmi  L928E          ; * RETURN IF < 0
a481 : 3402                       pshs a              ; SAVE ZEROES COUNTER
a483 : 8630                       lda  #'0'            ; * PUT A ZERO INTO
a485 : a7c0                       sta  ,u+            ; * THE BUFFER
a487 : a6e0                       lda  ,s+            ; RESTORE THE ZEROES COU
a489 : 26ed                       bne  L927B          ; BRANCH IF NOT DONE
a48b : 39               L928E     rts
                        
                        
                        * LINE
a48c : 8189             LINE      cmpa #TOK_INPUT     ; 'INPUT' TOKEN
a48e : 1027f95c                   lbeq L89C0          ; GO DO 'LINE INPUT' COM
a492 : 7e8ab0                     jmp  LB277          ; 'SYNTAX ERROR' IF NOT 
                        		  
                        
                        * END OF EXTENDED BASIC
                        
                        * DIR COMMAND				; DIR "DRIVE NUMBER"
a495 : bda49c           DIR 	  jsr LD24F 		; SCAN DRIVE NUMBER FROM INPUT LINE
                        		  ;jsr LC79D 		; GET FAT FOR THIS DRIVE
AS09 Assembler for M6809 [1.42].                                     Page  120
--------------------------------- merge.a09 ----------------------------------

                        		  ;jsr LB958 		; PRINT CARRIAGE RETURN TO CONSOLE OU
                        		  ;ldd #$1102 		; * GET TRACK 17 AND
                        		  ;sta DCTRK 		; * READ OP CODE AND
                        		  ;stb DCOPC 		; * SAVE IN DSKCON VARIABLES
                        		  ;ldb #$03 		; START WITH SECTOR 3 (FIRST DIRECTORY
a498 : bda4ec           		  jsr DSK_FDIR		; CALL THE DISK FILE LISTING FUNCTIO
a49b : 39               		  rts
                        
                        * GET DRIVE NUMBER FROM BASIC - USE THE DEFAULT DRIVE 
a49c :                  LD24F	  ;ldb				; DEFDRV	GET DEFAULT DRIVE NUMBER		
a49c : 9d82             		  jsr	GETCCH		; GET NEXT INPUT CHAR (TO MAINTAIN BAC
a49e : 5f               		  clrb				; ONLY DRIVE 0 SUPPORTED
                        		  ;beq LD25F			; USE DEFAULT DRIVE NUMBER IF NONE GI
a49f :                  LD256	  ;jsr EVALEXPB		; EVALUATE EXPRESSION
                        		  ;cmpb #$03		; 4 DRIVES MAX
                        		  ;lbhi LA61F		; 'DEVICE NUMBER ERROR' IF > 3
a49f :                  LD25F	  ;stb DCDRV		; STORE IN DSKCON VARIABLE
a49f : 39               		  rts
                        
000d =                  FILELENGTH    equ  13		; FORMAT 8.3 + NULL GIVES 13 BY
                        
                        * KILL COMMAND  ; FROM DISK BASIC UNRAVELLED II
a4a0 : 3273             KILL	  leas -FILELENGTH,s; ALLOCATE FILENAME STORAGE
a4a2 : bda4c6           		  jsr GET_FN
a4a5 : bda5b9           		  jsr DSK_FDEL		; CALL THE DISK FILE DELETION FUNCTI
a4a8 : 326d             		  leas FILELENGTH,s	; FREE FILENAME STACK		  
a4aa : 39               		  rts
                        
                        ; KILL	  ldb #FILELENGTH
                        		  ; pshs b			; SAVE FILE LENGTH POSITION
                        ; LC6E9_	  jsr  GETNCH		; GET THE CHARS  
                        		  ; puls b			; RESTORE FILE LENGTH POSITION
                        		  ; cmpa #'"'			; UNTIL THE STRING ENDS WITH "
                        		  ; beq LC6EA_
                        		  ; pshs a			; THE FILENAME STRING ON THE STACK
                        		  ; decb
                        		  ; beq LC6EE_
                        		  ; pshs b		  	; RE-SAVE FILE LENGTH POSITION
                        		  ; bra LC6E9_
                        ; LC6EA_	  clra
                        		  ; pshs a			; FILL FILENAME STRING WITH NULL
                        		  ; decb
                        		  ; bne LC6EA_
                        ; LC6EE_	  jsr DSK_FDEL		; CALL THE DISK FILE DELETION
                        		  ; leas FILELENGTH,s	; FREE FILENAME STACK		  
                        		  ; rts
                        		  
                        * LOAD COMMAND ; FROM DISK BASIC UNRAVELLED II
a4ab : 3273             LOAD 	  leas -FILELENGTH,s; ALLOCATE FILENAME STORAGE
a4ad : bda4c6           		  jsr GET_FN
a4b0 : bda5cd           		  jsr DSK_FRD		; CALL THE DISK FILE READING FUNCTION
a4b3 : 326d             		  leas FILELENGTH,s	; FREE FILENAME STACK		  
a4b5 : 39               		  rts
                        
                        *LOAD	  cmpa #'M'			; "LOADM" COMMAND
                        *		  lbeq LCFC1		; *BRANCH IF LOADM
                        *		 clra 				; RUN	FLAG = ZERO (DON'T RUN)
                        *LCA4F	 clrb				; CLEAR	MERGE FLAG
                        *LCA50	 sta	DRUNFL	RUN FLAG (0 = DON'T RUN, 2 = RUN)
                        *		 stb	DMRGFL	MERGE FLAG (0 = NO MERGE, $FF = MERGE)
                        *		  bsr	LCA33	GO GET FILENAME, ETC. FROM BASIC
                        *		  jsr	GETCCH	GET CURRENT INPUT CHAR
AS09 Assembler for M6809 [1.42].                                     Page  121
--------------------------------- merge.a09 ----------------------------------

                        *		  beq	LCA6C	BRANCH IF END OF LINE
                        *		  jsr	SYNCOMMA	SYNTAX CHECK FOR COMMA
a4b6 : 39               		  rts
                        
                        * SAVE COMMAND
a4b7 : 3273             SAVE 	  leas -FILELENGTH,s; ALLOCATE FILENAME STORAGE
a4b9 : bda4c6           		  jsr GET_FN
a4bc : bda5f4           		  jsr DSK_FWR		; CALL THE DISK FILE WRITING FUNCTION
a4bf : 326d             		  leas FILELENGTH,s	; FREE FILENAME STACK
a4c1 : 3262             		  leas 2,s          ; PURGE RETURN ADDRESS FROM THE 
a4c3 : 7e84ce           		  jmp  LAC73        ; RETURN TO BASIC'S MAIN INPUT L
                        		  
                        * SAVE COMMAND ; FROM DISK BASIC UNRAVELLED II
                        *SAVE	cmpa	#'M	*
                        ;	lbeq	LCF68	*BRANCH IF SAVEM
                        ;	bsr	LCA33	GO GET FILENAME, ETC. FROM BASIC
                        ;	ldx	ZERO	ZERO OUT X REG
                        ;	stx	DFLTYP	SET FILE TYPE AND ASCII FLAG TO ZERO
                        ;	jsr	GETCCH	GET CURRENT INPUT CHARACTER FROM BASIC
                        ;	beq	LCA12	BRANCH IF END OF LINE
                        ;	jsr	SYNCOMMA	SYNTAX CHECK FOR COMMA
                        ;	ldb	#'A		*ASCII FILE?
                        ;	jsr	>LB26F	*SYNTAX CHECK ON CONTENTS OF ACCB
                        ;	bne	LC9DF	RETURN IF NO MORE CHARACTERS ON LINE
                        ;	COM	DASCFL	SET CRUNCHED/ASCII FLAG TO ASCII
                        ;	bsr	LCA04	OPEN A SEQUENTIAL FILE FOR OUTPUT
                        ;	clra		SET	ZERO FLAG - CAUSE ENTIRE FILE TO BE LISTED
                        ;	jmp	LIST	'LIST' THE FILE TO CONSOLE OUT
                        
                        
a4c6 : 3440             GET_FN	  pshs u
a4c8 : 3364             		  leau 4,s ; +4 BYTES FOR RETURN ADDR + U
a4ca : c60d             		  ldb #FILELENGTH
a4cc : 3444             		  pshs u,b			; SAVE FILE LENGTH POSITION
a4ce : 9d7c             LC6E9	  jsr  GETNCH		; GET THE CHARS  
a4d0 : 3544             		  puls b,u			; RESTORE FILE LENGTH POSITION
a4d2 : 8122             		  cmpa #'"'			; UNTIL THE STRING ENDS WITH "
a4d4 : 270b             		  beq LC6EA
a4d6 : a7c0             		  sta ,u+			; THE FILENAME STRING ON THE STACK
a4d8 : 5a               		  decb
a4d9 : 10270004         		  lbeq LC6EA
a4dd : 3444             		  pshs u,b		  	; RE-SAVE FILE LENGTH POSITION
a4df : 20ed             		  bra LC6E9
a4e1 : 4f               LC6EA	  clra
a4e2 : a7c0             		  sta ,u+			; FILL FILENAME STRING WITH NULL
a4e4 : 5a               		  decb
a4e5 : 26fa             		  bne LC6EA
a4e7 : 9d7c             		  jsr  GETNCH		; purge the command
a4e9 : 3540             		  puls u
a4eb : 39               		  rts
                        		    
                        *************************CALLING FAT32 FUNCTIONS *****
                        * Generated code from C and optimized afterward
                        * Note for BASIC ASM -> C : the U, X and Y registers n
                        ******************************************************
                        
                        * DSK_FDIR()
                        * {
                        * 	fileInfo fileList; //18 bytes
                        * 	
                        * 	while(FILE_List(&fileList) != END_OF_FILE_LIST) {
a4ec :                  DSK_FDIR		
AS09 Assembler for M6809 [1.42].                                     Page  122
--------------------------------- merge.a09 ----------------------------------

a4ec : 3470             	pshs 	u,x,y
a4ee : 33e4             	leau 	,s
a4f0 : 32e8ee           	leas -18,s				; alloc 18 bytes
a4f3 : bda64e           	lbsr    initDISK
a4f6 : 102600bb         	lbne    FDIR_2			; return when failed
a4fa :                  FDIR_3	  
a4fa : 30c8ee           	leax -18,u
a4fd : 3410             	pshs 	x
a4ff : bdbc56           	lbsr	FILE_Lis
a502 : 3262             	leas 2,s		
a504 : 830009           	subd #$9
a507 : 102700aa         	lbeq 	FDIR_2
                        * 		PUTCHR('\r');
a50b : 860d             	lda	#$d
a50d : bd805c           	lbsr	PUTCHR	
                        * 		if(fileList.FI_Attr == ATTR_VOLUME_ID) {
a510 : e652             	ldb	-14,u
a512 : c108             	cmpb	#$8
a514 : 2619             	bne	FDIR_4
                        * 		L85B4("VOLUME NAME IS ");
a516 : 308d0002         	leax	FDIR_5_,pc
a51a : 2010             	bra	FDIR_5
a51c :                  FDIR_5_
a51c : 564f4c554d45204e 	fcb	$56, $4f, $4c, $55, $4d, $45, $20, $4e
a524 : 414d452049532000 	fcb	$41, $4d, $45, $20, $49, $53, $20, $0
a52c :                  FDIR_5
a52c : bd9a32           	lbsr	L85B4
                        * 		}
                        * 		L85B4(fileList.FI_Name); PUTCHR(' ');
a52f :                  FDIR_4
a52f : 3053             	leax -13,u
a531 : bd9a32           	jsr 	L85B4			; PRINT STRING TO THE SCREEN
a534 : 8620             	lda #SPACE
a536 : bd805c           	lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN)
                        * 		if((fileList.FI_Attr != ATTR_VOLUME_ID) && (fileLi
a539 : e652             	ldb	-14,u
a53b : c108             	cmpb	#$8
a53d : 2773             	beq		FDIR_6
a53f : e652             	ldb	-14,u
a541 : c110             	cmpb	#$10
a543 : 276d             	beq		FDIR_6	
                        * 			if(fileList.FI_Size.h != 0) {
a545 : ecc8ee           	ldd	-18,u
a548 : 2745             	beq		FDIR_7
                        * 				if(fileList.FI_Size.h > 0xf) {
a54a : 1083000f         	cmpd	#$f
a54e : 1023001c         	lbls	FDIR_8
                        * 					LBDCC(fileList.FI_Size.h >> 4); PUTCHR(' '); PU
a552 : 44               	lsra
a553 : 56               	rorb
a554 : 44               	lsra
a555 : 56               	rorb
a556 : 44               	lsra
a557 : 56               	rorb
a558 : 44               	lsra
a559 : 56               	rorb
a55a : 3440             	pshs	u
a55c : bd95d9           	lbsr 	LBDCC			; CONVERT ACCD TO DECIMAL AND PRINT ON 
a55f : 3540             	puls	u
a561 : 8620             	lda #SPACE
a563 : bd805c           	lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN)
a566 : 864d             	lda	#'M'
AS09 Assembler for M6809 [1.42].                                     Page  123
--------------------------------- merge.a09 ----------------------------------

a568 : bd805c           	lbsr	PUTCHR	
                        * 				}
                        * 				else {
a56b : 201f12           	lbra	FDIR_9
a56e :                  FDIR_8
                        * 					reg = ((fileList.FI_Size.h & 0xf) << 8) | (file
a56e : ecc8ee           	ldd	-18,u
a571 : c40f             	andb	#$f
a573 : 1f98             	tfr b,a
a575 : e650             	ldb	-16,u	
                        * 					reg = reg >> 2;
a577 : 44               	lsra
a578 : 56               	rorb
a579 : 44               	lsra
a57a : 56               	rorb	
                        * 					LBDCC(i);  PUTCHR(' '); PUTCHR('K');					
a57b : 3440             	pshs	u
a57d : bd95d9           	lbsr 	LBDCC			; CONVERT ACCD TO DECIMAL AND PRINT ON 
a580 : 3540             	puls	u
a582 : 8620             	lda #SPACE
a584 : bd805c           	lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN)
a587 : 864b             	lda	#'K'
a589 : bd805c           	lbsr	PUTCHR	
                        * 				}
                        * 			}
a58c :                  FDIR_9
                        * 			else {
a58c : 200f12           	lbra	FDIR_10
a58f :                  FDIR_7
                        * 				LBDCC(fileList.FI_Size.l); PUTCHR(' ');
a58f : ec50             	ldd	-16,u
a591 : 3440             	pshs	u
a593 : bd95d9           	lbsr 	LBDCC			; CONVERT ACCD TO DECIMAL AND PRINT ON 
a596 : 3540             	puls	u
a598 : 8620             	lda #SPACE
a59a : bd805c           	lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN)
                        * 			}
                        * 			L85B4("byte(s)");
a59d :                  FDIR_10
a59d : 308d0002         	leax	FDIR_11_,pc
a5a1 : 2008             	bra	FDIR_11
a5a3 :                  FDIR_11_
a5a3 : 6279746528732900 	fcb	$62, $79, $74, $65, $28, $73, $29, $0
a5ab :                  FDIR_11
a5ab : 3410             	pshs	x
a5ad : bd9a32           	lbsr	L85B4
a5b0 : 3262             	leas	2,s
                        * 		}
                        * 	}
a5b2 :                  FDIR_6
                        * }
a5b2 : 7ea4fa           	lbra	FDIR_3
a5b5 :                  FDIR_2
a5b5 : 32c4             	leas	,u			; free allocated bytes
a5b7 : 35f0             	puls	u,x,y,pc
                        
a5b9 :                  DSK_FDEL 
a5b9 : 3470             		  pshs u,x,y
a5bb : 33e4             		  leau 	,s
a5bd : bda64e           		  lbsr initDISK
a5c0 : 2609             		  bne  DSK_FDL1				; return when failed
                        		  		  
AS09 Assembler for M6809 [1.42].                                     Page  124
--------------------------------- merge.a09 ----------------------------------

                        * 	returnStatus = FILE_Delete(ptr);		  
a5c2 : 3048             		  leax 8,u	; +8 BYTES (RETURN ADDR, U, X, Y)
a5c4 : 3410             		  pshs	x
a5c6 : bdb3ce           		  lbsr	FILE_Del
a5c9 : 3262             		  leas	2,s
a5cb : 35f0             DSK_FDL1  puls	u,x,y,pc
                        
a5cd : 3470             DSK_FRD   pshs  u,x,y
a5cf : 33e4             		  leau 	,s
a5d1 : bda64e           		  lbsr  initDISK		  
a5d4 : 10260018         		  lbne  DSK_FRD1			; return when failed
                        		  
                        * 	unsigned char returnStatus; //1 byte
a5d8 : 327f             		  leas	-1,s		; alloc 1 byte
                        * 	srcFilePtr = FILE_Open(ptr, READ, &returnStatus);
a5da : 305f             	 	  leax	-1,u
a5dc : 3410             		  pshs	x
a5de : 4f               		  clra
a5df : 5f               		  clrb
a5e0 : 3406             		  pshs	d		  
a5e2 : 3048             		  leax  8,u			; +8 BYTES (RETURN ADDR, U, X, Y)
a5e4 : 3410             		  pshs	x
a5e6 : bdaf7c           		  lbsr	FILE_Ope	; file pointer in ACCD
a5e9 : 3266             		  leas	6,s		  	; CCR unchanged	
                        * 	if(srcFilePtr != 0)	{
a5eb : 2703             		  beq   DSK_FRD1
a5ed : fd0205           		  std	F_PTR		; let the ConsoleIn pull the file conte
                        * 	}
a5f0 : 32c4             DSK_FRD1  leas	,u			; free allocated bytes
a5f2 : 35f0             		  puls	u,x,y,pc
                        
                        
a5f4 : 3470             DSK_FWR   pshs  u,x,y	  
a5f6 : 33e4             		  leau 	,s
a5f8 : bda64e           		  lbsr  initDISK
a5fb : 1026004b         		  lbne  FWR_20				; return when failed
                        		  
                        * 	fileConfig_st *srcFilePtr; //2 bytes
                        * 	unsigned char returnStatus; //1 byte
a5ff : 327d             		  leas	-3,s	; alloc 3 bytes
                        * 	srcFilePtr = FILE_Open(ptr, WRITE, &returnStatus);
a601 : 305d             		  leax	-3,u
a603 : 3410             		  pshs	x
a605 : cc0002           		  ldd	#$2
a608 : 3406             		  pshs	d
a60a : 3048             		  leax 8,u	; +8 BYTES (RETURN ADDR, U, X, Y)		  
a60c : 3410             		  pshs	x
a60e : bdaf7c           		  lbsr	FILE_Ope
a611 : 3266             		  leas	6,s
a613 : ed5e             		  std	-2,u
                        		  
                        * 	if(srcFilePtr == 0)	{
a615 : ec5e             		  ldd	-2,u
a617 : 2603             		  bne	FWR_19
                        * 		//print_DebugMsg("\nFile Opening Failed!"); HEXBYT
a619 : 202f12           		  lbra	FWR_20
                        * 	}
                        * 	else {		  
a61c :                  FWR_19
                        *      send BAS program to the file
a61c : ec5e             		  ldd	-2,u
a61e : fd0205           		  std	F_PTR
AS09 Assembler for M6809 [1.42].                                     Page  125
--------------------------------- merge.a09 ----------------------------------

a621 : 0c6e             		  inc	DEVNUM
a623 : 3460             		  pshs  u,y			; save U,Y overwritten in LIST routine
a625 : 4f               		  clra				; SET	ZERO FLAG - CAUSE ENTIRE FILE TO BE 
a626 : bd8f8f           		  jsr	LIST		; Note for C -> BASIC ASM : the U and Y 
a629 : 3560             		  puls  u,y
a62b : 0f6e             		  clr	DEVNUM
a62d : 7f0205           		  clr	F_PTR
a630 : 7f0207           		  clr	F_PTR+2
                        		  
                        * 		FILE_PutCh(srcFilePtr,EOF);
a633 : cc001a           		  ldd	#$1a
a636 : 3406             		  pshs	d
a638 : ec5e             		  ldd	-2,u
a63a : 3406             		  pshs	d
a63c : bdb574           		  lbsr	FILE_Put
a63f : 3264             		  leas	4,s
                        * 		FILE_Close(srcFilePtr);
a641 : ec5e             		  ldd	-2,u
a643 : 3406             		  pshs	d
a645 : bdb3b7           		  lbsr	FILE_Clo
a648 : 3262             		  leas	2,s
                        * 	}
                        * }
a64a :                  FWR_20		  
a64a : 32c4             		  leas	,u			; free allocated bytes
a64c : 35f0             		  puls	u,x,y,pc		  
                        					
                        
                        * initDISK() {
                        * 	unsigned char returnStatus, sdcardType; //2 bytes  
a64e :                  initDISK
a64e : 3470             	pshs	u,x,y
a650 : 33e4             	leau	,s
a652 : 327e             	leas	-2,s	
                        * 	
                        * 	setPins();
a654 : bdaa84           	lbsr	setPins
                        * 	
                        * 	returnStatus = SD_Init(&sdcardType);		
a657 : 305e             	leax	-2,u
a659 : 3410             	pshs	x
a65b : bdacbb           	lbsr	SD_Init
a65e : 3262             	leas	2,s
a660 : e75f             	stb	-1,u
                        * 
                        * 	if(returnStatus != INIT_SUCCESSFUL) {
a662 : e65f             	ldb	-1,u
a664 : 1027005a         	lbeq	init_8
                        * 		if(returnStatus == NOT_DETECTED)	print_DebugMsg("S
a668 : c101             	cmpb	#$1
a66a : 2624             	bne		init_9
a66c : 308d0002         	leax	init_10_,pc
a670 : 2017             	bra	init_10
a672 :                  init_10_
a672 : 5344206361726420 	fcb	$53, $44, $20, $63, $61, $72, $64, $20
a67a : 6e6f742064657465 	fcb	$6e, $6f, $74, $20, $64, $65, $74, $65
a682 : 63746564210a00   	fcb	$63, $74, $65, $64, $21, $a, $0
a689 :                  init_10
a689 : 3410             	pshs	x
a68b : bdfa89           	lbsr	print_De
a68e : 3262             	leas	2,s
                        * 		if(returnStatus == INIT_FAILED) print_DebugMsg("Ca
AS09 Assembler for M6809 [1.42].                                     Page  126
--------------------------------- merge.a09 ----------------------------------

a690 :                  init_9
a690 : e65f             	ldb	-1,u
a692 : c102             	cmpb	#$2
a694 : 265c             	bne		init_15
a696 : 308d0002         	leax	init_12_,pc
a69a : 201d             	bra	init_12
a69c :                  init_12_
a69c : 4361726420496e69 	fcb	$43, $61, $72, $64, $20, $49, $6e, $69
a6a4 : 7469616c697a6174 	fcb	$74, $69, $61, $6c, $69, $7a, $61, $74
a6ac : 696f6e206661696c 	fcb	$69, $6f, $6e, $20, $66, $61, $69, $6c
a6b4 : 6564210a00       	fcb	$65, $64, $21, $a, $0
a6b9 :                  init_12
a6b9 : 3410             	pshs	x
a6bb : bdfa89           	lbsr	print_De
a6be : 3262             	leas	2,s
                        * 	}
a6c0 : 2630                 bne		init_15
                        * 	else {		
a6c2 :                  init_8
                        * 		returnStatus = getBootSectorData (); //read boot s
a6c2 : bdbe9e           	lbsr	getBootS
a6c5 : e75f             	stb	-1,u
                        * 		if(returnStatus == FAT_INVALID) print_DebugMsg("In
a6c7 : c103             	cmpb #$3
a6c9 : 2627             	bne		init_15
a6cb : 308d0002         	leax	init_16_,pc
a6cf : 201a             	bra	init_16
a6d1 :                  init_16_
a6d1 : 496e76616c696420 	fcb	$49, $6e, $76, $61, $6c, $69, $64, $20
a6d9 : 4641542066696c65 	fcb	$46, $41, $54, $20, $66, $69, $6c, $65
a6e1 : 2073797374656d21 	fcb	$20, $73, $79, $73, $74, $65, $6d, $21
a6e9 : 0a00             	fcb	$a, $0
a6eb :                  init_16
a6eb : 3410             	pshs	x
a6ed : bdfa89           	lbsr	print_De
a6f0 : 3262             	leas	2,s
                        * 	}    
a6f2 :                  init_15
a6f2 : e65f             	ldb	-1,u
a6f4 : 4f               	clra
                        * }
a6f5 : 32c4             	leas	,u			; free allocated bytes
a6f7 : 35f0             	puls	y,x,u,pc
                        		  
                        * END OF DISK BASIC
                        
                        * micro-C(ver 0.4.1), 1981-1987 Masataka Ohta, Hiroshi
                        * /***************************************************
                        * /*                                                  
                        * /* file:          stdutils.c		                      
                        * /*                                                  
                        * /* source:        2023, written by Adrian Kundert (a
                        * /*                                                  
                        * /* description:   read and write data from SD CARD (
                        * /*                                                  
                        * /* This library is free software; you can redistribu
                        * /* GNU Lesser General Public License as published by
                        * /* either version 2.1 of the License, or (at your op
                        * /*                                                  
                        * /* This library is distributed in the hope that it w
                        * /* without even the implied warranty of MERCHANTABIL
                        * /* See the GNU Lesser General Public License for mor
AS09 Assembler for M6809 [1.42].                                     Page  127
--------------------------------- merge.a09 ----------------------------------

                        * /*                                                  
                        * /***************************************************
                        * 
                        * #include "stdutils.h"
                        * /***************************************************
                        * /*                                                  
                        * /* file:          stdutils.h		                      
                        * /*                                                  
                        * /* source:        2023, written by Adrian Kundert (a
                        * /*                                                  
                        * /* description:   read and write data from SD CARD (
                        * /*                                                  
                        * /* This library is free software; you can redistribu
                        * /* GNU Lesser General Public License as published by
                        * /* either version 2.1 of the License, or (at your op
                        * /*                                                  
                        * /* This library is distributed in the hope that it w
                        * /* without even the implied warranty of MERCHANTABIL
                        * /* See the GNU Lesser General Public License for mor
                        * /*                                                  
                        * /***************************************************
                        * 
                        * /**----------char 8-bit--------
                        *      char (-128 to 127)
                        *      signed char (-128 to 127)
                        *      unsigned char (0 - 255)
                        * 	-----------------------------*/
                        * 
                        * /**---------int 16-bit----------
                        * 	 int (-32768 to 32767)
                        * 	 signed int (-32768 to 32767)
                        *      unsigned int (0 to 65535)
                        * 	 -----------------------------*/
                        * 
                        * /***************************************************
                        * 
                        * 
                        * /***************************************************
                        *                            Port Direction configurat
                        *  ***************************************************
                        * #define LOW                0x00
                        * #define HIGH               0x01
                        * /***************************************************
                        * 
                        * /***************************************************
                        * ****************************************************
                        *                               Commonly used constant
                        * ****************************************************
                        * #define FALSE              0x00
                        * #define TRUE               0x01
                        * 
                        * /***************************************************
                        * 			32-bit variable and operation wrapper for 16-bit 
                        * ****************************************************
                        * typedef struct _u32_t {
                        * 	unsigned int h;
                        * 	unsigned int l;
                        * }u32_t;
                        * 
                        * 
                        * /*
                        * void _u32_and(u32_t *a, u32_t *b, u32_t *out);
AS09 Assembler for M6809 [1.42].                                     Page  128
--------------------------------- merge.a09 ----------------------------------

                        * void _u32_div2(u32_t *a, unsigned int b, u32_t *quot
                        * void _u32_mul(unsigned int a, u32_t *b, u32_t *prod)
                        * void _u32_sub(u32_t *a, u32_t *b, u32_t *dif);
                        * void _u32_dec(u32_t *a);
                        * void _u32_add(u32_t *a, u32_t *b, u32_t *sum);
                        * void _u32_inc(u32_t *a);
                        * unsigned char _u32_lower(u32_t *a, u32_t *b);
                        * unsigned char _u32_equal(u32_t *a, u32_t *b);
                        * unsigned char _u32_higher(u32_t *a, u32_t *b); 
                        * */
                        * 
                        * /***************************************************
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * /***************************************************
                        * 			32-bit variable and operation wrapper for 16-bit 
                        *  ***************************************************
                        * 
                        * // &
                        * _u32_and(a, b, out) u32_t *a; u32_t *b; u32_t *out; 
                        * 	out->l = a->l & b->l;
a6f9 :                  _u32_and
a6f9 : 3440             	pshs	u
a6fb : 33e4             	leau	,s
a6fd : ae46             	ldx	6,u
a6ff : ec02             	ldd	2,x
a701 : 3406             	pshs	d
a703 : ae44             	ldx	4,u
a705 : ec02             	ldd	2,x
a707 : a4e0             	anda	,s+
a709 : e4e0             	andb	,s+
a70b : ae48             	ldx	8,u
a70d : ed02             	std	2,x
                        * 	out->h = a->h & b->h;
a70f : ecd806           	ldd	[6,u]
a712 : 3406             	pshs	d
a714 : ecd804           	ldd	[4,u]
a717 : a4e0             	anda	,s+
a719 : e4e0             	andb	,s+
a71b : edd808           	std	[8,u]
                        * }
a71e : 35c0             	puls	u,pc
                        * 
                        * // /
                        * _u32_div2(a,b, quot) u32_t *a; unsigned int b; u32_t
                        * 	quot->h = a->h; quot->l = a->l;
a720 :                  _u32_div
a720 : 3440             	pshs	u
a722 : 33e4             	leau	,s
a724 : ecd804           	ldd	[4,u]
a727 : edd808           	std	[8,u]
a72a : ae44             	ldx	4,u
a72c : ec02             	ldd	2,x
a72e : ae48             	ldx	8,u
a730 : ed02             	std	2,x
                        * 	while (b > 1) {
AS09 Assembler for M6809 [1.42].                                     Page  129
--------------------------------- merge.a09 ----------------------------------

a732 :                  _3
a732 : ec46             	ldd	6,u
a734 : 830001           	subd	#$1
a737 : 1023004f         	lbls	_2
                        * 		quot->l = quot->l >> 1;
a73b : cc0001           	ldd	#$1
a73e : 3406             	pshs	d
a740 : ae48             	ldx	8,u
a742 : ec02             	ldd	2,x
a744 : 3510             	puls	x
a746 : bdecc4           	lbsr	_00009
a749 : ae48             	ldx	8,u
a74b : ed02             	std	2,x
                        * 		if (quot->h & 1) quot->l |= 0x8000;
a74d : ecd808           	ldd	[8,u]
a750 : 8400             	anda	#$0
a752 : c401             	andb	#$1
a754 : 830000           	subd	#$0
a757 : 1027000f         	lbeq	_4
a75b : ec48             	ldd	8,u
a75d : c30002           	addd	#$2
a760 : 1f01             	tfr	d,x
a762 : ec84             	ldd	0,x
a764 : 8a80             	ora	#$80
a766 : ca00             	orb	#$0
a768 : ed84             	std	0,x
                        * 		quot->h = quot->h >> 1;
a76a :                  _4
a76a : cc0001           	ldd	#$1
a76d : 3406             	pshs	d
a76f : ecd808           	ldd	[8,u]
a772 : 3510             	puls	x
a774 : bdecc4           	lbsr	_00009
a777 : edd808           	std	[8,u]
                        * 		b = b >> 1;
a77a : cc0001           	ldd	#$1
a77d : 3406             	pshs	d
a77f : ec46             	ldd	6,u
a781 : 3510             	puls	x
a783 : bdecc4           	lbsr	_00009
a786 : ed46             	std	6,u
                        * 	}
                        * }
a788 : 20a8             	lbra	_3
a78a :                  _2
a78a : 35c0             	puls	u,pc
                        * 
                        * // *
                        * _u32_mul(a, b, prod) unsigned int a; u32_t *b; u32_t
                        * 	unsigned int u16, a0, a1, b0, b1, b2, b3; // any ch
                        * 	{ // brace to ensure proper initialisation before t
a78c :                  _u32_mul
a78c : 3440             	pshs	u
a78e : 33e4             	leau	,s
a790 : 3272             	leas	-14,s
                        * #asm
                        * 	a0 = a & 0xff;
a792 : e645             	ldb	5,u		;lower word
a794 : 4f               	clra
a795 : ed5c             	std	-4,u
                        * 	a1 = a >> 8;
a797 : e644             	ldb	4,u
AS09 Assembler for M6809 [1.42].                                     Page  130
--------------------------------- merge.a09 ----------------------------------

a799 : 4f               	clra
a79a : ed5a             	std	-6,u
                        * 	b0 = b->l & 0xff;
a79c : ae46             	ldx	6,u
a79e : e603             	ldb	3,x		;lower word
a7a0 : 4f               	clra
a7a1 : ed58             	std	-8,u
                        * 	b1 = b->l >> 8;
a7a3 : ae46             	ldx	6,u
a7a5 : e602             	ldb	2,x
a7a7 : 4f               	clra
a7a8 : ed56             	std	-10,u
                        * 	b2 = b->h & 0xff;
a7aa : ae46             	ldx	6,u
a7ac : e601             	ldb	1,x		;lower word
a7ae : 4f               	clra
a7af : ed54             	std	-12,u
                        * 	b3 = b->h >> 8;
a7b1 : ae46             	ldx	6,u
a7b3 : e684             	ldb	0,x
a7b5 : 4f               	clra
a7b6 : ed52             	std	-14,u
                        * 	}
                        * 	// byte 0
                        * 	u16 = (a0 * b0);
a7b8 : ec5c             	ldd	-4,u
a7ba : 3406             	pshs	d
a7bc : ec58             	ldd	-8,u
a7be : 3510             	puls	x
a7c0 : bdecaa           	lbsr	_00001
a7c3 : ed5e             	std	-2,u
                        * 	prod->l = u16 & 0xff;	
a7c5 : ec5e             	ldd	-2,u
a7c7 : 8400             	anda	#$0
a7c9 : c4ff             	andb	#$ff
a7cb : ae48             	ldx	8,u
a7cd : ed02             	std	2,x
                        * 
                        * 	// byte 1
                        * #asm
                        *	u16 = u16 >> 8;
a7cf : e65e             	ldb	-2,u
a7d1 : 4f               	clra
a7d2 : ed5e             	std	-2,u
                        * 	u16 += (a1 * b0) + (a0 * b1);
a7d4 : ec5c             	ldd	-4,u
a7d6 : 3406             	pshs	d
a7d8 : ec56             	ldd	-10,u
a7da : 3510             	puls	x
a7dc : bdecaa           	lbsr	_00001
a7df : 3406             	pshs	d
a7e1 : ec5a             	ldd	-6,u
a7e3 : 3406             	pshs	d
a7e5 : ec58             	ldd	-8,u
a7e7 : 3510             	puls	x
a7e9 : bdecaa           	lbsr	_00001
a7ec : e3e1             	addd	,s++
a7ee : 3406             	pshs	d
a7f0 : ec5e             	ldd	-2,u
a7f2 : e3e1             	addd	,s++
a7f4 : ed5e             	std	-2,u
                        * #asm
AS09 Assembler for M6809 [1.42].                                     Page  131
--------------------------------- merge.a09 ----------------------------------

                        * 	prod->l += u16 << 8;
a7f6 : a65f             	lda	-1,u	; lower word
a7f8 : 5f               	clrb
a7f9 : 3406             	pshs	d
a7fb : ec48             	ldd	8,u
a7fd : c30002           	addd	#$2
a800 : 1f01             	tfr	d,x
a802 : ec84             	ldd	0,x
a804 : e3e1             	addd	,s++
a806 : ed84             	std	0,x
                        	
                        *	// byte 2
                        *	u16 = u16 >> 8;
a808 : e65e             	ldb	-2,u
a80a : 4f               	clra
a80b : ed5e             	std -2,u
                        * 	u16 += (a1 * b1) + (a0 * b2);
a80d : ec5c             	ldd	-4,u
a80f : 3406             	pshs	d
a811 : ec54             	ldd	-12,u
a813 : 3510             	puls	x
a815 : bdecaa           	lbsr	_00001
a818 : 3406             	pshs	d
a81a : ec5a             	ldd	-6,u
a81c : 3406             	pshs	d
a81e : ec56             	ldd	-10,u
a820 : 3510             	puls	x
a822 : bdecaa           	lbsr	_00001
a825 : e3e1             	addd	,s++
a827 : 3406             	pshs	d
a829 : ec5e             	ldd	-2,u
a82b : e3e1             	addd	,s++
a82d : ed5e             	std	-2,u
                        * 	prod->h = u16 & 0xff;
a82f : ec5e             	ldd	-2,u
a831 : 8400             	anda	#$0
a833 : c4ff             	andb	#$ff
a835 : edd808           	std	[8,u]
                        * 	
                        * 	// byte 3
                        * #asm
                        * 	u16 = u16 >> 8;
a838 : e65e             	ldb	-2,u	;upper word
a83a : 4f               	clra
a83b : ed5e             	std	-2,u
                        * 	u16 += (a1 * b2) + (a0 * b3);
a83d : ec5c             	ldd	-4,u
a83f : 3406             	pshs	d
a841 : ec52             	ldd	-14,u
a843 : 3510             	puls	x
a845 : bdecaa           	lbsr	_00001
a848 : 3406             	pshs	d
a84a : ec5a             	ldd	-6,u
a84c : 3406             	pshs	d
a84e : ec54             	ldd	-12,u
a850 : 3510             	puls	x
a852 : bdecaa           	lbsr	_00001
a855 : e3e1             	addd	,s++
a857 : 3406             	pshs	d
a859 : ec5e             	ldd	-2,u
a85b : e3e1             	addd	,s++
a85d : ed5e             	std	-2,u
AS09 Assembler for M6809 [1.42].                                     Page  132
--------------------------------- merge.a09 ----------------------------------

                        * #asm
                        * 	prod->h += u16 << 8;
a85f : a65f             	lda	-1,u	; lower word
a861 : 5f               	clrb
a862 : 3406             	pshs	d
a864 : ae48             	ldx	8,u
a866 : ec84             	ldd	0,x
a868 : e3e1             	addd	,s++
a86a : ed84             	std	0,x
                        * }
a86c : 32c4             	leas	,u
a86e : 35c0             	puls	u,pc
                        * 
                        * // -
                        * _u32_sub(a, b, dif) u32_t *a; u32_t *b; u32_t *dif; 
                        * 	dif->h = a->h - b->h;
a870 :                  _u32_sub
a870 : 3440             	pshs	u
a872 : 33e4             	leau	,s
a874 : ecd806           	ldd	[6,u]
a877 : 3406             	pshs	d
a879 : ecd804           	ldd	[4,u]
a87c : a3e1             	subd	,s++
a87e : edd808           	std	[8,u]
                        * 	dif->l = a->l - b->l;	
a881 : ae46             	ldx	6,u
a883 : ec02             	ldd	2,x
a885 : 3406             	pshs	d
a887 : ae44             	ldx	4,u
a889 : ec02             	ldd	2,x
a88b : a3e1             	subd	,s++
a88d : ae48             	ldx	8,u
a88f : ed02             	std	2,x
                        * 	if(a->l < b->l) dif->h -= 1;
a891 : ae46             	ldx	6,u
a893 : ec02             	ldd	2,x
a895 : 3406             	pshs	d
a897 : ae44             	ldx	4,u
a899 : ec02             	ldd	2,x
a89b : a3e1             	subd	,s++
a89d : 10240009         	lbhs	_5
a8a1 : ae48             	ldx	8,u
a8a3 : ec84             	ldd	0,x
a8a5 : 830001           	subd	#$1
a8a8 : ed84             	std	0,x
                        * }
a8aa :                  _5
a8aa : 35c0             	puls	u,pc
                        * 
                        * _u32_dec(a) u32_t *a; {
                        * 	a->l--;
a8ac :                  _u32_dec
a8ac : 3440             	pshs	u
a8ae : 33e4             	leau	,s
a8b0 : ec44             	ldd	4,u
a8b2 : c30002           	addd	#$2
a8b5 : 1f01             	tfr	d,x
a8b7 : ec84             	ldd	,x
a8b9 : c3ffff           	addd	#$ffff
a8bc : ed84             	std	,x
a8be : 83ffff           	subd	#$ffff
                        * 	if (a->l == 0xffff) a->h--;
AS09 Assembler for M6809 [1.42].                                     Page  133
--------------------------------- merge.a09 ----------------------------------

a8c1 : ae44             	ldx	4,u
a8c3 : ec02             	ldd	2,x
a8c5 : 83ffff           	subd	#$ffff
a8c8 : 1026000c         	lbne	_6
a8cc : ae44             	ldx	4,u
a8ce : ec84             	ldd	,x
a8d0 : c3ffff           	addd	#$ffff
a8d3 : ed84             	std	,x
a8d5 : 83ffff           	subd	#$ffff
                        * }
a8d8 :                  _6
a8d8 : 35c0             	puls	u,pc
                        * 
                        * // +
                        * _u32_add(a, b, sum) u32_t *a; u32_t *b; u32_t *sum; 
                        * 	sum->h = a->h + b->h;
a8da :                  _u32_add
a8da : 3440             	pshs	u
a8dc : 33e4             	leau	,s
a8de : ecd806           	ldd	[6,u]
a8e1 : 3406             	pshs	d
a8e3 : ecd804           	ldd	[4,u]
a8e6 : e3e1             	addd	,s++
a8e8 : edd808           	std	[8,u]
                        * 	sum->l = a->l + b->l;
a8eb : ae46             	ldx	6,u
a8ed : ec02             	ldd	2,x
a8ef : 3406             	pshs	d
a8f1 : ae44             	ldx	4,u
a8f3 : ec02             	ldd	2,x
a8f5 : e3e1             	addd	,s++
a8f7 : ae48             	ldx	8,u
a8f9 : ed02             	std	2,x
                        * 	if ((sum->l < a->l) || (sum->l < b->l)) sum->h++;
a8fb : ae44             	ldx	4,u
a8fd : ec02             	ldd	2,x
a8ff : 3406             	pshs	d
a901 : ae48             	ldx	8,u
a903 : ec02             	ldd	2,x
a905 : a3e1             	subd	,s++
a907 : 10250010         	lblo	_8
a90b : ae46             	ldx	6,u
a90d : ec02             	ldd	2,x
a90f : 3406             	pshs	d
a911 : ae48             	ldx	8,u
a913 : ec02             	ldd	2,x
a915 : a3e1             	subd	,s++
a917 : 1024000c         	lbhs	_7
a91b :                  _8
a91b : ae48             	ldx	8,u
a91d : ec84             	ldd	,x
a91f : c30001           	addd	#$1
a922 : ed84             	std	,x
a924 : 830001           	subd	#$1
                        * }
a927 :                  _7
a927 : 35c0             	puls	u,pc
                        * 
                        * _u32_inc(a) u32_t *a; {
                        * 	a->l++;
a929 :                  _u32_inc
a929 : 3440             	pshs	u
AS09 Assembler for M6809 [1.42].                                     Page  134
--------------------------------- merge.a09 ----------------------------------

a92b : 33e4             	leau	,s
a92d : ec44             	ldd	4,u
a92f : c30002           	addd	#$2
a932 : 1f01             	tfr	d,x
a934 : ec84             	ldd	,x
a936 : c30001           	addd	#$1
a939 : ed84             	std	,x
a93b : 830001           	subd	#$1
                        * 	if (a->l == 0) a->h++;
a93e : ae44             	ldx	4,u
a940 : ec02             	ldd	2,x
a942 : 830000           	subd	#$0
a945 : 1026000c         	lbne	_9
a949 : ae44             	ldx	4,u
a94b : ec84             	ldd	,x
a94d : c30001           	addd	#$1
a950 : ed84             	std	,x
a952 : 830001           	subd	#$1
                        * }
a955 :                  _9
a955 : 35c0             	puls	u,pc
                        * 
                        * // <
                        * _u32_lower(a,b) u32_t *a; u32_t *b; {
                        * 	if ((a->h < b->h) || ((a->h == b->h) && (a->l < b->
a957 :                  _u32_low
a957 : 3440             	pshs	u
a959 : 33e4             	leau	,s
a95b : ecd806           	ldd	[6,u]
a95e : 3406             	pshs	d
a960 : ecd804           	ldd	[4,u]
a963 : a3e1             	subd	,s++
a965 : 1025001e         	lblo	_11
a969 : ecd806           	ldd	[6,u]
a96c : 3406             	pshs	d
a96e : ecd804           	ldd	[4,u]
a971 : a3e1             	subd	,s++
a973 : 10260015         	lbne	_10
a977 : ae46             	ldx	6,u
a979 : ec02             	ldd	2,x
a97b : 3406             	pshs	d
a97d : ae44             	ldx	4,u
a97f : ec02             	ldd	2,x
a981 : a3e1             	subd	,s++
a983 : 10240005         	lbhs	_10
a987 :                  _11
a987 : cc0001           	ldd	#$1
                        * 	else return FALSE;
a98a : 35c0             	puls	u,pc
a98c :                  _10
a98c : 4f               	clra
a98d : 5f               	clrb
                        * }
a98e : 35c0             	puls	u,pc
                        * 
                        * // ==
                        * _u32_equal(a,b) u32_t *a; u32_t *b; {
                        * 	if ((a->h == b->h) && (a->l == b->l)) return TRUE;
a990 :                  _u32_equ
a990 : 3440             	pshs	u
a992 : 33e4             	leau	,s
a994 : ecd806           	ldd	[6,u]
AS09 Assembler for M6809 [1.42].                                     Page  135
--------------------------------- merge.a09 ----------------------------------

a997 : 3406             	pshs	d
a999 : ecd804           	ldd	[4,u]
a99c : a3e1             	subd	,s++
a99e : 10260015         	lbne	_12
a9a2 : ae46             	ldx	6,u
a9a4 : ec02             	ldd	2,x
a9a6 : 3406             	pshs	d
a9a8 : ae44             	ldx	4,u
a9aa : ec02             	ldd	2,x
a9ac : a3e1             	subd	,s++
a9ae : 10260005         	lbne	_12
a9b2 : cc0001           	ldd	#$1
                        * 	else return FALSE;
a9b5 : 35c0             	puls	u,pc
a9b7 :                  _12
a9b7 : 4f               	clra
a9b8 : 5f               	clrb
                        * }
a9b9 : 35c0             	puls	u,pc
                        * 
                        * // >
                        * _u32_higher(a,b) u32_t *a; u32_t *b; {
                        * 	if ((a->h > b->h) || ((a->h == b->h) && (a->l > b->
a9bb :                  _u32_hig
a9bb : 3440             	pshs	u
a9bd : 33e4             	leau	,s
a9bf : ecd806           	ldd	[6,u]
a9c2 : 3406             	pshs	d
a9c4 : ecd804           	ldd	[4,u]
a9c7 : a3e1             	subd	,s++
a9c9 : 1022001e         	lbhi	_14
a9cd : ecd806           	ldd	[6,u]
a9d0 : 3406             	pshs	d
a9d2 : ecd804           	ldd	[4,u]
a9d5 : a3e1             	subd	,s++
a9d7 : 10260015         	lbne	_13
a9db : ae46             	ldx	6,u
a9dd : ec02             	ldd	2,x
a9df : 3406             	pshs	d
a9e1 : ae44             	ldx	4,u
a9e3 : ec02             	ldd	2,x
a9e5 : a3e1             	subd	,s++
a9e7 : 10230005         	lbls	_13
a9eb :                  _14
a9eb : cc0001           	ldd	#$1
                        * 	else return FALSE;
a9ee : 35c0             	puls	u,pc
a9f0 :                  _13
a9f0 : 4f               	clra
a9f1 : 5f               	clrb
                        * }
a9f2 : 35c0             	puls	u,pc
                        * 
                        * /***************************************************
                        * 
                        * //unsigned char _strcpy(char *src)
                        * _strlen(src) char *src;
                        * {
                        * 	unsigned char i;
                        * 	i=0;
a9f4 :                  _strlen
a9f4 : 3440             	pshs	u
AS09 Assembler for M6809 [1.42].                                     Page  136
--------------------------------- merge.a09 ----------------------------------

a9f6 : 33e4             	leau	,s
a9f8 : 327f             	leas	-1,s
a9fa : 4f               	clra
a9fb : 5f               	clrb
a9fc : e75f             	stb	-1,u
                        * 	while((src[i] != 0) && (i <= 0xff)) {
a9fe :                  _16
a9fe : e65f             	ldb	-1,u
aa00 : 4f               	clra
aa01 : ae44             	ldx	4,u
aa03 : e68b             	ldb	d,x
aa05 : 4f               	clra
aa06 : 830000           	subd	#$0
aa09 : 10270013         	lbeq	_15
aa0d : e65f             	ldb	-1,u
aa0f : 4f               	clra
aa10 : 8300ff           	subd	#$ff
aa13 : 10220009         	lbhi	_15
                        * 		i++;		
aa17 : 305f             	leax	-1,u
aa19 : e684             	ldb	,x
aa1b : 6c84             	inc	,x
aa1d : 4f               	clra
                        * 	};
aa1e : 20de             	lbra	_16
aa20 :                  _15
                        * 	return i;
aa20 : e65f             	ldb	-1,u
aa22 : 4f               	clra
                        * }
aa23 : 32c4             	leas	,u
aa25 : 35c0             	puls	u,pc
                        * 
                        * //void _strcpy(char *dest, char *src)
                        * _strcpy(dest, src) char *dest; char *src;
                        * {
                        * 	char b;
                        * 	do {
aa27 :                  _strcpy
aa27 : 3440             	pshs	u
aa29 : 33e4             	leau	,s
aa2b : 327f             	leas	-1,s
aa2d :                  _19
                        * 		b = *src++;
aa2d : ae46             	ldx	6,u
aa2f : e680             	ldb	,x+
aa31 : af46             	stx	6,u
aa33 : 1d               	sex
aa34 : e75f             	stb	-1,u
                        * 		*dest++ = b;
aa36 : e65f             	ldb	-1,u
aa38 : 1d               	sex
aa39 : ae44             	ldx	4,u
aa3b : e780             	stb	,x+
aa3d : af44             	stx	4,u
                        * 	}while(b != 0);
aa3f :                  _18
aa3f : e65f             	ldb	-1,u
aa41 : 1d               	sex
aa42 : 830000           	subd	#$0
aa45 : 26e6             	lbne	_19
                        * }
AS09 Assembler for M6809 [1.42].                                     Page  137
--------------------------------- merge.a09 ----------------------------------

aa47 :                  _17
aa47 : 35c2             	puls	a,u,pc
                        * 
                        * //unsigned char _strcmp(char *str1, char *str2)
                        * _strcmp(str1, str2) char *str1; char *str2;
                        * {
                        * 	while((*str1 != 0) && (*str2 != 0)) {
aa49 :                  _strcmp
aa49 : 3440             	pshs	u
aa4b : 33e4             	leau	,s
aa4d :                  _21
aa4d : e6d804           	ldb	[4,u]
aa50 : 1d               	sex
aa51 : 830000           	subd	#$0
aa54 : 10270028         	lbeq	_20
aa58 : e6d806           	ldb	[6,u]
aa5b : 1d               	sex
aa5c : 830000           	subd	#$0
aa5f : 1027001d         	lbeq	_20
                        * 		if (*str1++ != *str2++) return 1;
aa63 : ae46             	ldx	6,u
aa65 : e680             	ldb	,x+
aa67 : af46             	stx	6,u
aa69 : 1d               	sex
aa6a : 3406             	pshs	d
aa6c : ae44             	ldx	4,u
aa6e : e680             	ldb	,x+
aa70 : af44             	stx	4,u
aa72 : 1d               	sex
aa73 : a3e1             	subd	,s++
aa75 : 10270005         	lbeq	_22
aa79 : cc0001           	ldd	#$1
                        * 	}
aa7c : 35c0             	puls	u,pc
aa7e :                  _22
                        * 	return 0;
aa7e : 20cd             	lbra	_21
aa80 :                  _20
aa80 : 4f               	clra
aa81 : 5f               	clrb
                        * }
aa82 : 35c0             	puls	u,pc
                        * 
                        * 
                        * 
                        * 
                        * /***************************************************
                        * /*                                                  
                        * /* file:          sdcard.c			                       
                        * /*                                                  
                        * /* source:        2023, written by Adrian Kundert (a
                        * /*                                                  
                        * /* description:   read and write data from SD CARD (
                        * /*                                                  
                        * /* This library is free software; you can redistribu
                        * /* GNU Lesser General Public License as published by
                        * /* either version 2.1 of the License, or (at your op
                        * /*                                                  
                        * /* This library is distributed in the hope that it w
                        * /* without even the implied warranty of MERCHANTABIL
                        * /* See the GNU Lesser General Public License for mor
                        * /*                                                  
AS09 Assembler for M6809 [1.42].                                     Page  138
--------------------------------- merge.a09 ----------------------------------

                        * /***************************************************
                        * 
                        * #include "sdcard.h"
                        * /***************************************************
                        * /*                                                  
                        * /* file:          sdcard.h			                       
                        * /*                                                  
                        * /* source:        2023, written by Adrian Kundert (a
                        * /*                                                  
                        * /* description:   read and write data from SD CARD (
                        * /*                                                  
                        * /* This library is free software; you can redistribu
                        * /* GNU Lesser General Public License as published by
                        * /* either version 2.1 of the License, or (at your op
                        * /*                                                  
                        * /* This library is distributed in the hope that it w
                        * /* without even the implied warranty of MERCHANTABIL
                        * /* See the GNU Lesser General Public License for mor
                        * /*                                                  
                        * /***************************************************
                        * 
                        * /***************************************************
                        *                                SD CARD INIT STATUS
                        *  ***************************************************
                        * #define INIT_SUCCESSFUL 0
                        * #define NOT_DETECTED    1
                        * #define INIT_FAILED     2
                        * #define FAT_INVALID     3
                        * #define SIZE_INVALID    4
                        * 
                        * 
                        * #define TYPE_UNKNOWN        0
                        * #define TYPE_STANDARD       1
                        * #define TYPE_HIGH_CAPACITY  2
                        * /***************************************************
                        * 
                        * #define C_MaxPageSize_U16        512
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * //SD commands, many of these are not used here
                        * #define GO_IDLE_STATE            0
                        * #define SEND_OP_COND             1
                        * #define SEND_IF_COND			 8
                        * #define SEND_CSD                 9
                        * #define STOP_TRANSMISSION        12
                        * #define SEND_STATUS              13
                        * #define SET_BLOCK_LEN            16
                        * #define RD_SINGLE_BLOCK        17
                        * #define RD_MULTIPLE_BLOCKS     18
                        * #define WR_SINGLE_BLOCK       24
                        * #define WR_MULTIPLE_BLOCKS    25
                        * // #define ERASE_BLOCK_START_ADDR   32
                        * // #define ERASE_BLOCK_END_ADDR     33
                        * // #define ERASE_SELECTED_BLOCKS    38
                        * #define SD_SEND_OP_COND			 41   
AS09 Assembler for M6809 [1.42].                                     Page  139
--------------------------------- merge.a09 ----------------------------------

                        * #define APP_CMD					 55
                        * #define READ_OCR				 58
                        * #define CRC_ON_OFF               59
                        * 
                        * 
                        * 
                        *  
                        * #define PORTA   0xd800
                        * #define CRA     0xd801
                        * #define PORTB   0xd802
                        * #define CRB     0xd803
                        * 
                        * //--------------------------------------------------
                        * 
                        * #define SD_TIMEOUT 2000
                        * 
                        * /*
                        *   The circuit:
                        *     SD card attached to GPIO as follows:
                        *  ** CS   - PB0 
                        *  ** MOSI - PB1
                        *  ** MISO - PB2
                        *  ** CLK  - PB3
                        * */
                        * 
                        * setPins() {
                        * 	/*	
                        * 	DDR |= 0b00000001; CS_HIGH();	// cs_n
                        * 	DDR |= 0b00000010; MOSI_HIGH();	// mosi
                        * 	DDR &= 0b11111011;				// miso
                        * 	DDR |= 0b00001000; SCK_LOW();	// sck
                        * 	*/
                        *  	PIAinit(PORTB, 0x0b);
aa84 :                  setPins
aa84 : 3440             	pshs	u
aa86 : 33e4             	leau	,s
aa88 : cc000b           	ldd	#$b
aa8b : 3406             	pshs	d
aa8d : ccd802           	ldd	#$d802
aa90 : 3406             	pshs	d
aa92 : bdf079           	lbsr	PIAinit
aa95 : 3264             	leas	4,s
                        * 	CS_HIGH(); MOSI_HIGH(); SCK_LOW();
aa97 : bdaaa2           	lbsr	CS_HIGH
aa9a : bdaab4           	lbsr	MOSI_HIG
aa9d : bdaad8           	lbsr	SCK_LOW
                        * }
aaa0 : 35c0             	puls	u,pc
                        * 
                        * #asm
aaa2 : f6d802           CS_HIGH		ldb		PORTB
aaa5 : ca01             			orb		#%00000001
aaa7 : f7d802           			stb		PORTB
aaaa : 39               			rts
                        
aaab : f6d802           CS_LOW		ldb		PORTB
aaae : c4fe             			andb	#%11111110
aab0 : f7d802           			stb		PORTB
aab3 : 39               			rts
                        
aab4 : f6d802           MOSI_HIG	ldb		PORTB
aab7 : ca02             			orb		#%00000010
AS09 Assembler for M6809 [1.42].                                     Page  140
--------------------------------- merge.a09 ----------------------------------

aab9 : f7d802           			stb		PORTB
aabc : 39               			rts
                        
aabd : f6d802           MOSI_LOW	ldb		PORTB
aac0 : c4fd             			andb	#%11111101
aac2 : f7d802           			stb		PORTB
aac5 : 39               			rts		
                        
aac6 : f6d802           MISO_REA	ldb		PORTB
aac9 : c404             			andb	#%00000100
aacb : 54               			lsrb	
aacc : 54               			lsrb
aacd : 4f               			clra
aace : 39               			rts
                        
aacf : f6d802           SCK_HIGH	ldb		PORTB
aad2 : ca08             			orb		#%00001000
aad4 : f7d802           			stb		PORTB
aad7 : 39               			rts
                        
aad8 : f6d802           SCK_LOW		ldb		PORTB
aadb : c4f7             			andb	#%11110111
aadd : f7d802           			stb		PORTB
aae0 : 39               			rts
                        * 
                        * 
                        * SPI_Init() {
                        *   unsigned char i;
                        * 
                        *   setPins();
aae1 :                  SPI_Init
aae1 : 3440             	pshs	u
aae3 : 33e4             	leau	,s
aae5 : 327f             	leas	-1,s
aae7 : 8d9b             	lbsr	setPins
                        *   
                        *   // 80 clks without CS to init the SPI connection  
                        *   for(i=0; i<80; i++) {
aae9 : 4f               	clra
aaea : 5f               	clrb
aaeb : e75f             	stb	-1,u
aaed :                  _24
aaed : e65f             	ldb	-1,u
aaef : 4f               	clra
aaf0 : 830050           	subd	#$50
aaf3 : 1024000d         	lbhs	_23
                        *     SCK_HIGH();
aaf7 : 8dd6             	lbsr	SCK_HIGH
                        *     SCK_LOW();
aaf9 : 8ddd             	lbsr	SCK_LOW
                        *   }  
                        * }
aafb :                  _25
aafb : 305f             	leax	-1,u
aafd : e684             	ldb	,x
aaff : 6c84             	inc	,x
ab01 : 1d               	sex
ab02 : 20e9             	lbra	_24
ab04 :                  _23
ab04 : 35c2             	puls	a,u,pc
                        * 
                        * //SPI_Write(data) unsigned char data; {}
AS09 Assembler for M6809 [1.42].                                     Page  141
--------------------------------- merge.a09 ----------------------------------

                        * #asm
ab06 :                  SPI_Write
ab06 :                  SPI_Writ
                        		; 0,s return address
                        		; 2,s not used -> taken as unsigned char i
                        		; 3,s data
ab06 : 8608             		lda	#8			;8 bits countdown
ab08 : a762             		sta	2,s		
ab0a : 8dcc             SPI_W0	lbsr SCK_LOW
ab0c : 6863             		lsl 3,s
ab0e : 10240005         		lbcc SPI_W1
ab12 : 8da0             		lbsr MOSI_HIG
ab14 : 200312           		lbra SPI_W2
ab17 : 8da4             SPI_W1	lbsr MOSI_LOW
ab19 : 8db4             SPI_W2	lbsr SCK_HIGH		
ab1b : 6a62             		dec 2,s
ab1d : 26eb             		lbne SPI_W0
ab1f : 8db7             		lbsr SCK_LOW				
ab21 : 39               		rts
                        * 
                        * SPI_Rsync(mask) unsigned char mask; {
                        *     unsigned char data;			// any changes will impact
                        *     unsigned int retry;
                        * 	data = 0xff;
ab22 :                  SPI_Rsyn
ab22 : 3440             	pshs	u
ab24 : 33e4             	leau	,s
ab26 : 327d             	leas	-3,s
ab28 : cc00ff           	ldd	#$ff
ab2b : e75f             	stb	-1,u
                        *     retry = SD_TIMEOUT;
ab2d : cc07d0           	ldd	#$7d0
ab30 : ed5d             	std	-3,u
                        * 	
                        * 	MOSI_HIGH(); // rest state 
ab32 : 8d80             	lbsr	MOSI_HIG
                        *     do {  // 10 KHz sck loop
ab34 :                  _28
                        *         if(--retry == 0) break; //{print_DebugMsg("s
ab34 : ec5d             	ldd	-3,u
ab36 : c3ffff           	addd	#$ffff
ab39 : ed5d             	std	-3,u
ab3b : 830000           	subd	#$0
ab3e : 10260003         	lbne	_29
ab42 : 202312           	lbra	_26
                        * 		SCK_HIGH();
ab45 :                  _29
ab45 : 8d88             	lbsr	SCK_HIGH
                        * #asm
                        *       data = MISO_READ() | (data<<1);
ab47 : 685f             		lsl		-1,u
ab49 : bdaac6           		lbsr	MISO_REA
ab4c : ea5f             		orb		-1,u
ab4e : e75f             		stb		-1,u
                        * 		SCK_LOW();		
ab50 : 8d86             	lbsr	SCK_LOW
                        *     }while((data|mask) != mask);  // wait on matchin
ab52 :                  _27
ab52 : e645             	ldb	5,u
ab54 : 4f               	clra
ab55 : 3406             	pshs	d
ab57 : e645             	ldb	5,u
AS09 Assembler for M6809 [1.42].                                     Page  142
--------------------------------- merge.a09 ----------------------------------

ab59 : 4f               	clra
ab5a : 3406             	pshs	d
ab5c : e65f             	ldb	-1,u
ab5e : 4f               	clra
ab5f : aae0             	ora	,s+
ab61 : eae0             	orb	,s+
ab63 : a3e1             	subd	,s++
ab65 : 26cd             	lbne	_28
                        *     
                        *     return data;
ab67 :                  _26
ab67 : e65f             	ldb	-1,u
ab69 : 4f               	clra
                        * }
ab6a : 32c4             	leas	,u
ab6c : 35c0             	puls	u,pc
                        * 
                        * SPI_Read() {
                        *     unsigned char i, data;		// any changes will impa
                        * 	
                        * 	data=0;
ab6e :                  SPI_Read
ab6e : 3440             	pshs	u
ab70 : 33e4             	leau	,s
ab72 : 327e             	leas	-2,s
ab74 : 4f               	clra
ab75 : 5f               	clrb
ab76 : e75e             	stb	-2,u
                        *     MOSI_HIGH(); // rest state 
ab78 : bdaab4           	lbsr	MOSI_HIG
                        * #asm
                        *	for(i=8; i>0; i--)  {   // 10 KHz sck loop     
ab7b : c608             	ldb	#8
ab7d : e75f             	stb	-1,u
ab7f :                  SPI_R1	
                        *         SCK_HIGH(); 
ab7f : bdaacf           	lbsr	SCK_HIGH
                        *         data = MISO_READ() | (data<<1);        
ab82 : bdaac6           	lbsr	MISO_REA
ab85 : 685e             	lsl		-2,u
ab87 : ea5e             	orb		-2,u
ab89 : e75e             	stb		-2,u
                        *         SCK_LOW();
ab8b : bdaad8           	lbsr	SCK_LOW
ab8e : 6a5f             	dec		-1,u
ab90 : 26ed             	lbne	SPI_R1
                        *     }	
                        *     return data;
ab92 : e65e             	ldb	-2,u
ab94 : 4f               	clra
                        * }
ab95 : 35d0             	puls	x,u,pc
                        * 
                        * SPI_EnableChipSelect () {
                        *     CS_LOW();
ab97 :                  SPI_Enab
ab97 : 3440             	pshs	u
ab99 : 33e4             	leau	,s
ab9b : bdaaab           	lbsr	CS_LOW
                        * }
ab9e : 35c0             	puls	u,pc
                        * 
AS09 Assembler for M6809 [1.42].                                     Page  143
--------------------------------- merge.a09 ----------------------------------

                        * SPI_DisableChipSelect () {
                        *     CS_HIGH();
aba0 :                  SPI_Disa
aba0 : 3440             	pshs	u
aba2 : 33e4             	leau	,s
aba4 : bdaaa2           	lbsr	CS_HIGH
                        * }
aba7 : 35c0             	puls	u,pc
                        * 
                        * //--------------------------------------------------
                        * unsigned char V_SdHighcapacityFlag_u8;
ffff =                  V_SdHigh	equ	-1
                        * 
                        * 
                        * //**************************************************
                        * //Function	: to send a command to SD card
                        * //Arguments	: unsigned char (8-bit command value)
                        * // 			  & unsigned long (32-bit command argument)
                        * //return	: unsigned char; response byte
                        * //**************************************************
                        * SD_sendCommand(cmd, arg) unsigned char cmd; u32_t *a
                        * {
                        * 	unsigned char response; 		// any changes will impac
                        * 	unsigned int argLo, argHi;  	// any changes will im
                        * 	
                        * 	response = 0xff;	
aba9 :                  SD_sendC
aba9 : 3440             	pshs	u
abab : 33e4             	leau	,s
abad : 327b             	leas	-5,s
abaf : cc00ff           	ldd	#$ff
abb2 : e75f             	stb	-1,u
                        * 	argHi = arg->h;
abb4 : ecd806           	ldd	[6,u]
abb7 : ed5b             	std	-5,u
                        * 	argLo = arg->l;
abb9 : ae46             	ldx	6,u
abbb : ec02             	ldd	2,x
abbd : ed5d             	std	-3,u
                        * 	
                        * 	if(SPI_Rsync(0xff) == 0xff) //ensure ready, shall r
abbf : cc00ff           	ldd	#$ff
abc2 : 3406             	pshs	d
abc4 : bdab22           	lbsr	SPI_Rsyn
abc7 : 3262             	leas	2,s
abc9 : 8300ff           	subd	#$ff
abcc : 102600aa         	lbne	_30
                        * 	{
                        * 		   
                        * 	    //SD card accepts byte address while SDHC accep
                        * 	    //so, if it's SD card we need to convert block 
                        * 	    //multiplying it with 512. which is equivalent 
                        * 	    //following 'if' loop does that
                        * 	    
                        * 		if(V_SdHighcapacityFlag_u8 == 0)
abd0 : e63f             	ldb	V_SdHigh+0,y
abd2 : 4f               	clra
abd3 : 830000           	subd	#$0
abd6 : 1026003f         	lbne	_31
                        * 	    {
                        * 		    if((cmd == RD_SINGLE_BLOCK)      ||
                        * 				(cmd == RD_MULTIPLE_BLOCKS)  ||
AS09 Assembler for M6809 [1.42].                                     Page  144
--------------------------------- merge.a09 ----------------------------------

                        * 				(cmd == WR_SINGLE_BLOCK)    ||
                        * 				(cmd == WR_MULTIPLE_BLOCKS))
abda : e645             	ldb	5,u
abdc : 4f               	clra
abdd : 830011           	subd	#$11
abe0 : 1027001e         	lbeq	_33
abe4 : e645             	ldb	5,u
abe6 : 4f               	clra
abe7 : 830012           	subd	#$12
abea : 10270014         	lbeq	_33
abee : e645             	ldb	5,u
abf0 : 4f               	clra
abf1 : 830018           	subd	#$18
abf4 : 1027000a         	lbeq	_33
abf8 : e645             	ldb	5,u
abfa : 4f               	clra
abfb : 830019           	subd	#$19
abfe : 10260017         	lbne	_32
ac02 :                  _33
                        * 		    {
                        * #asm			
                        *				argHi = (argHi << 9) | (argLo >> 7);
ac02 : 4f               				clra
ac03 : e65e             				ldb	-2,u	; argLo lower word
ac05 : 58               				lslb
ac06 : 49               				rola
ac07 : 3402             				pshs a		; msb argLo lower word
ac09 : a65c             				lda	-4,u	; argHi lower word
ac0b : e65d             				ldb -3,u	; argLo upper word
ac0d : 58               				lslb
ac0e : 49               				rola
ac0f : ebe0             				addb ,s+
ac11 : ed5b             				std	-5,u
                         			    
                        *				argLo = argLo << 9;				
ac13 : a65e             				lda	-2,u	; argLo lower word
ac15 : 48               				lsla
ac16 : 5f               				clrb
ac17 : ed5d             				std	-3,u
                        * 		    }
                        * 	    }
ac19 :                  _32
                        * 		
                        * 		{	// use a brace when starting asm code following 
ac19 :                  _31
                        * #asm
                        *		SPI_Write( cmd | 0x40 );
ac19 : e645             		ldb	5,u
ac1b : 4f               		clra
ac1c : ca40             		orb	#$40
ac1e : 3406             		pshs	d
ac20 : bdab06           		lbsr	SPI_Writ
ac23 : 3262             		leas	2,s
                        *		SPI_Write( argHi >> 8);
ac25 : e65b             		ldb	-5,u	; argHi upper word
ac27 : 4f               		clra
ac28 : 3406             		pshs	d
ac2a : bdab06           		lbsr	SPI_Writ
ac2d : 3262             		leas	2,s
                        *		SPI_Write( argHi & 0xff );
ac2f : e65c             		ldb	-4,u	; argHi lower word
ac31 : 4f               		clra
AS09 Assembler for M6809 [1.42].                                     Page  145
--------------------------------- merge.a09 ----------------------------------

ac32 : 3406             		pshs	d
ac34 : bdab06           		lbsr	SPI_Writ
ac37 : 3262             		leas	2,s		
                        *		SPI_Write( argLo >> 8);
ac39 : e65d             		ldb	-3,u	; argLo upper word
ac3b : 4f               		clra
ac3c : 3406             		pshs	d
ac3e : bdab06           		lbsr	SPI_Writ
ac41 : 3262             		leas	2,s
                        *		SPI_Write( argLo & 0xff );
ac43 : e65e             		ldb	-2,u	; argLo lower word
ac45 : 4f               		clra
ac46 : 3406             		pshs	d
ac48 : bdab06           		lbsr	SPI_Writ
ac4b : 3262             		leas	2,s
                        * 		}
                        * 		
                        * 		if ( cmd == SEND_IF_COND )
ac4d : e645             	ldb	5,u
ac4f : 4f               	clra
ac50 : 830008           	subd	#$8
ac53 : 1026000d         	lbne	_34
                        * 			SPI_Write( 0x87 );     
ac57 : cc0087           	ldd	#$87
ac5a : 3406             	pshs	d
ac5c : bdab06           	lbsr	SPI_Writ
ac5f : 3262             	leas	2,s
                        * 		else {
ac61 : 200b12           	lbra	_35
ac64 :                  _34
                        * 			SPI_Write( 0x95 ); 
ac64 : cc0095           	ldd	#$95
ac67 : 3406             	pshs	d
ac69 : bdab06           	lbsr	SPI_Writ
ac6c : 3262             	leas	2,s
                        * 		}
                        * 		response = SPI_Rsync(0x7f); //wait response, is 0 
ac6e :                  _35
ac6e : cc007f           	ldd	#$7f
ac71 : 3406             	pshs	d
ac73 : bdab22           	lbsr	SPI_Rsyn
ac76 : 3262             	leas	2,s
ac78 : e75f             	stb	-1,u
                        * 	}
                        * 	
                        * 	if((response == 0x00) && (cmd == READ_OCR))  //chec
ac7a :                  _30
ac7a : e65f             	ldb	-1,u
ac7c : 4f               	clra
ac7d : 830000           	subd	#$0
ac80 : 1026002d         	lbne	_36
ac84 : e645             	ldb	5,u
ac86 : 4f               	clra
ac87 : 83003a           	subd	#$3a
ac8a : 10260023         	lbne	_36
                        * 	{
                        * 		if((SPI_Read() & 0x40) != 0) //first byte of the O
ac8e : bdab6e           	lbsr	SPI_Read
ac91 : 8400             	anda	#$0
ac93 : c440             	andb	#$40
ac95 : 830000           	subd	#$0
ac98 : 10270008         	lbeq	_37
AS09 Assembler for M6809 [1.42].                                     Page  146
--------------------------------- merge.a09 ----------------------------------

                        * 		{
                        * 			V_SdHighcapacityFlag_u8 = 1;  //we need it to ver
ac9c : cc0001           	ldd	#$1
ac9f : e73f             	stb	V_SdHigh+0,y
                        * 			//print_DebugMsg("set SdHighcapacityFlag\n");
                        * 		}
                        * 		else
aca1 : 200512           	lbra	_38
aca4 :                  _37
                        * 		{
                        * 			V_SdHighcapacityFlag_u8 = 0;
aca4 : 4f               	clra
aca5 : 5f               	clrb
aca6 : e73f             	stb	V_SdHigh+0,y
                        * 		}
                        * 
                        * 		SPI_Read(); //remaining 3 bytes of the OCR registe
aca8 :                  _38
aca8 : bdab6e           	lbsr	SPI_Read
                        * 		SPI_Read(); //one can use these bytes to check pow
acab : bdab6e           	lbsr	SPI_Read
                        * 		SPI_Read();
acae : bdab6e           	lbsr	SPI_Read
                        * 	}
                        * 	
                        *     SPI_Read(); //extra 8 CLK
acb1 :                  _36
acb1 : bdab6e           	lbsr	SPI_Read
                        * 	return response;
acb4 : e65f             	ldb	-1,u
acb6 : 4f               	clra
                        * }
acb7 : 32c4             	leas	,u
acb9 : 35c0             	puls	u,pc
                        * 
                        * /***************************************************
                        *                           uint8_t SD_Init(uint8_t *c
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                  uint8_t *: Pointer to stire Card Ty
                        *                            SDCARD_TYPE_UNKNOWN
                        *                            SDCARD_TYPE_STANDARD
                        *                            SDCARD_TYPE_HIGH_CAPACITY
                        * 
                        *  * Return value  :
                        *                   uint8_t : Returns the SD card init
                        *                   SDCARD_INIT_SUCCESSFUL
                        *                   SDCARD_NOT_DETECTED
                        *                   SDCARD_INIT_FAILED
                        *                   SDCARD_FAT_INVALID
                        * 
                        *  * description :
                        *                  This function is used to initialize
                        *                  It returns the initialization statu
                        *  ***************************************************
                        * SD_Init(cardType) unsigned char *cardType; {
                        * 	unsigned char response, sd_version;
                        * 	unsigned int retry;
                        * 	u32_t tmp;
                        * 	
                        * 	{ // brace to ensure proper initialisation before t
acbb :                  SD_Init
AS09 Assembler for M6809 [1.42].                                     Page  147
--------------------------------- merge.a09 ----------------------------------

acbb : 3440             	pshs	u
acbd : 33e4             	leau	,s
acbf : 3278             	leas	-8,s
                        * #asm	
acc1 : 108e7fbd         	ldy  #GV_StackBeginAddr	; restore C global variables 
                        * 	}
                        * 	
                        * 	SPI_Init();
acc5 : bdaae1           	lbsr	SPI_Init
                        * 	V_SdHighcapacityFlag_u8 = 0;
acc8 : 4f               	clra
acc9 : 5f               	clrb
acca : e73f             	stb	V_SdHigh+0,y
                        * 
                        * 	SPI_EnableChipSelect ();    
accc : bdab97           	lbsr	SPI_Enab
                        * 	retry=SD_TIMEOUT;
accf : cc07d0           	ldd	#$7d0
acd2 : ed5c             	std	-4,u
                        * 	tmp.h = tmp.l = 0x0000;
acd4 : 4f               	clra
acd5 : 5f               	clrb
acd6 : ed5a             	std	-6,u
acd8 : ed58             	std	-8,u
                        * 	do {
acda :                  _41
                        *         response = SD_sendCommand(GO_IDLE_STATE, &tm
acda : 3058             	leax	-8,u
acdc : 3410             	pshs	x
acde : 4f               	clra
acdf : 5f               	clrb
ace0 : 3406             	pshs	d
ace2 : bdaba9           	lbsr	SD_sendC
ace5 : 3264             	leas	4,s
ace7 : e75f             	stb	-1,u
                        *         if(--retry == 0) {return NOT_DETECTED;}   //
ace9 : ec5c             	ldd	-4,u
aceb : c3ffff           	addd	#$ffff
acee : ed5c             	std	-4,u
acf0 : 830000           	subd	#$0
acf3 : 10260007         	lbne	_42
acf7 : cc0001           	ldd	#$1
acfa : 32c4             	leas	,u
acfc : 35c0             	puls	u,pc
                        *     }while(response != 1);
acfe :                  _42
acfe :                  _40
acfe : e65f             	ldb	-1,u
ad00 : 4f               	clra
ad01 : 830001           	subd	#$1
ad04 : 26d4             	lbne	_41
                        * 	//print_DebugMsg("cmd00 OK\n");
                        *  	
                        * 	retry = SD_TIMEOUT;
ad06 :                  _39
ad06 : cc07d0           	ldd	#$7d0
ad09 : ed5c             	std	-4,u
                        * 	*cardType = TYPE_STANDARD;
ad0b : cc0001           	ldd	#$1
ad0e : e7d804           	stb	[4,u]
                        * 	sd_version = 2; //default set to SD compliance with
ad11 : cc0002           	ldd	#$2
AS09 Assembler for M6809 [1.42].                                     Page  148
--------------------------------- merge.a09 ----------------------------------

ad14 : e75e             	stb	-2,u
                        * 	//this may change after checking the next command
                        * 	tmp.h = 0x0000; tmp.l = 0x01AA;
ad16 : 4f               	clra
ad17 : 5f               	clrb
ad18 : ed58             	std	-8,u
ad1a : cc01aa           	ldd	#$1aa
ad1d : ed5a             	std	-6,u
                        * 	do {        
ad1f :                  _45
                        *         response = SD_sendCommand(SEND_IF_COND, &tmp
ad1f : 3058             	leax	-8,u
ad21 : 3410             	pshs	x
ad23 : cc0008           	ldd	#$8
ad26 : 3406             	pshs	d
ad28 : bdaba9           	lbsr	SD_sendC
ad2b : 3264             	leas	4,s
ad2d : e75f             	stb	-1,u
                        *         SPI_Read(); SPI_Read(); SPI_Read(); SPI_Read
ad2f : bdab6e           	lbsr	SPI_Read
ad32 : bdab6e           	lbsr	SPI_Read
ad35 : bdab6e           	lbsr	SPI_Read
ad38 : bdab6e           	lbsr	SPI_Read
                        * 		if(--retry == 0) {
ad3b : ec5c             	ldd	-4,u
ad3d : c3ffff           	addd	#$ffff
ad40 : ed5c             	std	-4,u
ad42 : 830000           	subd	#$0
ad45 : 10260008         	lbne	_46
                        * 			sd_version = 1;			
ad49 : cc0001           	ldd	#$1
ad4c : e75e             	stb	-2,u
                        * 			break;
ad4e : 200912           	lbra	_43
                        * 		}
                        *     }while(response != 1);    
ad51 :                  _46
ad51 :                  _44
ad51 : e65f             	ldb	-1,u
ad53 : 4f               	clra
ad54 : 830001           	subd	#$1
ad57 : 26c6             	lbne	_45
                        *     //print_DebugMsg("cmd08 done\n");
                        * 	 
                        * 	retry = SD_TIMEOUT;
ad59 :                  _43
ad59 : cc07d0           	ldd	#$7d0
ad5c : ed5c             	std	-4,u
                        * 	do {
ad5e :                  _49
                        *         tmp.h = tmp.l = 0x0000;
ad5e : 4f               	clra
ad5f : 5f               	clrb
ad60 : ed5a             	std	-6,u
ad62 : ed58             	std	-8,u
                        * 		SD_sendCommand(APP_CMD, &tmp);
ad64 : 3058             	leax	-8,u
ad66 : 3410             	pshs	x
ad68 : cc0037           	ldd	#$37
ad6b : 3406             	pshs	d
ad6d : bdaba9           	lbsr	SD_sendC
ad70 : 3264             	leas	4,s
AS09 Assembler for M6809 [1.42].                                     Page  149
--------------------------------- merge.a09 ----------------------------------

                        * 		tmp.h = 0x4000; tmp.l = 0x0000;
ad72 : cc4000           	ldd	#$4000
ad75 : ed58             	std	-8,u
ad77 : 4f               	clra
ad78 : 5f               	clrb
ad79 : ed5a             	std	-6,u
                        *         response = SD_sendCommand(SD_SEND_OP_COND, &
ad7b : 3058             	leax	-8,u
ad7d : 3410             	pshs	x
ad7f : cc0029           	ldd	#$29
ad82 : 3406             	pshs	d
ad84 : bdaba9           	lbsr	SD_sendC
ad87 : 3264             	leas	4,s
ad89 : e75f             	stb	-1,u
                        *         if(--retry == 0) {return INIT_FAILED;}  //ti
ad8b : ec5c             	ldd	-4,u
ad8d : c3ffff           	addd	#$ffff
ad90 : ed5c             	std	-4,u
ad92 : 830000           	subd	#$0
ad95 : 10260007         	lbne	_50
ad99 : cc0002           	ldd	#$2
ad9c : 32c4             	leas	,u
ad9e : 35c0             	puls	u,pc
                        *     }while(response != 0);
ada0 :                  _50
ada0 :                  _48
ada0 : e65f             	ldb	-1,u
ada2 : 4f               	clra
ada3 : 830000           	subd	#$0
ada6 : 26b6             	lbne	_49
                        *     //print_DebugMsg("cmd55,cmd41 OK\n");
                        *     //print_DebugMsg("Wiring is correct and a card i
                        * 	
                        * 	if (sd_version == 2) {
ada8 :                  _47
ada8 : e65e             	ldb	-2,u
adaa : 4f               	clra
adab : 830002           	subd	#$2
adae : 10260052         	lbne	_51
                        * 		retry = SD_TIMEOUT;
adb2 : cc07d0           	ldd	#$7d0
adb5 : ed5c             	std	-4,u
                        * 		tmp.h = tmp.l = 0x0000;		
adb7 : 4f               	clra
adb8 : 5f               	clrb
adb9 : ed5a             	std	-6,u
adbb : ed58             	std	-8,u
                        * 		do {			
adbd :                  _54
                        * 			response = SD_sendCommand(READ_OCR, &tmp);			
adbd : 3058             	leax	-8,u
adbf : 3410             	pshs	x
adc1 : cc003a           	ldd	#$3a
adc4 : 3406             	pshs	d
adc6 : bdaba9           	lbsr	SD_sendC
adc9 : 3264             	leas	4,s
adcb : e75f             	stb	-1,u
                        * 			if(--retry == 0) {
adcd : ec5c             	ldd	-4,u
adcf : c3ffff           	addd	#$ffff
add2 : ed5c             	std	-4,u
add4 : 830000           	subd	#$0
AS09 Assembler for M6809 [1.42].                                     Page  150
--------------------------------- merge.a09 ----------------------------------

add7 : 10260008         	lbne	_55
                        * 				*cardType = TYPE_UNKNOWN;
addb : 4f               	clra
addc : 5f               	clrb
addd : e7d804           	stb	[4,u]
                        * 				break;  //time out
ade0 : 200912           	lbra	_52
                        * 			}
                        * 		}while(response != 0);
ade3 :                  _55
ade3 :                  _53
ade3 : e65f             	ldb	-1,u
ade5 : 4f               	clra
ade6 : 830000           	subd	#$0
ade9 : 26d2             	lbne	_54
                        * 		//print_DebugMsg("cmd58 sent\n");
                        * 		
                        * 		if((cardType != TYPE_UNKNOWN) && (V_SdHighcapacity
adeb :                  _52
adeb : ec44             	ldd	4,u
aded : 830000           	subd	#$0
adf0 : 10270010         	lbeq	_56
adf4 : e63f             	ldb	V_SdHigh+0,y
adf6 : 4f               	clra
adf7 : 830001           	subd	#$1
adfa : 10260006         	lbne	_56
                        * 			*cardType = TYPE_HIGH_CAPACITY;
adfe : cc0002           	ldd	#$2
ae01 : e7d804           	stb	[4,u]
                        * 		}
                        * 	}
ae04 :                  _56
                        * 	SPI_DisableChipSelect ();
ae04 :                  _51
ae04 : bdaba0           	lbsr	SPI_Disa
                        * 
                        *     //print_DebugMsg("SD init completed\n");
                        * 	return INIT_SUCCESSFUL;  
ae07 : 4f               	clra
ae08 : 5f               	clrb
                        * }
ae09 : 32c4             	leas	,u
ae0b : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function	: to read a single block from SD card
                        * //Arguments	: none
                        * //return	: unsigned char; will be 0 if no error,
                        * // 			  otherwise the response byte is returned
                        * //**************************************************
                        * SD_readSingleBlock(buf, startBlock) char *buf; u32_t
                        * {
                        * 	unsigned char response;
                        * 	unsigned int i;
                        * 	
                        * 	SPI_EnableChipSelect ();
ae0d :                  SD_readS
ae0d : 3440             	pshs	u
ae0f : 33e4             	leau	,s
ae11 : 327d             	leas	-3,s
ae13 : bdab97           	lbsr	SPI_Enab
                        *     i=SD_TIMEOUT;
AS09 Assembler for M6809 [1.42].                                     Page  151
--------------------------------- merge.a09 ----------------------------------

ae16 : cc07d0           	ldd	#$7d0
ae19 : ed5d             	std	-3,u
                        * 	do {
ae1b :                  _59
                        * 		response = SD_sendCommand(RD_SINGLE_BLOCK, startBl
ae1b : ec46             	ldd	6,u
ae1d : 3406             	pshs	d
ae1f : cc0011           	ldd	#$11
ae22 : 3406             	pshs	d
ae24 : bdaba9           	lbsr	SD_sendC
ae27 : 3264             	leas	4,s
ae29 : e75f             	stb	-1,u
                        * 		if(--i == 0) {
ae2b : ec5d             	ldd	-3,u
ae2d : c3ffff           	addd	#$ffff
ae30 : ed5d             	std	-3,u
ae32 : 830000           	subd	#$0
ae35 : 10260007         	lbne	_60
                        * 		    //print_DebugMsg("\nread cmd failed!\n");
                        * 		    return response; //check for SD status: 0x00 -
ae39 : e65f             	ldb	-1,u
ae3b : 4f               	clra
                        * 	    }		
ae3c : 32c4             	leas	,u
ae3e : 35c0             	puls	u,pc
                        * 	}while(response != 0x00);
ae40 :                  _60
ae40 :                  _58
ae40 : e65f             	ldb	-1,u
ae42 : 4f               	clra
ae43 : 830000           	subd	#$0
ae46 : 26d3             	lbne	_59
                        *     
                        * 	if(SPI_Rsync(0xfe) != 0xfe) //wait data token 0xfe 
ae48 :                  _57
ae48 : cc00fe           	ldd	#$fe
ae4b : 3406             	pshs	d
ae4d : bdab22           	lbsr	SPI_Rsyn
ae50 : 3262             	leas	2,s
ae52 : 8300fe           	subd	#$fe
ae55 : 1027000a         	lbeq	_61
                        * 	{									
                        *   		SPI_DisableChipSelect();        
ae59 : bdaba0           	lbsr	SPI_Disa
                        *   		//print_DebugMsg("read token failed!\n");
                        * 		return 1;
ae5c : cc0001           	ldd	#$1
                        * 	}
ae5f : 32c4             	leas	,u
ae61 : 35c0             	puls	u,pc
                        * 	
                        * 	for (i = 0; i < C_MaxPageSize_U16; i ++ ) {
ae63 :                  _61
ae63 : 4f               	clra
ae64 : 5f               	clrb
ae65 : ed5d             	std	-3,u
ae67 :                  _63
ae67 : ec5d             	ldd	-3,u
ae69 : 830200           	subd	#$200
ae6c : 1024001b         	lbhs	_62
                        *   		buf[i] = SPI_Read ();
ae70 : bdab6e           	lbsr	SPI_Read
AS09 Assembler for M6809 [1.42].                                     Page  152
--------------------------------- merge.a09 ----------------------------------

ae73 : 3406             	pshs	d
ae75 : ec5d             	ldd	-3,u
ae77 : ae44             	ldx	4,u
ae79 : 308b             	leax	d,x
ae7b : 3506             	puls	d
ae7d : e784             	stb	0,x
                        * 	}
                        *       
                        *     SPI_Read (); 	SPI_Read (); // CRC
ae7f :                  _64
ae7f : ec5d             	ldd	-3,u
ae81 : c30001           	addd	#$1
ae84 : ed5d             	std	-3,u
ae86 : 830001           	subd	#$1
ae89 : 20dc             	lbra	_63
ae8b :                  _62
ae8b : bdab6e           	lbsr	SPI_Read
ae8e : bdab6e           	lbsr	SPI_Read
                        * 	SPI_DisableChipSelect();    
ae91 : bdaba0           	lbsr	SPI_Disa
                        *     
                        * 	return response;
ae94 : e65f             	ldb	-1,u
ae96 : 4f               	clra
                        * }
ae97 : 32c4             	leas	,u
ae99 : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function	: to write to a single block of SD card
                        * //Arguments	: none
                        * //return	: unsigned char; will be 0 if no error,
                        * // 			  otherwise the response byte will be sent
                        * //**************************************************
                        * SD_writeSingleBlock(buf, startBlock) char *buf; u32_
                        * {
                        * 	unsigned char response;
                        * 	unsigned int i;
                        * 			
                        * 	SPI_EnableChipSelect ();
ae9b :                  SD_write
ae9b : 3440             	pshs	u
ae9d : 33e4             	leau	,s
ae9f : 327d             	leas	-3,s
aea1 : bdab97           	lbsr	SPI_Enab
                        * 	i=SD_TIMEOUT;
aea4 : cc07d0           	ldd	#$7d0
aea7 : ed5d             	std	-3,u
                        * 	do {		
aea9 :                  _67
                        * 		response = SD_sendCommand(WR_SINGLE_BLOCK, startBl
aea9 : ec46             	ldd	6,u
aeab : 3406             	pshs	d
aead : cc0018           	ldd	#$18
aeb0 : 3406             	pshs	d
aeb2 : bdaba9           	lbsr	SD_sendC
aeb5 : 3264             	leas	4,s
aeb7 : e75f             	stb	-1,u
                        * 	    if(--i == 0) {
aeb9 : ec5d             	ldd	-3,u
aebb : c3ffff           	addd	#$ffff
aebe : ed5d             	std	-3,u
AS09 Assembler for M6809 [1.42].                                     Page  153
--------------------------------- merge.a09 ----------------------------------

aec0 : 830000           	subd	#$0
aec3 : 10260007         	lbne	_68
                        * 		  	//print_DebugMsg("\nwrite cmd failed!\n");
                        * 			return response; //check for SD status: 0x00 - OK
aec7 : e65f             	ldb	-1,u
aec9 : 4f               	clra
                        * 		}
aeca : 32c4             	leas	,u
aecc : 35c0             	puls	u,pc
                        *     }while(response != 0x00);
aece :                  _68
aece :                  _66
aece : e65f             	ldb	-1,u
aed0 : 4f               	clra
aed1 : 830000           	subd	#$0
aed4 : 26d3             	lbne	_67
                        * 		
                        * 	SPI_Write (0xff);   //8 clks before the packet
aed6 :                  _65
aed6 : cc00ff           	ldd	#$ff
aed9 : 3406             	pshs	d
aedb : bdab06           	lbsr	SPI_Writ
aede : 3262             	leas	2,s
                        * 	SPI_Write (0xfe);   //data token 0xfe to start tran
aee0 : cc00fe           	ldd	#$fe
aee3 : 3406             	pshs	d
aee5 : bdab06           	lbsr	SPI_Writ
aee8 : 3262             	leas	2,s
                        *     for (i=0; i<C_MaxPageSize_U16; i++) {	//send 512
aeea : 4f               	clra
aeeb : 5f               	clrb
aeec : ed5d             	std	-3,u
aeee :                  _70
aeee : ec5d             	ldd	-3,u
aef0 : 830200           	subd	#$200
aef3 : 1024001a         	lbhs	_69
                        *   		SPI_Write(buf[i]);
aef7 : ec5d             	ldd	-3,u
aef9 : ae44             	ldx	4,u
aefb : e68b             	ldb	d,x
aefd : 1d               	sex
aefe : 3406             	pshs	d
af00 : bdab06           	lbsr	SPI_Writ
af03 : 3262             	leas	2,s
                        * 	}
                        * 	SPI_Write (0xff);	SPI_Write (0xff);  //transmit dum
af05 :                  _71
af05 : ec5d             	ldd	-3,u
af07 : c30001           	addd	#$1
af0a : ed5d             	std	-3,u
af0c : 830001           	subd	#$1
af0f : 20dd             	lbra	_70
af11 :                  _69
af11 : cc00ff           	ldd	#$ff
af14 : 3406             	pshs	d
af16 : bdab06           	lbsr	SPI_Writ
af19 : 3262             	leas	2,s
af1b : cc00ff           	ldd	#$ff
af1e : 3406             	pshs	d
af20 : bdab06           	lbsr	SPI_Writ
af23 : 3262             	leas	2,s
                        *     
AS09 Assembler for M6809 [1.42].                                     Page  154
--------------------------------- merge.a09 ----------------------------------

                        * 	response = SPI_Read ();    
af25 : bdab6e           	lbsr	SPI_Read
af28 : e75f             	stb	-1,u
                        * 	if( ( response & 0x1f) != 0x05 )  		//r1 = 0bXXX0AA
af2a : e65f             	ldb	-1,u
af2c : 4f               	clra
af2d : 8400             	anda	#$0
af2f : c41f             	andb	#$1f
af31 : 830005           	subd	#$5
af34 : 1027000a         	lbeq	_72
                        * 	{										//AAA='101'-data rejected due to CRC err
                        *   		SPI_DisableChipSelect();          		//AAA='110'-
af38 : bdaba0           	lbsr	SPI_Disa
                        *         //print_DebugMsg("\ndata response "); HEXBYT
                        *   		//print_DebugMsg(", write failed!\n");
                        * 		return response;
af3b : e65f             	ldb	-1,u
af3d : 4f               	clra
                        * 	}
af3e : 32c4             	leas	,u
af40 : 35c0             	puls	u,pc
                        * 
                        * 	i = SD_TIMEOUT;
af42 :                  _72
af42 : cc07d0           	ldd	#$7d0
af45 : ed5d             	std	-3,u
                        * 	response = 0;
af47 : 4f               	clra
af48 : 5f               	clrb
af49 : e75f             	stb	-1,u
                        * 	while ( !SPI_Read ()) { 				//wait till writing com
af4b :                  _74
af4b : bdab6e           	lbsr	SPI_Read
af4e : 830000           	subd	#$0
af51 : 10260018         	lbne	_73
                        *         if(--i == 0) {
af55 : ec5d             	ldd	-3,u
af57 : c3ffff           	addd	#$ffff
af5a : ed5d             	std	-3,u
af5c : 830000           	subd	#$0
af5f : 10260008         	lbne	_75
                        * 			response = -1;
af63 : ccffff           	ldd	#$ffff
af66 : e75f             	stb	-1,u
                        * 			//print_DebugMsg("\nwrite failed!\n");
                        * 			break;			
af68 : 200312           	lbra	_73
                        * 		}
                        *     }	
af6b :                  _75
                        * 		
                        * 	SPI_DisableChipSelect();
af6b : 20de             	lbra	_74
af6d :                  _73
af6d : bdaba0           	lbsr	SPI_Disa
                        *     return response;
af70 : e65f             	ldb	-1,u
af72 : 4f               	clra
                        * }
af73 : 32c4             	leas	,u
af75 : 35c0             	puls	u,pc
                        * /***************************************************
AS09 Assembler for M6809 [1.42].                                     Page  155
--------------------------------- merge.a09 ----------------------------------

                        * /*                                                  
                        * /* file:          fat32.c			                        
                        * /*                                                  
                        * /* source:        2023, written by Adrian Kundert (a
                        * /*                                                  
                        * /* description:   read and write data from SD CARD (
                        * /*                                                  
                        * /* This library is free software; you can redistribu
                        * /* GNU Lesser General Public License as published by
                        * /* either version 2.1 of the License, or (at your op
                        * /*                                                  
                        * /* This library is distributed in the hope that it w
                        * /* without even the implied warranty of MERCHANTABIL
                        * /* See the GNU Lesser General Public License for mor
                        * /*                                                  
                        * /***************************************************
                        * 
                        * #include "fat32.h"
                        * /***************************************************
                        * /*                                                  
                        * /* file:          fat32.h			                        
                        * /*                                                  
                        * /* source:        2023, written by Adrian Kundert (a
                        * /*                                                  
                        * /* description:   read and write data from SD CARD (
                        * /*                                                  
                        * /* This library is free software; you can redistribu
                        * /* GNU Lesser General Public License as published by
                        * /* either version 2.1 of the License, or (at your op
                        * /*                                                  
                        * /* This library is distributed in the hope that it w
                        * /* without even the implied warranty of MERCHANTABIL
                        * /* See the GNU Lesser General Public License for mor
                        * /*                                                  
                        * /***************************************************
                        * 
                        * #define C_8_3_FileNameSize    11	//Root Directory En
                        * 
                        * //Structure to access Master Boot Record for getting
                        * typedef struct {
                        *     unsigned char	nothing[446];		//ignore, placed he
                        *     unsigned char	partitionData[64];	//partition rec
                        *     unsigned char	signature[2];		//0xaa55
                        * } LE_MBRinfo_Structure;
                        * 
                        * 
                        * 
                        * //Structure to access boot sector data (Little Endia
                        * typedef struct {
                        *     unsigned char jumpBoot[3];			//00, default: 0x00
                        *     unsigned char OEMName[8];			//03,
                        *     unsigned char bytesPerSector[2];	//11, default: 
                        *     unsigned char secPrCluster; 		//13, "sectorPerCl
                        *     unsigned char rsvSectorCount[2];	//14, "reserved
                        *     unsigned char nbofFATs;				//16, "numberofFATs"
                        *     unsigned char rootEntryCount[2];	//17,
                        *     unsigned char tSec_F16[2];			//19, "totalSectors
                        *     unsigned char mediaType;			//21,
                        *     unsigned char FATsz_F16[2];			//22, "FATsize_F16
                        *     unsigned char sectorsPerTrack[2];	//24,
                        *     unsigned char nbofHeads[2];			//26, "numberofHea
                        *     unsigned char hiddenSectors[4];		//28, 
AS09 Assembler for M6809 [1.42].                                     Page  156
--------------------------------- merge.a09 ----------------------------------

                        *     unsigned char tSec_F32[4];			//32, "totalSectors
                        *     unsigned char FATsz_F32[4];			//36, "unsigned ch
                        *     unsigned char extFlags[2];
                        *     unsigned char FSversion[2]; //0x0000 (defines ve
                        *     unsigned char rootCluster[4]; //first cluster of
                        *     unsigned char FSinfo[2]; //sector number of FSin
                        *     unsigned char BackupBootSector[2];
                        *     unsigned char rsved[12];//    unsigned char rese
                        *     unsigned char driveNumber;
                        *     unsigned char rsved1;//    unsigned char reserve
                        *     unsigned char bootSignature;
                        *     unsigned char volumeID[4];
                        *     unsigned char volumeLabel[11]; //"NO NAME "
                        *     unsigned char fileSystemType[8]; //"FAT32"
                        *     unsigned char bootData[420];
                        *     unsigned char bootEndSignature[2]; //0xaa55
                        * }LE_BS_Structure;
                        * 
                        * 
                        * //Structure to access FSinfo sector data (Little End
                        * typedef struct {
                        *     unsigned char leadSignature[4]; //0x41615252
                        *     unsigned char rsved3[480];  //    unsigned char 
                        *     unsigned char structureSignature[4]; //0x6141727
                        *     unsigned char freeClusterCount[4]; //initial: 0x
                        *     unsigned char nextFreeCluster[4]; //initial: 0xf
                        *     unsigned char rsved4[12];  //    unsigned char r
                        *     unsigned char trailSignature[4]; //0xaa550000
                        * }LE_FSinfo_Structure;
                        * 
                        * //Structure to access Directory Entry in the FAT (Li
                        * typedef struct{
                        *     unsigned char name[C_8_3_FileNameSize];
                        *     unsigned char attrib; //file attributes
                        *     unsigned char NTreserved; //always 0
                        *     unsigned char timeTenth; //tenths of seconds, se
                        *     unsigned char createTime[2]; //time file was cre
                        *     unsigned char createDate[2]; //date file was cre
                        *     unsigned char lastAccessDate[2];
                        *     unsigned char fClsterHI[2]; //higher word of the
                        *     unsigned char writeTime[2]; //time of last write
                        *     unsigned char writeDate[2]; //date of last write
                        *     unsigned char fClsterLO[2]; //lower word of the 
                        *     unsigned char fSize[4]; //size of file in bytes	
                        * }LE_dir_Structure;
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * //Attribute definitions for file/directory
                        * #define ATTR_READ_ONLY     0x01
                        * #define ATTR_HIDDEN        0x02
                        * #define ATTR_SYSTEM        0x04
                        * #define ATTR_VOLUME_ID     0x08
                        * #define ATTR_DIRECTORY     0x10
                        * #define ATTR_ARCHIVE       0x20
                        * #define ATTR_LONG_NAME     0x0f
                        * 
                        * 
AS09 Assembler for M6809 [1.42].                                     Page  157
--------------------------------- merge.a09 ----------------------------------

                        * #define END_OF_CLUSTERS    0x0fffffff
                        * #define DIR_ENTRY_SIZE     0x32
                        * #define EMPTY              0x00
                        * #define DELETED            0xe5
                        * #define GET     0
                        * #define SET     1
                        * 
                        * #define READ	0
                        * #define VERIFY  1
                        * #define WRITE   2
                        * #define APPEND  3
                        * 
                        * #define ADD		0
                        * #define REMOVE	1
                        * 
                        * #define TOTAL_FREE   1
                        * #define NEXT_FREE    2
                        * 
                        * #define GET_LIST     0
                        * #define GET_FILE     1
                        * #define DELETE		 2
                        * 
                        * #define EOF     26
                        * 
                        * #define FOPEN_SUCCESSFUL                   0 //FAT32
                        * #define FDELETED_OR_NOT_FOUND              1 //FAT32
                        * #define FALREADY_EXISTS                    2 //FAT32
                        * #define VALID_FILE_NAME                    3
                        * #define INVALID_FILE_NAME                  4
                        * #define NO_FREE_CLUSTERS_FOUND             5
                        * #define FILE_OPENED_CANNOT_BE_DELETED      6
                        * #define TO_MANY_FILES_OPENED               7
                        * #define MORE_FILES_To_READ                 8
                        * #define END_OF_FILE_LIST                   9
                        * 
                        * #define CONTINUE_LOOP                   0x55
                        * 
                        * #define C_MaxFileNameSize     13 //(C_8_3_FileNameSi
                        * 
                        * 
                        * typedef struct
                        * {
                        *     u32_t firstSector;
                        *     u32_t cluster;
                        *     u32_t prevCluster;
                        *     u32_t appFSector;
                        *     unsigned int appFLocation;
                        *     u32_t fileSize;
                        *     u32_t byteCounter;
                        *     u32_t blockNumber_u32;
                        *     u32_t appendStartCluster;
                        *     unsigned int sectorIndex;
                        *     unsigned int bufferIndex_u16;
                        *     //unsigned int fClstrHigh;
                        *     //unsigned int fClstrLow;
                        *     unsigned char LE_fileBuffer[C_MaxPageSize_U16];
                        *     unsigned char fileOperation_u8;
                        *     unsigned char fileOpenedFlag;
                        *     unsigned char fileCreatedFlag;
                        *     unsigned char appendFileFlag;
                        *     unsigned char sectorEndFlag;
                        *     unsigned char endOfFileDetected;
AS09 Assembler for M6809 [1.42].                                     Page  158
--------------------------------- merge.a09 ----------------------------------

                        *     char fName[C_MaxFileNameSize];
                        * }fileConfig_st;
                        * 
                        * typedef struct{
                        * 	u32_t FI_Size;	unsigned char FI_Attr;	char FI_Name[
                        * }fileInfo;
                        * 
                        * 
                        * 
                        * 
                        * 
                        * /***************************************************
                        *                            Global Variables
                        *  ***************************************************
                        * u32_t fDataSector, rCluster, totalClusters;   			// 
fffb =                  fDataSec	equ	-5
fff7 =                  rCluster	equ	-9
fff3 =                  totalClu	equ	-13
                        * unsigned int  bPerSector, secPerCluster, rsvSecCnt; 
fff1 =                  bPerSect	equ	-15
ffef =                  secPerCl	equ	-17
ffed =                  rsvSecCn	equ	-19
                        * u32_t unusedSectors;
ffe9 =                  unusedSe	equ	-23
                        * unsigned char fClstCnU; 								// "freeClusterCount
ffe8 =                  fClstCnU	equ	-24
                        * unsigned char FL_initialized;
ffe7 =                  FL_initi	equ	-25
                        * 	
                        * fileConfig_st fatMapTb; 								// "fatMappingTable"
fdae =                  fatMapTb	equ	-594
                        * 
                        * u32_t clusterNumber, sectorNumber, frstSectorIndex;
fdaa =                  clusterN	equ	-598
fda6 =                  sectorNu	equ	-602
fda2 =                  frstSect	equ	-606
                        * unsigned int list_i;
fda0 =                  list_i	equ	-608
                        * 
                        * #asm
af77 :                  _setGVpt
af77 : 108e7fbd         	ldy  #GV_StackBeginAddr	; set C global variables stac
af7b : 39               	rts
                        * /***************************************************
                        * 
                        * 
                        * 
                        * /***************************************************
                        *                  fileConfig_st* FILE_Open(char* file
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                   char *: Name of the file to be ope
                        *                   unsigned char: READ, WRITE, APPEND
                        *                   char *: pointer to update the file
                        * 
                        *  * Return value  :
                        *                   fileConfig_st *: Pointer to file s
                        *                                  : NULL, if file is 
                        * 
                        *  * description :
                        *                  This functions opens the file with 
                        *                  If the file is successfully opened,
AS09 Assembler for M6809 [1.42].                                     Page  159
--------------------------------- merge.a09 ----------------------------------

                        *                  In case the file is not opened it r
                        *  ***************************************************
                        * //fileConfig_st* FILE_Open(char* filename,unsigned c
                        * FILE_Open(filename, fOperation, fOpenSts) char* file
                        * {
                        *     fileConfig_st *filePtr;
                        *     u32_t nextCluster, clusterCount, tmp1, tmp2;
                        *     
                        * 	_setGVpt(); // call when GV are utilized
af7c :                  FILE_Ope
af7c : 3440             	pshs	u
af7e : 33e4             	leau	,s
af80 : 32e8ee           	leas	-18,s
af83 : 8df2             	lbsr	_setGVpt
                        * 
                        * 	filePtr = 0;
af85 : 4f               	clra
af86 : 5f               	clrb
af87 : ed5e             	std	-2,u
                        * 	
                        *     // ensure the filename length
                        * 	if(_strlen(filename) >= C_MaxFileNameSize) {
af89 : ec44             	ldd	4,u
af8b : 3406             	pshs	d
af8d : bda9f4           	lbsr	_strlen
af90 : 3262             	leas	2,s
af92 : 83000d           	subd	#$d
af95 : 102d000c         	lblt	_76
                        * 		*fOpenSts = INVALID_FILE_NAME;
af99 : cc0004           	ldd	#$4
af9c : e7d808           	stb	[8,u]
                        * 		return 0; /* Set the pointer to NULL indication wh
af9f : 4f               	clra
afa0 : 5f               	clrb
                        * 	}
afa1 : 32c4             	leas	,u
afa3 : 35c0             	puls	u,pc
                        * 	
                        *     if(fatMapTb.fileOpenedFlag == FALSE)
afa5 :                  _76
afa5 : e6a8d5           	ldb	fatMapTb+551,y
afa8 : 4f               	clra
afa9 : 830000           	subd	#$0
afac : 10260401         	lbne	_77
                        *     {
                        *         filePtr = &fatMapTb;
afb0 : 30a9fdae         	leax	fatMapTb+0,y
afb4 : 1f10             	tfr	x,d
afb6 : ed5e             	std	-2,u
                        *         _strcpy(filePtr->fName,filename);
afb8 : ec44             	ldd	4,u
afba : 3406             	pshs	d
afbc : ec5e             	ldd	-2,u
afbe : c3022c           	addd	#$22c
afc1 : 3406             	pshs	d
afc3 : bdaa27           	lbsr	_strcpy
afc6 : 3264             	leas	4,s
                        * 		filePtr->fileOperation_u8 = fOperation;
afc8 : e647             	ldb	7,u
afca : 4f               	clra
afcb : ae5e             	ldx	-2,u
afcd : e7890226         	stb	550,x
AS09 Assembler for M6809 [1.42].                                     Page  160
--------------------------------- merge.a09 ----------------------------------

                        *         filePtr->firstSector.h = filePtr->firstSecto
afd1 : 4f               	clra
afd2 : 5f               	clrb
afd3 : ae5e             	ldx	-2,u
afd5 : ed02             	std	2,x
afd7 : edd8fe           	std	[-2,u]
                        *         filePtr->cluster.h = filePtr->cluster.l =0x0
afda : ec5e             	ldd	-2,u
afdc : c30004           	addd	#$4
afdf : c30002           	addd	#$2
afe2 : 1f01             	tfr	d,x
afe4 : 4f               	clra
afe5 : 5f               	clrb
afe6 : ed84             	std	0,x
afe8 : ae5e             	ldx	-2,u
afea : ed04             	std	4,x
                        *         filePtr->blockNumber_u32.h = filePtr->blockN
afec : ec5e             	ldd	-2,u
afee : c3001a           	addd	#$1a
aff1 : c30002           	addd	#$2
aff4 : 1f01             	tfr	d,x
aff6 : 4f               	clra
aff7 : 5f               	clrb
aff8 : ed84             	std	0,x
affa : ae5e             	ldx	-2,u
affc : ed881a           	std	26,x
                        *         filePtr->appFSector.h = filePtr->appFSector.
afff : ec5e             	ldd	-2,u
b001 : c3000c           	addd	#$c
b004 : c30002           	addd	#$2
b007 : 1f01             	tfr	d,x
b009 : 4f               	clra
b00a : 5f               	clrb
b00b : ed84             	std	0,x
b00d : ae5e             	ldx	-2,u
b00f : ed0c             	std	12,x
                        *         filePtr->appFLocation= 0x00;
b011 : 4f               	clra
b012 : 5f               	clrb
b013 : ae5e             	ldx	-2,u
b015 : ed8810           	std	16,x
                        *         filePtr->fileSize.h = filePtr->fileSize.l = 
b018 : ec5e             	ldd	-2,u
b01a : c30012           	addd	#$12
b01d : c30002           	addd	#$2
b020 : 1f01             	tfr	d,x
b022 : 4f               	clra
b023 : 5f               	clrb
b024 : ed84             	std	0,x
b026 : ae5e             	ldx	-2,u
b028 : ed8812           	std	18,x
                        *         filePtr->byteCounter.h = filePtr->byteCounte
b02b : ec5e             	ldd	-2,u
b02d : c30016           	addd	#$16
b030 : c30002           	addd	#$2
b033 : 1f01             	tfr	d,x
b035 : 4f               	clra
b036 : 5f               	clrb
b037 : ed84             	std	0,x
b039 : ae5e             	ldx	-2,u
b03b : ed8816           	std	22,x
                        *         filePtr->appendStartCluster.h = filePtr->app
AS09 Assembler for M6809 [1.42].                                     Page  161
--------------------------------- merge.a09 ----------------------------------

b03e : ec5e             	ldd	-2,u
b040 : c3001e           	addd	#$1e
b043 : c30002           	addd	#$2
b046 : 1f01             	tfr	d,x
b048 : 4f               	clra
b049 : 5f               	clrb
b04a : ed84             	std	0,x
b04c : ae5e             	ldx	-2,u
b04e : ed881e           	std	30,x
                        *         filePtr->sectorIndex= 0x00;
b051 : 4f               	clra
b052 : 5f               	clrb
b053 : ae5e             	ldx	-2,u
b055 : ed8822           	std	34,x
                        *         filePtr->bufferIndex_u16= 0x00;
b058 : 4f               	clra
b059 : 5f               	clrb
b05a : ae5e             	ldx	-2,u
b05c : ed8824           	std	36,x
                        * 		filePtr->appendFileFlag = 0;
b05f : 4f               	clra
b060 : 5f               	clrb
b061 : ae5e             	ldx	-2,u
b063 : e7890229         	stb	553,x
                        *         filePtr->fileCreatedFlag = 0x00;
b067 : 4f               	clra
b068 : 5f               	clrb
b069 : ae5e             	ldx	-2,u
b06b : e7890228         	stb	552,x
                        *         filePtr->endOfFileDetected = 0x00;
b06f : 4f               	clra
b070 : 5f               	clrb
b071 : ae5e             	ldx	-2,u
b073 : e789022b         	stb	555,x
                        * 
                        *         if(fOperation == READ)
b077 : e647             	ldb	7,u
b079 : 4f               	clra
b07a : 830000           	subd	#$0
b07d : 10260024         	lbne	_78
                        *         {
                        *             *fOpenSts = openFile( READ, filePtr);
b081 : ec5e             	ldd	-2,u
b083 : 3406             	pshs	d
b085 : 4f               	clra
b086 : 5f               	clrb
b087 : 3406             	pshs	d
b089 : bde6a8           	lbsr	openFile
b08c : 3264             	leas	4,s
b08e : e7d808           	stb	[8,u]
                        *             if(*fOpenSts != FOPEN_SUCCESSFUL) return
b091 : e6d808           	ldb	[8,u]
b094 : 4f               	clra
b095 : 830000           	subd	#$0
b098 : 10270006         	lbeq	_79
b09c : 4f               	clra
b09d : 5f               	clrb
                        *         }
b09e : 32c4             	leas	,u
b0a0 : 35c0             	puls	u,pc
b0a2 :                  _79
                        *         else if((fOperation == WRITE) || (fOperation
AS09 Assembler for M6809 [1.42].                                     Page  162
--------------------------------- merge.a09 ----------------------------------

b0a2 : 7eb3a2           	lbra	_80
b0a5 :                  _78
b0a5 : e647             	ldb	7,u
b0a7 : 4f               	clra
b0a8 : 830002           	subd	#$2
b0ab : 1027000a         	lbeq	_82
b0af : e647             	ldb	7,u
b0b1 : 4f               	clra
b0b2 : 830003           	subd	#$3
b0b5 : 102602e9         	lbne	_81
b0b9 :                  _82
                        *         {
                        *             *fOpenSts = openFile (VERIFY, filePtr);
b0b9 : ec5e             	ldd	-2,u
b0bb : 3406             	pshs	d
b0bd : cc0001           	ldd	#$1
b0c0 : 3406             	pshs	d
b0c2 : bde6a8           	lbsr	openFile
b0c5 : 3264             	leas	4,s
b0c7 : e7d808           	stb	[8,u]
                        * 
                        *             if(*fOpenSts == FOPEN_SUCCESSFUL)
b0ca : e6d808           	ldb	[8,u]
b0cd : 4f               	clra
b0ce : 830000           	subd	#$0
b0d1 : 10260179         	lbne	_83
                        *             {
                        * 				filePtr->appendFileFlag = 1;
b0d5 : cc0001           	ldd	#$1
b0d8 : ae5e             	ldx	-2,u
b0da : e7890229         	stb	553,x
                        *                 filePtr->cluster.h = filePtr->append
b0de : ae5e             	ldx	-2,u
b0e0 : ec881e           	ldd	30,x
b0e3 : ae5e             	ldx	-2,u
b0e5 : ed04             	std	4,x
b0e7 : ec5e             	ldd	-2,u
b0e9 : c3001e           	addd	#$1e
b0ec : 3406             	pshs	d
b0ee : cc0002           	ldd	#$2
b0f1 : 3510             	puls	x
b0f3 : ec8b             	ldd	d,x
b0f5 : 3406             	pshs	d
b0f7 : ec5e             	ldd	-2,u
b0f9 : c30004           	addd	#$4
b0fc : c30002           	addd	#$2
b0ff : 1f01             	tfr	d,x
b101 : 3506             	puls	d
b103 : ed84             	std	0,x
                        * 				clusterCount.h = clusterCount.l = 0;
b105 : 4f               	clra
b106 : 5f               	clrb
b107 : ed58             	std	-8,u
b109 : ed56             	std	-10,u
                        *                 while(1)
b10b :                  _85
                        *                 {
                        *                     //nextCluster = getSetNextCluste
                        * 					tmp1.h = tmp1.l = 0;
b10b : 4f               	clra
b10c : 5f               	clrb
b10d : ed54             	std	-12,u
AS09 Assembler for M6809 [1.42].                                     Page  163
--------------------------------- merge.a09 ----------------------------------

b10f : ed52             	std	-14,u
                        * 					getSetNC(filePtr->LE_fileBuffer, &filePtr->clus
b111 : 305a             	leax	-6,u
b113 : 3410             	pshs	x
b115 : 3052             	leax	-14,u
b117 : 3410             	pshs	x
b119 : 4f               	clra
b11a : 5f               	clrb
b11b : 3406             	pshs	d
b11d : ec5e             	ldd	-2,u
b11f : c30004           	addd	#$4
b122 : 3406             	pshs	d
b124 : ec5e             	ldd	-2,u
b126 : c30026           	addd	#$26
b129 : 3406             	pshs	d
b12b : bde1d8           	lbsr	getSetNC
b12e : 326a             	leas	10,s
                        * 					
                        *                     //if(nextCluster == END_OF_CLUST
                        * 					tmp1.h = 0x0fff; tmp1.l = 0xffff; // = END_OF_C
b130 : cc0fff           	ldd	#$fff
b133 : ed52             	std	-14,u
b135 : ccffff           	ldd	#$ffff
b138 : ed54             	std	-12,u
                        * 					if(_u32_equal(&nextCluster, &tmp1) != 0) break;
b13a : 3052             	leax	-14,u
b13c : 3410             	pshs	x
b13e : 305a             	leax	-6,u
b140 : 3410             	pshs	x
b142 : bda990           	lbsr	_u32_equ
b145 : 3264             	leas	4,s
b147 : 830000           	subd	#$0
b14a : 10270003         	lbeq	_86
b14e : 202012           	lbra	_84
                        *                     filePtr->cluster.h = nextCluster
b151 :                  _86
b151 : ec5a             	ldd	-6,u
b153 : ae5e             	ldx	-2,u
b155 : ed04             	std	4,x
b157 : ec5e             	ldd	-2,u
b159 : c30004           	addd	#$4
b15c : c30002           	addd	#$2
b15f : 1f01             	tfr	d,x
b161 : ec5c             	ldd	-4,u
b163 : ed84             	std	0,x
                        *                     _u32_inc(&clusterCount);
b165 : 3056             	leax	-10,u
b167 : 3410             	pshs	x
b169 : bda929           	lbsr	_u32_inc
b16c : 3262             	leas	2,s
                        *                 }
                        * 
                        *                 //filePtr->sectorIndex = (filePtr->f
                        * 				_u32_mul(secPerCluster, &clusterCount, &tmp1);
b16e : 209b             	lbra	_85
b170 :                  _84
b170 : 3052             	leax	-14,u
b172 : 3410             	pshs	x
b174 : 3056             	leax	-10,u
b176 : 3410             	pshs	x
b178 : eca8ef           	ldd	secPerCl+0,y
b17b : 3406             	pshs	d
AS09 Assembler for M6809 [1.42].                                     Page  164
--------------------------------- merge.a09 ----------------------------------

b17d : bda78c           	lbsr	_u32_mul
b180 : 3266             	leas	6,s
                        * 				_u32_mul(bPerSector, &tmp1, &tmp2);
b182 : 30c8ee           	leax	-18,u
b185 : 3410             	pshs	x
b187 : 3052             	leax	-14,u
b189 : 3410             	pshs	x
b18b : ec31             	ldd	bPerSect+0,y
b18d : 3406             	pshs	d
b18f : bda78c           	lbsr	_u32_mul
b192 : 3266             	leas	6,s
                        * 				_u32_sub(&filePtr->fileSize, &tmp2, &tmp1);
b194 : 3052             	leax	-14,u
b196 : 3410             	pshs	x
b198 : 30c8ee           	leax	-18,u
b19b : 3410             	pshs	x
b19d : ec5e             	ldd	-2,u
b19f : c30012           	addd	#$12
b1a2 : 3406             	pshs	d
b1a4 : bda870           	lbsr	_u32_sub
b1a7 : 3266             	leas	6,s
                        * 				_u32_div2(&tmp1, bPerSector, &tmp2);
b1a9 : 30c8ee           	leax	-18,u
b1ac : 3410             	pshs	x
b1ae : ec31             	ldd	bPerSect+0,y
b1b0 : 3406             	pshs	d
b1b2 : 3052             	leax	-14,u
b1b4 : 3410             	pshs	x
b1b6 : bda720           	lbsr	_u32_div
b1b9 : 3266             	leas	6,s
                        * 				filePtr->sectorIndex = tmp2.l;
b1bb : ec50             	ldd	-16,u
b1bd : ae5e             	ldx	-2,u
b1bf : ed8822           	std	34,x
                        * 					
                        *                 getFirstSector (&filePtr->cluster, &
b1c2 : ec5e             	ldd	-2,u
b1c4 : c3001a           	addd	#$1a
b1c7 : 3406             	pshs	d
b1c9 : ec5e             	ldd	-2,u
b1cb : c30004           	addd	#$4
b1ce : 3406             	pshs	d
b1d0 : bde191           	lbsr	getFirst
b1d3 : 3264             	leas	4,s
                        * 				tmp1.h = filePtr->blockNumber_u32.h; tmp1.l = fi
b1d5 : ae5e             	ldx	-2,u
b1d7 : ec881a           	ldd	26,x
b1da : ed52             	std	-14,u
b1dc : ec5e             	ldd	-2,u
b1de : c3001a           	addd	#$1a
b1e1 : 3406             	pshs	d
b1e3 : cc0002           	ldd	#$2
b1e6 : 3510             	puls	x
b1e8 : ec8b             	ldd	d,x
b1ea : ed54             	std	-12,u
                        * 				tmp2.h = 0; tmp2.l = filePtr->sectorIndex;
b1ec : 4f               	clra
b1ed : 5f               	clrb
b1ee : edc8ee           	std	-18,u
b1f1 : ae5e             	ldx	-2,u
b1f3 : ec8822           	ldd	34,x
b1f6 : ed50             	std	-16,u
AS09 Assembler for M6809 [1.42].                                     Page  165
--------------------------------- merge.a09 ----------------------------------

                        * 				_u32_add(&tmp1, &tmp2, &filePtr->blockNumber_u32
b1f8 : ec5e             	ldd	-2,u
b1fa : c3001a           	addd	#$1a
b1fd : 3406             	pshs	d
b1ff : 30c8ee           	leax	-18,u
b202 : 3410             	pshs	x
b204 : 3052             	leax	-14,u
b206 : 3410             	pshs	x
b208 : bda8da           	lbsr	_u32_add
b20b : 3266             	leas	6,s
                        *                 if(SD_readSingleBlock(filePtr->LE_fi
b20d : ec5e             	ldd	-2,u
b20f : c3001a           	addd	#$1a
b212 : 3406             	pshs	d
b214 : ec5e             	ldd	-2,u
b216 : c30026           	addd	#$26
b219 : 3406             	pshs	d
b21b : bdae0d           	lbsr	SD_readS
b21e : 3264             	leas	4,s
b220 : 830000           	subd	#$0
b223 : 10270006         	lbeq	_87
b227 : 4f               	clra
b228 : 5f               	clrb
                        *                 filePtr->bufferIndex_u16 = filePtr->
b229 : 32c4             	leas	,u
b22b : 35c0             	puls	u,pc
b22d :                  _87
b22d : ec31             	ldd	bPerSect+0,y
b22f : 830001           	subd	#$1
b232 : 3406             	pshs	d
b234 : ec5e             	ldd	-2,u
b236 : c30012           	addd	#$12
b239 : 3406             	pshs	d
b23b : cc0002           	ldd	#$2
b23e : 3510             	puls	x
b240 : ec8b             	ldd	d,x
b242 : a4e0             	anda	,s+
b244 : e4e0             	andb	,s+
b246 : ae5e             	ldx	-2,u
b248 : ed8824           	std	36,x
                        *             }
                        *             else if(*fOpenSts == FDELETED_OR_NOT_FOU
b24b : 7eb3a2           	lbra	_88
b24e :                  _83
b24e : e6d808           	ldb	[8,u]
b251 : 4f               	clra
b252 : 830001           	subd	#$1
b255 : 10260145         	lbne	_89
                        *             {
                        *                 *fOpenSts = FOPEN_SUCCESSFUL;
b259 : 4f               	clra
b25a : 5f               	clrb
b25b : e7d808           	stb	[8,u]
                        * 
                        *                 getSetFreeCluster(filePtr->LE_fileBu
b25e : ec5e             	ldd	-2,u
b260 : c30004           	addd	#$4
b263 : 3406             	pshs	d
b265 : 4f               	clra
b266 : 5f               	clrb
b267 : 3406             	pshs	d
b269 : 4f               	clra
AS09 Assembler for M6809 [1.42].                                     Page  166
--------------------------------- merge.a09 ----------------------------------

b26a : 5f               	clrb
b26b : 3406             	pshs	d
b26d : cc0002           	ldd	#$2
b270 : 3406             	pshs	d
b272 : ec5e             	ldd	-2,u
b274 : c30026           	addd	#$26
b277 : 3406             	pshs	d
b279 : bde2df           	lbsr	getSetFr
b27c : 326a             	leas	10,s
                        * 				if((filePtr->cluster.h == 0xffff) && (filePtr->c
b27e : ae5e             	ldx	-2,u
b280 : ec04             	ldd	4,x
b282 : 83ffff           	subd	#$ffff
b285 : 1026001b         	lbne	_90
b289 : ec5e             	ldd	-2,u
b28b : c30004           	addd	#$4
b28e : 3406             	pshs	d
b290 : cc0002           	ldd	#$2
b293 : 3510             	puls	x
b295 : ec8b             	ldd	d,x
b297 : 83ffff           	subd	#$ffff
b29a : 10260006         	lbne	_90
b29e : 4f               	clra
b29f : 5f               	clrb
                        * 				if(_u32_higher(&filePtr->cluster, &totalClusters
b2a0 : 32c4             	leas	,u
b2a2 : 35c0             	puls	u,pc
b2a4 :                  _90
b2a4 : 3033             	leax	totalClu+0,y
b2a6 : 3410             	pshs	x
b2a8 : ec5e             	ldd	-2,u
b2aa : c30004           	addd	#$4
b2ad : 3406             	pshs	d
b2af : bda9bb           	lbsr	_u32_hig
b2b2 : 3264             	leas	4,s
b2b4 : 830000           	subd	#$0
b2b7 : 10270014         	lbeq	_91
                        *                 {
                        *                     filePtr->cluster.h = rCluster.h;
b2bb : ec37             	ldd	rCluster+0,y
b2bd : ae5e             	ldx	-2,u
b2bf : ed04             	std	4,x
b2c1 : ec5e             	ldd	-2,u
b2c3 : c30004           	addd	#$4
b2c6 : c30002           	addd	#$2
b2c9 : 1f01             	tfr	d,x
b2cb : ec39             	ldd	rCluster+2,y
b2cd : ed84             	std	0,x
                        * 	            }
                        *                 searchNextFreeCluster(filePtr->LE_fi
b2cf :                  _91
b2cf : ec5e             	ldd	-2,u
b2d1 : c30004           	addd	#$4
b2d4 : 3406             	pshs	d
b2d6 : ec5e             	ldd	-2,u
b2d8 : c30004           	addd	#$4
b2db : 3406             	pshs	d
b2dd : ec5e             	ldd	-2,u
b2df : c30026           	addd	#$26
b2e2 : 3406             	pshs	d
b2e4 : bde3fc           	lbsr	searchNe
b2e7 : 3266             	leas	6,s
AS09 Assembler for M6809 [1.42].                                     Page  167
--------------------------------- merge.a09 ----------------------------------

                        *                 if((filePtr->cluster.h == 0) && (fil
b2e9 : ae5e             	ldx	-2,u
b2eb : ec04             	ldd	4,x
b2ed : 830000           	subd	#$0
b2f0 : 10260021         	lbne	_92
b2f4 : ec5e             	ldd	-2,u
b2f6 : c30004           	addd	#$4
b2f9 : 3406             	pshs	d
b2fb : cc0002           	ldd	#$2
b2fe : 3510             	puls	x
b300 : ec8b             	ldd	d,x
b302 : 830000           	subd	#$0
b305 : 1026000c         	lbne	_92
                        *                 {
                        *                     *fOpenSts = NO_FREE_CLUSTERS_FOU
b309 : cc0005           	ldd	#$5
b30c : e7d808           	stb	[8,u]
                        *                     return 0; /* Set the pointer to 
b30f : 4f               	clra
b310 : 5f               	clrb
                        *                 } 
b311 : 32c4             	leas	,u
b313 : 35c0             	puls	u,pc
                        * 
                        *                 tmp1.h = 0x0fff; tmp1.l = 0xffff; //
b315 :                  _92
b315 : cc0fff           	ldd	#$fff
b318 : ed52             	std	-14,u
b31a : ccffff           	ldd	#$ffff
b31d : ed54             	std	-12,u
                        * 				getSetNC(filePtr->LE_fileBuffer, &filePtr->clust
b31f : 30c8ee           	leax	-18,u
b322 : 3410             	pshs	x
b324 : 3052             	leax	-14,u
b326 : 3410             	pshs	x
b328 : cc0001           	ldd	#$1
b32b : 3406             	pshs	d
b32d : ec5e             	ldd	-2,u
b32f : c30004           	addd	#$4
b332 : 3406             	pshs	d
b334 : ec5e             	ldd	-2,u
b336 : c30026           	addd	#$26
b339 : 3406             	pshs	d
b33b : bde1d8           	lbsr	getSetNC
b33e : 326a             	leas	10,s
                        * 				
                        *                 filePtr->appendStartCluster.h = file
b340 : ae5e             	ldx	-2,u
b342 : ec04             	ldd	4,x
b344 : ae5e             	ldx	-2,u
b346 : ed881e           	std	30,x
                        *                 filePtr->appendStartCluster.l = file
b349 : ec5e             	ldd	-2,u
b34b : c30004           	addd	#$4
b34e : 3406             	pshs	d
b350 : cc0002           	ldd	#$2
b353 : 3510             	puls	x
b355 : ec8b             	ldd	d,x
b357 : 3406             	pshs	d
b359 : ec5e             	ldd	-2,u
b35b : c3001e           	addd	#$1e
b35e : c30002           	addd	#$2
AS09 Assembler for M6809 [1.42].                                     Page  168
--------------------------------- merge.a09 ----------------------------------

b361 : 1f01             	tfr	d,x
b363 : 3506             	puls	d
b365 : ed84             	std	0,x
                        *                 filePtr->fileSize.h = filePtr->fileS
b367 : ec5e             	ldd	-2,u
b369 : c30012           	addd	#$12
b36c : c30002           	addd	#$2
b36f : 1f01             	tfr	d,x
b371 : 4f               	clra
b372 : 5f               	clrb
b373 : ed84             	std	0,x
b375 : ae5e             	ldx	-2,u
b377 : ed8812           	std	18,x
                        * 
                        *                 getFirstSector (&filePtr->cluster, &
b37a : ec5e             	ldd	-2,u
b37c : c3001a           	addd	#$1a
b37f : 3406             	pshs	d
b381 : ec5e             	ldd	-2,u
b383 : c30004           	addd	#$4
b386 : 3406             	pshs	d
b388 : bde191           	lbsr	getFirst
b38b : 3264             	leas	4,s
                        *                 filePtr->bufferIndex_u16=0;
b38d : 4f               	clra
b38e : 5f               	clrb
b38f : ae5e             	ldx	-2,u
b391 : ed8824           	std	36,x
                        *                 filePtr->sectorIndex=0;					
b394 : 4f               	clra
b395 : 5f               	clrb
b396 : ae5e             	ldx	-2,u
b398 : ed8822           	std	34,x
                        *             }
                        *             else
b39b : 200512           	lbra	_93
b39e :                  _89
                        *             {
                        *                 filePtr = 0;
b39e : 4f               	clra
b39f : 5f               	clrb
b3a0 : ed5e             	std	-2,u
                        *             }
                        *         }
b3a2 :                  _93
b3a2 :                  _88
                        * 
                        *         if(filePtr != 0)
b3a2 :                  _81
b3a2 :                  _80
b3a2 : ec5e             	ldd	-2,u
b3a4 : 830000           	subd	#$0
b3a7 : 10270006         	lbeq	_94
                        *         {
                        *             fatMapTb.fileOpenedFlag = TRUE;
b3ab : cc0001           	ldd	#$1
b3ae : e7a8d5           	stb	fatMapTb+551,y
                        *         }
                        *     }
b3b1 :                  _94
                        * 
                        *     return filePtr;
AS09 Assembler for M6809 [1.42].                                     Page  169
--------------------------------- merge.a09 ----------------------------------

b3b1 :                  _77
b3b1 : ec5e             	ldd	-2,u
                        * }
b3b3 : 32c4             	leas	,u
b3b5 : 35c0             	puls	u,pc
                        * 
                        * 
                        * 
                        * 
                        * /***************************************************
                        *                          void FILE_Close(fileConfig_
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                   fileConfig_st *: structure pointer
                        * 
                        *  * Return value  :
                        *                   none
                        * 
                        *  * description :
                        *                  This functions closes the file and 
                        *                  Once the file is closed, no more fi
                        *  ***************************************************
                        * //void FILE_Close(fileConfig_st *ptr)
                        * FILE_Close(ptr) fileConfig_st *ptr;
                        * {
                        * 	if(ptr != 0) {
b3b7 :                  FILE_Clo
b3b7 : 3440             	pshs	u
b3b9 : 33e4             	leau	,s
b3bb : ec44             	ldd	4,u
b3bd : 830000           	subd	#$0
b3c0 : 10270008         	lbeq	_95
                        *         ptr->fileOpenedFlag = FALSE; /* Clear the fi
b3c4 : 4f               	clra
b3c5 : 5f               	clrb
b3c6 : ae44             	ldx	4,u
b3c8 : e7890227         	stb	551,x
                        * 	}
                        * }
b3cc :                  _95
b3cc : 35c0             	puls	u,pc
                        * 
                        * 
                        * 
                        * 
                        * /***************************************************
                        *                          unsigned char FILE_Delete(c
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                   char *: Name of the file to be del
                        * 
                        *  * Return value  :
                        *                   unsigned char:
                        *                   INVALID_FILE_NAME--> In case file 
                        *                   FILE_OPENED_CANNOT_BE_DELETED--> F
                        *                   FILE_DELETED_OR_NOT_FOUND --> File
                        * 
                        *  * description :
                        *                  This functions deletes the file fro
                        *  ***************************************************
                        * //unsigned char FILE_Delete(char *fileName)
                        * FILE_Delete(fileName) char *fileName;
AS09 Assembler for M6809 [1.42].                                     Page  170
--------------------------------- merge.a09 ----------------------------------

                        * {
                        *     unsigned char returnStatus;
                        *     char localfileName[C_MaxFileNameSize];
                        * 
                        * 	_setGVpt(); // call when GV are utilized
b3ce :                  FILE_Del
b3ce : 3440             	pshs	u
b3d0 : 33e4             	leau	,s
b3d2 : 3272             	leas	-14,s
b3d4 : bdaf77           	lbsr	_setGVpt
                        * 
                        * 	// ensure the filename length
                        * 	if(_strlen(fileName) >= C_MaxFileNameSize) {
b3d7 : ec44             	ldd	4,u
b3d9 : 3406             	pshs	d
b3db : bda9f4           	lbsr	_strlen
b3de : 3262             	leas	2,s
b3e0 : 83000d           	subd	#$d
b3e3 : 102d0008         	lblt	_96
                        * 		returnStatus = INVALID_FILE_NAME;		
b3e7 : cc0004           	ldd	#$4
b3ea : e75f             	stb	-1,u
                        * 	}
                        * 	else {
b3ec : 201912           	lbra	_97
b3ef :                  _96
                        * 		_strcpy(localfileName, fileName);
b3ef : ec44             	ldd	4,u
b3f1 : 3406             	pshs	d
b3f3 : 3052             	leax	-14,u
b3f5 : 3410             	pshs	x
b3f7 : bdaa27           	lbsr	_strcpy
b3fa : 3264             	leas	4,s
                        * 		returnStatus = convertFileName (localfileName);
b3fc : 3052             	leax	-14,u
b3fe : 3410             	pshs	x
b400 : bde53c           	lbsr	convertF
b403 : 3262             	leas	2,s
b405 : e75f             	stb	-1,u
                        * 	}
                        * 
                        *     if(returnStatus == VALID_FILE_NAME)
b407 :                  _97
b407 : e65f             	ldb	-1,u
b409 : 4f               	clra
b40a : 830003           	subd	#$3
b40d : 1026003e         	lbne	_98
                        *     {
                        *         returnStatus = 0; // default
b411 : 4f               	clra
b412 : 5f               	clrb
b413 : e75f             	stb	-1,u
                        * 		if(fatMapTb.fileOpenedFlag == TRUE)
b415 : e6a8d5           	ldb	fatMapTb+551,y
b418 : 4f               	clra
b419 : 830001           	subd	#$1
b41c : 1026001a         	lbne	_99
                        *         {
                        *             /* Check the file to be deleted is alrea
                        *             if(_strcmp(localfileName,fatMapTb.fName)
b420 : 30a8da           	leax	fatMapTb+556,y
b423 : 3410             	pshs	x
AS09 Assembler for M6809 [1.42].                                     Page  171
--------------------------------- merge.a09 ----------------------------------

b425 : 3052             	leax	-14,u
b427 : 3410             	pshs	x
b429 : bdaa49           	lbsr	_strcmp
b42c : 3264             	leas	4,s
b42e : 830000           	subd	#$0
b431 : 10260005         	lbne	_100
b435 : cc0006           	ldd	#$6
b438 : e75f             	stb	-1,u
                        *         }
b43a :                  _100
                        * 
                        *         if(returnStatus == 0) returnStatus = deleteF
b43a :                  _99
b43a : e65f             	ldb	-1,u
b43c : 4f               	clra
b43d : 830000           	subd	#$0
b440 : 1026000b         	lbne	_101
b444 : 3052             	leax	-14,u
b446 : 3410             	pshs	x
b448 : bde9ee           	lbsr	deleteFi
b44b : 3262             	leas	2,s
b44d : e75f             	stb	-1,u
                        *     }
b44f :                  _101
                        * 
                        *     return returnStatus;
b44f :                  _98
b44f : e65f             	ldb	-1,u
b451 : 4f               	clra
                        * }
b452 : 32c4             	leas	,u
b454 : 35c0             	puls	u,pc
                        * 
                        * /***************************************************
                        *                          char FILE_GetCh(fileConfig_
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                   fileConfig_st *: structure pointer
                        * 
                        *  * Return value  :
                        *                    char : Byte of data read from fil
                        * 
                        * 
                        *  * description :
                        *                  This functions reads a byte of data
                        *                  It checks whether the requested fil
                        *                  Once the End of File is reached it 
                        *  ***************************************************
                        * //char FILE_GetCh(fileConfig_st *filePtr)
                        * FILE_GetCh(filePtr) fileConfig_st *filePtr;
                        * {
                        *     char ch;
                        * 	u32_t tmp1, tmp2;
                        * 
                        * 	_setGVpt(); // call when GV are utilized
b456 :                  FILE_Get
b456 : 3440             	pshs	u
b458 : 33e4             	leau	,s
b45a : 3277             	leas	-9,s
b45c : bdaf77           	lbsr	_setGVpt
                        * 
                        *     if( ((_u32_higher(&filePtr->fileSize, &filePtr->
AS09 Assembler for M6809 [1.42].                                     Page  172
--------------------------------- merge.a09 ----------------------------------

b45f : ec44             	ldd	4,u
b461 : c30016           	addd	#$16
b464 : 3406             	pshs	d
b466 : ec44             	ldd	4,u
b468 : c30012           	addd	#$12
b46b : 3406             	pshs	d
b46d : bda9bb           	lbsr	_u32_hig
b470 : 3264             	leas	4,s
b472 : 830000           	subd	#$0
b475 : 102700ef         	lbeq	_102
b479 : ae44             	ldx	4,u
b47b : e6890227         	ldb	551,x
b47f : 4f               	clra
b480 : 830001           	subd	#$1
b483 : 102600e1         	lbne	_102
                        *     {
                        *         if(filePtr->bufferIndex_u16 == 0)
b487 : ae44             	ldx	4,u
b489 : ec8824           	ldd	36,x
b48c : 830000           	subd	#$0
b48f : 10260048         	lbne	_103
                        *         {
                        *             if((filePtr->sectorIndex == 0))
b493 : ae44             	ldx	4,u
b495 : ec8822           	ldd	34,x
b498 : 830000           	subd	#$0
b49b : 10260010         	lbne	_104
                        *             {
                        *                 getFirstSector(&filePtr->cluster, &f
b49f : ec44             	ldd	4,u
b4a1 : 3406             	pshs	d
b4a3 : ec44             	ldd	4,u
b4a5 : c30004           	addd	#$4
b4a8 : 3406             	pshs	d
b4aa : bde191           	lbsr	getFirst
b4ad : 3264             	leas	4,s
                        *             }            
                        * 			tmp1.h = 0; tmp1.l = filePtr->sectorIndex;
b4af :                  _104
b4af : 4f               	clra
b4b0 : 5f               	clrb
b4b1 : ed5b             	std	-5,u
b4b3 : ae44             	ldx	4,u
b4b5 : ec8822           	ldd	34,x
b4b8 : ed5d             	std	-3,u
                        * 			_u32_add(&filePtr->firstSector, &tmp1, &tmp2);
b4ba : 3057             	leax	-9,u
b4bc : 3410             	pshs	x
b4be : 305b             	leax	-5,u
b4c0 : 3410             	pshs	x
b4c2 : ec44             	ldd	4,u
b4c4 : 3406             	pshs	d
b4c6 : bda8da           	lbsr	_u32_add
b4c9 : 3266             	leas	6,s
                        * 			SD_readSingleBlock(filePtr->LE_fileBuffer, &tmp2)
b4cb : 3057             	leax	-9,u
b4cd : 3410             	pshs	x
b4cf : ec44             	ldd	4,u
b4d1 : c30026           	addd	#$26
b4d4 : 3406             	pshs	d
b4d6 : bdae0d           	lbsr	SD_readS
b4d9 : 3264             	leas	4,s
AS09 Assembler for M6809 [1.42].                                     Page  173
--------------------------------- merge.a09 ----------------------------------

                        *         }
                        * 
                        *         ch = filePtr->LE_fileBuffer[filePtr->bufferI
b4db :                  _103
b4db : ec44             	ldd	4,u
b4dd : c30026           	addd	#$26
b4e0 : 3406             	pshs	d
b4e2 : ec44             	ldd	4,u
b4e4 : c30024           	addd	#$24
b4e7 : 1f01             	tfr	d,x
b4e9 : ec84             	ldd	,x
b4eb : c30001           	addd	#$1
b4ee : ed84             	std	,x
b4f0 : 830001           	subd	#$1
b4f3 : 3510             	puls	x
b4f5 : e68b             	ldb	d,x
b4f7 : 1d               	sex
b4f8 : e75f             	stb	-1,u
                        *         _u32_inc(&filePtr->byteCounter);
b4fa : ec44             	ldd	4,u
b4fc : c30016           	addd	#$16
b4ff : 3406             	pshs	d
b501 : bda929           	lbsr	_u32_inc
b504 : 3262             	leas	2,s
                        * 
                        *         if(filePtr->bufferIndex_u16 == C_MaxPageSize
b506 : ae44             	ldx	4,u
b508 : ec8824           	ldd	36,x
b50b : 830200           	subd	#$200
b50e : 10260053         	lbne	_105
                        *         {
                        *             filePtr->sectorIndex++;
b512 : ec44             	ldd	4,u
b514 : c30022           	addd	#$22
b517 : 1f01             	tfr	d,x
b519 : ec84             	ldd	,x
b51b : c30001           	addd	#$1
b51e : ed84             	std	,x
b520 : 830001           	subd	#$1
                        *             filePtr->bufferIndex_u16 = 0;
b523 : 4f               	clra
b524 : 5f               	clrb
b525 : ae44             	ldx	4,u
b527 : ed8824           	std	36,x
                        *             if(filePtr->sectorIndex == secPerCluster
b52a : ae44             	ldx	4,u
b52c : ec8822           	ldd	34,x
b52f : a3a8ef           	subd	secPerCl+0,y
b532 : 1026002f         	lbne	_106
                        *             {
                        *                 filePtr->sectorIndex = 0;
b536 : 4f               	clra
b537 : 5f               	clrb
b538 : ae44             	ldx	4,u
b53a : ed8822           	std	34,x
                        *                 tmp1.h = tmp1.l = 0;
b53d : 4f               	clra
b53e : 5f               	clrb
b53f : ed5d             	std	-3,u
b541 : ed5b             	std	-5,u
                        * 				getSetNC (filePtr->LE_fileBuffer, &filePtr->clus
b543 : ec44             	ldd	4,u
AS09 Assembler for M6809 [1.42].                                     Page  174
--------------------------------- merge.a09 ----------------------------------

b545 : c30004           	addd	#$4
b548 : 3406             	pshs	d
b54a : 305b             	leax	-5,u
b54c : 3410             	pshs	x
b54e : 4f               	clra
b54f : 5f               	clrb
b550 : 3406             	pshs	d
b552 : ec44             	ldd	4,u
b554 : c30004           	addd	#$4
b557 : 3406             	pshs	d
b559 : ec44             	ldd	4,u
b55b : c30026           	addd	#$26
b55e : 3406             	pshs	d
b560 : bde1d8           	lbsr	getSetNC
b563 : 326a             	leas	10,s
                        *             }
                        *         }
b565 :                  _106
                        *     }
b565 :                  _105
                        *     else
b565 : 200612           	lbra	_107
b568 :                  _102
                        *     {
                        *         ch = EOF;
b568 : cc001a           	ldd	#$1a
b56b : e75f             	stb	-1,u
                        *     }
                        * 
                        *     return ch;
b56d :                  _107
b56d : e65f             	ldb	-1,u
b56f : 1d               	sex
                        * }
b570 : 32c4             	leas	,u
b572 : 35c0             	puls	u,pc
                        * 
                        * /***************************************************
                        *                          void FILE_PutCh (fileConfig
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                   fileConfig_st *: structure pointer
                        *                   char           : Byte of data to b
                        * 
                        *  * Return value  :
                        *                   0 when successfully
                        * 
                        * 
                        *  * description :
                        *                  This functions writes a byte of dat
                        *                  It checks whether the requested fil
                        * 
                        *            Note: CTRL+Z(26) needs to be passed to ma
                        *  ***************************************************
                        * //void FILE_PutCh (fileConfig_st *filePtr, char data
                        * FILE_PutCh(filePtr, data) fileConfig_st *filePtr; ch
                        * {
                        *     unsigned char k;
                        *     LE_dir_Structure *dir;
                        *     u32_t tmp1, tmp2;
                        * 
                        * 	_setGVpt(); // call when GV are utilized
AS09 Assembler for M6809 [1.42].                                     Page  175
--------------------------------- merge.a09 ----------------------------------

b574 :                  FILE_Put
b574 : 3440             	pshs	u
b576 : 33e4             	leau	,s
b578 : 3275             	leas	-11,s
b57a : bdaf77           	lbsr	_setGVpt
                        * 	
                        *     if(filePtr->fileOpenedFlag == TRUE)
b57d : ae44             	ldx	4,u
b57f : e6890227         	ldb	551,x
b583 : 4f               	clra
b584 : 830001           	subd	#$1
b587 : 102606c4         	lbne	_108
                        *     {
                        *         if((filePtr->endOfFileDetected == 0) && (dat
b58b : ae44             	ldx	4,u
b58d : e689022b         	ldb	555,x
b591 : 1d               	sex
b592 : 830000           	subd	#$0
b595 : 10260231         	lbne	_109
b599 : e647             	ldb	7,u
b59b : 1d               	sex
b59c : 83001a           	subd	#$1a
b59f : 10270227         	lbeq	_109
                        *         {
                        *             if(filePtr->sectorEndFlag == 1) //specia
b5a3 : ae44             	ldx	4,u
b5a5 : e689022a         	ldb	554,x
b5a9 : 4f               	clra
b5aa : 830001           	subd	#$1
b5ad : 10260035         	lbne	_110
                        *             {
                        *                 filePtr->LE_fileBuffer[filePtr->buff
b5b1 : ec44             	ldd	4,u
b5b3 : c30024           	addd	#$24
b5b6 : 1f01             	tfr	d,x
b5b8 : ec84             	ldd	,x
b5ba : c30001           	addd	#$1
b5bd : ed84             	std	,x
b5bf : 830001           	subd	#$1
b5c2 : 3406             	pshs	d
b5c4 : ec44             	ldd	4,u
b5c6 : c30026           	addd	#$26
b5c9 : e3e1             	addd	,s++
b5cb : 1f01             	tfr	d,x
b5cd : cc000a           	ldd	#$a
b5d0 : e784             	stb	0,x
                        *                 _u32_inc(&filePtr->fileSize);
b5d2 : ec44             	ldd	4,u
b5d4 : c30012           	addd	#$12
b5d7 : 3406             	pshs	d
b5d9 : bda929           	lbsr	_u32_inc
b5dc : 3262             	leas	2,s
                        *                 filePtr->sectorEndFlag = 0;
b5de : 4f               	clra
b5df : 5f               	clrb
b5e0 : ae44             	ldx	4,u
b5e2 : e789022a         	stb	554,x
                        *             }
                        * 
                        *             if(data == 0x08)    //'Back Space' key p
b5e6 :                  _110
b5e6 : e647             	ldb	7,u
AS09 Assembler for M6809 [1.42].                                     Page  176
--------------------------------- merge.a09 ----------------------------------

b5e8 : 1d               	sex
b5e9 : 830008           	subd	#$8
b5ec : 1026002c         	lbne	_111
                        *             {
                        *                 if(filePtr->bufferIndex_u16 != 0)
b5f0 : ae44             	ldx	4,u
b5f2 : ec8824           	ldd	36,x
b5f5 : 830000           	subd	#$0
b5f8 : 1027001d         	lbeq	_112
                        *                 {
                        *                     filePtr->bufferIndex_u16--;
b5fc : ec44             	ldd	4,u
b5fe : c30024           	addd	#$24
b601 : 1f01             	tfr	d,x
b603 : ec84             	ldd	,x
b605 : c3ffff           	addd	#$ffff
b608 : ed84             	std	,x
b60a : 83ffff           	subd	#$ffff
                        *                     _u32_dec(&filePtr->fileSize);
b60d : ec44             	ldd	4,u
b60f : c30012           	addd	#$12
b612 : 3406             	pshs	d
b614 : bda8ac           	lbsr	_u32_dec
b617 : 3262             	leas	2,s
                        *                 }
                        *             }
b619 :                  _112
                        *             else
b619 : 202e12           	lbra	_113
b61c :                  _111
                        *             {
                        *                 filePtr->LE_fileBuffer[filePtr->buff
b61c : ec44             	ldd	4,u
b61e : c30024           	addd	#$24
b621 : 1f01             	tfr	d,x
b623 : ec84             	ldd	,x
b625 : c30001           	addd	#$1
b628 : ed84             	std	,x
b62a : 830001           	subd	#$1
b62d : 3406             	pshs	d
b62f : ec44             	ldd	4,u
b631 : c30026           	addd	#$26
b634 : e3e1             	addd	,s++
b636 : 1f01             	tfr	d,x
b638 : e647             	ldb	7,u
b63a : 4f               	clra
b63b : e784             	stb	0,x
                        *                 _u32_inc(&filePtr->fileSize);
b63d : ec44             	ldd	4,u
b63f : c30012           	addd	#$12
b642 : 3406             	pshs	d
b644 : bda929           	lbsr	_u32_inc
b647 : 3262             	leas	2,s
                        *             }
                        * 
                        * 
                        *             if(data == '\r')  //'Carriage Return (CR
b649 :                  _113
b649 : e647             	ldb	7,u
b64b : 1d               	sex
b64c : 83000d           	subd	#$d
b64f : 10260045         	lbne	_114
AS09 Assembler for M6809 [1.42].                                     Page  177
--------------------------------- merge.a09 ----------------------------------

                        *             {
                        *                 if(filePtr->bufferIndex_u16 == C_Max
b653 : ae44             	ldx	4,u
b655 : ec8824           	ldd	36,x
b658 : 830200           	subd	#$200
b65b : 1026000c         	lbne	_115
                        *                     filePtr->sectorEndFlag = 1;  //f
b65f : cc0001           	ldd	#$1
b662 : ae44             	ldx	4,u
b664 : e789022a         	stb	554,x
                        *                 else
b668 : 202e12           	lbra	_116
b66b :                  _115
                        *                 {
                        *                     filePtr->LE_fileBuffer[filePtr->
b66b : ec44             	ldd	4,u
b66d : c30024           	addd	#$24
b670 : 1f01             	tfr	d,x
b672 : ec84             	ldd	,x
b674 : c30001           	addd	#$1
b677 : ed84             	std	,x
b679 : 830001           	subd	#$1
b67c : 3406             	pshs	d
b67e : ec44             	ldd	4,u
b680 : c30026           	addd	#$26
b683 : e3e1             	addd	,s++
b685 : 1f01             	tfr	d,x
b687 : cc000a           	ldd	#$a
b68a : e784             	stb	0,x
                        *                     _u32_inc(&filePtr->fileSize);
b68c : ec44             	ldd	4,u
b68e : c30012           	addd	#$12
b691 : 3406             	pshs	d
b693 : bda929           	lbsr	_u32_inc
b696 : 3262             	leas	2,s
                        *                 }
                        *             }
b698 :                  _116
                        * 
                        *             if(filePtr->bufferIndex_u16 >= C_MaxPage
b698 :                  _114
b698 : ae44             	ldx	4,u
b69a : ec8824           	ldd	36,x
b69d : 830200           	subd	#$200
b6a0 : 10250123         	lblo	_117
                        *             {               //infinite loop in case 
                        *                 filePtr->bufferIndex_u16=0;         
b6a4 : 4f               	clra
b6a5 : 5f               	clrb
b6a6 : ae44             	ldx	4,u
b6a8 : ed8824           	std	36,x
                        * 				if (SD_writeSingleBlock(filePtr->LE_fileBuffer, 
b6ab : ec44             	ldd	4,u
b6ad : c3001a           	addd	#$1a
b6b0 : 3406             	pshs	d
b6b2 : ec44             	ldd	4,u
b6b4 : c30026           	addd	#$26
b6b7 : 3406             	pshs	d
b6b9 : bdae9b           	lbsr	SD_write
b6bc : 3264             	leas	4,s
b6be : 830000           	subd	#$0
b6c1 : 10270007         	lbeq	_118
AS09 Assembler for M6809 [1.42].                                     Page  178
--------------------------------- merge.a09 ----------------------------------

b6c5 : ccffff           	ldd	#$ffff
                        *                 filePtr->sectorIndex++;
b6c8 : 32c4             	leas	,u
b6ca : 35c0             	puls	u,pc
b6cc :                  _118
b6cc : ec44             	ldd	4,u
b6ce : c30022           	addd	#$22
b6d1 : 1f01             	tfr	d,x
b6d3 : ec84             	ldd	,x
b6d5 : c30001           	addd	#$1
b6d8 : ed84             	std	,x
b6da : 830001           	subd	#$1
                        *                 if(filePtr->sectorIndex == secPerClu
b6dd : ae44             	ldx	4,u
b6df : ec8822           	ldd	34,x
b6e2 : a3a8ef           	subd	secPerCl+0,y
b6e5 : 102600d2         	lbne	_119
                        *                 {
                        *                     filePtr->sectorIndex = 0;
b6e9 : 4f               	clra
b6ea : 5f               	clrb
b6eb : ae44             	ldx	4,u
b6ed : ed8822           	std	34,x
                        *                     filePtr->prevCluster.h = filePtr
b6f0 : ae44             	ldx	4,u
b6f2 : ec04             	ldd	4,x
b6f4 : ae44             	ldx	4,u
b6f6 : ed08             	std	8,x
b6f8 : ec44             	ldd	4,u
b6fa : c30004           	addd	#$4
b6fd : 3406             	pshs	d
b6ff : cc0002           	ldd	#$2
b702 : 3510             	puls	x
b704 : ec8b             	ldd	d,x
b706 : 3406             	pshs	d
b708 : ec44             	ldd	4,u
b70a : c30008           	addd	#$8
b70d : c30002           	addd	#$2
b710 : 1f01             	tfr	d,x
b712 : 3506             	puls	d
b714 : ed84             	std	0,x
                        * 
                        *                     searchNextFreeCluster(filePtr->L
b716 : ec44             	ldd	4,u
b718 : c30004           	addd	#$4
b71b : 3406             	pshs	d
b71d : ec44             	ldd	4,u
b71f : c30008           	addd	#$8
b722 : 3406             	pshs	d
b724 : ec44             	ldd	4,u
b726 : c30026           	addd	#$26
b729 : 3406             	pshs	d
b72b : bde3fc           	lbsr	searchNe
b72e : 3266             	leas	6,s
                        * 
                        *                     tmp1.h = tmp1.l = 0;
b730 : 4f               	clra
b731 : 5f               	clrb
b732 : ed5b             	std	-5,u
b734 : ed59             	std	-7,u
                        *                     if(_u32_equal(&filePtr->cluster,
b736 : 3059             	leax	-7,u
AS09 Assembler for M6809 [1.42].                                     Page  179
--------------------------------- merge.a09 ----------------------------------

b738 : 3410             	pshs	x
b73a : ec44             	ldd	4,u
b73c : c30004           	addd	#$4
b73f : 3406             	pshs	d
b741 : bda990           	lbsr	_u32_equ
b744 : 3264             	leas	4,s
b746 : 830000           	subd	#$0
b749 : 10270007         	lbeq	_120
b74d : ccffff           	ldd	#$ffff
                        * 
                        *                     getSetNC(filePtr->LE_fileBuffer,
b750 : 32c4             	leas	,u
b752 : 35c0             	puls	u,pc
b754 :                  _120
b754 : 3059             	leax	-7,u
b756 : 3410             	pshs	x
b758 : ec44             	ldd	4,u
b75a : c30004           	addd	#$4
b75d : 3406             	pshs	d
b75f : cc0001           	ldd	#$1
b762 : 3406             	pshs	d
b764 : ec44             	ldd	4,u
b766 : c30008           	addd	#$8
b769 : 3406             	pshs	d
b76b : ec44             	ldd	4,u
b76d : c30026           	addd	#$26
b770 : 3406             	pshs	d
b772 : bde1d8           	lbsr	getSetNC
b775 : 326a             	leas	10,s
                        * 					tmp1.h = 0x0fff; tmp1.l = 0xffff; // = END_OF_C
b777 : cc0fff           	ldd	#$fff
b77a : ed59             	std	-7,u
b77c : ccffff           	ldd	#$ffff
b77f : ed5b             	std	-5,u
                        *                     getSetNC(filePtr->LE_fileBuffer,
b781 : 3055             	leax	-11,u
b783 : 3410             	pshs	x
b785 : 3059             	leax	-7,u
b787 : 3410             	pshs	x
b789 : cc0001           	ldd	#$1
b78c : 3406             	pshs	d
b78e : ec44             	ldd	4,u
b790 : c30004           	addd	#$4
b793 : 3406             	pshs	d
b795 : ec44             	ldd	4,u
b797 : c30026           	addd	#$26
b79a : 3406             	pshs	d
b79c : bde1d8           	lbsr	getSetNC
b79f : 326a             	leas	10,s
                        * 
                        *                     getFirstSector (&filePtr->cluste
b7a1 : ec44             	ldd	4,u
b7a3 : c3001a           	addd	#$1a
b7a6 : 3406             	pshs	d
b7a8 : ec44             	ldd	4,u
b7aa : c30004           	addd	#$4
b7ad : 3406             	pshs	d
b7af : bde191           	lbsr	getFirst
b7b2 : 3264             	leas	4,s
                        *                     filePtr->bufferIndex_u16=0;
b7b4 : 4f               	clra
b7b5 : 5f               	clrb
AS09 Assembler for M6809 [1.42].                                     Page  180
--------------------------------- merge.a09 ----------------------------------

b7b6 : ae44             	ldx	4,u
b7b8 : ed8824           	std	36,x
                        *                 }
                        *                 _u32_inc(&filePtr->blockNumber_u32);
b7bb :                  _119
b7bb : ec44             	ldd	4,u
b7bd : c3001a           	addd	#$1a
b7c0 : 3406             	pshs	d
b7c2 : bda929           	lbsr	_u32_inc
b7c5 : 3262             	leas	2,s
                        *             }
                        *         }
b7c7 :                  _117
                        *         else if(filePtr->endOfFileDetected == 0)
b7c7 : 7ebc4c           	lbra	_121
b7ca :                  _109
b7ca : ae44             	ldx	4,u
b7cc : e689022b         	ldb	555,x
b7d0 : 4f               	clra
b7d1 : 830000           	subd	#$0
b7d4 : 10260474         	lbne	_122
                        *         {
                        *             filePtr->endOfFileDetected = 1;
b7d8 : cc0001           	ldd	#$1
b7db : ae44             	ldx	4,u
b7dd : e789022b         	stb	555,x
                        *             for(;filePtr->bufferIndex_u16<C_MaxPageS
b7e1 :                  _124
b7e1 : ae44             	ldx	4,u
b7e3 : ec8824           	ldd	36,x
b7e6 : 830200           	subd	#$200
b7e9 : 10240027         	lbhs	_123
                        *                 filePtr->LE_fileBuffer[filePtr->buff
b7ed : ae44             	ldx	4,u
b7ef : ec8824           	ldd	36,x
b7f2 : 3406             	pshs	d
b7f4 : ec44             	ldd	4,u
b7f6 : c30026           	addd	#$26
b7f9 : e3e1             	addd	,s++
b7fb : 1f01             	tfr	d,x
b7fd : 4f               	clra
b7fe : 5f               	clrb
b7ff : e784             	stb	0,x
                        * 
                        * 			if (SD_writeSingleBlock(filePtr->LE_fileBuffer, &
b801 :                  _125
b801 : ec44             	ldd	4,u
b803 : c30024           	addd	#$24
b806 : 1f01             	tfr	d,x
b808 : ec84             	ldd	,x
b80a : c30001           	addd	#$1
b80d : ed84             	std	,x
b80f : 830001           	subd	#$1
b812 : 20cd             	lbra	_124
b814 :                  _123
b814 : ec44             	ldd	4,u
b816 : c3001a           	addd	#$1a
b819 : 3406             	pshs	d
b81b : ec44             	ldd	4,u
b81d : c30026           	addd	#$26
b820 : 3406             	pshs	d
b822 : bdae9b           	lbsr	SD_write
AS09 Assembler for M6809 [1.42].                                     Page  181
--------------------------------- merge.a09 ----------------------------------

b825 : 3264             	leas	4,s
b827 : 830000           	subd	#$0
b82a : 10270007         	lbeq	_126
b82e : ccffff           	ldd	#$ffff
                        *             
                        * 			getSetFreeCluster(filePtr->LE_fileBuffer,NEXT_FRE
b831 : 32c4             	leas	,u
b833 : 35c0             	puls	u,pc
b835 :                  _126
b835 : 3059             	leax	-7,u
b837 : 3410             	pshs	x
b839 : ec44             	ldd	4,u
b83b : c30004           	addd	#$4
b83e : 3406             	pshs	d
b840 : cc0001           	ldd	#$1
b843 : 3406             	pshs	d
b845 : cc0002           	ldd	#$2
b848 : 3406             	pshs	d
b84a : ec44             	ldd	4,u
b84c : c30026           	addd	#$26
b84f : 3406             	pshs	d
b851 : bde2df           	lbsr	getSetFr
b854 : 326a             	leas	10,s
                        * 
                        *             if(filePtr->appendFileFlag == 1)  //exec
b856 : ae44             	ldx	4,u
b858 : e6890229         	ldb	553,x
b85c : 4f               	clra
b85d : 830001           	subd	#$1
b860 : 102600a4         	lbne	_127
                        *             {
                        *                 if (SD_readSingleBlock(filePtr->LE_f
b864 : ec44             	ldd	4,u
b866 : c3000c           	addd	#$c
b869 : 3406             	pshs	d
b86b : ec44             	ldd	4,u
b86d : c30026           	addd	#$26
b870 : 3406             	pshs	d
b872 : bdae0d           	lbsr	SD_readS
b875 : 3264             	leas	4,s
b877 : 830000           	subd	#$0
b87a : 10270007         	lbeq	_128
b87e : ccffff           	ldd	#$ffff
                        * 				
                        *                 dir = &filePtr->LE_fileBuffer[filePt
b881 : 32c4             	leas	,u
b883 : 35c0             	puls	u,pc
b885 :                  _128
b885 : ae44             	ldx	4,u
b887 : ec8810           	ldd	16,x
b88a : 3406             	pshs	d
b88c : ec44             	ldd	4,u
b88e : c30026           	addd	#$26
b891 : e3e1             	addd	,s++
b893 : ed5d             	std	-3,u
                        *                 get_QByte(dir->fSize, &tmp1);
b895 : 3059             	leax	-7,u
b897 : 3410             	pshs	x
b899 : ec5d             	ldd	-3,u
b89b : c3001c           	addd	#$1c
b89e : 3406             	pshs	d
b8a0 : bde17c           	lbsr	get_QByt
AS09 Assembler for M6809 [1.42].                                     Page  182
--------------------------------- merge.a09 ----------------------------------

b8a3 : 3264             	leas	4,s
                        * 				_u32_sub(&filePtr->fileSize, &tmp1, &tmp2);
b8a5 : 3055             	leax	-11,u
b8a7 : 3410             	pshs	x
b8a9 : 3059             	leax	-7,u
b8ab : 3410             	pshs	x
b8ad : ec44             	ldd	4,u
b8af : c30012           	addd	#$12
b8b2 : 3406             	pshs	d
b8b4 : bda870           	lbsr	_u32_sub
b8b7 : 3266             	leas	6,s
                        * 				set_QByte(&filePtr->fileSize, dir->fSize);
b8b9 : ec5d             	ldd	-3,u
b8bb : c3001c           	addd	#$1c
b8be : 3406             	pshs	d
b8c0 : ec44             	ldd	4,u
b8c2 : c30012           	addd	#$12
b8c5 : 3406             	pshs	d
b8c7 : bde17c           	lbsr	set_QByt
b8ca : 3264             	leas	4,s
                        *                 if (SD_writeSingleBlock(filePtr->LE_
b8cc : ec44             	ldd	4,u
b8ce : c3000c           	addd	#$c
b8d1 : 3406             	pshs	d
b8d3 : ec44             	ldd	4,u
b8d5 : c30026           	addd	#$26
b8d8 : 3406             	pshs	d
b8da : bdae9b           	lbsr	SD_write
b8dd : 3264             	leas	4,s
b8df : 830000           	subd	#$0
b8e2 : 10270007         	lbeq	_129
b8e6 : ccffff           	ldd	#$ffff
                        *                 freeMemoryUpdate (filePtr->LE_fileBu
b8e9 : 32c4             	leas	,u
b8eb : 35c0             	puls	u,pc
b8ed :                  _129
b8ed : 3055             	leax	-11,u
b8ef : 3410             	pshs	x
b8f1 : cc0001           	ldd	#$1
b8f4 : 3406             	pshs	d
b8f6 : ec44             	ldd	4,u
b8f8 : c30026           	addd	#$26
b8fb : 3406             	pshs	d
b8fd : bde901           	lbsr	freeMemo
b900 : 3266             	leas	6,s
                        *                 return 0;
b902 : 4f               	clra
b903 : 5f               	clrb
                        *             }
b904 : 32c4             	leas	,u
b906 : 35c0             	puls	u,pc
                        * 
                        *             //executes following portion when new fi
                        * 			filePtr->prevCluster.h = rCluster.h; filePtr->pre
b908 :                  _127
b908 : ec37             	ldd	rCluster+0,y
b90a : ae44             	ldx	4,u
b90c : ed08             	std	8,x
b90e : ec44             	ldd	4,u
b910 : c30008           	addd	#$8
b913 : c30002           	addd	#$2
b916 : 1f01             	tfr	d,x
AS09 Assembler for M6809 [1.42].                                     Page  183
--------------------------------- merge.a09 ----------------------------------

b918 : ec39             	ldd	rCluster+2,y
b91a : ed84             	std	0,x
                        * 
                        *             while(1)
b91c :                  _131
                        *             {
                        *                 getFirstSector(&filePtr->prevCluster
b91c : ec44             	ldd	4,u
b91e : 3406             	pshs	d
b920 : ec44             	ldd	4,u
b922 : c30008           	addd	#$8
b925 : 3406             	pshs	d
b927 : bde191           	lbsr	getFirst
b92a : 3264             	leas	4,s
                        * 
                        *                 for(filePtr->sectorIndex = 0; filePt
b92c : 4f               	clra
b92d : 5f               	clrb
b92e : ae44             	ldx	4,u
b930 : ed8822           	std	34,x
b933 :                  _133
b933 : ae44             	ldx	4,u
b935 : ec8822           	ldd	34,x
b938 : a3a8ef           	subd	secPerCl+0,y
b93b : 102401ef         	lbhs	_132
                        *                 {
                        *                     tmp1.h = 0; tmp1.l = filePtr->se
b93f : 4f               	clra
b940 : 5f               	clrb
b941 : ed59             	std	-7,u
b943 : ae44             	ldx	4,u
b945 : ec8822           	ldd	34,x
b948 : ed5b             	std	-5,u
                        *                     _u32_add(&filePtr->firstSector, 
b94a : 3055             	leax	-11,u
b94c : 3410             	pshs	x
b94e : 3059             	leax	-7,u
b950 : 3410             	pshs	x
b952 : ec44             	ldd	4,u
b954 : 3406             	pshs	d
b956 : bda8da           	lbsr	_u32_add
b959 : 3266             	leas	6,s
                        * 					if (SD_readSingleBlock(filePtr->LE_fileBuffer, 
b95b : 3055             	leax	-11,u
b95d : 3410             	pshs	x
b95f : ec44             	ldd	4,u
b961 : c30026           	addd	#$26
b964 : 3406             	pshs	d
b966 : bdae0d           	lbsr	SD_readS
b969 : 3264             	leas	4,s
b96b : 830000           	subd	#$0
b96e : 10270007         	lbeq	_135
b972 : ccffff           	ldd	#$ffff
                        * 					
                        *                     for(filePtr->bufferIndex_u16=0; 
b975 : 32c4             	leas	,u
b977 : 35c0             	puls	u,pc
b979 :                  _135
b979 : 4f               	clra
b97a : 5f               	clrb
b97b : ae44             	ldx	4,u
b97d : ed8824           	std	36,x
AS09 Assembler for M6809 [1.42].                                     Page  184
--------------------------------- merge.a09 ----------------------------------

b980 :                  _137
b980 : ae44             	ldx	4,u
b982 : ec8824           	ldd	36,x
b985 : a331             	subd	bPerSect+0,y
b987 : 1024018f         	lbhs	_136
                        *                     {
                        *                         dir = &filePtr->LE_fileBuffe
b98b : ae44             	ldx	4,u
b98d : ec8824           	ldd	36,x
b990 : 3406             	pshs	d
b992 : ec44             	ldd	4,u
b994 : c30026           	addd	#$26
b997 : e3e1             	addd	,s++
b999 : ed5d             	std	-3,u
                        * 						if(filePtr->fileCreatedFlag != 0)   //to mark 
b99b : ae44             	ldx	4,u
b99d : e6890228         	ldb	552,x
b9a1 : 4f               	clra
b9a2 : 830000           	subd	#$0
b9a5 : 1027000c         	lbeq	_139
                        *                         {                     //indi
                        *                             dir->name[0] = 0x00;
b9a9 : 4f               	clra
b9aa : 5f               	clrb
b9ab : ae5d             	ldx	-3,u
b9ad : e784             	stb	0,x
                        *                             return 0;
b9af : 4f               	clra
b9b0 : 5f               	clrb
                        *                         }
b9b1 : 32c4             	leas	,u
b9b3 : 35c0             	puls	u,pc
                        * 
                        *                         if((dir->name[0] == EMPTY) |
b9b5 :                  _139
b9b5 : ae5d             	ldx	-3,u
b9b7 : e684             	ldb	0,x
b9b9 : 4f               	clra
b9ba : 830000           	subd	#$0
b9bd : 1027000c         	lbeq	_141
b9c1 : ae5d             	ldx	-3,u
b9c3 : e684             	ldb	0,x
b9c5 : 4f               	clra
b9c6 : 8300e5           	subd	#$e5
b9c9 : 1026013c         	lbne	_140
b9cd :                  _141
                        *                         {                           
                        * 							// Root Directory Entry Format (SFN)					
                        * 							for(k=0; k<C_8_3_FileNameSize; k++) {        
b9cd : 4f               	clra
b9ce : 5f               	clrb
b9cf : e75f             	stb	-1,u
b9d1 :                  _143
b9d1 : e65f             	ldb	-1,u
b9d3 : 4f               	clra
b9d4 : 83000b           	subd	#$b
b9d7 : 10240025         	lbhs	_142
                        * 								dir->name[k] = filePtr->fName[k];
b9db : ec44             	ldd	4,u
b9dd : c3022c           	addd	#$22c
b9e0 : 3406             	pshs	d
b9e2 : e65f             	ldb	-1,u
AS09 Assembler for M6809 [1.42].                                     Page  185
--------------------------------- merge.a09 ----------------------------------

b9e4 : 4f               	clra
b9e5 : 3510             	puls	x
b9e7 : e68b             	ldb	d,x
b9e9 : 4f               	clra
b9ea : 3406             	pshs	d
b9ec : e65f             	ldb	-1,u
b9ee : 4f               	clra
b9ef : ae5d             	ldx	-3,u
b9f1 : 308b             	leax	d,x
b9f3 : 3506             	puls	d
b9f5 : e784             	stb	0,x
                        * 							}
                        *                             dir->attrib = ATTR_ARCHI
b9f7 :                  _144
b9f7 : 305f             	leax	-1,u
b9f9 : e684             	ldb	,x
b9fb : 6c84             	inc	,x
b9fd : 4f               	clra
b9fe : 20d1             	lbra	_143
ba00 :                  _142
ba00 : cc0020           	ldd	#$20
ba03 : ae5d             	ldx	-3,u
ba05 : e70b             	stb	11,x
                        *                             dir->NTreserved = 0;    
ba07 : 4f               	clra
ba08 : 5f               	clrb
ba09 : ae5d             	ldx	-3,u
ba0b : e70c             	stb	12,x
                        * 							dir->timeTenth = 0;         					//always set
ba0d : 4f               	clra
ba0e : 5f               	clrb
ba0f : ae5d             	ldx	-3,u
ba11 : e70d             	stb	13,x
                        *                             // Time		Bit 15-11: Hour
                        * 							//			Bit 10-5: Minutes in range from 0 to 59.
                        * 							//			Bit 4-0: 2 second count in range of form
                        * 							tmp1.l = 0;
ba13 : 4f               	clra
ba14 : 5f               	clrb
ba15 : ed5b             	std	-5,u
                        * 							set_Word(tmp1.l, dir->createTime);       // t
ba17 : ec5d             	ldd	-3,u
ba19 : c3000e           	addd	#$e
ba1c : 3406             	pshs	d
ba1e : ec5b             	ldd	-5,u
ba20 : 3406             	pshs	d
ba22 : bde174           	lbsr	set_Word
ba25 : 3264             	leas	4,s
                        * 	                        set_Word(tmp1.l, dir->write
ba27 : ec5d             	ldd	-3,u
ba29 : c30016           	addd	#$16
ba2c : 3406             	pshs	d
ba2e : ec5b             	ldd	-5,u
ba30 : 3406             	pshs	d
ba32 : bde174           	lbsr	set_Word
ba35 : 3264             	leas	4,s
                        * 							// Date  	Bit 15-9: Count of years from 1980 
                        * 							// 			Bit 8-5: Month of year in range of from
                        * 							//			Bit 4-0: Day of month in range of from 1
                        * 							tmp1.l = (44<<9) | (1<<5) | 1;
ba37 : cc5821           	ldd	#$5821
ba3a : ed5b             	std	-5,u
AS09 Assembler for M6809 [1.42].                                     Page  186
--------------------------------- merge.a09 ----------------------------------

                        * 							set_Word(tmp1.l, dir->createDate); 		 // date
ba3c : ec5d             	ldd	-3,u
ba3e : c30010           	addd	#$10
ba41 : 3406             	pshs	d
ba43 : ec5b             	ldd	-5,u
ba45 : 3406             	pshs	d
ba47 : bde174           	lbsr	set_Word
ba4a : 3264             	leas	4,s
                        * 	                        set_Word(tmp1.l, dir->lastA
ba4c : ec5d             	ldd	-3,u
ba4e : c30012           	addd	#$12
ba51 : 3406             	pshs	d
ba53 : ec5b             	ldd	-5,u
ba55 : 3406             	pshs	d
ba57 : bde174           	lbsr	set_Word
ba5a : 3264             	leas	4,s
                        * 	                        set_Word(tmp1.l, dir->write
ba5c : ec5d             	ldd	-3,u
ba5e : c30018           	addd	#$18
ba61 : 3406             	pshs	d
ba63 : ec5b             	ldd	-5,u
ba65 : 3406             	pshs	d
ba67 : bde174           	lbsr	set_Word
ba6a : 3264             	leas	4,s
                        * 	                        set_Word(filePtr->appendSta
ba6c : ec5d             	ldd	-3,u
ba6e : c30014           	addd	#$14
ba71 : 3406             	pshs	d
ba73 : ae44             	ldx	4,u
ba75 : ec881e           	ldd	30,x
ba78 : 3406             	pshs	d
ba7a : bde174           	lbsr	set_Word
ba7d : 3264             	leas	4,s
                        * 	                        set_Word(filePtr->appendSta
ba7f : ec5d             	ldd	-3,u
ba81 : c3001a           	addd	#$1a
ba84 : 3406             	pshs	d
ba86 : ec44             	ldd	4,u
ba88 : c3001e           	addd	#$1e
ba8b : 3406             	pshs	d
ba8d : cc0002           	ldd	#$2
ba90 : 3510             	puls	x
ba92 : ec8b             	ldd	d,x
ba94 : 3406             	pshs	d
ba96 : bde174           	lbsr	set_Word
ba99 : 3264             	leas	4,s
                        * 	                        set_QByte(&filePtr->fileSiz
ba9b : ec5d             	ldd	-3,u
ba9d : c3001c           	addd	#$1c
baa0 : 3406             	pshs	d
baa2 : ec44             	ldd	4,u
baa4 : c30012           	addd	#$12
baa7 : 3406             	pshs	d
baa9 : bde17c           	lbsr	set_QByt
baac : 3264             	leas	4,s
                        * 							
                        * 							tmp1.h = 0; tmp1.l = filePtr->sectorIndex;
baae : 4f               	clra
baaf : 5f               	clrb
bab0 : ed59             	std	-7,u
bab2 : ae44             	ldx	4,u
bab4 : ec8822           	ldd	34,x
AS09 Assembler for M6809 [1.42].                                     Page  187
--------------------------------- merge.a09 ----------------------------------

bab7 : ed5b             	std	-5,u
                        * 							_u32_add(&filePtr->firstSector, &tmp1, &tmp2)
bab9 : 3055             	leax	-11,u
babb : 3410             	pshs	x
babd : 3059             	leax	-7,u
babf : 3410             	pshs	x
bac1 : ec44             	ldd	4,u
bac3 : 3406             	pshs	d
bac5 : bda8da           	lbsr	_u32_add
bac8 : 3266             	leas	6,s
                        * 							if (SD_writeSingleBlock(filePtr->LE_fileBuffe
baca : 3055             	leax	-11,u
bacc : 3410             	pshs	x
bace : ec44             	ldd	4,u
bad0 : c30026           	addd	#$26
bad3 : 3406             	pshs	d
bad5 : bdae9b           	lbsr	SD_write
bad8 : 3264             	leas	4,s
bada : 830000           	subd	#$0
badd : 10270007         	lbeq	_145
bae1 : ccffff           	ldd	#$ffff
                        *                             filePtr->fileCreatedFlag
bae4 : 32c4             	leas	,u
bae6 : 35c0             	puls	u,pc
bae8 :                  _145
bae8 : cc0001           	ldd	#$1
baeb : ae44             	ldx	4,u
baed : e7890228         	stb	552,x
                        *                             freeMemoryUpdate (filePt
baf1 : ec44             	ldd	4,u
baf3 : c30012           	addd	#$12
baf6 : 3406             	pshs	d
baf8 : cc0001           	ldd	#$1
bafb : 3406             	pshs	d
bafd : ec44             	ldd	4,u
baff : c30026           	addd	#$26
bb02 : 3406             	pshs	d
bb04 : bde901           	lbsr	freeMemo
bb07 : 3266             	leas	6,s
                        *                         }
                        *                     }
bb09 :                  _140
                        *                 }
bb09 :                  _138
bb09 : ec44             	ldd	4,u
bb0b : c30024           	addd	#$24
bb0e : 1f01             	tfr	d,x
bb10 : ec84             	ldd	0,x
bb12 : c30020           	addd	#$20
bb15 : ed84             	std	0,x
bb17 : 7eb980           	lbra	_137
bb1a :                  _136
                        * 				tmp1.h = tmp1.l = 0;
bb1a :                  _134
bb1a : ec44             	ldd	4,u
bb1c : c30022           	addd	#$22
bb1f : 1f01             	tfr	d,x
bb21 : ec84             	ldd	,x
bb23 : c30001           	addd	#$1
bb26 : ed84             	std	,x
bb28 : 830001           	subd	#$1
bb2b : 7eb933           	lbra	_133
AS09 Assembler for M6809 [1.42].                                     Page  188
--------------------------------- merge.a09 ----------------------------------

bb2e :                  _132
bb2e : 4f               	clra
bb2f : 5f               	clrb
bb30 : ed5b             	std	-5,u
bb32 : ed59             	std	-7,u
                        *                 getSetNC (filePtr->LE_fileBuffer, &f
bb34 : ec44             	ldd	4,u
bb36 : c30004           	addd	#$4
bb39 : 3406             	pshs	d
bb3b : 3059             	leax	-7,u
bb3d : 3410             	pshs	x
bb3f : 4f               	clra
bb40 : 5f               	clrb
bb41 : 3406             	pshs	d
bb43 : ec44             	ldd	4,u
bb45 : c30008           	addd	#$8
bb48 : 3406             	pshs	d
bb4a : ec44             	ldd	4,u
bb4c : c30026           	addd	#$26
bb4f : 3406             	pshs	d
bb51 : bde1d8           	lbsr	getSetNC
bb54 : 326a             	leas	10,s
                        * 
                        *                 tmp1.h = 0x0fff; tmp1.l = 0xfff6;
bb56 : cc0fff           	ldd	#$fff
bb59 : ed59             	std	-7,u
bb5b : ccfff6           	ldd	#$fff6
bb5e : ed5b             	std	-5,u
                        * 				if(_u32_higher(&filePtr->cluster, &tmp1) != 0)
bb60 : 3059             	leax	-7,u
bb62 : 3410             	pshs	x
bb64 : ec44             	ldd	4,u
bb66 : c30004           	addd	#$4
bb69 : 3406             	pshs	d
bb6b : bda9bb           	lbsr	_u32_hig
bb6e : 3264             	leas	4,s
bb70 : 830000           	subd	#$0
bb73 : 10270088         	lbeq	_146
                        *                 {
                        *                     tmp1.h = 0x0fff; tmp1.l = 0xffff
bb77 : cc0fff           	ldd	#$fff
bb7a : ed59             	std	-7,u
bb7c : ccffff           	ldd	#$ffff
bb7f : ed5b             	std	-5,u
                        * 					if(_u32_equal(&filePtr->cluster, &tmp1) != 0)  
bb81 : 3059             	leax	-7,u
bb83 : 3410             	pshs	x
bb85 : ec44             	ldd	4,u
bb87 : c30004           	addd	#$4
bb8a : 3406             	pshs	d
bb8c : bda990           	lbsr	_u32_equ
bb8f : 3264             	leas	4,s
bb91 : 830000           	subd	#$0
bb94 : 10270060         	lbeq	_147
                        *                     {
                        *                         searchNextFreeCluster(filePt
bb98 : ec44             	ldd	4,u
bb9a : c30004           	addd	#$4
bb9d : 3406             	pshs	d
bb9f : ec44             	ldd	4,u
bba1 : c30008           	addd	#$8
bba4 : 3406             	pshs	d
AS09 Assembler for M6809 [1.42].                                     Page  189
--------------------------------- merge.a09 ----------------------------------

bba6 : ec44             	ldd	4,u
bba8 : c30026           	addd	#$26
bbab : 3406             	pshs	d
bbad : bde3fc           	lbsr	searchNe
bbb0 : 3266             	leas	6,s
                        *                         getSetNC(filePtr->LE_fileBuf
bbb2 : 3055             	leax	-11,u
bbb4 : 3410             	pshs	x
bbb6 : ec44             	ldd	4,u
bbb8 : c30004           	addd	#$4
bbbb : 3406             	pshs	d
bbbd : cc0001           	ldd	#$1
bbc0 : 3406             	pshs	d
bbc2 : ec44             	ldd	4,u
bbc4 : c30008           	addd	#$8
bbc7 : 3406             	pshs	d
bbc9 : ec44             	ldd	4,u
bbcb : c30026           	addd	#$26
bbce : 3406             	pshs	d
bbd0 : bde1d8           	lbsr	getSetNC
bbd3 : 326a             	leas	10,s
                        * 						getSetNC(filePtr->LE_fileBuffer, &filePtr->clu
bbd5 : 3055             	leax	-11,u
bbd7 : 3410             	pshs	x
bbd9 : 3059             	leax	-7,u
bbdb : 3410             	pshs	x
bbdd : cc0001           	ldd	#$1
bbe0 : 3406             	pshs	d
bbe2 : ec44             	ldd	4,u
bbe4 : c30004           	addd	#$4
bbe7 : 3406             	pshs	d
bbe9 : ec44             	ldd	4,u
bbeb : c30026           	addd	#$26
bbee : 3406             	pshs	d
bbf0 : bde1d8           	lbsr	getSetNC
bbf3 : 326a             	leas	10,s
                        *                     }
                        *                     else
bbf5 : 200812           	lbra	_148
bbf8 :                  _147
                        *                     {
                        *                         return -1;
bbf8 : ccffff           	ldd	#$ffff
                        *                     }
bbfb : 32c4             	leas	,u
bbfd : 35c0             	puls	u,pc
                        *                 }
bbff :                  _148
                        *                 tmp1.h = tmp1.l = 0;
bbff :                  _146
bbff : 4f               	clra
bc00 : 5f               	clrb
bc01 : ed5b             	std	-5,u
bc03 : ed59             	std	-7,u
                        *                 if(_u32_equal(&filePtr->cluster, &tm
bc05 : 3059             	leax	-7,u
bc07 : 3410             	pshs	x
bc09 : ec44             	ldd	4,u
bc0b : c30004           	addd	#$4
bc0e : 3406             	pshs	d
bc10 : bda990           	lbsr	_u32_equ
bc13 : 3264             	leas	4,s
AS09 Assembler for M6809 [1.42].                                     Page  190
--------------------------------- merge.a09 ----------------------------------

bc15 : 830000           	subd	#$0
bc18 : 10270007         	lbeq	_149
bc1c : ccffff           	ldd	#$ffff
                        * 
                        *                 filePtr->prevCluster.h = filePtr->cl
bc1f : 32c4             	leas	,u
bc21 : 35c0             	puls	u,pc
bc23 :                  _149
bc23 : ae44             	ldx	4,u
bc25 : ec04             	ldd	4,x
bc27 : ae44             	ldx	4,u
bc29 : ed08             	std	8,x
bc2b : ec44             	ldd	4,u
bc2d : c30004           	addd	#$4
bc30 : 3406             	pshs	d
bc32 : cc0002           	ldd	#$2
bc35 : 3510             	puls	x
bc37 : ec8b             	ldd	d,x
bc39 : 3406             	pshs	d
bc3b : ec44             	ldd	4,u
bc3d : c30008           	addd	#$8
bc40 : c30002           	addd	#$2
bc43 : 1f01             	tfr	d,x
bc45 : 3506             	puls	d
bc47 : ed84             	std	0,x
                        *             }
                        *         }
bc49 : 7eb91c           	lbra	_131
bc4c :                  _130
                        *     }
bc4c :                  _122
bc4c :                  _121
                        *     else
bc4c : 200112           	lbra	_150
bc4f :                  _108
                        *     {
                        *         /* FIle not opened, do not handle the file o
                        *     }
                        * 
                        *     return -1;
bc4f :                  _150
bc4f : ccffff           	ldd	#$ffff
                        * }
bc52 : 32c4             	leas	,u
bc54 : 35c0             	puls	u,pc
                        * 
                        * /***************************************************
                        *                          unsigned char FILE_List (fi
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                   fileInfo *: structure pointer to s
                        * 
                        *  * Return value  :
                        *                   unsigned char : MORE_FILES_To_READ
                        *                             END_OF_FILE_LIST(9)  -->
                        * 
                        * 
                        *  * description :
                        *                  This functions traverses through th
                        *                  It updates the file name and its si
                        *                  It returns MORE_FILES_To_READ(8), i
                        *                  In case there are no files to be li
AS09 Assembler for M6809 [1.42].                                     Page  191
--------------------------------- merge.a09 ----------------------------------

                        *  ***************************************************
                        * //unsigned char FILE_List (fileInfo *fileList)
                        * FILE_List(fileList) fileInfo *fileList;
                        * {
                        *     LE_dir_Structure *dir;
                        *     unsigned char j;
                        *     unsigned char fNameIndex;
                        * 	u32_t tmp;
                        * 
                        * 	_setGVpt(); // call when GV are utilized
bc56 :                  FILE_Lis
bc56 : 3440             	pshs	u
bc58 : 33e4             	leau	,s
bc5a : 3278             	leas	-8,s
bc5c : bdaf77           	lbsr	_setGVpt
                        * 
                        * 	if(FL_initialized == 0)
bc5f : e6a8e7           	ldb	FL_initi+0,y
bc62 : 4f               	clra
bc63 : 830000           	subd	#$0
bc66 : 10260059         	lbne	_151
                        *     {
                        *         clusterNumber.h = rCluster.h; clusterNumber.
bc6a : ec37             	ldd	rCluster+0,y
bc6c : eda9fdaa         	std	clusterN+0,y
bc70 : ec39             	ldd	rCluster+2,y
bc72 : eda9fdac         	std	clusterN+2,y
                        *         sectorNumber.h = 0; sectorNumber.l = 0;
bc76 : 4f               	clra
bc77 : 5f               	clrb
bc78 : eda9fda6         	std	sectorNu+0,y
bc7c : 4f               	clra
bc7d : 5f               	clrb
bc7e : eda9fda8         	std	sectorNu+2,y
                        *         list_i = 0;
bc82 : 4f               	clra
bc83 : 5f               	clrb
bc84 : eda9fda0         	std	list_i+0,y
                        * 		getFirstSector(&clusterNumber, &frstSectorIndex);
bc88 : 30a9fda2         	leax	frstSect+0,y
bc8c : 3410             	pshs	x
bc8e : 30a9fdaa         	leax	clusterN+0,y
bc92 : 3410             	pshs	x
bc94 : bde191           	lbsr	getFirst
bc97 : 3264             	leas	4,s
                        * 		_u32_add(&frstSectorIndex, &sectorNumber, &tmp);
bc99 : 3058             	leax	-8,u
bc9b : 3410             	pshs	x
bc9d : 30a9fda6         	leax	sectorNu+0,y
bca1 : 3410             	pshs	x
bca3 : 30a9fda2         	leax	frstSect+0,y
bca7 : 3410             	pshs	x
bca9 : bda8da           	lbsr	_u32_add
bcac : 3266             	leas	6,s
                        * 		SD_readSingleBlock(fatMapTb.LE_fileBuffer, &tmp); 
bcae : 3058             	leax	-8,u
bcb0 : 3410             	pshs	x
bcb2 : 30a9fdd4         	leax	fatMapTb+38,y
bcb6 : 3410             	pshs	x
bcb8 : bdae0d           	lbsr	SD_readS
bcbb : 3264             	leas	4,s
                        * 		FL_initialized = 1;		
AS09 Assembler for M6809 [1.42].                                     Page  192
--------------------------------- merge.a09 ----------------------------------

bcbd : cc0001           	ldd	#$1
bcc0 : e7a8e7           	stb	FL_initi+0,y
                        *     }
                        * 
                        *     fNameIndex = 0;
bcc3 :                  _151
bcc3 : 4f               	clra
bcc4 : 5f               	clrb
bcc5 : e75c             	stb	-4,u
                        *     do
bcc7 :                  _154
                        *     {
                        *         dir = &fatMapTb.LE_fileBuffer[list_i];  //ca
bcc7 : 30a9fdd4         	leax	fatMapTb+38,y
bccb : 1f10             	tfr	x,d
bccd : e3a9fda0         	addd	list_i+0,y
bcd1 : ed5e             	std	-2,u
                        * 		
                        * 		if(dir->name[0] == EMPTY) //indicates end of the f
bcd3 : ae5e             	ldx	-2,u
bcd5 : e684             	ldb	0,x
bcd7 : 4f               	clra
bcd8 : 830000           	subd	#$0
bcdb : 1026000c         	lbne	_155
                        *         {
                        *             FL_initialized = 0;
bcdf : 4f               	clra
bce0 : 5f               	clrb
bce1 : e7a8e7           	stb	FL_initi+0,y
                        *             return (END_OF_FILE_LIST);
bce4 : cc0009           	ldd	#$9
                        *         }
bce7 : 32c4             	leas	,u
bce9 : 35c0             	puls	u,pc
                        *         if((dir->name[0] != DELETED) && (dir->attrib
bceb :                  _155
bceb : ae5e             	ldx	-2,u
bced : e684             	ldb	0,x
bcef : 4f               	clra
bcf0 : 8300e5           	subd	#$e5
bcf3 : 10270097         	lbeq	_156
bcf7 : ae5e             	ldx	-2,u
bcf9 : e60b             	ldb	11,x
bcfb : 4f               	clra
bcfc : 83000f           	subd	#$f
bcff : 1027008b         	lbeq	_156
                        *         {
                        *             for(j=0; j<11; j++)
bd03 : 4f               	clra
bd04 : 5f               	clrb
bd05 : e75d             	stb	-3,u
bd07 :                  _158
bd07 : e65d             	ldb	-3,u
bd09 : 4f               	clra
bd0a : 83000b           	subd	#$b
bd0d : 10240052         	lbhs	_157
                        *             {
                        *                 if(dir->name[j] == '\n') fileList->F
bd11 : e65d             	ldb	-3,u
bd13 : 4f               	clra
bd14 : ae5e             	ldx	-2,u
bd16 : e68b             	ldb	d,x
AS09 Assembler for M6809 [1.42].                                     Page  193
--------------------------------- merge.a09 ----------------------------------

bd18 : 4f               	clra
bd19 : 83000a           	subd	#$a
bd1c : 1026001a         	lbne	_160
bd20 : 305c             	leax	-4,u
bd22 : e684             	ldb	,x
bd24 : 6c84             	inc	,x
bd26 : 1d               	sex
bd27 : 3406             	pshs	d
bd29 : ec44             	ldd	4,u
bd2b : c30005           	addd	#$5
bd2e : e3e1             	addd	,s++
bd30 : 1f01             	tfr	d,x
bd32 : cc000d           	ldd	#$d
bd35 : e784             	stb	0,x
                        * 				else {
bd37 : 202112           	lbra	_161
bd3a :                  _160
                        * 					fileList->FI_Name[fNameIndex++] = dir->name[j];
bd3a : e65d             	ldb	-3,u
bd3c : 1d               	sex
bd3d : ae5e             	ldx	-2,u
bd3f : e68b             	ldb	d,x
bd41 : 1d               	sex
bd42 : 3406             	pshs	d
bd44 : 305c             	leax	-4,u
bd46 : e684             	ldb	,x
bd48 : 6c84             	inc	,x
bd4a : 1d               	sex
bd4b : 3406             	pshs	d
bd4d : ec44             	ldd	4,u
bd4f : c30005           	addd	#$5
bd52 : e3e1             	addd	,s++
bd54 : 1f01             	tfr	d,x
bd56 : 3506             	puls	d
bd58 : e784             	stb	0,x
                        * 				}
                        *             }		
bd5a :                  _161
                        *             fileList->FI_Name[fNameIndex] = 0;
bd5a :                  _159
bd5a : 305d             	leax	-3,u
bd5c : e684             	ldb	,x
bd5e : 6c84             	inc	,x
bd60 : 1d               	sex
bd61 : 20a4             	lbra	_158
bd63 :                  _157
bd63 : e65c             	ldb	-4,u
bd65 : 1d               	sex
bd66 : 3406             	pshs	d
bd68 : ec44             	ldd	4,u
bd6a : c30005           	addd	#$5
bd6d : e3e1             	addd	,s++
bd6f : 1f01             	tfr	d,x
bd71 : 4f               	clra
bd72 : 5f               	clrb
bd73 : e784             	stb	0,x
                        * 			
                        * 			fileList->FI_Attr = dir->attrib;
bd75 : ae5e             	ldx	-2,u
bd77 : e60b             	ldb	11,x
bd79 : 4f               	clra
bd7a : ae44             	ldx	4,u
AS09 Assembler for M6809 [1.42].                                     Page  194
--------------------------------- merge.a09 ----------------------------------

bd7c : e704             	stb	4,x
                        * 			get_QByte(dir->fSize, &fileList->FI_Size);
bd7e : ec44             	ldd	4,u
bd80 : 3406             	pshs	d
bd82 : ec5e             	ldd	-2,u
bd84 : c3001c           	addd	#$1c
bd87 : 3406             	pshs	d
bd89 : bde17c           	lbsr	get_QByt
bd8c : 3264             	leas	4,s
                        *         }
                        * 
                        *         list_i = list_i+32;
bd8e :                  _156
bd8e : eca9fda0         	ldd	list_i+0,y
bd92 : c30020           	addd	#$20
bd95 : eda9fda0         	std	list_i+0,y
                        * 
                        *         if(list_i >= bPerSector)
bd99 : eca9fda0         	ldd	list_i+0,y
bd9d : a331             	subd	bPerSect+0,y
bd9f : 102500ea         	lblo	_162
                        *         {
                        *             list_i = 0;
bda3 : 4f               	clra
bda4 : 5f               	clrb
bda5 : eda9fda0         	std	list_i+0,y
                        *             _u32_inc(&sectorNumber);
bda9 : 30a9fda6         	leax	sectorNu+0,y
bdad : 3410             	pshs	x
bdaf : bda929           	lbsr	_u32_inc
bdb2 : 3262             	leas	2,s
                        * 
                        *             tmp.h = 0x00; tmp.l = secPerCluster;
bdb4 : 4f               	clra
bdb5 : 5f               	clrb
bdb6 : ed58             	std	-8,u
bdb8 : eca8ef           	ldd	secPerCl+0,y
bdbb : ed5a             	std	-6,u
                        *             if(_u32_equal(&sectorNumber, &tmp) != 0)
bdbd : 3058             	leax	-8,u
bdbf : 3410             	pshs	x
bdc1 : 30a9fda6         	leax	sectorNu+0,y
bdc5 : 3410             	pshs	x
bdc7 : bda990           	lbsr	_u32_equ
bdca : 3264             	leas	4,s
bdcc : 830000           	subd	#$0
bdcf : 10270096         	lbeq	_163
                        *             {
                        *                 sectorNumber.h = sectorNumber.l = 0;
bdd3 : 4f               	clra
bdd4 : 5f               	clrb
bdd5 : eda9fda8         	std	sectorNu+2,y
bdd9 : eda9fda6         	std	sectorNu+0,y
                        *                 tmp.h = tmp.l = 0;
bddd : 4f               	clra
bdde : 5f               	clrb
bddf : ed5a             	std	-6,u
bde1 : ed58             	std	-8,u
                        *                 getSetNC (fatMapTb.LE_fileBuffer, &c
bde3 : 30a9fdaa         	leax	clusterN+0,y
bde7 : 3410             	pshs	x
bde9 : 3058             	leax	-8,u
AS09 Assembler for M6809 [1.42].                                     Page  195
--------------------------------- merge.a09 ----------------------------------

bdeb : 3410             	pshs	x
bded : 4f               	clra
bdee : 5f               	clrb
bdef : 3406             	pshs	d
bdf1 : 30a9fdaa         	leax	clusterN+0,y
bdf5 : 3410             	pshs	x
bdf7 : 30a9fdd4         	leax	fatMapTb+38,y
bdfb : 3410             	pshs	x
bdfd : bde1d8           	lbsr	getSetNC
be00 : 326a             	leas	10,s
                        * 
                        *                 tmp.h = 0x0fff; tmp.l = 0xfff6;     
be02 : cc0fff           	ldd	#$fff
be05 : ed58             	std	-8,u
be07 : ccfff6           	ldd	#$fff6
be0a : ed5a             	std	-6,u
                        * 				if(_u32_higher(&clusterNumber, &tmp) != 0)
be0c : 3058             	leax	-8,u
be0e : 3410             	pshs	x
be10 : 30a9fdaa         	leax	clusterN+0,y
be14 : 3410             	pshs	x
be16 : bda9bb           	lbsr	_u32_hig
be19 : 3264             	leas	4,s
be1b : 830000           	subd	#$0
be1e : 1027000c         	lbeq	_164
                        *                 {
                        *                     FL_initialized = 0;
be22 : 4f               	clra
be23 : 5f               	clrb
be24 : e7a8e7           	stb	FL_initi+0,y
                        *                     return END_OF_FILE_LIST;
be27 : cc0009           	ldd	#$9
                        *                 }
be2a : 32c4             	leas	,u
be2c : 35c0             	puls	u,pc
                        * 
                        *                 tmp.h = 0x00; tmp.l = 0x00;
be2e :                  _164
be2e : 4f               	clra
be2f : 5f               	clrb
be30 : ed58             	std	-8,u
be32 : 4f               	clra
be33 : 5f               	clrb
be34 : ed5a             	std	-6,u
                        *                 if(_u32_equal(&clusterNumber, &tmp) 
be36 : 3058             	leax	-8,u
be38 : 3410             	pshs	x
be3a : 30a9fdaa         	leax	clusterN+0,y
be3e : 3410             	pshs	x
be40 : bda990           	lbsr	_u32_equ
be43 : 3264             	leas	4,s
be45 : 830000           	subd	#$0
be48 : 1027000c         	lbeq	_165
                        *                 {
                        *                     FL_initialized = 0;
be4c : 4f               	clra
be4d : 5f               	clrb
be4e : e7a8e7           	stb	FL_initi+0,y
                        *                     return END_OF_FILE_LIST;
be51 : cc0009           	ldd	#$9
                        *                 }
be54 : 32c4             	leas	,u
AS09 Assembler for M6809 [1.42].                                     Page  196
--------------------------------- merge.a09 ----------------------------------

be56 : 35c0             	puls	u,pc
                        * 
                        *                 getFirstSector(&clusterNumber, &frst
be58 :                  _165
be58 : 30a9fda2         	leax	frstSect+0,y
be5c : 3410             	pshs	x
be5e : 30a9fdaa         	leax	clusterN+0,y
be62 : 3410             	pshs	x
be64 : bde191           	lbsr	getFirst
be67 : 3264             	leas	4,s
                        *             }
                        * 	        _u32_add(&frstSectorIndex, &sectorNumber, &
be69 :                  _163
be69 : 3058             	leax	-8,u
be6b : 3410             	pshs	x
be6d : 30a9fda6         	leax	sectorNu+0,y
be71 : 3410             	pshs	x
be73 : 30a9fda2         	leax	frstSect+0,y
be77 : 3410             	pshs	x
be79 : bda8da           	lbsr	_u32_add
be7c : 3266             	leas	6,s
                        *             SD_readSingleBlock(fatMapTb.LE_fileBuffe
be7e : 3058             	leax	-8,u
be80 : 3410             	pshs	x
be82 : 30a9fdd4         	leax	fatMapTb+38,y
be86 : 3410             	pshs	x
be88 : bdae0d           	lbsr	SD_readS
be8b : 3264             	leas	4,s
                        *         }
                        *     }while(fNameIndex == 0);
be8d :                  _162
be8d :                  _153
be8d : e65c             	ldb	-4,u
be8f : 4f               	clra
be90 : 830000           	subd	#$0
be93 : 1027fe30         	lbeq	_154
                        * 
                        * 
                        *     return MORE_FILES_To_READ;
be97 :                  _152
be97 : cc0008           	ldd	#$8
                        * }
be9a : 32c4             	leas	,u
be9c : 35c0             	puls	u,pc
                        * 
                        * //unsigned char getBootSectorData (void)
                        * getBootSectorData()
                        * {
                        * 	LE_BS_Structure *bpb; //mapping the buffer onto the
                        * 	LE_MBRinfo_Structure *mbr;
                        *     u32_t FATsize_t;
                        * 	u32_t dataSectors;
                        * 	u32_t tmp1, tmp2;
                        * 	unsigned char i, n;
                        * 	unsigned int tmp16;
                        * 
                        * 	FL_initialized = 0;	
be9e :                  getBootS
be9e : 3440             	pshs	u
bea0 : 33e4             	leau	,s
bea2 : 32e8e8           	leas	-24,s
bea5 : 4f               	clra
AS09 Assembler for M6809 [1.42].                                     Page  197
--------------------------------- merge.a09 ----------------------------------

bea6 : 5f               	clrb
bea7 : e7a8e7           	stb	FL_initi+0,y
                        * 	unusedSectors.h = unusedSectors.l = 0;   //init at 
beaa : 4f               	clra
beab : 5f               	clrb
beac : eda8eb           	std	unusedSe+2,y
beaf : eda8e9           	std	unusedSe+0,y
                        *     fatMapTb.fileOpenedFlag = FALSE;
beb2 : 4f               	clra
beb3 : 5f               	clrb
beb4 : e7a8d5           	stb	fatMapTb+551,y
                        * 	
                        *     if(SD_readSingleBlock(fatMapTb.LE_fileBuffer, &u
beb7 : 30a8e9           	leax	unusedSe+0,y
beba : 3410             	pshs	x
bebc : 30a9fdd4         	leax	fatMapTb+38,y
bec0 : 3410             	pshs	x
bec2 : bdae0d           	lbsr	SD_readS
bec5 : 3264             	leas	4,s
bec7 : 830000           	subd	#$0
beca : 10270007         	lbeq	_166
bece : cc0003           	ldd	#$3
                        * 	
                        * 	bpb = fatMapTb.LE_fileBuffer;   //cast removed
bed1 : 32c4             	leas	,u
bed3 : 35c0             	puls	u,pc
bed5 :                  _166
bed5 : 30a9fdd4         	leax	fatMapTb+38,y
bed9 : 1f10             	tfr	x,d
bedb : ed5e             	std	-2,u
                        * 	
                        *     if((bpb->jumpBoot[0]!=0xE9) && (bpb->jumpBoot[0]
bedd : ae5e             	ldx	-2,u
bedf : e684             	ldb	0,x
bee1 : 4f               	clra
bee2 : 8300e9           	subd	#$e9
bee5 : 10270082         	lbeq	_167
bee9 : ae5e             	ldx	-2,u
beeb : e684             	ldb	0,x
beed : 4f               	clra
beee : 8300eb           	subd	#$eb
bef1 : 10270076         	lbeq	_167
                        *     {
                        *         mbr = fatMapTb.LE_fileBuffer;       //if it 
bef5 : 30a9fdd4         	leax	fatMapTb+38,y
bef9 : 1f10             	tfr	x,d
befb : ed5c             	std	-4,u
                        * 		
                        * 		if(get_Word(mbr->signature) != 0xaa55)
befd : ec5c             	ldd	-4,u
beff : c301fe           	addd	#$1fe
bf02 : 3406             	pshs	d
bf04 : bde16e           	lbsr	get_Word
bf07 : 3262             	leas	2,s
bf09 : 83aa55           	subd	#$aa55
bf0c : 10270007         	lbeq	_168
                        *         {
                        *             return FAT_INVALID;       //if it is not
bf10 : cc0003           	ldd	#$3
                        *         }
bf13 : 32c4             	leas	,u
bf15 : 35c0             	puls	u,pc
AS09 Assembler for M6809 [1.42].                                     Page  198
--------------------------------- merge.a09 ----------------------------------

                        *         
                        *         //partition = (struct partitionInfo_Structur
                        *         get_QByte(fatMapTb.LE_fileBuffer+454, &unuse
bf17 :                  _168
bf17 : 30a8e9           	leax	unusedSe+0,y
bf1a : 3410             	pshs	x
bf1c : 30a89a           	leax	fatMapTb+492,y
bf1f : 3410             	pshs	x
bf21 : bde17c           	lbsr	get_QByt
bf24 : 3264             	leas	4,s
                        * 		
                        *         if(SD_readSingleBlock(fatMapTb.LE_fileBuffer
bf26 : 30a8e9           	leax	unusedSe+0,y
bf29 : 3410             	pshs	x
bf2b : 30a9fdd4         	leax	fatMapTb+38,y
bf2f : 3410             	pshs	x
bf31 : bdae0d           	lbsr	SD_readS
bf34 : 3264             	leas	4,s
bf36 : 830000           	subd	#$0
bf39 : 10270007         	lbeq	_169
bf3d : cc0002           	ldd	#$2
                        *         bpb = fatMapTb.LE_fileBuffer;  //cast remove
bf40 : 32c4             	leas	,u
bf42 : 35c0             	puls	u,pc
bf44 :                  _169
bf44 : 30a9fdd4         	leax	fatMapTb+38,y
bf48 : 1f10             	tfr	x,d
bf4a : ed5e             	std	-2,u
                        *         if((bpb->jumpBoot[0]!=0xE9) && (bpb->jumpBoo
bf4c : ae5e             	ldx	-2,u
bf4e : e684             	ldb	0,x
bf50 : 4f               	clra
bf51 : 8300e9           	subd	#$e9
bf54 : 10270013         	lbeq	_170
bf58 : ae5e             	ldx	-2,u
bf5a : e684             	ldb	0,x
bf5c : 4f               	clra
bf5d : 8300eb           	subd	#$eb
bf60 : 10270007         	lbeq	_170
                        *         {
                        *             return FAT_INVALID;
bf64 : cc0003           	ldd	#$3
                        *         }
bf67 : 32c4             	leas	,u
bf69 : 35c0             	puls	u,pc
                        *     }
bf6b :                  _170
                        * 
                        *     bPerSector = get_Word(bpb->bytesPerSector);
bf6b :                  _167
bf6b : ec5e             	ldd	-2,u
bf6d : c3000b           	addd	#$b
bf70 : 3406             	pshs	d
bf72 : bde16e           	lbsr	get_Word
bf75 : 3262             	leas	2,s
bf77 : ed31             	std	bPerSect+0,y
                        * 	i=0;
bf79 : 4f               	clra
bf7a : 5f               	clrb
bf7b : e7c8eb           	stb	-21,u
                        * 	tmp16 = bPerSector;
bf7e : ec31             	ldd	bPerSect+0,y
AS09 Assembler for M6809 [1.42].                                     Page  199
--------------------------------- merge.a09 ----------------------------------

bf80 : edc8e8           	std	-24,u
                        * 	for (n=0; n<16; n++) {
bf83 : 4f               	clra
bf84 : 5f               	clrb
bf85 : e7c8ea           	stb	-22,u
bf88 :                  _172
bf88 : e6c8ea           	ldb	-22,u
bf8b : 4f               	clra
bf8c : 830010           	subd	#$10
bf8f : 10240030         	lbhs	_171
                        * 		if (tmp16 & 1) i++;
bf93 : ecc8e8           	ldd	-24,u
bf96 : 8400             	anda	#$0
bf98 : c401             	andb	#$1
bf9a : 830000           	subd	#$0
bf9d : 10270008         	lbeq	_174
bfa1 : 30c8eb           	leax	-21,u
bfa4 : e684             	ldb	,x
bfa6 : 6c84             	inc	,x
bfa8 : 4f               	clra
                        * 		tmp16 = tmp16 >> 1;
bfa9 :                  _174
bfa9 : cc0001           	ldd	#$1
bfac : 3406             	pshs	d
bfae : ecc8e8           	ldd	-24,u
bfb1 : 3510             	puls	x
bfb3 : bdecc4           	lbsr	_00009
bfb6 : edc8e8           	std	-24,u
                        * 	}
                        * 	if (i != 1) return SIZE_INVALID; //allow just 2^n b
bfb9 :                  _173
bfb9 : 30c8ea           	leax	-22,u
bfbc : e684             	ldb	,x
bfbe : 6c84             	inc	,x
bfc0 : 4f               	clra
bfc1 : 20c5             	lbra	_172
bfc3 :                  _171
bfc3 : e6c8eb           	ldb	-21,u
bfc6 : 4f               	clra
bfc7 : 830001           	subd	#$1
bfca : 10270007         	lbeq	_175
bfce : cc0004           	ldd	#$4
                        * 	
                        *     secPerCluster = bpb->secPrCluster;
bfd1 : 32c4             	leas	,u
bfd3 : 35c0             	puls	u,pc
bfd5 :                  _175
bfd5 : ae5e             	ldx	-2,u
bfd7 : e60d             	ldb	13,x
bfd9 : 4f               	clra
bfda : eda8ef           	std	secPerCl+0,y
                        * 	i=0;
bfdd : 4f               	clra
bfde : 5f               	clrb
bfdf : e7c8eb           	stb	-21,u
                        * 	tmp16 = secPerCluster;
bfe2 : eca8ef           	ldd	secPerCl+0,y
bfe5 : edc8e8           	std	-24,u
                        * 	
                        * // split the ROMs
                        * #asm
bfe8 : 7ee000               jmp $e000
AS09 Assembler for M6809 [1.42].                                     Page  200
--------------------------------- merge.a09 ----------------------------------

e000 =                  	org $e000    
                        * 
                        * 	for (n=0; n<16; n++) {
e000 : 4f               	clra
e001 : 5f               	clrb
e002 : e7c8ea           	stb	-22,u
e005 :                  _177
e005 : e6c8ea           	ldb	-22,u
e008 : 4f               	clra
e009 : 830010           	subd	#$10
e00c : 10240030         	lbhs	_176
                        * 		if (tmp16 & 1) i++;
e010 : ecc8e8           	ldd	-24,u
e013 : 8400             	anda	#$0
e015 : c401             	andb	#$1
e017 : 830000           	subd	#$0
e01a : 10270008         	lbeq	_179
e01e : 30c8eb           	leax	-21,u
e021 : e684             	ldb	,x
e023 : 6c84             	inc	,x
e025 : 4f               	clra
                        * 		tmp16 = tmp16 >> 1;
e026 :                  _179
e026 : cc0001           	ldd	#$1
e029 : 3406             	pshs	d
e02b : ecc8e8           	ldd	-24,u
e02e : 3510             	puls	x
e030 : bdecc4           	lbsr	_00009
e033 : edc8e8           	std	-24,u
                        * 	}
                        * 	if (i != 1) return SIZE_INVALID; //allow just 2^n b
e036 :                  _178
e036 : 30c8ea           	leax	-22,u
e039 : e684             	ldb	,x
e03b : 6c84             	inc	,x
e03d : 4f               	clra
e03e : 20c5             	lbra	_177
e040 :                  _176
e040 : e6c8eb           	ldb	-21,u
e043 : 4f               	clra
e044 : 830001           	subd	#$1
e047 : 10270007         	lbeq	_180
e04b : cc0004           	ldd	#$4
                        * 
                        *     rsvSecCnt = get_Word(bpb->rsvSectorCount);
e04e : 32c4             	leas	,u
e050 : 35c0             	puls	u,pc
e052 :                  _180
e052 : ec5e             	ldd	-2,u
e054 : c3000e           	addd	#$e
e057 : 3406             	pshs	d
e059 : bde16e           	lbsr	get_Word
e05c : 3262             	leas	2,s
e05e : eda8ed           	std	rsvSecCn+0,y
                        *     get_QByte(bpb->rootCluster, &rCluster);
e061 : 3037             	leax	rCluster+0,y
e063 : 3410             	pshs	x
e065 : ec5e             	ldd	-2,u
e067 : c3002c           	addd	#$2c
e06a : 3406             	pshs	d
e06c : bde17c           	lbsr	get_QByt
e06f : 3264             	leas	4,s
AS09 Assembler for M6809 [1.42].                                     Page  201
--------------------------------- merge.a09 ----------------------------------

                        *     
                        * 	//firstDataSector = bpb->hiddenSectors + reservedSe
                        * 	get_QByte(bpb->FATsz_F32, &tmp1);
e071 : 3050             	leax	-16,u
e073 : 3410             	pshs	x
e075 : ec5e             	ldd	-2,u
e077 : c30024           	addd	#$24
e07a : 3406             	pshs	d
e07c : bde17c           	lbsr	get_QByt
e07f : 3264             	leas	4,s
                        * 	_u32_mul(bpb->nbofFATs, &tmp1, &FATsize_t);
e081 : 3058             	leax	-8,u
e083 : 3410             	pshs	x
e085 : 3050             	leax	-16,u
e087 : 3410             	pshs	x
e089 : ae5e             	ldx	-2,u
e08b : e68810           	ldb	16,x
e08e : 1d               	sex
e08f : 3406             	pshs	d
e091 : bda78c           	lbsr	_u32_mul
e094 : 3266             	leas	6,s
                        * 	get_QByte(bpb->hiddenSectors, &fDataSector);    
e096 : 303b             	leax	fDataSec+0,y
e098 : 3410             	pshs	x
e09a : ec5e             	ldd	-2,u
e09c : c3001c           	addd	#$1c
e09f : 3406             	pshs	d
e0a1 : bde17c           	lbsr	get_QByt
e0a4 : 3264             	leas	4,s
                        * 	tmp1.h = 0; tmp1.l = rsvSecCnt; 
e0a6 : 4f               	clra
e0a7 : 5f               	clrb
e0a8 : ed50             	std	-16,u
e0aa : eca8ed           	ldd	rsvSecCn+0,y
e0ad : ed52             	std	-14,u
                        * 	_u32_add(&fDataSector, &tmp1, &tmp2);
e0af : 30c8ec           	leax	-20,u
e0b2 : 3410             	pshs	x
e0b4 : 3050             	leax	-16,u
e0b6 : 3410             	pshs	x
e0b8 : 303b             	leax	fDataSec+0,y
e0ba : 3410             	pshs	x
e0bc : bda8da           	lbsr	_u32_add
e0bf : 3266             	leas	6,s
                        * 	_u32_add(&tmp2, &FATsize_t, &fDataSector);
e0c1 : 303b             	leax	fDataSec+0,y
e0c3 : 3410             	pshs	x
e0c5 : 3058             	leax	-8,u
e0c7 : 3410             	pshs	x
e0c9 : 30c8ec           	leax	-20,u
e0cc : 3410             	pshs	x
e0ce : bda8da           	lbsr	_u32_add
e0d1 : 3266             	leas	6,s
                        *     	
                        *     //dataSectors = bpb->totalSectors_F32 - reserved
                        *     get_QByte(bpb->tSec_F32, &dataSectors);
e0d3 : 3054             	leax	-12,u
e0d5 : 3410             	pshs	x
e0d7 : ec5e             	ldd	-2,u
e0d9 : c30020           	addd	#$20
e0dc : 3406             	pshs	d
e0de : bde17c           	lbsr	get_QByt
AS09 Assembler for M6809 [1.42].                                     Page  202
--------------------------------- merge.a09 ----------------------------------

e0e1 : 3264             	leas	4,s
                        * 	tmp1.h = 0; tmp1.l = rsvSecCnt;
e0e3 : 4f               	clra
e0e4 : 5f               	clrb
e0e5 : ed50             	std	-16,u
e0e7 : eca8ed           	ldd	rsvSecCn+0,y
e0ea : ed52             	std	-14,u
                        * 	_u32_sub(&dataSectors, &tmp1, &tmp2);
e0ec : 30c8ec           	leax	-20,u
e0ef : 3410             	pshs	x
e0f1 : 3050             	leax	-16,u
e0f3 : 3410             	pshs	x
e0f5 : 3054             	leax	-12,u
e0f7 : 3410             	pshs	x
e0f9 : bda870           	lbsr	_u32_sub
e0fc : 3266             	leas	6,s
                        * 	_u32_sub(&tmp2, &FATsize_t, &dataSectors);
e0fe : 3054             	leax	-12,u
e100 : 3410             	pshs	x
e102 : 3058             	leax	-8,u
e104 : 3410             	pshs	x
e106 : 30c8ec           	leax	-20,u
e109 : 3410             	pshs	x
e10b : bda870           	lbsr	_u32_sub
e10e : 3266             	leas	6,s
                        *    
                        * 	//totalClusters = dataSectors / sectorPerCluster;
                        * 	_u32_div2(&dataSectors, secPerCluster, &totalCluste
e110 : 3033             	leax	totalClu+0,y
e112 : 3410             	pshs	x
e114 : eca8ef           	ldd	secPerCl+0,y
e117 : 3406             	pshs	d
e119 : 3054             	leax	-12,u
e11b : 3410             	pshs	x
e11d : bda720           	lbsr	_u32_div
e120 : 3266             	leas	6,s
                        *    	
                        * 	//if((getSetFreeCluster (GlobalBuffer,TOTAL_FREE, G
                        * 	tmp1.h = tmp1.l = 0;
e122 : 4f               	clra
e123 : 5f               	clrb
e124 : ed52             	std	-14,u
e126 : ed50             	std	-16,u
                        * 	getSetFreeCluster(fatMapTb.LE_fileBuffer,TOTAL_FREE
e128 : 30c8ec           	leax	-20,u
e12b : 3410             	pshs	x
e12d : 3050             	leax	-16,u
e12f : 3410             	pshs	x
e131 : 4f               	clra
e132 : 5f               	clrb
e133 : 3406             	pshs	d
e135 : cc0001           	ldd	#$1
e138 : 3406             	pshs	d
e13a : 30a9fdd4         	leax	fatMapTb+38,y
e13e : 3410             	pshs	x
e140 : bde2df           	lbsr	getSetFr
e143 : 326a             	leas	10,s
                        * 	if(_u32_higher(&tmp2, &totalClusters) != 0)
e145 : 3033             	leax	totalClu+0,y
e147 : 3410             	pshs	x
e149 : 30c8ec           	leax	-20,u
e14c : 3410             	pshs	x
AS09 Assembler for M6809 [1.42].                                     Page  203
--------------------------------- merge.a09 ----------------------------------

e14e : bda9bb           	lbsr	_u32_hig
e151 : 3264             	leas	4,s
e153 : 830000           	subd	#$0
e156 : 10270008         	lbeq	_181
                        *         fClstCnU = 0;
e15a : 4f               	clra
e15b : 5f               	clrb
e15c : e7a8e8           	stb	fClstCnU+0,y
                        *     else
e15f : 200712           	lbra	_182
e162 :                  _181
                        *         fClstCnU = 1;
e162 : cc0001           	ldd	#$1
e165 : e7a8e8           	stb	fClstCnU+0,y
                        * 
                        *     return INIT_SUCCESSFUL;
e168 :                  _182
e168 : 4f               	clra
e169 : 5f               	clrb
                        * }
e16a : 32c4             	leas	,u
e16c : 35c0             	puls	u,pc
                        * 
                        * /***************************************************
                        *                                      Local Functions
                        * ****************************************************
                        * //unsigned int get_Word(unsigned char *ptr)
                        * //get_Word(ptr) unsigned char *ptr;
                        * //{
                        * 	// Conversion from the FAT allocated in Little-endi
                        * #asm
e16e :                  get_Word
                        *	unsigned int retval;
                        *	retval = *ptr++; //cast removed
                        * 	retval += (*ptr) << 8; //cast removed
                        *	return retval;
e16e : ecf802           	ldd	[2,s]
e171 : 1e89             	exg	a,b
e173 : 39               	rts
                        * //}
                        * 
                        * //void set_Word(unsigned int data, unsigned char *pt
                        * //set_Word(data, ptr) unsigned int data; unsigned ch
                        * //{
                        * 	// Conversion to the FAT allocated in Little-endian
                        * #asm
e174 :                  set_Word
                        * 	*ptr++ = data & 0xff;
                        * 	*ptr = data >> 8;
e174 : ec62             	ldd	2,s	
e176 : 1e89             	exg	a,b
e178 : edf804           	std	[4,s]
e17b : 39               	rts
                        * //}
                        * 
                        * //void get_QByte(unsigned char *ptr, u32_t *sData)
                        * //get_QByte(ptr, sData) unsigned char *ptr; u32_t *s
                        * //{
                        * 	// Conversion from the FAT allocated in Little-endi
                        * //	sData->l = get_Word(ptr);
                        * //	ptr += 2; 
                        * //	sData->h = get_Word(ptr);
AS09 Assembler for M6809 [1.42].                                     Page  204
--------------------------------- merge.a09 ----------------------------------

                        * #asm
e17c :                  get_QByt	
e17c : 3420             	pshs y
e17e : 10ae64           	ldy	4,s	;src
e181 : ae66             	ldx	6,s ;dst
e183 : eca4             	ldd 0,y
e185 : a703             	sta	3,x
e187 : e702             	stb	2,x
e189 : ec22             	ldd 2,y
e18b : a701             	sta	1,x
e18d : e784             	stb	0,x
e18f : 35a0             	puls y,pc
                        * //}
                        * 
                        * //void set_QByte(u32_t *sData, unsigned char *ptr)
                        * /*set_QByte(sData, ptr) u32_t *sData; unsigned char 
                        * {
                        * 	// Conversion to the FAT allocated in Little-endian
                        * 	set_Word(sData->l, ptr);
                        * 	ptr += 2;
                        * 	set_Word(sData->h, ptr);
                        * }*/
                        * #asm
e17c =                  set_QByt 	equ 	get_QByt	; same bytes swapping
                        * 
                        * //**************************************************
                        * //Function: to calculate first sector address of any
                        * //Arguments: cluster number for which first sector i
                        * //return: first sector address
                        * //**************************************************
                        * //void getFirstSector(u32_t *clusterNumber, u32_t *r
                        * getFirstSector(clusterNumber, rValue) u32_t *cluster
                        * {
                        *     u32_t tmp1, tmp2;
                        * 		
                        * 	//*rValue = ((clusterNumber - 2) * secPerCluster) +
                        * 	tmp1.h = 0; tmp1.l = 2;
e191 :                  getFirst
e191 : 3440             	pshs	u
e193 : 33e4             	leau	,s
e195 : 3278             	leas	-8,s
e197 : 4f               	clra
e198 : 5f               	clrb
e199 : ed5c             	std	-4,u
e19b : cc0002           	ldd	#$2
e19e : ed5e             	std	-2,u
                        * 	_u32_sub(clusterNumber, &tmp1, &tmp2);
e1a0 : 3058             	leax	-8,u
e1a2 : 3410             	pshs	x
e1a4 : 305c             	leax	-4,u
e1a6 : 3410             	pshs	x
e1a8 : ec44             	ldd	4,u
e1aa : 3406             	pshs	d
e1ac : bda870           	lbsr	_u32_sub
e1af : 3266             	leas	6,s
                        * 	_u32_mul(secPerCluster, &tmp2, &tmp1);
e1b1 : 305c             	leax	-4,u
e1b3 : 3410             	pshs	x
e1b5 : 3058             	leax	-8,u
e1b7 : 3410             	pshs	x
e1b9 : eca8ef           	ldd	secPerCl+0,y
e1bc : 3406             	pshs	d
AS09 Assembler for M6809 [1.42].                                     Page  205
--------------------------------- merge.a09 ----------------------------------

e1be : bda78c           	lbsr	_u32_mul
e1c1 : 3266             	leas	6,s
                        * 	_u32_add(&tmp1, &fDataSector, rValue);	
e1c3 : ec46             	ldd	6,u
e1c5 : 3406             	pshs	d
e1c7 : 303b             	leax	fDataSec+0,y
e1c9 : 3410             	pshs	x
e1cb : 305c             	leax	-4,u
e1cd : 3410             	pshs	x
e1cf : bda8da           	lbsr	_u32_add
e1d2 : 3266             	leas	6,s
                        * }
e1d4 : 32c4             	leas	,u
e1d6 : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function: get cluster entry value from FAT to find
                        * //or set new cluster entry in FAT
                        * //Arguments: 1. current cluster number, 2. get_set (
                        * //if next cluster is to be set 3. next cluster numbe
                        * //return: next cluster number, if if argument#2 = GE
                        * //**************************************************
                        * //uint32_t getSetNextCluster(char *inputBuffer,uint3
                        * getSetNC(inputBuffer, clusterNumber, get_set, cluste
                        * {
                        *     unsigned int EntryOffset; // "FATEntryOffset"
                        *     //uint32_t *FATEntryValue;
                        *     u32_t EntrySector; // "FATEntrySector"
                        *     unsigned char retry;
                        * 	u32_t tmp1, tmp2;
                        * 	
                        *     //get sector number of the cluster entry in the 
                        *     //FATEntrySector = unusedSectors + reservedSecto
                        * 	_u32_mul(4, clusterNumber, &tmp1);	
e1d8 :                  getSetNC
e1d8 : 3440             	pshs	u
e1da : 33e4             	leau	,s
e1dc : 3271             	leas	-15,s
e1de : 3055             	leax	-11,u
e1e0 : 3410             	pshs	x
e1e2 : ec46             	ldd	6,u
e1e4 : 3406             	pshs	d
e1e6 : cc0004           	ldd	#$4
e1e9 : 3406             	pshs	d
e1eb : bda78c           	lbsr	_u32_mul
e1ee : 3266             	leas	6,s
                        * 	_u32_div2(&tmp1, bPerSector, &tmp2);
e1f0 : 3051             	leax	-15,u
e1f2 : 3410             	pshs	x
e1f4 : ec31             	ldd	bPerSect+0,y
e1f6 : 3406             	pshs	d
e1f8 : 3055             	leax	-11,u
e1fa : 3410             	pshs	x
e1fc : bda720           	lbsr	_u32_div
e1ff : 3266             	leas	6,s
                        * 	EntrySector.h = 0; EntrySector.l = rsvSecCnt;
e201 : 4f               	clra
e202 : 5f               	clrb
e203 : ed5a             	std	-6,u
e205 : eca8ed           	ldd	rsvSecCn+0,y
e208 : ed5c             	std	-4,u
                        * 	_u32_add(&tmp2, &EntrySector, &tmp1);
AS09 Assembler for M6809 [1.42].                                     Page  206
--------------------------------- merge.a09 ----------------------------------

e20a : 3055             	leax	-11,u
e20c : 3410             	pshs	x
e20e : 305a             	leax	-6,u
e210 : 3410             	pshs	x
e212 : 3051             	leax	-15,u
e214 : 3410             	pshs	x
e216 : bda8da           	lbsr	_u32_add
e219 : 3266             	leas	6,s
                        * 	_u32_add(&tmp1, &unusedSectors, &EntrySector);
e21b : 305a             	leax	-6,u
e21d : 3410             	pshs	x
e21f : 30a8e9           	leax	unusedSe+0,y
e222 : 3410             	pshs	x
e224 : 3055             	leax	-11,u
e226 : 3410             	pshs	x
e228 : bda8da           	lbsr	_u32_add
e22b : 3266             	leas	6,s
                        * 	
                        *     //get the offset address in that sector number
                        * 	//FATEntryOffset = (uint16_t) ((clusterNumber * 4) 
                        *     EntryOffset = (clusterNumber->l * 4) & (bPerSect
e22d : ec31             	ldd	bPerSect+0,y
e22f : 830001           	subd	#$1
e232 : 3406             	pshs	d
e234 : ae46             	ldx	6,u
e236 : ec02             	ldd	2,x
e238 : 58               	aslb
e239 : 49               	rola
e23a : 58               	aslb
e23b : 49               	rola
e23c : a4e0             	anda	,s+
e23e : e4e0             	andb	,s+
e240 : ed5e             	std	-2,u
                        * 
                        *     //read the sector into a buffer
                        *     retry = 0;
e242 : 4f               	clra
e243 : 5f               	clrb
e244 : e759             	stb	-7,u
                        *     while(retry <10)
e246 :                  _184
                        *     {
e246 : e659             	ldb	-7,u
e248 : 4f               	clra
e249 : 83000a           	subd	#$a
e24c : 1024002e         	lbhs	_183
                        *         if(!SD_readSingleBlock(inputBuffer, &EntrySe
e250 : 305a             	leax	-6,u
e252 : 3410             	pshs	x
e254 : ec44             	ldd	4,u
e256 : 3406             	pshs	d
e258 : bdae0d           	lbsr	SD_readS
e25b : 3264             	leas	4,s
e25d : 830000           	subd	#$0
e260 : 10270004         	lbeq	_186
e264 : 4f               	clra
e265 : 5f               	clrb
e266 : 2003             	bra	*+5
e268 :                  _186
e268 : cc0001           	ldd	#$1
e26b : 830000           	subd	#$0
e26e : 10270003         	lbeq	_185
AS09 Assembler for M6809 [1.42].                                     Page  207
--------------------------------- merge.a09 ----------------------------------

                        *             break;
e272 : 200a12           	lbra	_183
                        *         retry++;
e275 :                  _185
e275 : 3059             	leax	-7,u
e277 : e684             	ldb	,x
e279 : 6c84             	inc	,x
e27b : 4f               	clra
                        *     }
                        * 
                        *     //get the cluster address from the buffer
                        *     //FATEntryValue = (uint32_t *) &inputBuffer[FATE
                        *     
                        * 	if(get_set == GET) {		
e27c : 20c8             	lbra	_184
e27e :                  _183
e27e : e649             	ldb	9,u
e280 : 4f               	clra
e281 : 830000           	subd	#$0
e284 : 1026002e         	lbne	_187
                        * 		//return ((*FATEntryValue) & 0x0fffffff);
                        * 		get_QByte(&inputBuffer[EntryOffset], &tmp1);
e288 : 3055             	leax	-11,u
e28a : 3410             	pshs	x
e28c : ec5e             	ldd	-2,u
e28e : e344             	addd	4,u
e290 : 3406             	pshs	d
e292 : bde17c           	lbsr	get_QByt
e295 : 3264             	leas	4,s
                        * 		tmp2.h = 0x0fff; tmp2.l = 0xffff;
e297 : cc0fff           	ldd	#$fff
e29a : ed51             	std	-15,u
e29c : ccffff           	ldd	#$ffff
e29f : ed53             	std	-13,u
                        * 		_u32_and(&tmp1, &tmp2, rValue);
e2a1 : ec4c             	ldd	12,u
e2a3 : 3406             	pshs	d
e2a5 : 3051             	leax	-15,u
e2a7 : 3410             	pshs	x
e2a9 : 3055             	leax	-11,u
e2ab : 3410             	pshs	x
e2ad : bda6f9           	lbsr	_u32_and
e2b0 : 3266             	leas	6,s
                        * 		return;
                        * 	}
e2b2 : 32c4             	leas	,u
e2b4 : 35c0             	puls	u,pc
                        * 
                        *     //*FATEntryValue = clusterEntry;   //for setting
                        * 	set_QByte(clusterEntry, &inputBuffer[EntryOffset]);
e2b6 :                  _187
e2b6 : ec5e             	ldd	-2,u
e2b8 : e344             	addd	4,u
e2ba : 3406             	pshs	d
e2bc : ec4a             	ldd	10,u
e2be : 3406             	pshs	d
e2c0 : bde17c           	lbsr	set_QByt
e2c3 : 3264             	leas	4,s
                        *     SD_writeSingleBlock(inputBuffer, &EntrySector); 
e2c5 : 305a             	leax	-6,u
e2c7 : 3410             	pshs	x
e2c9 : ec44             	ldd	4,u
AS09 Assembler for M6809 [1.42].                                     Page  208
--------------------------------- merge.a09 ----------------------------------

e2cb : 3406             	pshs	d
e2cd : bdae9b           	lbsr	SD_write
e2d0 : 3264             	leas	4,s
                        * 
                        *     rValue->h = rValue->l = 0;	
e2d2 : 4f               	clra
e2d3 : 5f               	clrb
e2d4 : ae4c             	ldx	12,u
e2d6 : ed02             	std	2,x
e2d8 : edd80c           	std	[12,u]
                        * }
e2db : 32c4             	leas	,u
e2dd : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function: to get or set next free cluster or total
                        * //Arguments: 1.flag:TOTAL_FREE or NEXT_FREE, 
                        * //			 2.flag: GET or SET 
                        * //			 3.new FS entry, when argument2 is SET; or 0, w
                        * //return: next free cluster, if arg1 is NEXT_FREE & 
                        * //        total number of free clusters, if arg1 is 
                        * //		  0xffffffff, if any error or if arg2 is SET
                        * //**************************************************
                        * //uint32_t getSetFreeCluster(char *inputBuffer, uint
                        * getSetFreeCluster(inputBuffer, totOrNext, get_set, F
                        * {
                        * 	LE_FSinfo_Structure *FS;
                        * 	u32_t _unusedSectors, tmp;
                        * 	
                        * 	FS = inputBuffer; //cast ok, but removed
e2df :                  getSetFr
e2df : 3440             	pshs	u
e2e1 : 33e4             	leau	,s
e2e3 : 3276             	leas	-10,s
e2e5 : ec44             	ldd	4,u
e2e7 : ed5e             	std	-2,u
                        *     
                        * 	//SD_readSingleBlock(inputBuffer,unusedSectors + 1)
                        * 	_unusedSectors.h = unusedSectors.h; _unusedSectors.
e2e9 : eca8e9           	ldd	unusedSe+0,y
e2ec : ed5a             	std	-6,u
e2ee : eca8eb           	ldd	unusedSe+2,y
e2f1 : ed5c             	std	-4,u
                        * 	_u32_inc(&_unusedSectors);
e2f3 : 305a             	leax	-6,u
e2f5 : 3410             	pshs	x
e2f7 : bda929           	lbsr	_u32_inc
e2fa : 3262             	leas	2,s
                        * 	SD_readSingleBlock(inputBuffer, &_unusedSectors);  
e2fc : 305a             	leax	-6,u
e2fe : 3410             	pshs	x
e300 : ec44             	ldd	4,u
e302 : 3406             	pshs	d
e304 : bdae0d           	lbsr	SD_readS
e307 : 3264             	leas	4,s
                        * 
                        * 	//if((FS->leadSignature != 0x41615252) || (FS->stru
                        *     rValue->h = rValue->l = 0xffff; //return default
e309 : ccffff           	ldd	#$ffff
e30c : ae4c             	ldx	12,u
e30e : ed02             	std	2,x
e310 : edd80c           	std	[12,u]
AS09 Assembler for M6809 [1.42].                                     Page  209
--------------------------------- merge.a09 ----------------------------------

                        * 	get_QByte(FS->leadSignature, &tmp);	//print_DebugMs
e313 : 3056             	leax	-10,u
e315 : 3410             	pshs	x
e317 : ec5e             	ldd	-2,u
e319 : 3406             	pshs	d
e31b : bde17c           	lbsr	get_QByt
e31e : 3264             	leas	4,s
                        * 	if((tmp.h != 0x4161) || (tmp.l != 0x5252)) return;
e320 : ec56             	ldd	-10,u
e322 : 834161           	subd	#$4161
e325 : 10260009         	lbne	_189
e329 : ec58             	ldd	-8,u
e32b : 835252           	subd	#$5252
e32e : 10270004         	lbeq	_188
e332 :                  _189
                        * 	get_QByte(FS->structureSignature, &tmp); //print_De
e332 : 32c4             	leas	,u
e334 : 35c0             	puls	u,pc
e336 :                  _188
e336 : 3056             	leax	-10,u
e338 : 3410             	pshs	x
e33a : ec5e             	ldd	-2,u
e33c : c301e4           	addd	#$1e4
e33f : 3406             	pshs	d
e341 : bde17c           	lbsr	get_QByt
e344 : 3264             	leas	4,s
                        * 	if((tmp.h != 0x6141) || (tmp.l != 0x7272)) return;
e346 : ec56             	ldd	-10,u
e348 : 836141           	subd	#$6141
e34b : 10260009         	lbne	_191
e34f : ec58             	ldd	-8,u
e351 : 837272           	subd	#$7272
e354 : 10270004         	lbeq	_190
e358 :                  _191
                        * 	get_QByte(FS->trailSignature, &tmp); //print_DebugM
e358 : 32c4             	leas	,u
e35a : 35c0             	puls	u,pc
e35c :                  _190
e35c : 3056             	leax	-10,u
e35e : 3410             	pshs	x
e360 : ec5e             	ldd	-2,u
e362 : c301fc           	addd	#$1fc
e365 : 3406             	pshs	d
e367 : bde17c           	lbsr	get_QByt
e36a : 3264             	leas	4,s
                        * 	if((tmp.h != 0xaa55) || (tmp.l != 0x0000)) return;
e36c : ec56             	ldd	-10,u
e36e : 83aa55           	subd	#$aa55
e371 : 10260009         	lbne	_193
e375 : ec58             	ldd	-8,u
e377 : 830000           	subd	#$0
e37a : 10270004         	lbeq	_192
e37e :                  _193
                        * 	
                        *     if(get_set == GET)
e37e : 32c4             	leas	,u
e380 : 35c0             	puls	u,pc
e382 :                  _192
e382 : e649             	ldb	9,u
e384 : 4f               	clra
e385 : 830000           	subd	#$0
e388 : 10260032         	lbne	_194
AS09 Assembler for M6809 [1.42].                                     Page  210
--------------------------------- merge.a09 ----------------------------------

                        *     {
                        *         if(totOrNext == TOTAL_FREE) {			
e38c : e647             	ldb	7,u
e38e : 4f               	clra
e38f : 830001           	subd	#$1
e392 : 10260014         	lbne	_195
                        * 			//return(FS->freeClusterCount);
                        * 			get_QByte(FS->freeClusterCount, rValue);
e396 : ec4c             	ldd	12,u
e398 : 3406             	pshs	d
e39a : ec5e             	ldd	-2,u
e39c : c301e8           	addd	#$1e8
e39f : 3406             	pshs	d
e3a1 : bde17c           	lbsr	get_QByt
e3a4 : 3264             	leas	4,s
                        * 			return;
                        * 		}
e3a6 : 32c4             	leas	,u
e3a8 : 35c0             	puls	u,pc
                        *         else { // when totOrNext = NEXT_FREE		
e3aa :                  _195
                        * 			//return(FS->nextFreeCluster);
                        * 			get_QByte(FS->nextFreeCluster, rValue);
e3aa : ec4c             	ldd	12,u
e3ac : 3406             	pshs	d
e3ae : ec5e             	ldd	-2,u
e3b0 : c301ec           	addd	#$1ec
e3b3 : 3406             	pshs	d
e3b5 : bde17c           	lbsr	get_QByt
e3b8 : 3264             	leas	4,s
                        * 			return;
                        * 		}
e3ba : 32c4             	leas	,u
e3bc : 35c0             	puls	u,pc
                        *     }
                        *     else
e3be :                  _194
                        *     {
                        *         if(totOrNext == TOTAL_FREE) {            
e3be : e647             	ldb	7,u
e3c0 : 4f               	clra
e3c1 : 830001           	subd	#$1
e3c4 : 10260013         	lbne	_196
                        * 			//FS->freeClusterCount = FSEntry;			
                        * 			set_QByte(FSEntry, FS->freeClusterCount);
e3c8 : ec5e             	ldd	-2,u
e3ca : c301e8           	addd	#$1e8
e3cd : 3406             	pshs	d
e3cf : ec4a             	ldd	10,u
e3d1 : 3406             	pshs	d
e3d3 : bde17c           	lbsr	set_QByt
e3d6 : 3264             	leas	4,s
                        * 		}
                        *         else { // when totOrNext = NEXT_FREE
e3d8 : 201112           	lbra	_197
e3db :                  _196
                        *             //FS->nextFreeCluster = FSEntry;
                        * 			set_QByte(FSEntry, FS->nextFreeCluster);
e3db : ec5e             	ldd	-2,u
e3dd : c301ec           	addd	#$1ec
e3e0 : 3406             	pshs	d
e3e2 : ec4a             	ldd	10,u
AS09 Assembler for M6809 [1.42].                                     Page  211
--------------------------------- merge.a09 ----------------------------------

e3e4 : 3406             	pshs	d
e3e6 : bde17c           	lbsr	set_QByt
e3e9 : 3264             	leas	4,s
                        * 		}
                        *         //SD_writeSingleBlock(inputBuffer,unusedSect
                        * 		SD_writeSingleBlock(inputBuffer, &_unusedSectors);
e3eb :                  _197
e3eb : 305a             	leax	-6,u
e3ed : 3410             	pshs	x
e3ef : ec44             	ldd	4,u
e3f1 : 3406             	pshs	d
e3f3 : bdae9b           	lbsr	SD_write
e3f6 : 3264             	leas	4,s
                        *     }
                        * }
e3f8 : 32c4             	leas	,u
e3fa : 35c0             	puls	u,pc
                        * 
                        * 
                        * 
                        * 
                        * //**************************************************
                        * //Function: to search for the next free cluster in t
                        * //          starting from a specified cluster
                        * //Arguments: Starting cluster
                        * //return: the next free cluster
                        * //**************************************************
                        * //uint32_t searchNextFreeCluster (char *inputBuffer,
                        * searchNextFreeCluster(inputBuffer, startCluster, rVa
                        * {
                        *     u32_t cluster, sector;
                        *     unsigned char i;
                        * 	u32_t tmp1, tmp2;
                        * 
                        *     //startCluster -=  (startCluster & 127);   //to 
                        * 	//for(cluster =startCluster; cluster < totalCluster
                        * 	cluster.h = startCluster->h; cluster.l = startClust
e3fc :                  searchNe
e3fc : 3440             	pshs	u
e3fe : 33e4             	leau	,s
e400 : 32e8ef           	leas	-17,s
e403 : ecd806           	ldd	[6,u]
e406 : ed5c             	std	-4,u
e408 : ae46             	ldx	6,u
e40a : ec02             	ldd	2,x
e40c : 84ff             	anda	#$ff
e40e : c480             	andb	#$80
e410 : ed5e             	std	-2,u
                        * 	while(_u32_higher(&totalClusters, &cluster)) {
e412 :                  _199
e412 : 305c             	leax	-4,u
e414 : 3410             	pshs	x
e416 : 3033             	leax	totalClu+0,y
e418 : 3410             	pshs	x
e41a : bda9bb           	lbsr	_u32_hig
e41d : 3264             	leas	4,s
e41f : 830000           	subd	#$0
e422 : 10270109         	lbeq	_198
                        *         //sector = unusedSectors + reservedSectorCou
                        * 		_u32_mul(4, &cluster, &tmp2);		
e426 : 30c8ef           	leax	-17,u
e429 : 3410             	pshs	x
AS09 Assembler for M6809 [1.42].                                     Page  212
--------------------------------- merge.a09 ----------------------------------

e42b : 305c             	leax	-4,u
e42d : 3410             	pshs	x
e42f : cc0004           	ldd	#$4
e432 : 3406             	pshs	d
e434 : bda78c           	lbsr	_u32_mul
e437 : 3266             	leas	6,s
                        * 		_u32_div2(&tmp2, bPerSector, &tmp1);
e439 : 3053             	leax	-13,u
e43b : 3410             	pshs	x
e43d : ec31             	ldd	bPerSect+0,y
e43f : 3406             	pshs	d
e441 : 30c8ef           	leax	-17,u
e444 : 3410             	pshs	x
e446 : bda720           	lbsr	_u32_div
e449 : 3266             	leas	6,s
                        * 		sector.h = 0; sector.l = rsvSecCnt;
e44b : 4f               	clra
e44c : 5f               	clrb
e44d : ed58             	std	-8,u
e44f : eca8ed           	ldd	rsvSecCn+0,y
e452 : ed5a             	std	-6,u
                        * 		_u32_add(&tmp1, &sector, &tmp2);
e454 : 30c8ef           	leax	-17,u
e457 : 3410             	pshs	x
e459 : 3058             	leax	-8,u
e45b : 3410             	pshs	x
e45d : 3053             	leax	-13,u
e45f : 3410             	pshs	x
e461 : bda8da           	lbsr	_u32_add
e464 : 3266             	leas	6,s
                        * 		_u32_add(&tmp2, &unusedSectors, &sector);
e466 : 3058             	leax	-8,u
e468 : 3410             	pshs	x
e46a : 30a8e9           	leax	unusedSe+0,y
e46d : 3410             	pshs	x
e46f : 30c8ef           	leax	-17,u
e472 : 3410             	pshs	x
e474 : bda8da           	lbsr	_u32_add
e477 : 3266             	leas	6,s
                        * 		
                        *         SD_readSingleBlock(inputBuffer, &sector);  /
e479 : 3058             	leax	-8,u
e47b : 3410             	pshs	x
e47d : ec44             	ldd	4,u
e47f : 3406             	pshs	d
e481 : bdae0d           	lbsr	SD_readS
e484 : 3264             	leas	4,s
                        *         for(i=0; i<128; i++)
e486 : 4f               	clra
e487 : 5f               	clrb
e488 : e757             	stb	-9,u
e48a :                  _201
e48a : e657             	ldb	-9,u
e48c : 4f               	clra
e48d : 830080           	subd	#$80
e490 : 10240074         	lbhs	_200
                        *         {
                        *             // if(((uint32_t *) &inputBuffer[i*4]) &
                        * 			get_QByte((unsigned char*)&inputBuffer[i*4], &tmp
e494 : 3053             	leax	-13,u
e496 : 3410             	pshs	x
e498 : e657             	ldb	-9,u
AS09 Assembler for M6809 [1.42].                                     Page  213
--------------------------------- merge.a09 ----------------------------------

e49a : 1d               	sex
e49b : 58               	aslb
e49c : 49               	rola
e49d : 58               	aslb
e49e : 49               	rola
e49f : e344             	addd	4,u
e4a1 : 3406             	pshs	d
e4a3 : bde17c           	lbsr	get_QByt
e4a6 : 3264             	leas	4,s
                        * 			tmp2.h = 0x0fff; tmp2.l = 0xffff;
e4a8 : cc0fff           	ldd	#$fff
e4ab : edc8ef           	std	-17,u
e4ae : ccffff           	ldd	#$ffff
e4b1 : ed51             	std	-15,u
                        * 			_u32_and(&tmp1, &tmp2, &tmp1);
e4b3 : 3053             	leax	-13,u
e4b5 : 3410             	pshs	x
e4b7 : 30c8ef           	leax	-17,u
e4ba : 3410             	pshs	x
e4bc : 3053             	leax	-13,u
e4be : 3410             	pshs	x
e4c0 : bda6f9           	lbsr	_u32_and
e4c3 : 3266             	leas	6,s
                        * 			tmp2.h = tmp2.l = 0;
e4c5 : 4f               	clra
e4c6 : 5f               	clrb
e4c7 : ed51             	std	-15,u
e4c9 : edc8ef           	std	-17,u
                        * 			if(_u32_equal(&tmp1, &tmp2)) {
e4cc : 30c8ef           	leax	-17,u
e4cf : 3410             	pshs	x
e4d1 : 3053             	leax	-13,u
e4d3 : 3410             	pshs	x
e4d5 : bda990           	lbsr	_u32_equ
e4d8 : 3264             	leas	4,s
e4da : 830000           	subd	#$0
e4dd : 1027001e         	lbeq	_203
                        *                 tmp1.h = 0; tmp1.l = i;
e4e1 : 4f               	clra
e4e2 : 5f               	clrb
e4e3 : ed53             	std	-13,u
e4e5 : e657             	ldb	-9,u
e4e7 : 4f               	clra
e4e8 : ed55             	std	-11,u
                        * 				_u32_add(&cluster, &tmp1, rValue);				
e4ea : ec48             	ldd	8,u
e4ec : 3406             	pshs	d
e4ee : 3053             	leax	-13,u
e4f0 : 3410             	pshs	x
e4f2 : 305c             	leax	-4,u
e4f4 : 3410             	pshs	x
e4f6 : bda8da           	lbsr	_u32_add
e4f9 : 3266             	leas	6,s
                        * 				return;
                        *             }
e4fb : 32c4             	leas	,u
e4fd : 35c0             	puls	u,pc
                        *         }
e4ff :                  _203
                        * 		tmp1.h = 0; tmp1.l = 128;
e4ff :                  _202
e4ff : 3057             	leax	-9,u
AS09 Assembler for M6809 [1.42].                                     Page  214
--------------------------------- merge.a09 ----------------------------------

e501 : e684             	ldb	,x
e503 : 6c84             	inc	,x
e505 : 1d               	sex
e506 : 2082             	lbra	_201
e508 :                  _200
e508 : 4f               	clra
e509 : 5f               	clrb
e50a : ed53             	std	-13,u
e50c : cc0080           	ldd	#$80
e50f : ed55             	std	-11,u
                        * 		_u32_add(&cluster, &tmp1, &tmp2);
e511 : 30c8ef           	leax	-17,u
e514 : 3410             	pshs	x
e516 : 3053             	leax	-13,u
e518 : 3410             	pshs	x
e51a : 305c             	leax	-4,u
e51c : 3410             	pshs	x
e51e : bda8da           	lbsr	_u32_add
e521 : 3266             	leas	6,s
                        * 		cluster.h = tmp2.h; cluster.l = tmp2.l;
e523 : ecc8ef           	ldd	-17,u
e526 : ed5c             	std	-4,u
e528 : ec51             	ldd	-15,u
e52a : ed5e             	std	-2,u
                        *     }
                        * 	rValue->h = rValue->l = 0; //return value
e52c : 7ee412           	lbra	_199
e52f :                  _198
e52f : 4f               	clra
e530 : 5f               	clrb
e531 : ae48             	ldx	8,u
e533 : ed02             	std	2,x
e535 : edd808           	std	[8,u]
                        * }
e538 : 32c4             	leas	,u
e53a : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function: to convert normal short file name into F
                        * //Arguments: pointer to the file name
                        * //return: 0, if successful else 1.
                        * //**************************************************
                        * //unsigned char convertFileName (char *inputFileName
                        * convertFileName(inputFileName) char *inputFileName;
                        * {
                        *     unsigned char fileNameFAT[C_8_3_FileNameSize];
                        *     unsigned char j, k;
                        * 
                        *     for(j=0; j<C_MaxFileNameSize-1; j++)
e53c :                  convertF
e53c : 3440             	pshs	u
e53e : 33e4             	leau	,s
e540 : 3273             	leas	-13,s
e542 : 4f               	clra
e543 : 5f               	clrb
e544 : e754             	stb	-12,u
e546 :                  _205
e546 : e654             	ldb	-12,u
e548 : 4f               	clra
e549 : 83000c           	subd	#$c
e54c : 1024001b         	lbhs	_204
                        *         if(inputFileName[j] == '.') break;
AS09 Assembler for M6809 [1.42].                                     Page  215
--------------------------------- merge.a09 ----------------------------------

e550 : e654             	ldb	-12,u
e552 : 1d               	sex
e553 : ae44             	ldx	4,u
e555 : e68b             	ldb	d,x
e557 : 1d               	sex
e558 : 83002e           	subd	#$2e
e55b : 10260003         	lbne	_207
e55f : 200a12           	lbra	_204
                        * 
                        *     if(j>8) {
e562 :                  _207
e562 :                  _206
e562 : 3054             	leax	-12,u
e564 : e684             	ldb	,x
e566 : 6c84             	inc	,x
e568 : 1d               	sex
e569 : 20db             	lbra	_205
e56b :                  _204
e56b : e654             	ldb	-12,u
e56d : 4f               	clra
e56e : 830008           	subd	#$8
e571 : 10230007         	lbls	_208
                        *         return INVALID_FILE_NAME;
e575 : cc0004           	ldd	#$4
                        *     }
e578 : 32c4             	leas	,u
e57a : 35c0             	puls	u,pc
                        * 
                        *     for(k=0; k<j; k++) //setting file name
e57c :                  _208
e57c : 4f               	clra
e57d : 5f               	clrb
e57e : e753             	stb	-13,u
e580 :                  _210
e580 : e654             	ldb	-12,u
e582 : 4f               	clra
e583 : 3406             	pshs	d
e585 : e653             	ldb	-13,u
e587 : 4f               	clra
e588 : a3e1             	subd	,s++
e58a : 1024001e         	lbhs	_209
                        *         fileNameFAT[k] = inputFileName[k];
e58e : e653             	ldb	-13,u
e590 : 4f               	clra
e591 : ae44             	ldx	4,u
e593 : e68b             	ldb	d,x
e595 : 4f               	clra
e596 : 3406             	pshs	d
e598 : e653             	ldb	-13,u
e59a : 4f               	clra
e59b : 3055             	leax	-11,u
e59d : 308b             	leax	d,x
e59f : 3506             	puls	d
e5a1 : e784             	stb	0,x
                        * 
                        *     for(k=j; k<=7; k++) //filling file name trail wi
e5a3 :                  _211
e5a3 : 3053             	leax	-13,u
e5a5 : e684             	ldb	,x
e5a7 : 6c84             	inc	,x
e5a9 : 4f               	clra
e5aa : 20d4             	lbra	_210
AS09 Assembler for M6809 [1.42].                                     Page  216
--------------------------------- merge.a09 ----------------------------------

e5ac :                  _209
e5ac : e654             	ldb	-12,u
e5ae : 4f               	clra
e5af : e753             	stb	-13,u
e5b1 :                  _213
e5b1 : e653             	ldb	-13,u
e5b3 : 4f               	clra
e5b4 : 830007           	subd	#$7
e5b7 : 10220015         	lbhi	_212
                        *         fileNameFAT[k] = ' ';
e5bb : e653             	ldb	-13,u
e5bd : 4f               	clra
e5be : 3055             	leax	-11,u
e5c0 : 308b             	leax	d,x
e5c2 : cc0020           	ldd	#$20
e5c5 : e784             	stb	0,x
                        * 
                        *     j++;
e5c7 :                  _214
e5c7 : 3053             	leax	-13,u
e5c9 : e684             	ldb	,x
e5cb : 6c84             	inc	,x
e5cd : 4f               	clra
e5ce : 20e1             	lbra	_213
e5d0 :                  _212
e5d0 : 3054             	leax	-12,u
e5d2 : e684             	ldb	,x
e5d4 : 6c84             	inc	,x
e5d6 : 4f               	clra
                        *     for(k=8; k<C_8_3_FileNameSize; k++) //setting fi
e5d7 : cc0008           	ldd	#$8
e5da : e753             	stb	-13,u
e5dc :                  _216
e5dc : e653             	ldb	-13,u
e5de : 4f               	clra
e5df : 83000b           	subd	#$b
e5e2 : 10240050         	lbhs	_215
                        *     {
                        *         if(inputFileName[j] != 0)
e5e6 : e654             	ldb	-12,u
e5e8 : 1d               	sex
e5e9 : ae44             	ldx	4,u
e5eb : e68b             	ldb	d,x
e5ed : 1d               	sex
e5ee : 830000           	subd	#$0
e5f1 : 1027001c         	lbeq	_218
                        *             fileNameFAT[k] = inputFileName[j++];
e5f5 : 3054             	leax	-12,u
e5f7 : e684             	ldb	,x
e5f9 : 6c84             	inc	,x
e5fb : 4f               	clra
e5fc : ae44             	ldx	4,u
e5fe : e68b             	ldb	d,x
e600 : 4f               	clra
e601 : 3406             	pshs	d
e603 : e653             	ldb	-13,u
e605 : 4f               	clra
e606 : 3055             	leax	-11,u
e608 : 308b             	leax	d,x
e60a : 3506             	puls	d
e60c : e784             	stb	0,x
                        *         else //filling extension trail with blanks
AS09 Assembler for M6809 [1.42].                                     Page  217
--------------------------------- merge.a09 ----------------------------------

e60e : 201d12           	lbra	_219
e611 :                  _218
                        *             while(k<C_8_3_FileNameSize)
e611 :                  _221
                        *                 fileNameFAT[k++] = ' ';
e611 : e653             	ldb	-13,u
e613 : 4f               	clra
e614 : 83000b           	subd	#$b
e617 : 10240012         	lbhs	_220
e61b : 3053             	leax	-13,u
e61d : e684             	ldb	,x
e61f : 6c84             	inc	,x
e621 : 4f               	clra
e622 : 3055             	leax	-11,u
e624 : 308b             	leax	d,x
e626 : cc0020           	ldd	#$20
e629 : e784             	stb	0,x
                        *     }
e62b : 20e4             	lbra	_221
e62d :                  _220
e62d :                  _219
                        * 
                        *     for(j=0; j<C_8_3_FileNameSize; j++) //converting
e62d :                  _217
e62d : 3053             	leax	-13,u
e62f : e684             	ldb	,x
e631 : 6c84             	inc	,x
e633 : 4f               	clra
e634 : 20a6             	lbra	_216
e636 :                  _215
e636 : 4f               	clra
e637 : 5f               	clrb
e638 : e754             	stb	-12,u
e63a :                  _223
e63a : e654             	ldb	-12,u
e63c : 4f               	clra
e63d : 83000b           	subd	#$b
e640 : 10240057         	lbhs	_222
                        *     {
                        *         if((fileNameFAT[j] >= 'a') && (fileNameFAT[j
e644 : e654             	ldb	-12,u
e646 : 4f               	clra
e647 : 3055             	leax	-11,u
e649 : e68b             	ldb	d,x
e64b : 4f               	clra
e64c : 830061           	subd	#$61
e64f : 1025002a         	lblo	_225
e653 : e654             	ldb	-12,u
e655 : 4f               	clra
e656 : 3055             	leax	-11,u
e658 : e68b             	ldb	d,x
e65a : 4f               	clra
e65b : 83007a           	subd	#$7a
e65e : 1022001b         	lbhi	_225
                        *         {
                        *             inputFileName[j] = fileNameFAT[j] - 0x20
e662 : e654             	ldb	-12,u
e664 : 1d               	sex
e665 : 3055             	leax	-11,u
e667 : e68b             	ldb	d,x
e669 : 1d               	sex
e66a : 830020           	subd	#$20
AS09 Assembler for M6809 [1.42].                                     Page  218
--------------------------------- merge.a09 ----------------------------------

e66d : 3406             	pshs	d
e66f : e654             	ldb	-12,u
e671 : 1d               	sex
e672 : ae44             	ldx	4,u
e674 : 308b             	leax	d,x
e676 : 3506             	puls	d
e678 : e784             	stb	0,x
                        *         }
                        *         else
e67a : 201612           	lbra	_226
e67d :                  _225
                        *         {
                        *             inputFileName[j] = fileNameFAT[j];
e67d : e654             	ldb	-12,u
e67f : 1d               	sex
e680 : 3055             	leax	-11,u
e682 : e68b             	ldb	d,x
e684 : 1d               	sex
e685 : 3406             	pshs	d
e687 : e654             	ldb	-12,u
e689 : 1d               	sex
e68a : ae44             	ldx	4,u
e68c : 308b             	leax	d,x
e68e : 3506             	puls	d
e690 : e784             	stb	0,x
                        *         }
                        *     }
e692 :                  _226
                        * 	inputFileName[C_8_3_FileNameSize] = 0;
e692 :                  _224
e692 : 3054             	leax	-12,u
e694 : e684             	ldb	,x
e696 : 6c84             	inc	,x
e698 : 1d               	sex
e699 : 209f             	lbra	_223
e69b :                  _222
e69b : 4f               	clra
e69c : 5f               	clrb
e69d : ae44             	ldx	4,u
e69f : e70b             	stb	11,x
                        * 
                        *     return VALID_FILE_NAME;
e6a1 : cc0003           	ldd	#$3
                        * }
e6a4 : 32c4             	leas	,u
e6a6 : 35c0             	puls	u,pc
                        * 
                        * 
                        * //**************************************************
                        * //Function: to create a file in FAT32 format in the 
                        * //			file name does not exist; if the file already e
                        * //Arguments: pointer to the file name
                        * //return: status
                        * //**************************************************
                        * //unsigned char openFile (unsigned char fileOperatio
                        * openFile(fileOperation, filePtr) unsigned char fileO
                        * {
                        *     unsigned char returnStatus;
                        *     u32_t cluster_, sector, firstSector;
                        *     LE_dir_Structure *dir;
                        *     u32_t tmp1, tmp2; 
                        * 	unsigned int i;
AS09 Assembler for M6809 [1.42].                                     Page  219
--------------------------------- merge.a09 ----------------------------------

                        *     unsigned char j;
                        * 	cluster_.h = rCluster.h; cluster_.l = rCluster.l;
e6a8 :                  openFile
e6a8 : 3440             	pshs	u
e6aa : 33e4             	leau	,s
e6ac : 32e8e6           	leas	-26,s
e6af : ec37             	ldd	rCluster+0,y
e6b1 : ed5b             	std	-5,u
e6b3 : ec39             	ldd	rCluster+2,y
e6b5 : ed5d             	std	-3,u
                        * 	
                        *     returnStatus = convertFileName(filePtr->fName); 
e6b7 : ec46             	ldd	6,u
e6b9 : c3022c           	addd	#$22c
e6bc : 3406             	pshs	d
e6be : bde53c           	lbsr	convertF
e6c1 : 3262             	leas	2,s
e6c3 : e75f             	stb	-1,u
                        * 
                        *     if(returnStatus == VALID_FILE_NAME)
e6c5 : e65f             	ldb	-1,u
e6c7 : 4f               	clra
e6c8 : 830003           	subd	#$3
e6cb : 1026022b         	lbne	_227
                        *     {
                        *        returnStatus = CONTINUE_LOOP;
e6cf : cc0055           	ldd	#$55
e6d2 : e75f             	stb	-1,u
                        * 
                        *         do
e6d4 :                  _230
                        *         {
                        *             getFirstSector(&cluster_, &firstSector);
e6d4 : 3053             	leax	-13,u
e6d6 : 3410             	pshs	x
e6d8 : 305b             	leax	-5,u
e6da : 3410             	pshs	x
e6dc : bde191           	lbsr	getFirst
e6df : 3264             	leas	4,s
                        * 			
                        * 			sector.h = 0;
e6e1 : 4f               	clra
e6e2 : 5f               	clrb
e6e3 : ed57             	std	-9,u
                        * 			for(sector.l = 0; ((sector.l < secPerCluster) && 
e6e5 : 4f               	clra
e6e6 : 5f               	clrb
e6e7 : ed59             	std	-7,u
e6e9 :                  _232
e6e9 : ec59             	ldd	-7,u
e6eb : a3a8ef           	subd	secPerCl+0,y
e6ee : 10240140         	lbhs	_231
e6f2 : e65f             	ldb	-1,u
e6f4 : 4f               	clra
e6f5 : 830055           	subd	#$55
e6f8 : 10260136         	lbne	_231
                        *             {                
                        *                 _u32_add(&firstSector, &sector, &tmp
e6fc : 30c8ed           	leax	-19,u
e6ff : 3410             	pshs	x
e701 : 3057             	leax	-9,u
e703 : 3410             	pshs	x
AS09 Assembler for M6809 [1.42].                                     Page  220
--------------------------------- merge.a09 ----------------------------------

e705 : 3053             	leax	-13,u
e707 : 3410             	pshs	x
e709 : bda8da           	lbsr	_u32_add
e70c : 3266             	leas	6,s
                        * 				SD_readSingleBlock(filePtr->LE_fileBuffer, &tmp1
e70e : 30c8ed           	leax	-19,u
e711 : 3410             	pshs	x
e713 : ec46             	ldd	6,u
e715 : c30026           	addd	#$26
e718 : 3406             	pshs	d
e71a : bdae0d           	lbsr	SD_readS
e71d : 3264             	leas	4,s
                        * 
                        *                 for(i=0; ((i<bPerSector) && (returnS
e71f : 4f               	clra
e720 : 5f               	clrb
e721 : edc8e7           	std	-25,u
e724 :                  _235
e724 : ecc8e7           	ldd	-25,u
e727 : a331             	subd	bPerSect+0,y
e729 : 102400f8         	lbhs	_234
e72d : e65f             	ldb	-1,u
e72f : 4f               	clra
e730 : 830055           	subd	#$55
e733 : 102600ee         	lbne	_234
                        *                 {
                        * 					dir = &filePtr->LE_fileBuffer[i];  //cast ok, b
e737 : ec46             	ldd	6,u
e739 : c30026           	addd	#$26
e73c : e3c8e7           	addd	-25,u
e73f : ed51             	std	-15,u
                        * 
                        *                     if(dir->name[0] == EMPTY) //indi
e741 : ae51             	ldx	-15,u
e743 : e684             	ldb	0,x
e745 : 4f               	clra
e746 : 830000           	subd	#$0
e749 : 10260008         	lbne	_237
                        *                     {
                        *                         returnStatus = FDELETED_OR_N
e74d : cc0001           	ldd	#$1
e750 : e75f             	stb	-1,u
                        *                         break;
e752 : 7ee825           	lbra	_234
                        *                     }
                        *                     if((dir->name[0] != DELETED) && 
e755 :                  _237
e755 : ae51             	ldx	-15,u
e757 : e684             	ldb	0,x
e759 : 4f               	clra
e75a : 8300e5           	subd	#$e5
e75d : 102700b8         	lbeq	_238
e761 : ae51             	ldx	-15,u
e763 : e60b             	ldb	11,x
e765 : 4f               	clra
e766 : 83000f           	subd	#$f
e769 : 102700ac         	lbeq	_238
                        *                     {
                        *                         for(j=0; j<C_8_3_FileNameSiz
e76d : 4f               	clra
e76e : 5f               	clrb
e76f : e7c8e6           	stb	-26,u
AS09 Assembler for M6809 [1.42].                                     Page  221
--------------------------------- merge.a09 ----------------------------------

e772 :                  _240
e772 : e6c8e6           	ldb	-26,u
e775 : 4f               	clra
e776 : 83000b           	subd	#$b
e779 : 1024002e         	lbhs	_239
                        *                         {
                        *                             if(dir->name[j] != fileP
e77d : ec46             	ldd	6,u
e77f : c3022c           	addd	#$22c
e782 : 3406             	pshs	d
e784 : e6c8e6           	ldb	-26,u
e787 : 1d               	sex
e788 : 3510             	puls	x
e78a : e68b             	ldb	d,x
e78c : 1d               	sex
e78d : 3406             	pshs	d
e78f : e6c8e6           	ldb	-26,u
e792 : 1d               	sex
e793 : ae51             	ldx	-15,u
e795 : e68b             	ldb	d,x
e797 : 1d               	sex
e798 : a3e1             	subd	,s++
e79a : 10270003         	lbeq	_242
                        *                                 break;
e79e : 200b12           	lbra	_239
                        *                         }
e7a1 :                  _242
                        *                         if(j == C_8_3_FileNameSize)
e7a1 :                  _241
e7a1 : 30c8e6           	leax	-26,u
e7a4 : e684             	ldb	,x
e7a6 : 6c84             	inc	,x
e7a8 : 1d               	sex
e7a9 : 20c7             	lbra	_240
e7ab :                  _239
e7ab : e6c8e6           	ldb	-26,u
e7ae : 4f               	clra
e7af : 83000b           	subd	#$b
e7b2 : 10260063         	lbne	_243
                        *                         {
                        *                             _u32_add(&firstSector, &
e7b6 : ec46             	ldd	6,u
e7b8 : c3000c           	addd	#$c
e7bb : 3406             	pshs	d
e7bd : 3057             	leax	-9,u
e7bf : 3410             	pshs	x
e7c1 : 3053             	leax	-13,u
e7c3 : 3410             	pshs	x
e7c5 : bda8da           	lbsr	_u32_add
e7c8 : 3266             	leas	6,s
                        *                             filePtr->appFLocation = 
e7ca : ecc8e7           	ldd	-25,u
e7cd : ae46             	ldx	6,u
e7cf : ed8810           	std	16,x
                        *                             filePtr->appendStartClus
e7d2 : ec51             	ldd	-15,u
e7d4 : c30014           	addd	#$14
e7d7 : 3406             	pshs	d
e7d9 : bde16e           	lbsr	get_Word
e7dc : 3262             	leas	2,s
e7de : ae46             	ldx	6,u
e7e0 : ed881e           	std	30,x
AS09 Assembler for M6809 [1.42].                                     Page  222
--------------------------------- merge.a09 ----------------------------------

                        * 							filePtr->appendStartCluster.l = get_Word(dir-
e7e3 : ec51             	ldd	-15,u
e7e5 : c3001a           	addd	#$1a
e7e8 : 3406             	pshs	d
e7ea : bde16e           	lbsr	get_Word
e7ed : 3262             	leas	2,s
e7ef : 3406             	pshs	d
e7f1 : ec46             	ldd	6,u
e7f3 : c3001e           	addd	#$1e
e7f6 : c30002           	addd	#$2
e7f9 : 1f01             	tfr	d,x
e7fb : 3506             	puls	d
e7fd : ed84             	std	0,x
                        *                             get_QByte(dir->fSize, &f
e7ff : ec46             	ldd	6,u
e801 : c30012           	addd	#$12
e804 : 3406             	pshs	d
e806 : ec51             	ldd	-15,u
e808 : c3001c           	addd	#$1c
e80b : 3406             	pshs	d
e80d : bde17c           	lbsr	get_QByt
e810 : 3264             	leas	4,s
                        *                             returnStatus = FOPEN_SUC
e812 : 4f               	clra
e813 : 5f               	clrb
e814 : e75f             	stb	-1,u
                        *                             break;
e816 : 200d12           	lbra	_234
                        *                         }
                        *                     }
e819 :                  _243
                        *                 }
e819 :                  _238
                        *             }
e819 :                  _236
e819 : ecc8e7           	ldd	-25,u
e81c : c30020           	addd	#$20
e81f : edc8e7           	std	-25,u
e822 : 7ee724           	lbra	_235
e825 :                  _234
                        * 
                        *             if(returnStatus == CONTINUE_LOOP)
e825 :                  _233
e825 : ec59             	ldd	-7,u
e827 : c30001           	addd	#$1
e82a : ed59             	std	-7,u
e82c : 830001           	subd	#$1
e82f : 7ee6e9           	lbra	_232
e832 :                  _231
e832 : e65f             	ldb	-1,u
e834 : 4f               	clra
e835 : 830055           	subd	#$55
e838 : 10260061         	lbne	_244
                        *             {
                        *                 getSetNC (filePtr->LE_fileBuffer, &c
e83c : 305b             	leax	-5,u
e83e : 3410             	pshs	x
e840 : 4f               	clra
e841 : 5f               	clrb
e842 : 3406             	pshs	d
e844 : 4f               	clra
e845 : 5f               	clrb
AS09 Assembler for M6809 [1.42].                                     Page  223
--------------------------------- merge.a09 ----------------------------------

e846 : 3406             	pshs	d
e848 : 305b             	leax	-5,u
e84a : 3410             	pshs	x
e84c : ec46             	ldd	6,u
e84e : c30026           	addd	#$26
e851 : 3406             	pshs	d
e853 : bde1d8           	lbsr	getSetNC
e856 : 326a             	leas	10,s
                        * 
                        *                 tmp1.h = 0x0fff; tmp1.l = 0xfff6;
e858 : cc0fff           	ldd	#$fff
e85b : edc8ed           	std	-19,u
e85e : ccfff6           	ldd	#$fff6
e861 : edc8ef           	std	-17,u
                        * 				tmp2.h = 0x00; tmp2.l = 0x00;
e864 : 4f               	clra
e865 : 5f               	clrb
e866 : edc8e9           	std	-23,u
e869 : 4f               	clra
e86a : 5f               	clrb
e86b : edc8eb           	std	-21,u
                        *                 if((_u32_higher(&cluster_, &tmp1) !=
e86e : 30c8ed           	leax	-19,u
e871 : 3410             	pshs	x
e873 : 305b             	leax	-5,u
e875 : 3410             	pshs	x
e877 : bda9bb           	lbsr	_u32_hig
e87a : 3264             	leas	4,s
e87c : 830000           	subd	#$0
e87f : 10260015         	lbne	_246
e883 : 30c8e9           	leax	-23,u
e886 : 3410             	pshs	x
e888 : 305b             	leax	-5,u
e88a : 3410             	pshs	x
e88c : bda990           	lbsr	_u32_equ
e88f : 3264             	leas	4,s
e891 : 830000           	subd	#$0
e894 : 10270005         	lbeq	_245
e898 :                  _246
                        * 				{
                        *                     returnStatus = NO_FREE_CLUSTERS_
e898 : cc0005           	ldd	#$5
e89b : e75f             	stb	-1,u
                        *                 }
                        *             }
e89d :                  _245
                        *         }while(returnStatus == CONTINUE_LOOP);
e89d :                  _244
e89d :                  _229
e89d : e65f             	ldb	-1,u
e89f : 4f               	clra
e8a0 : 830055           	subd	#$55
e8a3 : 1027fe2d         	lbeq	_230
                        * 
                        * 
                        *         if((returnStatus == FOPEN_SUCCESSFUL) && (fi
e8a7 :                  _228
e8a7 : e65f             	ldb	-1,u
e8a9 : 4f               	clra
e8aa : 830000           	subd	#$0
e8ad : 10260049         	lbne	_247
e8b1 : e645             	ldb	5,u
AS09 Assembler for M6809 [1.42].                                     Page  224
--------------------------------- merge.a09 ----------------------------------

e8b3 : 4f               	clra
e8b4 : 830000           	subd	#$0
e8b7 : 1026003f         	lbne	_247
                        *         {
                        *             filePtr->cluster.h = get_Word(dir->fClst
e8bb : ec51             	ldd	-15,u
e8bd : c30014           	addd	#$14
e8c0 : 3406             	pshs	d
e8c2 : bde16e           	lbsr	get_Word
e8c5 : 3262             	leas	2,s
e8c7 : ae46             	ldx	6,u
e8c9 : ed04             	std	4,x
e8cb : ec51             	ldd	-15,u
e8cd : c3001a           	addd	#$1a
e8d0 : 3406             	pshs	d
e8d2 : bde16e           	lbsr	get_Word
e8d5 : 3262             	leas	2,s
e8d7 : 3406             	pshs	d
e8d9 : ec46             	ldd	6,u
e8db : c30004           	addd	#$4
e8de : c30002           	addd	#$2
e8e1 : 1f01             	tfr	d,x
e8e3 : 3506             	puls	d
e8e5 : ed84             	std	0,x
                        *             get_QByte(dir->fSize, &filePtr->fileSize
e8e7 : ec46             	ldd	6,u
e8e9 : c30012           	addd	#$12
e8ec : 3406             	pshs	d
e8ee : ec51             	ldd	-15,u
e8f0 : c3001c           	addd	#$1c
e8f3 : 3406             	pshs	d
e8f5 : bde17c           	lbsr	get_QByt
e8f8 : 3264             	leas	4,s
                        *         }
                        *     }
e8fa :                  _247
                        *  
                        *     return returnStatus;
e8fa :                  _227
e8fa : e65f             	ldb	-1,u
e8fc : 4f               	clra
                        * }
e8fd : 32c4             	leas	,u
e8ff : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function: update the free memory count in the FSin
                        * //			Whenever a file is deleted or created, this fun
                        * //			to ADD or REMOVE clusters occupied by the file
                        * //Arguments: #1.flag ADD or REMOVE #2.file size in B
                        * //return: none
                        * //**************************************************
                        * //void freeMemoryUpdate (char *inputBuffer, unsigned
                        * freeMemoryUpdate(inputBuffer, flag, size) char *inpu
                        * {
                        *     u32_t freeClusters;
                        * 	u32_t tmp;
                        *     
                        * 	//convert file size into number of clusters occupie
                        *     tmp.h = size->h; tmp.l = size->l;
e901 :                  freeMemo
e901 : 3440             	pshs	u
AS09 Assembler for M6809 [1.42].                                     Page  225
--------------------------------- merge.a09 ----------------------------------

e903 : 33e4             	leau	,s
e905 : 3278             	leas	-8,s
e907 : ecd808           	ldd	[8,u]
e90a : ed58             	std	-8,u
e90c : ae48             	ldx	8,u
e90e : ec02             	ldd	2,x
e910 : ed5a             	std	-6,u
                        * 	_u32_div2(&tmp, C_MaxPageSize_U16, size);
e912 : ec48             	ldd	8,u
e914 : 3406             	pshs	d
e916 : cc0200           	ldd	#$200
e919 : 3406             	pshs	d
e91b : 3058             	leax	-8,u
e91d : 3410             	pshs	x
e91f : bda720           	lbsr	_u32_div
e922 : 3266             	leas	6,s
                        * 	if((tmp.l & 511) != 0) _u32_inc(size);
e924 : ec5a             	ldd	-6,u
e926 : 8401             	anda	#$1
e928 : c4ff             	andb	#$ff
e92a : 830000           	subd	#$0
e92d : 10270009         	lbeq	_248
e931 : ec48             	ldd	8,u
e933 : 3406             	pshs	d
e935 : bda929           	lbsr	_u32_inc
e938 : 3262             	leas	2,s
                        *     
                        * 	tmp.h = size->h; tmp.l = size->l;
e93a :                  _248
e93a : ecd808           	ldd	[8,u]
e93d : ed58             	std	-8,u
e93f : ae48             	ldx	8,u
e941 : ec02             	ldd	2,x
e943 : ed5a             	std	-6,u
                        * 	_u32_div2(&tmp, 8, size);
e945 : ec48             	ldd	8,u
e947 : 3406             	pshs	d
e949 : cc0008           	ldd	#$8
e94c : 3406             	pshs	d
e94e : 3058             	leax	-8,u
e950 : 3410             	pshs	x
e952 : bda720           	lbsr	_u32_div
e955 : 3266             	leas	6,s
                        * 	if((tmp.l & 7) != 0) _u32_inc(size);
e957 : ec5a             	ldd	-6,u
e959 : 8400             	anda	#$0
e95b : c407             	andb	#$7
e95d : 830000           	subd	#$0
e960 : 10270009         	lbeq	_249
e964 : ec48             	ldd	8,u
e966 : 3406             	pshs	d
e968 : bda929           	lbsr	_u32_inc
e96b : 3262             	leas	2,s
                        * 
                        *     if(fClstCnU != 0)
e96d :                  _249
e96d : e6a8e8           	ldb	fClstCnU+0,y
e970 : 4f               	clra
e971 : 830000           	subd	#$0
e974 : 10270072         	lbeq	_250
                        *     {
                        *         tmp.h = tmp.l = 0;
AS09 Assembler for M6809 [1.42].                                     Page  226
--------------------------------- merge.a09 ----------------------------------

e978 : 4f               	clra
e979 : 5f               	clrb
e97a : ed5a             	std	-6,u
e97c : ed58             	std	-8,u
                        * 		getSetFreeCluster (inputBuffer,TOTAL_FREE, GET, &t
e97e : 305c             	leax	-4,u
e980 : 3410             	pshs	x
e982 : 3058             	leax	-8,u
e984 : 3410             	pshs	x
e986 : 4f               	clra
e987 : 5f               	clrb
e988 : 3406             	pshs	d
e98a : cc0001           	ldd	#$1
e98d : 3406             	pshs	d
e98f : ec44             	ldd	4,u
e991 : 3406             	pshs	d
e993 : bde2df           	lbsr	getSetFr
e996 : 326a             	leas	10,s
                        *         tmp.h = freeClusters.h; tmp.l = freeClusters
e998 : ec5c             	ldd	-4,u
e99a : ed58             	std	-8,u
e99c : ec5e             	ldd	-2,u
e99e : ed5a             	std	-6,u
                        * 		if(flag == ADD) {            
e9a0 : e647             	ldb	7,u
e9a2 : 4f               	clra
e9a3 : 830000           	subd	#$0
e9a6 : 10260014         	lbne	_251
                        * 			_u32_add(&tmp, size, &freeClusters);			
e9aa : 305c             	leax	-4,u
e9ac : 3410             	pshs	x
e9ae : ec48             	ldd	8,u
e9b0 : 3406             	pshs	d
e9b2 : 3058             	leax	-8,u
e9b4 : 3410             	pshs	x
e9b6 : bda8da           	lbsr	_u32_add
e9b9 : 3266             	leas	6,s
                        * 		}
                        *         else {  //when flag = REMOVE
e9bb : 201212           	lbra	_252
e9be :                  _251
                        *             _u32_sub(&tmp, size, &freeClusters);    
e9be : 305c             	leax	-4,u
e9c0 : 3410             	pshs	x
e9c2 : ec48             	ldd	8,u
e9c4 : 3406             	pshs	d
e9c6 : 3058             	leax	-8,u
e9c8 : 3410             	pshs	x
e9ca : bda870           	lbsr	_u32_sub
e9cd : 3266             	leas	6,s
                        * 		}
                        *         getSetFreeCluster(inputBuffer,TOTAL_FREE, SE
e9cf :                  _252
e9cf : 3058             	leax	-8,u
e9d1 : 3410             	pshs	x
e9d3 : 305c             	leax	-4,u
e9d5 : 3410             	pshs	x
e9d7 : cc0001           	ldd	#$1
e9da : 3406             	pshs	d
e9dc : cc0001           	ldd	#$1
e9df : 3406             	pshs	d
e9e1 : ec44             	ldd	4,u
AS09 Assembler for M6809 [1.42].                                     Page  227
--------------------------------- merge.a09 ----------------------------------

e9e3 : 3406             	pshs	d
e9e5 : bde2df           	lbsr	getSetFr
e9e8 : 326a             	leas	10,s
                        *     }
                        * }
e9ea :                  _250
e9ea : 32c4             	leas	,u
e9ec : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function: file deletion FAT32 format 
                        * //Arguments: pointer to the file name
                        * //return: 0 when successfully
                        * //**************************************************
                        * //unsigned char deleteFile (char *fileName)
                        * deleteFile(fileName) char *fileName;
                        * {
                        *     u32_t sector, cluster_, firstCluster, nextCluste
                        * 	u32_t tmp1, tmp2;
                        *     LE_dir_Structure *dir;
                        *     unsigned int i, j;
                        * 
                        *     cluster_.h = rCluster.h; cluster_.l = rCluster.l
e9ee :                  deleteFi
e9ee : 3440             	pshs	u
e9f0 : 33e4             	leau	,s
e9f2 : 32e8de           	leas	-34,s
e9f5 : ec37             	ldd	rCluster+0,y
e9f7 : ed58             	std	-8,u
e9f9 : ec39             	ldd	rCluster+2,y
e9fb : ed5a             	std	-6,u
                        * 
                        *     while(1)
e9fd :                  _254
                        *     {
                        *         getFirstSector(&cluster_, &firstSector);
e9fd : 30c8ec           	leax	-20,u
ea00 : 3410             	pshs	x
ea02 : 3058             	leax	-8,u
ea04 : 3410             	pshs	x
ea06 : bde191           	lbsr	getFirst
ea09 : 3264             	leas	4,s
                        * 		sector.h = 0;
ea0b : 4f               	clra
ea0c : 5f               	clrb
ea0d : ed5c             	std	-4,u
                        *         for(sector.l = 0; sector.l < secPerCluster; 
ea0f : 4f               	clra
ea10 : 5f               	clrb
ea11 : ed5e             	std	-2,u
ea13 :                  _256
ea13 : ec5e             	ldd	-2,u
ea15 : a3a8ef           	subd	secPerCl+0,y
ea18 : 1024021c         	lbhs	_255
                        * 		{
                        *             _u32_add(&firstSector, &sector, &tmp1);
ea1c : 30c8e8           	leax	-24,u
ea1f : 3410             	pshs	x
ea21 : 305c             	leax	-4,u
ea23 : 3410             	pshs	x
ea25 : 30c8ec           	leax	-20,u
ea28 : 3410             	pshs	x
AS09 Assembler for M6809 [1.42].                                     Page  228
--------------------------------- merge.a09 ----------------------------------

ea2a : bda8da           	lbsr	_u32_add
ea2d : 3266             	leas	6,s
                        * 			if(SD_readSingleBlock(fatMapTb.LE_fileBuffer, &tm
ea2f : 30c8e8           	leax	-24,u
ea32 : 3410             	pshs	x
ea34 : 30a9fdd4         	leax	fatMapTb+38,y
ea38 : 3410             	pshs	x
ea3a : bdae0d           	lbsr	SD_readS
ea3d : 3264             	leas	4,s
ea3f : 830000           	subd	#$0
ea42 : 10270007         	lbeq	_258
ea46 : ccffff           	ldd	#$ffff
                        *             for(i=0; i<bPerSector; i+=32)
ea49 : 32c4             	leas	,u
ea4b : 35c0             	puls	u,pc
ea4d :                  _258
ea4d : 4f               	clra
ea4e : 5f               	clrb
ea4f : edc8e0           	std	-32,u
ea52 :                  _260
ea52 : ecc8e0           	ldd	-32,u
ea55 : a331             	subd	bPerSect+0,y
ea57 : 102401d0         	lbhs	_259
                        *             {
                        *                 dir = &fatMapTb.LE_fileBuffer[i];  /
ea5b : 30a9fdd4         	leax	fatMapTb+38,y
ea5f : 1f10             	tfr	x,d
ea61 : e3c8e0           	addd	-32,u
ea64 : edc8e2           	std	-30,u
                        * 
                        *                 if(dir->name[0] == EMPTY) //indicate
ea67 : aec8e2           	ldx	-30,u
ea6a : e684             	ldb	0,x
ea6c : 4f               	clra
ea6d : 830000           	subd	#$0
ea70 : 10260007         	lbne	_262
                        *                 {
                        *                     return FDELETED_OR_NOT_FOUND;
ea74 : cc0001           	ldd	#$1
                        *                 }
ea77 : 32c4             	leas	,u
ea79 : 35c0             	puls	u,pc
                        *                 if((dir->name[0] != DELETED) && (dir
ea7b :                  _262
ea7b : aec8e2           	ldx	-30,u
ea7e : e684             	ldb	0,x
ea80 : 4f               	clra
ea81 : 8300e5           	subd	#$e5
ea84 : 10270197         	lbeq	_263
ea88 : aec8e2           	ldx	-30,u
ea8b : e60b             	ldb	11,x
ea8d : 4f               	clra
ea8e : 83000f           	subd	#$f
ea91 : 1027018a         	lbeq	_263
                        *                 {
                        *                     for(j=0; j<11; j++)
ea95 : 4f               	clra
ea96 : 5f               	clrb
ea97 : edc8de           	std	-34,u
ea9a :                  _265
ea9a : ecc8de           	ldd	-34,u
ea9d : 83000b           	subd	#$b
AS09 Assembler for M6809 [1.42].                                     Page  229
--------------------------------- merge.a09 ----------------------------------

eaa0 : 1024002a         	lbhs	_264
                        *                         if(dir->name[j] != fileName[
eaa4 : ecc8de           	ldd	-34,u
eaa7 : ae44             	ldx	4,u
eaa9 : e68b             	ldb	d,x
eaab : 1d               	sex
eaac : 3406             	pshs	d
eaae : ecc8de           	ldd	-34,u
eab1 : aec8e2           	ldx	-30,u
eab4 : e68b             	ldb	d,x
eab6 : 1d               	sex
eab7 : a3e1             	subd	,s++
eab9 : 10270003         	lbeq	_267
eabd : 200f12           	lbra	_264
                        *                     if(j == 11)
eac0 :                  _267
eac0 :                  _266
eac0 : ecc8de           	ldd	-34,u
eac3 : c30001           	addd	#$1
eac6 : edc8de           	std	-34,u
eac9 : 830001           	subd	#$1
eacc : 20cc             	lbra	_265
eace :                  _264
eace : ecc8de           	ldd	-34,u
ead1 : 83000b           	subd	#$b
ead4 : 10260147         	lbne	_268
                        *                     {
                        *                         firstCluster.h = get_Word(di
ead8 : ecc8e2           	ldd	-30,u
eadb : c30014           	addd	#$14
eade : 3406             	pshs	d
eae0 : bde16e           	lbsr	get_Word
eae3 : 3262             	leas	2,s
eae5 : ed54             	std	-12,u
eae7 : ecc8e2           	ldd	-30,u
eaea : c3001a           	addd	#$1a
eaed : 3406             	pshs	d
eaef : bde16e           	lbsr	get_Word
eaf2 : 3262             	leas	2,s
eaf4 : ed56             	std	-10,u
                        * 
                        *                         //mark file as 'deleted' in 
                        *                         dir->name[0] = DELETED;
eaf6 : cc00e5           	ldd	#$e5
eaf9 : aec8e2           	ldx	-30,u
eafc : e784             	stb	0,x
                        *                         _u32_add(&firstSector, &sect
eafe : 30c8e8           	leax	-24,u
eb01 : 3410             	pshs	x
eb03 : 305c             	leax	-4,u
eb05 : 3410             	pshs	x
eb07 : 30c8ec           	leax	-20,u
eb0a : 3410             	pshs	x
eb0c : bda8da           	lbsr	_u32_add
eb0f : 3266             	leas	6,s
                        * 						if(SD_writeSingleBlock(fatMapTb.LE_fileBuffer,
eb11 : 30c8e8           	leax	-24,u
eb14 : 3410             	pshs	x
eb16 : 30a9fdd4         	leax	fatMapTb+38,y
eb1a : 3410             	pshs	x
eb1c : bdae9b           	lbsr	SD_write
eb1f : 3264             	leas	4,s
AS09 Assembler for M6809 [1.42].                                     Page  230
--------------------------------- merge.a09 ----------------------------------

eb21 : 830000           	subd	#$0
eb24 : 10270007         	lbeq	_269
eb28 : ccffff           	ldd	#$ffff
                        * 
                        *                         get_QByte(dir->fSize, &tmp1)
eb2b : 32c4             	leas	,u
eb2d : 35c0             	puls	u,pc
eb2f :                  _269
eb2f : 30c8e8           	leax	-24,u
eb32 : 3410             	pshs	x
eb34 : ecc8e2           	ldd	-30,u
eb37 : c3001c           	addd	#$1c
eb3a : 3406             	pshs	d
eb3c : bde17c           	lbsr	get_QByt
eb3f : 3264             	leas	4,s
                        * 						freeMemoryUpdate (fatMapTb.LE_fileBuffer,ADD, 
eb41 : 30c8e8           	leax	-24,u
eb44 : 3410             	pshs	x
eb46 : 4f               	clra
eb47 : 5f               	clrb
eb48 : 3406             	pshs	d
eb4a : 30a9fdd4         	leax	fatMapTb+38,y
eb4e : 3410             	pshs	x
eb50 : bde901           	lbsr	freeMemo
eb53 : 3266             	leas	6,s
                        * 
                        *                         //update next free cluster e
                        *                         tmp1.h = tmp1.l = 0;
eb55 : 4f               	clra
eb56 : 5f               	clrb
eb57 : edc8ea           	std	-22,u
eb5a : edc8e8           	std	-24,u
                        * 						getSetFreeCluster (fatMapTb.LE_fileBuffer,NEXT
eb5d : 3058             	leax	-8,u
eb5f : 3410             	pshs	x
eb61 : 30c8e8           	leax	-24,u
eb64 : 3410             	pshs	x
eb66 : 4f               	clra
eb67 : 5f               	clrb
eb68 : 3406             	pshs	d
eb6a : cc0002           	ldd	#$2
eb6d : 3406             	pshs	d
eb6f : 30a9fdd4         	leax	fatMapTb+38,y
eb73 : 3410             	pshs	x
eb75 : bde2df           	lbsr	getSetFr
eb78 : 326a             	leas	10,s
                        *                         //if(firstCluster < cluster)
                        *                         if(_u32_higher(&cluster_, &f
eb7a : 3054             	leax	-12,u
eb7c : 3410             	pshs	x
eb7e : 3058             	leax	-8,u
eb80 : 3410             	pshs	x
eb82 : bda9bb           	lbsr	_u32_hig
eb85 : 3264             	leas	4,s
eb87 : 830000           	subd	#$0
eb8a : 1027001e         	lbeq	_270
                        * 						    getSetFreeCluster (fatMapTb.LE_fileBuffer,
eb8e : 30c8e8           	leax	-24,u
eb91 : 3410             	pshs	x
eb93 : 3054             	leax	-12,u
eb95 : 3410             	pshs	x
eb97 : cc0001           	ldd	#$1
AS09 Assembler for M6809 [1.42].                                     Page  231
--------------------------------- merge.a09 ----------------------------------

eb9a : 3406             	pshs	d
eb9c : cc0002           	ldd	#$2
eb9f : 3406             	pshs	d
eba1 : 30a9fdd4         	leax	fatMapTb+38,y
eba5 : 3410             	pshs	x
eba7 : bde2df           	lbsr	getSetFr
ebaa : 326a             	leas	10,s
                        * 
                        *                         //mark all the clusters allo
                        *                         while(1)
ebac :                  _270
ebac :                  _272
                        *                         {
                        *                             tmp1.h = tmp1.l = 0;
ebac : 4f               	clra
ebad : 5f               	clrb
ebae : edc8ea           	std	-22,u
ebb1 : edc8e8           	std	-24,u
                        * 							getSetNC(fatMapTb.LE_fileBuffer, &firstCluste
ebb4 : 3050             	leax	-16,u
ebb6 : 3410             	pshs	x
ebb8 : 30c8e8           	leax	-24,u
ebbb : 3410             	pshs	x
ebbd : 4f               	clra
ebbe : 5f               	clrb
ebbf : 3406             	pshs	d
ebc1 : 3054             	leax	-12,u
ebc3 : 3410             	pshs	x
ebc5 : 30a9fdd4         	leax	fatMapTb+38,y
ebc9 : 3410             	pshs	x
ebcb : bde1d8           	lbsr	getSetNC
ebce : 326a             	leas	10,s
                        *                             getSetNC(fatMapTb.LE_fil
ebd0 : 30c8e8           	leax	-24,u
ebd3 : 3410             	pshs	x
ebd5 : 30c8e8           	leax	-24,u
ebd8 : 3410             	pshs	x
ebda : cc0001           	ldd	#$1
ebdd : 3406             	pshs	d
ebdf : 3054             	leax	-12,u
ebe1 : 3410             	pshs	x
ebe3 : 30a9fdd4         	leax	fatMapTb+38,y
ebe7 : 3410             	pshs	x
ebe9 : bde1d8           	lbsr	getSetNC
ebec : 326a             	leas	10,s
                        *                             tmp1.h = 0x0fff; tmp1.l 
ebee : cc0fff           	ldd	#$fff
ebf1 : edc8e8           	std	-24,u
ebf4 : ccfff6           	ldd	#$fff6
ebf7 : edc8ea           	std	-22,u
                        * 							//if(nextCluster > 0x0ffffff6)
                        * 							if(_u32_higher(&nextCluster, &tmp1) != 0) ret
ebfa : 30c8e8           	leax	-24,u
ebfd : 3410             	pshs	x
ebff : 3050             	leax	-16,u
ec01 : 3410             	pshs	x
ec03 : bda9bb           	lbsr	_u32_hig
ec06 : 3264             	leas	4,s
ec08 : 830000           	subd	#$0
ec0b : 10270006         	lbeq	_273
ec0f : 4f               	clra
ec10 : 5f               	clrb
AS09 Assembler for M6809 [1.42].                                     Page  232
--------------------------------- merge.a09 ----------------------------------

                        *                             firstCluster.h = nextClu
ec11 : 32c4             	leas	,u
ec13 : 35c0             	puls	u,pc
ec15 :                  _273
ec15 : ec50             	ldd	-16,u
ec17 : ed54             	std	-12,u
ec19 : ec52             	ldd	-14,u
ec1b : ed56             	std	-10,u
                        *                         }
                        *                     }
ec1d : 208d             	lbra	_272
ec1f :                  _271
                        *                 }
ec1f :                  _268
                        *             }
ec1f :                  _263
                        *         }
ec1f :                  _261
ec1f : ecc8e0           	ldd	-32,u
ec22 : c30020           	addd	#$20
ec25 : edc8e0           	std	-32,u
ec28 : 7eea52           	lbra	_260
ec2b :                  _259
                        * 
                        *         tmp1.h = tmp1.l = 0;
ec2b :                  _257
ec2b : ec5e             	ldd	-2,u
ec2d : c30001           	addd	#$1
ec30 : ed5e             	std	-2,u
ec32 : 830001           	subd	#$1
ec35 : 7eea13           	lbra	_256
ec38 :                  _255
ec38 : 4f               	clra
ec39 : 5f               	clrb
ec3a : edc8ea           	std	-22,u
ec3d : edc8e8           	std	-24,u
                        * 		getSetNC(fatMapTb.LE_fileBuffer, &cluster_, GET, &
ec40 : 3058             	leax	-8,u
ec42 : 3410             	pshs	x
ec44 : 30c8e8           	leax	-24,u
ec47 : 3410             	pshs	x
ec49 : 4f               	clra
ec4a : 5f               	clrb
ec4b : 3406             	pshs	d
ec4d : 3058             	leax	-8,u
ec4f : 3410             	pshs	x
ec51 : 30a9fdd4         	leax	fatMapTb+38,y
ec55 : 3410             	pshs	x
ec57 : bde1d8           	lbsr	getSetNC
ec5a : 326a             	leas	10,s
                        * 
                        *         tmp1.h = 0x0fff; tmp1.l = 0xfff6;
ec5c : cc0fff           	ldd	#$fff
ec5f : edc8e8           	std	-24,u
ec62 : ccfff6           	ldd	#$fff6
ec65 : edc8ea           	std	-22,u
                        *         tmp2.h = 0x00; tmp2.l = 0x00;
ec68 : 4f               	clra
ec69 : 5f               	clrb
ec6a : edc8e4           	std	-28,u
ec6d : 4f               	clra
ec6e : 5f               	clrb
AS09 Assembler for M6809 [1.42].                                     Page  233
--------------------------------- merge.a09 ----------------------------------

ec6f : edc8e6           	std	-26,u
                        *         if((_u32_higher(&cluster_, &tmp1)) || (_u32_
ec72 : 30c8e8           	leax	-24,u
ec75 : 3410             	pshs	x
ec77 : 3058             	leax	-8,u
ec79 : 3410             	pshs	x
ec7b : bda9bb           	lbsr	_u32_hig
ec7e : 3264             	leas	4,s
ec80 : 830000           	subd	#$0
ec83 : 10260015         	lbne	_275
ec87 : 30c8e4           	leax	-28,u
ec8a : 3410             	pshs	x
ec8c : 3058             	leax	-8,u
ec8e : 3410             	pshs	x
ec90 : bda990           	lbsr	_u32_equ
ec93 : 3264             	leas	4,s
ec95 : 830000           	subd	#$0
ec98 : 10270007         	lbeq	_274
ec9c :                  _275
                        *         {
                        *             return FDELETED_OR_NOT_FOUND;
ec9c : cc0001           	ldd	#$1
                        *         }
ec9f : 32c4             	leas	,u
eca1 : 35c0             	puls	u,pc
                        *     }
eca3 :                  _274
                        * }
eca3 : 7ee9fd           	lbra	_254
eca6 :                  _253
eca6 : 32c4             	leas	,u
eca8 : 35c0             	puls	u,pc
                        * 
                        * 
                        * /***************************************************
                        *                   Fat32 date and time encoding
                        *  ***************************************************
                        * Each directory is of 32bytes.
                        * 
                        * Bytes   Content
                        * 0-10    File name (8 bytes) with extension (3 bytes)
                        * 11      Attribute - a bitvector. Bit 0: read only. B
                        *         Bit 2: system file. Bit 3: volume label. Bit
                        *         Bit 5: archive. Bits 6-7: unused.
                        * 12-21   Reserved (see below)
                        * 22-23   Time (5/6/5 bits, for hour/minutes/doublesec
                        * 24-25   Date (7/4/5 bits, for year-since-1980/month/
                        * 26-27   Starting cluster (0 for an empty file)
                        * 28-31   Filesize in bytes 
                        *  ***************************************************
                        * //unsigned int GetTime(void)
                        * /*GetTime()
                        * {
                        *     unsigned char hour, min, sec;
                        *     unsigned int fat32Time;
                        * 	hour=13; min=40; sec=30;
                        *     // RTC_GetTime(&hour,&min,&sec);
                        *     fat32Time = ((hour & 0x1f)<<11) | ((min&0x3f)<<5
                        * 
                        *     return fat32Time;
                        * }*/
                        * 
AS09 Assembler for M6809 [1.42].                                     Page  234
--------------------------------- merge.a09 ----------------------------------

                        * //unsigned int GetDate(void)
                        * /*GetDate()
                        * {
                        *     unsigned char day, month;
                        *     unsigned int fat32Date, year;
                        * 	day = 2; month=10; year=2015;
                        *     //	 RTC_GetDate(&year,&month,&day);
                        *     fat32Date = ((year - 1980)<<9) | ((month & 0x0f)
                        * 
                        *     return fat32Date;
                        * }*/
                        * 
                        * /***************************************************
0260 =                  _GLOBALS	equ	608
                        
                        *
                        * micro-c driver under flex
                        *
                        *	12-dec-81	m.ohta,h.tezuka
                        *
                        
ecaa : 3436             _00001	pshs	d,x,y		;multiply	
ecac : a6e4             		lda	,s
ecae : e663             		ldb	3,s
ecb0 : 3d               		mul
ecb1 : e764             		stb	4,s		
ecb3 : ec61             		ldd	1,s
ecb5 : 3d               		mul
ecb6 : e765             		stb	5,s		
ecb8 : a661             		lda	1,s
ecba : e663             		ldb	3,s
ecbc : 3d               		mul
ecbd : ab64             		adda	4,s
ecbf : ab65             		adda	5,s		
ecc1 : 3266             		leas	6,s
ecc3 : 39               		rts
                        
                        ; _00002	clr	,-s				; signed divide	
                        		; cmpx	#0
                        		; bpl	_02000		
                        		; com	,s		
                        		; exg	d,x
                        		; lbsr	_00020
                        		; exg	d,x
                        ; _02000	tsta
                        		; bpl	_02001		
                        		; com	,s		
                        		; lbsr	_00020	
                        ; _02001	lbsr	_00010
                        		; tfr	x,d
                        		; tst	,s+
                        		; bpl	_02002		
                        		; lbsr	_00020	
                        ; _02002	rts
                        
                        ; _00003	lbsr	_00010		; unsigned divide
                        		; tfr	x,d
                        		; rts
                        
                        ; _00004	clr	,-s				; signed modulous	
                        		; cmpx	#0
                        		; bpl	_04000		
AS09 Assembler for M6809 [1.42].                                     Page  235
--------------------------------- merge.a09 ----------------------------------

                        		; exg	d,x
                        		; bsr	_00020
                        		; exg	d,x
                        ; _04000	tsta
                        		; bpl	_04001		
                        		; com	,s
                        		; bsr	_00020	
                        ; _04001	bsr	_00010	
                        		; tst	,s+
                        		; bpl	_04002		
                        		; bsr	_00020	
                        ; _04002	rts
                        
                        ; _00005	bsr	_00010		; unsigned modulous
                        		; rts
                        
                        ; _00006	cmpx	#0		; signed left shift
                        		; bmi	_06001 
                        ; _06000	beq	_06009
                        		; lslb
                        		; rola
                        		; leax	-1,x
                        		; bra	_06000	
                        ; _06001	beq	_06009
                        		; asra
                        		; rorb
                        		; leax	1,x
                        		; bra	_06001	
                        ; _06009	rts
                        
                        ; _00007	cmpx	#0		; unsigned left shift
                        		; bmi	_07001	
                        ; _07000	beq	_07009
                        		; lslb
                        		; rola
                        		; leax	-1,x
                        		; bra	_07000	
                        ; _07001	beq	_07009
                        		; lsra
                        		; rorb
                        		; leax	1,x
                        		; bra	_07001	
                        ; _07009	rts
                        
                        ; _00008	cmpx	#0		; signed right shift
                        		; bmi	_08001	
                        ; _08000	beq	_08009
                        		; asra
                        		; rorb
                        		; leax	-1,x
                        		; bra	_08000
                        	
                        ; _08001	beq	_08009
                        		; lslb
                        		; rola
                        		; leax	1,x
                        		; bra	_08001	
                        ; _08009	rts
                        
ecc4 : 8c0000           _00009	cmpx	#0		; unsigned right shift
ecc7 : 2b08             		bmi	_09001	
ecc9 : 270e             _09000	beq	_09009
AS09 Assembler for M6809 [1.42].                                     Page  236
--------------------------------- merge.a09 ----------------------------------

eccb : 44               		lsra
eccc : 56               		rorb
eccd : 301f             		leax	-1,x
eccf : 20f8             		bra	_09000	
ecd1 : 2706             _09001	beq	_09009
ecd3 : 58               		lslb
ecd4 : 49               		rola
ecd5 : 3001             		leax	1,x
ecd7 : 20f8             		bra	_09001	
ecd9 : 39               _09009	rts
                        
ecda : 40               _00020	nega			;negate d reg
ecdb : 50               		negb
ecdc : 8200             		sbca	#0
ecde : 39               		rts
                        
                        ; _00010	pshs	d,x		;divide subroutine	
                        		; clra
                        		; clrb	
                        		; ldx	#17
                        	
                        ; _00011	subd	2,s
                        		; bcc	_00012	
                        		; addd	2,s
                        	
                        ; _00012	rol	1,s
                        		; rol	,s
                        		; rolb
                        		; rola	
                        		; leax	-1,x
                        		; bne	_00011	
                        		; rora
                        		; rorb	
                        		; com	1,s
                        		; com	,s
                        		; puls	x	
                        		; leas	2,s
                        		; rts
                        
                        
                        ; coding convention:
                        ; normal function paramters are passed by the stack: a
                        ; the returned value is in D
                        ; the registers D and X can modified in the called fun
                        ;
                        ; special function lead by an 's' (e.g. sFUNCTION) is 
                        ;
                        ;{ ----------------------------------- Program Start -
                        					code
                        					
0010 =                  MONITOR_PROCESS_ID	equ		$10
0020 =                  BASIC_PROCESS_ID	equ		$20
                        
                        
                        ; configuration DEBUG_MON_PORT linked to USB_COM_PORT
00ef =                  ENABLE_MON_INT		equ		%11101111			; enable irq for moni
c800 =                  DEBUG_MON_PORT		equ		USB_COM_WR			; link the debugMonP
c000 =                  sMON_PORT_RD		equ		USB_COM_RD			; use the defined moni
ecdf : f7c800           sMON_PORT_WR		stb		USB_COM_WR			; use the defined moni
ece2 : 39               					rts
                        						
ece3 : 0d76657273696f.. VERSION         	db      CR,"version 2.1.0.3",CR		; ve
AS09 Assembler for M6809 [1.42].                                     Page  237
--------------------------------- merge.a09 ----------------------------------

ecf4 : 323031342d3230.. BOOT_SCR         	db      "2014-2023, Retro 6809 SBC",
ed0e : 68747470733a2f.. 					db		"https://github.com/akund/retro-6809-SBC",CR,
                        
fbcd =                  CheckSum16_ROM0		equ		$FBCD
ed38 : c882             CheckSum16_ROM1		dw		CSum16_ROM1			; BASIC ROM1 CheckS
                        
ed3a : 1a50             RESET           	orcc	#%01010000			; disable all inter
ed3c : 10ce7d5d         					lds		#LV_StackBeginAddr
                        										
                        					; init (clear 16-bit) the re-mapping int vector t
ed40 : 8e7ff2           					ldx		#IntVectSWI3
ed43 : 4f               					clra
ed44 : 5f               					clrb
ed45 : ed81             					std		,x++	;sw3
ed47 : ed81             					std		,x++	;sw2
ed49 : ed81             					std		,x++	;firq
ed4b : ed81             					std		,x++	;irq
ed4d : ed81             					std		,x++	;sw1
ed4f : ed81             					std		,x++	;nmi
ed51 : ed81             					std		,x++	;start
                        					
ed53 : 8eece3           					ldx		#VERSION			; version at boot up
ed56 : bdf91c           					lbsr	sPUTSTR
                        					
ed59 : 8ee000           					ldx		#ROM0_ORG										
ed5c : 3410             					pshs	x					; push as 1st arg
ed5e : 30892000         					leax	$2000,x				; calculate end addr+2 (8k size)
ed62 : 3410             					pshs	x					; push as 2nd arg
ed64 : 4f               					clra
ed65 : 5f               					clrb
ed66 : b3fff0           					subd	ROM_Integrity		; ROM0 initial CheckSum16 is 
ed69 : 3406             					pshs	d					; push as 3rd arg (initial value)
ed6b : bdfa64           					lbsr	getCheckSum16		; ret value in d
ed6e : 3266             					leas	6,s					; free the 3 pushes					
ed70 : 8efff0           					ldx		#ROM_Integrity
ed73 : bdfa2d           					lbsr	sROMcheck			; check the ROM integrity							
                        					
                        					;--------- init peripherals and others ----------
                        					; port A and B initialized with SD Card (requires
ed76 : bdf924           					lbsr	SELECTBANK0
                        					
                        					;---------- initialize monitor resources --------
ed79 : bdf2ed           					lbsr	sMONITORSTART
                        					
                        					;---------- initialize DISK EXT BASIC resources -
ed7c : fc8000           					ldd		ROM1_ORG			; check if BASIC ROM available
ed7f : 10b3ed38         					cmpd	CheckSum16_ROM1
ed83 : 2626             					bne		main
ed85 : 8e8000           					ldx		#ROM1_ORG										
ed88 : 3410             					pshs	x					; push as 1st arg
ed8a : 30894000         					leax	$4000,x				; calculate end addr+2 (16k size)
ed8e : 3410             					pshs	x					; push as 2nd arg
ed90 : 4f               					clra
ed91 : 5f               					clrb
ed92 : b38000           					subd	ROM1_ORG			; ROM1 initial CheckSum16 is excl
ed95 : 3406             					pshs	d					; push as 3rd arg (initial value)
ed97 : bdfa64           					lbsr	getCheckSum16		; ret value in d
ed9a : 3266             					leas	6,s					; free the 3 pushes
ed9c : 8e8000           					ldx		#ROM1_ORG
ed9f : bdfa2d           					lbsr	sROMcheck			; check the ROM integrity
eda2 : 5d               					tstb
eda3 : 2606             					bne		main				; start BASIC only when ROM1 validat
AS09 Assembler for M6809 [1.42].                                     Page  238
--------------------------------- merge.a09 ----------------------------------

eda5 : bdee1e           					lbsr	APL_init
eda8 : bdaa84           					lbsr    setPins				; PIA initialization
                        
                        ;-------------------------------- main program -------
edab : 327f             main				leas	-1,s				; last APL status @ 2,u
edad : 327e             					leas	-2,s				; heart beat countdown @ 0,u
edaf : 33e4             					leau	0,s					
                        
edb1 : bdf357           loop				lbsr	sMonProcessCmd		; monitor process call
                        					
edb4 : bdee9c           					lbsr	BASICprocess		; BASIC process call
                        					
edb7 : 8130             					cmpa	#APL_RESET			; reset supervision
edb9 : 260c             					bne		_loop1
edbb : a142             					cmpa	2,u
edbd : 2708             					beq		_loop1
edbf : a742             					sta		2,u
edc1 : 8eedda           					ldx		#APL_RESET_STR
edc4 : bdf91c           					lbsr	sPUTSTR
                        					
                        					;--------- heart beat ~1 sec period -------------
edc7 : ecc4             _loop1				ldd		0,u					; get heart beat countdown
edc9 : 830001           					subd    #1
edcc : 2608             					bne     _loop2
edce : c62e             					ldb		#'.'
edd0 : f7c800           					stb		DEBUG_MON_PORT 		; write the dot as life che
edd3 : cc1fff           					ldd		#$1fff
edd6 : edc4             _loop2				std		0,u					; save heart beat countdown				
edd8 : 20d7             					bra		loop
edda : 0d41504c207265.. APL_RESET_STR      	db      CR,"APL reset",CR,0
                        
                        ;-----------------------------------------------------
                        ; APL interface routines
                        ;-----------------------------------------------------
                        					code
                        					
                        ; APL status definitions
0030 =                  APL_RESET 			equ		'0'
0031 =                  APL_READY			equ		'1'
0032 =                  APL_BUSY			equ		'2'
0039 =                  APL_UNDEFINED		equ		'9'
                        
                        					
                        ; interface to APL API for calls from BASIC
ede6 : 7eef3c           APLgetChar			lbra	getKeyboard					
                        
ede9 : b7c800           APLsendChar			sta		DEBUG_MON_PORT 		; forward to debug
edec : 1f89             					tfr  	a,b			  		; char in B
edee : 3406             					pshs 	d			  		; charater as parameter (16-bit)
edf0 : bdef61           					lbsr  	sendCharToScreen          
edf3 : 3586             					puls 	d,pc
                        					
edf5 : 7eef81           APLcurBlinking		lbra	cursorBlinking
edf8 : 7eef85           APLcurOff			lbra	cursorOff
                        
edfb : 3406             APLclearscreen		pshs 	d
edfd : bdefa4           					lbsr	sendClearScreen
ee00 : 3586             					puls 	d,pc
                        
ee02 : 3404             APLsound			pshs b						; save duration value (lower 8-
ee04 : 5f               					clrb
ee05 : 3404             					pshs b						; save duration value (higer 8-bit)		
AS09 Assembler for M6809 [1.42].                                     Page  239
--------------------------------- merge.a09 ----------------------------------

ee07 : 3402             					pshs a						; save tone value (lower 8-bit)					
ee09 : 3404             					pshs b						; save tone value (higer 8-bit)					
ee0b : bdf005           					lbsr	setTone
ee0e : 3264             					leas 4,s					; free parameters
ee10 : 39               					rts
                        
ee11 : 3402             APLsetXY			pshs a						; save ver value (lower 8-bit)
ee13 : 4f               					clra
ee14 : 3402             					pshs a						; save ver value (higer 8-bit)					
ee16 : 3406             					pshs d						; save hor value (16-bit)
ee18 : bdefc1           					lbsr 	setpointXY			; character location (hor in 0
ee1b : 3264             					leas 4,s					; free parameters
ee1d : 39               					rts
                        
                        ;-----------------------------------------------------
                        ; APL initialization
                        ; param: 	none
                        ; return:	none
                        ;-----------------------------------------------------
ee1e : 3410             APL_init			pshs	x					; save register(s)
                        
ee20 : 7f7ff0           					clr		BasicCallBack		; unused the next callback ad
ee23 : 7f7ff1           					clr		BasicCallBack+1
                        
                        					; init APL output stream interpretation
ee26 : 8639             					lda		#APL_UNDEFINED
ee28 : b77fe3           					sta		APLstatus
ee2b : 7f7fe4           					clr		KeyboardRbHead
ee2e : 7f7fe5           					clr		KeyboardRbTail
                        				
ee31 : bdf0ac           					lbsr	UART_Init			; initialize the communication w
                        
ee34 : 8effff           					ldx		#$ffff				; timeout count
ee37 : 301f             _APL_init0			leax	-1,x
ee39 : 2742             					beq		_APL_init4
ee3b : bdeebc           					lbsr	APL_OutputStream	; process the APL output st
ee3e : c131             					cmpb	#APL_READY				
ee40 : 26f5             					bne		_APL_init0			; wait until ready
                        					
ee42 : 8eee80           					ldx		#STR_BASIC
ee45 : bdf91c           					lbsr	sPUTSTR	
ee48 : c620             					ldb		#BASIC_PROCESS_ID
ee4a : 3406             					pshs	d
ee4c : bdfacd           					lbsr	HEXBYTE2MONPORT
ee4f : c60d             					ldb		#CR
ee51 : 3406             					pshs	d
ee53 : bdfaed           					lbsr	BYTE2MONPORT
ee56 : bdfaed           					lbsr	BYTE2MONPORT
ee59 : 3264             					leas	4,s					; clear the 2 pshs
                        										
ee5b : 5f               					clrb
ee5c : bdefa4           					lbsr	sendClearScreen
                        					
ee5f : 8eecf4           					ldx		#BOOT_SCR					
ee62 : e680             _APL_init1			ldb		,x+
ee64 : 2711             					beq		_APL_init3 			; string ends with NULL
ee66 : 4f               					clra
ee67 : 3406             					pshs	d
ee69 : bdef61           					lbsr	sendCharToScreen
ee6c : 3262             					leas	2,s
ee6e : bdeebc           _APL_init2			lbsr	APL_OutputStream	; process the APL o
ee71 : c131             					cmpb	#APL_READY				
AS09 Assembler for M6809 [1.42].                                     Page  240
--------------------------------- merge.a09 ----------------------------------

ee73 : 26f9             					bne		_APL_init2			; wait until ready					
ee75 : 20eb             					bra		_APL_init1					
ee77 : cc8002           _APL_init3			ldd		#BASIC_ORG			; init first time BASIC
ee7a : fd7ff0           					std		BasicCallBack
ee7d : 3510             _APL_init4			puls	x					; restore the register(s)
ee7f : 39               					rts
ee80 : 0d737461727469.. STR_BASIC      		db      CR,"starting BASIC process ID
                        
                        ;-----------------------------------------------------
                        ; basic process
                        ; param: 	none
                        ; return:	APLstatus -> B
                        ;-----------------------------------------------------
ee9c : 8d1e             BASICprocess		bsr		APL_OutputStream	; process the APL 
ee9e : c131             					cmpb	#APL_READY				
eea0 : 2619             					bne		_BASICprocess2		; skip BASIC when APL not re
                        					
eea2 : 3447             					pshs	d,u,cc				; save the registers					
eea4 : be7ff0           					ldx  	BasicCallBack
eea7 : 2710             					beq		_BASICprocess1		; skip the process execution
eea9 : 10ff7fee         					sts		MonSavReg_S
eead : cceeb5           					ldd  	#_BASICprocess0
eeb0 : fd7ff0           					std  	BasicCallBack
eeb3 : 6e84             					jmp		0,x
eeb5 : 10fe7fee         _BASICprocess0		lds		MonSavReg_S
eeb9 : 3547             _BASICprocess1		puls	d,u,cc				; restore the registers
eebb : 39               _BASICprocess2		rts
                        					
                        ;-----------------------------------------------------
                        ; APL output stream process
                        ; param: 	none
                        ; return:	APLstatus -> B
                        ;-----------------------------------------------------
eebc : 3410             APL_OutputStream	pshs	x					; save register(s)
eebe : 8e0001           					ldx		#1					; sAPLgetOutput param: 1 iteration on
eec1 : 8d51             					bsr		sAPLgetOutput		; get first protocol byte				
eec3 : 4d               					tsta
eec4 : 2748             					beq		_APL_OutputStream5										
eec6 : c155             					cmpb	#'U'				; Upload msg
eec8 : 2644             					bne		_APL_OutputStream5
                        				
eeca : 8effff           					ldx		#$ffff				; sAPLgetOutput param: max iterati
eecd : 8d45             					bsr		sAPLgetOutput		; get second protocol byte
eecf : 4d               					tsta
eed0 : 273c             					beq		_APL_OutputStream5
eed2 : c161             					cmpb	#'a'				; st'A'tus msg type
eed4 : 261b             					bne		_APL_OutputStream2
eed6 : 8d3c             					bsr		sAPLgetOutput		; get status value
eed8 : 4d               					tsta
eed9 : 2733             					beq		_APL_OutputStream5
eedb : 3404             					pshs	b					; save status value
eedd : 8d35             					bsr		sAPLgetOutput		; CR
eedf : 4d               					tsta	
eee0 : 270b             					beq		_APL_OutputStream1
eee2 : c10d             					cmpb	#CR
eee4 : 2607             					bne		_APL_OutputStream1
eee6 : 3504             					puls	b					; restore status value
eee8 : f77fe3           					stb		APLstatus
eeeb : 2021             					bra		_APL_OutputStream5
eeed : 3261             _APL_OutputStream1 	leas	1,s					; free unrestored val
eeef : 201d             					bra		_APL_OutputStream5
                        					
AS09 Assembler for M6809 [1.42].                                     Page  241
--------------------------------- merge.a09 ----------------------------------

eef1 : c16b             _APL_OutputStream2	cmpb	#'k'				; 'K'eyboard msg type
eef3 : 2619             					bne		_APL_OutputStream5
                        					
eef5 : 8d1d             					bsr		sAPLgetOutput		; get msg length
eef7 : 4d               					tsta
eef8 : 2714             					beq		_APL_OutputStream5
eefa : 8d18             					bsr		sAPLgetOutput		; get char value
eefc : 4d               					tsta
eefd : 270f             					beq		_APL_OutputStream5
eeff : 3404             					pshs	b					; save value
ef01 : 8d11             					bsr		sAPLgetOutput		; get CR
ef03 : 4d               					tsta
ef04 : 27e7             					beq		_APL_OutputStream1
ef06 : c10d             					cmpb	#CR
ef08 : 26e3             					bne		_APL_OutputStream1
ef0a : 3504             					puls	b
ef0c : 8d11             					bsr		sAPL_KeyboardData
ef0e : 4f               _APL_OutputStream5	clra
ef0f : f67fe3           					ldb		APLstatus			; return the APL status					
ef12 : 3590             					puls	x,pc				; restore the register(s) and return
                        					
                        ;-----------------------------------------------------
                        ; Get APL output stream with timeout
                        ; param: 	X -> timeout iterations
                        ; return:	char in -> B and A when != 0
                        ;-----------------------------------------------------
ef14 :                  sAPLgetOutput ;{					
ef14 : bdf0cb           _sAPLgetOutput1		lbsr	UartRead
ef17 : 4d               					tsta
ef18 : 2604             					bne		_sAPLgetOutput2
ef1a : 301f             					leax	-1,x				; dec iteration counter
ef1c : 26f6             					bne		_sAPLgetOutput1
ef1e : 39               _sAPLgetOutput2		rts
                        ;}
                        ;-----------------------------------------------------
                        ; Store APL keyboard data in the keyboard RB
                        ; param: 	key value in -> B
                        ; return:	none
                        ;-----------------------------------------------------
ef1f : 3410             sAPL_KeyboardData	pshs	x					; save register(s)
ef21 : 8e7fe6           					ldx     #KeyboardRbuffer	; get buffer base addr		
ef24 : b67fe4           					lda		KeyboardRbHead		; head index value
ef27 : 3086             					leax	a,x					; set X to the head pointer
ef29 : 4c               					inca				
ef2a : 8108             					cmpa	#KeyboardRbSize
ef2c : 2501             					blo		_APL_KeyboardData1
ef2e : 4f               					clra
ef2f : b17fe5           _APL_KeyboardData1  cmpa	KeyboardRbTail
ef32 : 2705             					beq		_APL_KeyboardData2
ef34 : b77fe4           					sta     KeyboardRbHead
ef37 : e784             					stb		,x					; store data to keyboard RB head poin
ef39 : 3510             _APL_KeyboardData2	puls	x					; restore the register(s
ef3b : 39               					rts					
                        
                        ;-----------------------------------------------------
                        ; Get keyboard char from ringbuffer (C call compatible
                        ; param: 	none
                        ; return:	key value as char (or zero when no key was p
                        ;-----------------------------------------------------
ef3c :                  getKeyboard ;{
ef3c : bdef59           getKeybo			lbsr	isKeyboardData
ef3f : 5d               					tstb
AS09 Assembler for M6809 [1.42].                                     Page  242
--------------------------------- merge.a09 ----------------------------------

ef40 : 2716             					beq		_getKeyboard2		; fifo empty when tail = head
ef42 : 3410             					pshs	x
ef44 : 8e7fe6           					ldx		#KeyboardRbuffer
ef47 : b67fe5           					lda		KeyboardRbTail					
ef4a : e686             					ldb		a,x
ef4c : 3510             					puls	x
ef4e : 4c               					inca						; inc tail index
ef4f : 8108             					cmpa	#KeyboardRbSize
ef51 : 2501             					blo		_getKeyboard1
ef53 : 4f               					clra						; wrap RbTail
ef54 : b77fe5           _getKeyboard1		sta		KeyboardRbTail		; save updated tai
ef57 : 4f               					clra
ef58 : 39               _getKeyboard2		rts
                        
                        ;-----------------------------------------------------
                        ; isKeyboardData in the ringbuffer? (C call compatible
                        ; param: 	none
                        ; return:	when no data, 0 -> D (unsigned int)
                        ;-----------------------------------------------------
ef59 :                  isKeyboardData ;{
ef59 : f67fe4           isKeyboa			ldb		KeyboardRbHead
ef5c : f07fe5           					subb	KeyboardRbTail
ef5f : 4f               					clra
ef60 : 39               					rts
                        ;}
                        
                        ;-----------------------------------------------------
                        ; Send a char to the screen [Text mode] (C call compat
                        ; param: 	2,s -> unused
                        ;			3,s -> char to send
                        ; return:	none
                        ;-----------------------------------------------------
ef61 :                  sendCharToScreen ;{
ef61 : bdf0e2           					lbsr	waitSendDone
ef64 : bdf0ea           					lbsr	waitCTS
ef67 : c644             					ldb		#'D'				; sending
ef69 : f7d000           					stb		UART
ef6c : c666             					ldb		#'f'				; cmd
ef6e : f7d000           					stb		UART
ef71 : c631             					ldb		#'1'				; len
ef73 : f7d000           					stb		UART
ef76 : e663             					ldb		3,s
ef78 : f7d000           					stb 	UART  				; char
ef7b : c60d             					ldb		#CR					; end
ef7d : f7d000           					stb		UART				
ef80 : 39               					rts
                        ;}
                        
                        ;-----------------------------------------------------
                        ; Set the screen cursor propriety [Text mode], (C call
                        ; param: 	none
                        ; return:	none
                        ;-----------------------------------------------------
ef81 : 8662             cursorBlinking		lda		#'b'				; param 'b' for blinking
ef83 : 2002             					bra		_sCursor1
ef85 : 8630             cursorOff   		lda		#'0'				; param '0' for Off
ef87 : 3402             _sCursor1			pshs	a
ef89 : bdf0e2           					lbsr	waitSendDone
ef8c : bdf0ea           					lbsr	waitCTS
ef8f : 3502             					puls	a
ef91 : c644             					ldb		#'D'				; sending
ef93 : f7d000           					stb		UART
AS09 Assembler for M6809 [1.42].                                     Page  243
--------------------------------- merge.a09 ----------------------------------

ef96 : c663             					ldb		#'c'				; cmd
ef98 : f7d000           					stb		UART
ef9b : b7d000           					sta 	UART  				; param
ef9e : c60d             					ldb		#CR					; end
efa0 : f7d000           					stb		UART				
efa3 : 39               					rts
                        	
                        ;-----------------------------------------------------
                        ; Send the clear screen command (C call compatible)
                        ; param: 	2,s -> unused
                        ;			3,s -> color
                        ; return:	none
                        ;-----------------------------------------------------
efa4 :                  sendClearScreen ;{
efa4 : bdf0e2           					lbsr	waitSendDone
efa7 : bdf0ea           					lbsr	waitCTS
efaa : c644             					ldb		#'D'				; sending
efac : f7d000           					stb		UART
efaf : c66c             					ldb		#'l'				; cmd
efb1 : f7d000           					stb		UART
efb4 : e663             					ldb		3,s
efb6 : cb30             					addb	#'0'
efb8 : f7d000           					stb		UART				; color
efbb : c60d             					ldb		#CR					; end
efbd : f7d000           					stb		UART				
efc0 : 39               					rts	
                        ;}		
                        			
                        ;-----------------------------------------------------
                        ; Send the setpointXY command (C call compatible)
                        ; param: 	2,s -> unused
                        ;			3,s -> x
                        ;			4,s -> unused
                        ;			5,s -> y
                        ; return:	none
                        ;-----------------------------------------------------
efc1 :                  setpointXY ;{
efc1 : bdf0e2           setpoint			lbsr	waitSendDone
efc4 : bdf0ea           					lbsr	waitCTS
efc7 : c644             					ldb		#'D'				; sending
efc9 : f7d000           					stb		UART
efcc : c670             					ldb		#'p'				; cmd
efce : f7d000           					stb		UART
efd1 : e663             					ldb		3,s
efd3 : cb30             					addb	#'0'
efd5 : f7d000           					stb		UART				; x
efd8 : e665             					ldb		5,s
efda : cb30             					addb	#'0'
efdc : f7d000           					stb		UART				; y
efdf : c60d             					ldb		#CR					; end
efe1 : f7d000           					stb		UART				
efe4 : 39               					rts	
                        ;}	
                        
                        ;-----------------------------------------------------
                        ; Set tile index [Graph mode] (C call compatible)
                        ; param: 	2,s -> unused
                        ;			3,s -> tile index
                        ; return:	none
                        ;-----------------------------------------------------
efe5 :                  setTile ;{
efe5 : bdf0e2           					lbsr	waitSendDone
AS09 Assembler for M6809 [1.42].                                     Page  244
--------------------------------- merge.a09 ----------------------------------

efe8 : bdf0ea           					lbsr	waitCTS
efeb : c644             					ldb		#'D'				; sending
efed : f7d000           					stb		UART
eff0 : c674             					ldb		#'t'				; cmd
eff2 : f7d000           					stb		UART
eff5 : c631             					ldb		#'1'				; len
eff7 : f7d000           					stb		UART
effa : e663             					ldb		3,s
effc : f7d000           					stb 	UART  				; index
efff : c60d             					ldb		#CR					; end
f001 : f7d000           					stb		UART				
f004 : 39               					rts
                        ;}
                        
                        ;-----------------------------------------------------
                        ; Send the tone command (C call compatible)
                        ; param: 	2,s -> unused
                        ;			3,s -> tone (8-bit)
                        ;			4,s -> unused
                        ;			5,s -> duration (8-bit)
                        ; return:	none
                        ;-----------------------------------------------------
f005 :                  setTone ;{
f005 : bdf0e2           					lbsr	waitSendDone
f008 : bdf0ea           					lbsr	waitCTS
f00b : c644             					ldb		#'D'				; sending
f00d : f7d000           					stb		UART
f010 : c66f             					ldb		#'o'				; cmd
f012 : f7d000           					stb		UART
f015 : e663             					ldb		3,s
f017 : f7d000           					stb		UART				; tone
f01a : e665             					ldb		5,s
f01c : f7d000           					stb		UART				; duration
f01f : c60d             					ldb		#CR					; end
f021 : f7d000           					stb		UART				
f024 : 39               					rts	
                        ;}	
                        
                        ;-----------------------------------------------------
                        ; Set sound index (C call compatible)
                        ; param: 	2,s -> unused
                        ;			3,s -> index
                        ; return:	none
                        ;-----------------------------------------------------
f025 :                  setSound ;{
f025 : bdf0e2           					lbsr	waitSendDone
f028 : bdf0ea           					lbsr	waitCTS
f02b : c644             					ldb		#'D'				; sending
f02d : f7d000           					stb		UART
f030 : c673             					ldb		#'s'				; cmd
f032 : f7d000           					stb		UART
f035 : e663             					ldb		3,s
f037 : cb30             					addb	#'0'				; container index
f039 : f7d000           					stb		UART					
f03c : c60d             					ldb		#CR					; end
f03e : f7d000           					stb		UART				
f041 : 39               					rts
                        ;}		
                        
                        ;-----------------------------------------------------
                        ; Send container data [Graph mode] (C call compatible)
                        ; param: 	2,s -> unused
AS09 Assembler for M6809 [1.42].                                     Page  245
--------------------------------- merge.a09 ----------------------------------

                        ;			3,s -> index
                        ;			4-5,s -> pointer (16-bit) to max 32 bytes array "R
                        ; return:	none
                        ;-----------------------------------------------------
f042 :                  sendContainerData ;{
f042 : bdf0e2           sendCont			lbsr	waitSendDone
f045 : bdf0ea           					lbsr	waitCTS
f048 : 3410             					pshs	x					; save used pointers (+2 bytes on stac
f04a : c644             					ldb		#'D'				; sending
f04c : f7d000           					stb		UART
f04f : c664             					ldb		#'d'				; cmd
f051 : f7d000           					stb		UART
f054 : c650             					ldb		#32+'0'				; len 32 bytes
f056 : f7d000           					stb		UART
f059 : e665             					ldb		5,s					; 3,s +2 bytes
f05b : cb30             					addb	#'0'				; container index
f05d : f7d000           					stb		UART
f060 : ae66             					ldx		6,s					; 4,s +2 bytes
f062 : c620             					ldb		#32
f064 : a680             _sendCtnData1		lda		,x+
f066 : b7d000           					sta 	UART  				; data 1 to 32
f069 : bdf0e2           					lbsr	waitSendDone		; check again when more than 1
f06c : bdf0ea           					lbsr	waitCTS
f06f : 5a               					decb
f070 : 26f2             					bne		_sendCtnData1					
f072 : c60d             					ldb		#CR					; end
f074 : f7d000           					stb		UART				
f077 : 3590             					puls	x,pc				; restore the register(s) and return
                        	
                        ;-----------------------------------------------------
                        ; delay in ms (C call compatible)
                        ; param: 	2-3,s -> delay value (16-bit)
                        ; return:	none
                        ;-----------------------------------------------------
                        ; msDelay ;{
                        					; ldd		#282		; 3 cycles
                        ; _msDelay0			subd	#1			; 4 cycles
                        					; bne		_msDelay0	; 3 cycles
                        					; ldd		2,s			; 5 cycles
                        					; subd	#1			; 4 cycles
                        					; std		2,s			; 5 cycles
                        					; cmpd	#0			; 5 cycles
                        					; bne		msDelay		; 3 cycles
                        					; rts
                        										; 3 + (4+3 cycles * 282) + 5+4+5+5+3 = 2000 
                        
                        ;}	;--------------------------------------------------
                        				code
                        				
                        * 
                        * PIAinit(pPort, DDR) unsigned char *pPort; unsigned c
                        *     *(pPort+1)	= 0x30; // Cx2 used as output, select
f079 :                  PIAinit
f079 : ae62             	ldx	2,s
f07b : c630             	ldb	#$30
f07d : e701             	stb	1,x
                        *     *pPort      = DDR;  // DDRx configured as: 1 for
f07f : e665             	ldb	5,s
f081 : e784             	stb	,x
                        * 
                        *     *(pPort+1)	= 0x34; // Cx2 used as output, select
f083 : c634             	ldb	#$34	
AS09 Assembler for M6809 [1.42].                                     Page  246
--------------------------------- merge.a09 ----------------------------------

f085 : e701             	stb	1,x
                        *     *pPort		= 0x00; // IOs bits cleared	
f087 : 5f               	clrb
f088 : e784             	stb	,x
                        * }
f08a : 39               	rts
                        * 
                        
                        * 
                        * PIA_Out(pPort, value) unsigned char *pPort; unsigned
                        *     *pPort	= value;
f08b :                  PIA_Out
f08b : e665             	ldb	5,s
f08d : e7f802           	stb	[2,s]
                        * }
f090 : 39               	rts
                        * 
                        * PIA_In(pPort) unsigned char *pPort; {
                        *     return *pPort;
f091 :                  PIA_In
f091 : e6f802           	ldb	[2,s]	
f094 : 4f               	clra
                        * }
f095 : 39               	rts
                        * 
                        * PIA_SetCx2(pPort) unsigned char *pPort; {
                        *     *(pPort+1)	= *(pPort+1) | 0b00001000; // set bit
f096 :                  PIA_SetC
f096 : ae62             	ldx	2,s
f098 : e601             	ldb	1,x
f09a : ca08             	orb	#$8
f09c : ae62             	ldx	2,s
f09e : e701             	stb	1,x
                        * }
f0a0 : 39               	rts
                        * 
                        * PIA_ClrCx2(pPort) unsigned char *pPort; {
                        *     *(pPort+1)	= *(pPort+1) & 0b11110111;// clear bi
f0a1 :                  PIA_ClrC
f0a1 : ae62             	ldx	2,s
f0a3 : e601             	ldb	1,x
f0a5 : c4f7             	andb #$f7
f0a7 : ae62             	ldx	2,s
f0a9 : e701             	stb	1,x
                        * }
f0ab : 39               	rts
                        * ;---------------------------------------------------
                        				code
                        				
                        ;----------------------------------------------------;
                        ; UART Init
                        ; param: 	none
                        ; return:	none
                        ;----------------------------------------------------;
f0ac :                  UART_Init	;{
f0ac : 8680             				lda		#$80			; DLAB=1
f0ae : b7d003           				sta		UART+3
                        				
                        										; 12MHz ->  78:baudrate 9600,               
                        										; 16MHz -> 104:baudrate 9600, 26:baudrate 38
                        										; 24MHz -> 156:baudrate 9600, 39:baudrate 38
f0b1 : 8611             				lda		#17
AS09 Assembler for M6809 [1.42].                                     Page  247
--------------------------------- merge.a09 ----------------------------------

f0b3 : b7d000           				sta		UART
f0b6 : 8600             				lda		#$00	  	
f0b8 : b7d001           				sta		UART+1
                        				
f0bb : 8601             				lda		#$01	  		; Fifo enable
f0bd : b7d002           				sta		UART+2
                        				
f0c0 : 8603             				lda		#$03			; DLAB=0, config 8N1 
f0c2 : b7d003           				sta		UART+3
                        				
f0c5 : 8601             				lda		#$01			; enable rx interrrupt
f0c7 : b7d001           				sta		UART+1
f0ca : 39               				rts
                        ;}
                        
                        ;----------------------------------------------------;
                        ; UART Read
                        ; param: 	none
                        ; return:	read byte -> B when when A != 0
                        ;----------------------------------------------------;
f0cb :                  UartRead ;{
f0cb : b6d005           				lda		UART+5 			; check if a byte is available
f0ce : 8401             				anda	#1				; a contains not NULL when a byte avail
f0d0 : 2703             				beq		_UartRead1
f0d2 : f6d000           				ldb 	UART   			; read first byte
f0d5 : 39               _UartRead1		rts
                        ;}
                        
                        ;----------------------------------------------------;
                        ; wait until a char available or 256 polling cycles ti
                        ; param: 	none
                        ; return:	none
                        ;----------------------------------------------------;
f0d6 :                  waitdata ;{		
f0d6 : 5f               				clrb
f0d7 : 5a               _waitdata1		decb
f0d8 : 2707             				beq		_waitdata2 		; exit
f0da : b6d005           				lda		UART+5 			; check if a byte is available
f0dd : 8401             				anda	#1
f0df : 27f6             				beq		_waitdata1		
f0e1 : 39               _waitdata2		rts
                        ;}
                        
                        ;----------------------------------------------------;
                        ; wait until the remaining char is sent (fifo empty)
                        ; param: 	none
                        ; return:	none
                        ;----------------------------------------------------;
f0e2 :                  waitSendDone ;{
f0e2 : b6d005           				lda		UART+5 			; check if uart TX ready (waiting f
f0e5 : 8420             				anda	#$20
f0e7 : 27f9             				beq		waitSendDone		
f0e9 : 39               				rts
                        ;}
                        
                        ;----------------------------------------------------;
                        ; wait CTS
                        ; param: 	none
                        ; return:	none
                        ;----------------------------------------------------;
f0ea :                  waitCTS ;{
f0ea : b6d006           				lda		UART+6 			; read the moden status register
AS09 Assembler for M6809 [1.42].                                     Page  248
--------------------------------- merge.a09 ----------------------------------

f0ed : 8410             				anda	#$10
f0ef : 27f9             				beq		waitCTS
f0f1 : 39               				rts
                        ;}
                        ;{ ---------------------------------------------------
                        					code
                        					
f0f2 : 302e392e302e3000 MON_VERSION     	db		"0.9.0.0",0			; version [major, m
                        					
                        ;---------------------------------------------------
                        ; write commands menu with version in terminal
                        ;---------------------------------------------------
f0fa : 0d737461727469.. STR_MONITOR      	db      CR,"starting monitor process
f118 : 0d4d6f6e69746f.. STR_VERSION			db		CR,"Monitor for 6809 Computer v",0
f135 : 0d636f6d6d616e.. STR_COMMAND			db		CR,"command menu",CR
f143 : 72205b66697273.. 					db		"r [first addr] (optional [n repeat]) reads t
f17c : 77205b61646472.. 					db		"w [addr] [data], optional [n repeat] writes 
f1b9 : 65205b7372635d.. 					db		"e [src] [dst] [length] (optional [protection
f1ff : 6c206f72206c20.. 					db		"l or l [offset] loads a SRec data",CR
f221 : 67205b61646472.. 					db		"g [addr] executes at the address",CR
f242 : 73205b70726f63.. 					db		"s [process ID] stops the process",CR
f263 : 62205b61646472.. 					db		"b [addr] sets debugging mode a breakpoint at
f29c : 71207175697473.. 					db		"q quits debugging mode",CR
f2b3 : 42205b42415349.. 					db		"B [BASIC line entry]",CR
f2c8 : 4c206c6f616473.. 					db		"L loads a BASIC program",CR
f2e0 : 68207468697320.. 					db		"h this menu",CR,0
                        
f2ed : cc0000           sMONITORSTART		ldd		#BrkPtOff			; init break point var
f2f0 : fd7fbd           					std		BrkPtAddr										
f2f3 : bdf322           					lbsr	sRbInit				; monitor init ring buffer
f2f6 : 1cef             					andcc	#ENABLE_MON_INT		; enable monitor interrupt
                        					
f2f8 : 8ef0fa           					ldx		#STR_MONITOR		; monitor start-up message
f2fb : bdf91c           					lbsr	sPUTSTR				;	
f2fe : c610             					ldb		#MONITOR_PROCESS_ID
f300 : 3406             					pshs	d
f302 : bdfacd           					lbsr	HEXBYTE2MONPORT
f305 : c60d             					ldb		#CR
f307 : 3406             					pshs	d
f309 : bdfaed           					lbsr	BYTE2MONPORT
f30c : 3264             					leas	4,s					; clear 2 pushes
f30e : 39               					rts
                        												; print help menu at startup
f30f : 8ef118           sMONITORMENU		ldx		#STR_VERSION
f312 : bdf91c           					lbsr	sPUTSTR
f315 : 8ef0f2           					ldx		#MON_VERSION
f318 : bdf91c           					lbsr	sPUTSTR
f31b : 8ef135           					ldx		#STR_COMMAND
f31e : bdf91c           					lbsr	sPUTSTR
f321 : 39               					rts
                        
                        	;{ --------------------------------------------------
f322 :                  sRbInit	
                        		;---------------------------------------------------
                        		; asm call init ring buffer
                        		;---------------------------------------------------
                        		;{
f322 : 7f7fc0           					clr		RbHead
f325 : 7f7fc1           					clr		RbTail
f328 : 7f7fe2           					clr		RbDectCR
f32b : 39               					rts
                        		;}
AS09 Assembler for M6809 [1.42].                                     Page  249
--------------------------------- merge.a09 ----------------------------------

                        
f32c :                  sRbReadCmd 
                        		;---------------------------------------------------
                        		; asm call read a byte from ringbuffer (a 'CR' must 
                        		; param:	none
                        		; return:	cmd value -> A. when invalid, NULL -> B
                        		;---------------------------------------------------
                        		;{
f32c : 5f               					clrb						; no char by default
f32d : b67fe2           					lda		RbDectCR
f330 : 2724             					beq		_sRbRead3			; still no CR in the cmd buffer
                        		
f332 : f67fc1           sRbRead				ldb		RbTail
f335 : f17fc0           					cmpb	RbHead
f338 : 2716             					beq		_sRbRead11			; fifo empty when tail = head
f33a : 3410             					pshs	x
f33c : 8e7fc2           					ldx		#Rbuffer
f33f : a685             					lda		b,x
f341 : 3510             					puls	x
f343 : 5c               					incb						; inc tail index
f344 : c120             					cmpb	#RbSize
f346 : 2501             					blo		_sRbRead1
f348 : 5f               					clrb						; wrap RbTail
f349 : f77fc1           _sRbRead1			stb		RbTail				; save updated tail index o
f34c : c601             					ldb		#1					; not null when valid
f34e : 2004             					bra		_sRbRead2
f350 : 7f7fe2           _sRbRead11			clr		RbDectCR			; no more CR possible
f353 : 5f               					clrb						; no char
f354 : 1cef             _sRbRead2			andcc	#ENABLE_MON_INT		; re-enable int in 
f356 : 39               _sRbRead3			rts
                        
                        	;}
                        
f357 :                  sMonProcessCmd
                        		;---------------------------------------------------
                        		; asm call extract and execute the cmd
                        		;---------------------------------------------------
                        		;{
f357 : 8dd3             					bsr		sRbReadCmd
f359 : 5d               					tstb						; RB empty ?
f35a : 273e             					beq		_sMonProcessCmd					
f35c : 8168             					cmpa	#'h'
f35e : 273b             					beq		sCMDhelp 			; help command
f360 : 8172             					cmpa	#'r'
f362 : 2746             					beq		sCMDrd  			; read command
f364 : 8177             					cmpa	#'w'
f366 : 102700b6         					lbeq	sCMDwr  			; write command
f36a : 8165             					cmpa	#'e'
f36c : 1027019b         					lbeq	sCMDew 				; eeprom write command
f370 : 816c             					cmpa	#'l'
f372 : 1027028d         					lbeq	sCMDld  			; load SRec command
f376 : 8167             					cmpa	#'g'
f378 : 10270367         					lbeq	sCMDgo  			; Go command
f37c : 8173             					cmpa	#'s'
f37e : 102703a1         					lbeq	sCMDStp  			; Stop process command
f382 : 8162             					cmpa	#'b'
f384 : 102703fe         					lbeq	sCMDbp  			; breakpoint command
f388 : 8171             					cmpa	#'q'
f38a : 1027047c         					lbeq	sCMDqbp  			; stop debugging command
f38e : 8142             					cmpa	#'B'
f390 : 10270505         					lbeq	sCMDbas  			; BASIC line entry command
f394 : 814c             					cmpa	#'L'
AS09 Assembler for M6809 [1.42].                                     Page  250
--------------------------------- merge.a09 ----------------------------------

f396 : 102704bc         					lbeq	sCMDldbas			; load BASIC program command
f39a : 39               _sMonProcessCmd		rts  						; cmd no existing
                        
                        			;--------------------------------------------------
f39b : 8d8f             sCMDhelp 			bsr		sRbReadCmd
f39d : 5d               					tstb
f39e : 2709             					beq		_sCMDhelp				
f3a0 : 810d             					cmpa	#CR
f3a2 : 1026052b         					lbne	sCMDinvalid  		; not CR, invalid CMD
f3a6 : bdf30f           					lbsr	sMONITORMENU
f3a9 : 39               _sCMDhelp			rts							; exit
                        			
                        			;--------------------------------------------------
f3aa :                  sCMDrd
0000 =                  RdAddr				equ		0					; uint RdAddr index
0002 =                  RdRepeat			equ		2					; uint Count index
f3aa : 3440             					pshs	u
f3ac : 327e             					leas	-2,s				; allocate 16-bit
f3ae : 327e             					leas	-2,s				; allocate 16-bit
f3b0 : 33e4             					leau	,s					; use the U as pointer
f3b2 : 4f               					clra
f3b3 : 5f               					clrb
f3b4 : ed42             					std		RdRepeat,u 			; set to 0 by default
                        				
                        					;------- extract the ' ' only -------------------
f3b6 : bdf8d8           					lbsr	sCMDextr
f3b9 : c120             					cmpb	#' '
f3bb : 2615             					bne		_sCMDrdinvalid	
                        				
                        					;------- extract 'raddr' --------------------
f3bd : bdf8d8           					lbsr	sCMDextr
f3c0 : 5d               					tstb
f3c1 : 270f             					beq		_sCMDrdinvalid
f3c3 : afc4             					stx		RdAddr,u 			; save read param 1
f3c5 : c10d             					cmpb	#CR					; check if a repeat param follows
f3c7 : 2714             					beq		_sCMDexe_rd0
                        				
                        					;------- extract the optional 'repeat' ----------
f3c9 : bdf8d8           					lbsr	sCMDextr
f3cc : af42             					stx		RdRepeat,u 			; save read param 2
f3ce : c10d             					cmpb	#CR
f3d0 : 270b             					beq		_sCMDexe_rd0
f3d2 : bdf8d1           _sCMDrdinvalid		lbsr	sCMDinvalid
f3d5 : 2042             					bra		_sCMDrddone
                        				
f3d7 : 0d7265616400     STR_CMD_rd			db		CR,"read",0
f3dd : 8ef3d7           _sCMDexe_rd0		ldx		#STR_CMD_rd
f3e0 : bdf91c           					lbsr	sPUTSTR
                        				
f3e3 : c60d             _sCMDexe_rd1   		ldb		#CR
f3e5 : bdecdf           					lbsr	sMON_PORT_WR		; CR when begin with addr
f3e8 : ecc4             					ldd		RdAddr,u
f3ea : 3406             					pshs	d
f3ec : bdfa98           					lbsr	HEXWORD2MONPORT
f3ef : 3262             					leas	2,s
f3f1 : c620             _sCMDexe_rd2		ldb		#' '
f3f3 : bdecdf           					lbsr	sMON_PORT_WR
f3f6 : e6d4             					ldb		[RdAddr,u]
f3f8 : 3406             					pshs	d
f3fa : bdfacd           					lbsr	HEXBYTE2MONPORT
f3fd : 3262             					leas	2,s
f3ff : ec42             					ldd		RdRepeat,u
AS09 Assembler for M6809 [1.42].                                     Page  251
--------------------------------- merge.a09 ----------------------------------

f401 : 10830000         					cmpd	#0
f405 : 2712             					beq		_sCMDrddone
f407 : 830001           					subd	#1
f40a : ed42             					std		RdRepeat,u
f40c : ecc4             					ldd		RdAddr,u
f40e : c30001           					addd	#1
f411 : edc4             					std		RdAddr,u
f413 : c41f             					andb	#$1f
f415 : 27cc             					beq		_sCMDexe_rd1		; write addr at begin
f417 : 20d8             					bra		_sCMDexe_rd2
f419 : 3262             _sCMDrddone			leas	2,s					; free 16-bit param 2
f41b : 3262             					leas	2,s					; free 16-bit param 1
f41d : 3540             					puls	u
f41f : 39               					rts  						; exit
                        
                        ;----------------------------------------------------;
f420 :                  sCMDwr
0000 =                  WrAddr				equ		0					; uint WrAddr index
0002 =                  WrData				equ		2					; uchar WrData index
0003 =                  WrRepeat			equ		3					; uint repeat
f420 : 3440             					pshs	u
f422 : 327e             					leas	-2,s				; allocate 16-bit
f424 : 327f             					leas	-1,s				; allocate 8-bit
f426 : 327e             					leas	-2,s				; allocate 16-bit
f428 : 33e4             					leau	,s					; use the U as pointer
f42a : 4f               					clra
f42b : 5f               					clrb
f42c : ed43             					std		WrRepeat,u 			; set to 0 by default
                        					
                        					;------- extract the ' ' only -------------------
f42e : bdf8d8           					lbsr	sCMDextr
f431 : c120             					cmpb	#' '
f433 : 262c             					bne		_sCMDwrInvalid
                        
                        					;------- extract 'waddr' --------------------
f435 : bdf8d8           					lbsr	sCMDextr
f438 : c10d             					cmpb	#CR
f43a : 2725             					beq		_sCMDwrInvalid		; CR shall come later
f43c : c120             					cmpb	#' '
f43e : 2621             					bne		_sCMDwrInvalid		
f440 : 8ce000           					cmpx	#ROM0_ORG			; avoid write in ROM
f443 : 241c             					bhs		_sCMDwrInvalid
f445 : afc4             					stx		WrAddr,u 			; save read param 1
                        					
                        					;------- extract 'wdata' --------------------
f447 : bdf8d8           					lbsr	sCMDextr
f44a : 1e10             					exg		x,d
f44c : e742             					stb		WrData,u 			; save read param 2
f44e : 1e10             					exg		x,d
f450 : c10d             					cmpb	#CR					; check if param ended
f452 : 271a             					beq		_sCMDwr1
f454 : c120             					cmpb	#' '				; check if a repeat param follows
f456 : 2609             					bne		_sCMDwrInvalid				
                        					
                        					;------- extract the optional 'repeat' ----------
f458 : bdf8d8           					lbsr	sCMDextr
f45b : af43             					stx		WrRepeat,u 			; save read param 3
f45d : c10d             					cmpb	#CR
f45f : 270d             					beq		_sCMDwr1				
                        				
f461 : bdf8d1           _sCMDwrInvalid		lbsr	sCMDinvalid
f464 : 204812           					lbra	_sCMDwrdone
AS09 Assembler for M6809 [1.42].                                     Page  252
--------------------------------- merge.a09 ----------------------------------

                        				
f467 : 0d777269746500   STR_CMD_wr			db		CR,"write",0
f46e : 8ef467           _sCMDwr1			ldx		#STR_CMD_wr
f471 : bdf91c           					lbsr	sPUTSTR
f474 : c60d             _sCMDexe_wr1     	ldb		#CR					; CR when begin with ad
f476 : bdecdf           					lbsr	sMON_PORT_WR
f479 : ecc4             					ldd		WrAddr,u
f47b : 3406             					pshs	d
f47d : bdfa98           					lbsr	HEXWORD2MONPORT
f480 : 3262             					leas	2,s
f482 : c620             _sCMDexe_wr2		ldb		#' '
f484 : bdecdf           					lbsr	sMON_PORT_WR
f487 : e642             					ldb		WrData,u
f489 : 3406             					pshs	d
f48b : bdfacd           					lbsr	HEXBYTE2MONPORT
f48e : 3262             					leas	2,s
f490 : a642             					lda		WrData,u
f492 : a7d4             					sta		[WrAddr,u]			; perform the write
f494 : ec43             					ldd		WrRepeat,u
f496 : 10830000         					cmpd	#0
f49a : 2712             					beq		_sCMDwrdone
f49c : 830001           					subd	#1
f49f : ed43             					std		WrRepeat,u
f4a1 : ecc4             					ldd		WrAddr,u
f4a3 : c30001           					addd	#1
f4a6 : edc4             					std		WrAddr,u
f4a8 : c41f             					andb	#$1f
f4aa : 27c8             					beq		_sCMDexe_wr1		; write addr at begin
f4ac : 20d4             					bra		_sCMDexe_wr2
                        	
f4ae : 3262             _sCMDwrdone			leas	2,s					; free 16-bit param 3
f4b0 : 3261             					leas	1,s					; free 8-bit param 2
f4b2 : 3262             					leas	2,s					; free 16-bit param 1
f4b4 : 3540             					puls	u
f4b6 : 39               					rts							; exit
                        
                        ;----------------------------------------------------;
f4b7 : 0d77726974696e.. STR_EW1				db		CR,"writing ",0
f4c1 : 20627974652873.. STR_EW2				db		" byte(s) from ",0
f4d0 : 20746f2000       STR_EW3				db		" to ",0
f4d5 : 2c20706c656173.. STR_EW4				db		", please wait ...",0
f4e7 : 0d656570726f6d.. STR_EWdone			db		CR,"eeprom writing done, ",0
f4fe : 436865636b5375.. STR_EW_CS			db		"CheckSum16: ",0
f50b : 3440             sCMDew				pshs	u					; save register(s)
                        					;------- extract ' ' --------------------
f50d : bdf8d8           					lbsr	sCMDextr
f510 : c120             					cmpb	#' '
f512 : 262f             					bne		_sCMDewInvalid0					
                        					
                        					;------- extract 'src' until ' ' ----------------
f514 : bdf8d8           					lbsr	sCMDextr
f517 : 3410             					pshs	x					; push WriteEEP param 1 (src)
f519 : c120             					cmpb	#' '
f51b : 2624             					bne		_sCMDewInvalid1					
                        					
                        					;------- extract 'dst'until' ' ------------------
f51d : bdf8d8           					lbsr	sCMDextr
f520 : 3410             					pshs	x 					; push WriteEEP param 2 (dst)
f522 : c120             					cmpb	#' '
f524 : 2619             					bne		_sCMDewInvalid2								
                        					
                        					;------- extract 'len'until' ' ------------------
AS09 Assembler for M6809 [1.42].                                     Page  253
--------------------------------- merge.a09 ----------------------------------

f526 : bdf8d8           					lbsr	sCMDextr
f529 : 3410             					pshs	x 					; push WriteEEP param 3 (len)
f52b : 8e0000           					ldx		#0					; no protection param by default
f52e : c10d             					cmpb	#CR
f530 : 2717             					beq		_sCMDew1			; no protection param
f532 : c120             					cmpb	#' '
f534 : 2607             					bne		_sCMDewInvalid3					
                        					
                        					;------- extract 'protection'until'CR' ----------
f536 : bdf8d8           					lbsr	sCMDextr					
f539 : c10d             					cmpb	#CR
f53b : 270c             					beq		_sCMDew1				; branch when OK, otherwise free
f53d : 3262             _sCMDewInvalid3		leas	2,s					; free WriteEEP param 3
f53f : 3262             _sCMDewInvalid2		leas	2,s					; free WriteEEP param 2
f541 : 3262             _sCMDewInvalid1		leas	2,s					; free WriteEEP param 1
f543 : bdf8d1           _sCMDewInvalid0		lbsr	sCMDinvalid
f546 : 205f12           					lbra	_sCMDewdone
                        
f549 : 3410             _sCMDew1			pshs	x 					; WriteEEP param 4 (protection)
f54b : 33e4             					leau	0,s					; use U as parameter pointer
f54d : 8ef4b7           					ldx		#STR_EW1
f550 : bdf91c           					lbsr	sPUTSTR
f553 : ec42             					ldd		2,u					; print param 3 (length in byte)
f555 : 3406             					pshs	d
f557 : bdfa98           					lbsr	HEXWORD2MONPORT
f55a : 3262             					leas	2,s
f55c : 8ef4c1           					ldx		#STR_EW2
f55f : bdf91c           					lbsr	sPUTSTR
f562 : ec46             					ldd		6,u					; print param 2 (source)
f564 : 3406             					pshs	d
f566 : bdfa98           					lbsr	HEXWORD2MONPORT
f569 : 3262             					leas	2,s
f56b : 8ef4d0           					ldx		#STR_EW3
f56e : bdf91c           					lbsr	sPUTSTR
f571 : ec44             					ldd		4,u					; print param 1 (destination)
f573 : 3406             					pshs	d
f575 : bdfa98           					lbsr	HEXWORD2MONPORT
f578 : 3262             					leas	2,s
f57a : 8ef4d5           					ldx		#STR_EW4
f57d : bdf91c           					lbsr	sPUTSTR
                        					
f580 : bdf936           					lbsr	WriteEEP
f583 : 8ef4e7           					ldx		#STR_EWdone
f586 : bdf91c           					lbsr	sPUTSTR
                        					
f589 : 8ef4fe           					ldx		#STR_EW_CS
f58c : bdf91c           					lbsr	sPUTSTR
f58f : ec44             					ldd		4,u					; Checksum calculated in ROM. Take W
f591 : 3406             					pshs	d					; push as 1st arg (CheckSum16 begin ad
f593 : e342             					addd	2,u					; add WriteEEP length in byte
f595 : 3406             					pshs	d					; push as 2nd arg (CheckSum16 end addr
f597 : 4f               					clra						; initial CheckSum16 value shall be 0
f598 : 5f               					clrb
f599 : 3406             					pshs	d					; push as 3rd arg
f59b : bdfa64           					lbsr	getCheckSum16
f59e : 3266             					leas	6,s					; free the 3 args					
f5a0 : 3406             					pshs	d
f5a2 : bdfa98           					lbsr	HEXWORD2MONPORT
f5a5 : 3262             					leas	2,s
f5a7 : 3268             _sCMDewdone			leas	8,s					; free the WriteEEP 4 param
f5a9 : 35c0             					puls	u,pc  				; restore u and return				
                        						
AS09 Assembler for M6809 [1.42].                                     Page  254
--------------------------------- merge.a09 ----------------------------------

                        ;----------------------------------------------------;
f5ab : 0d73656e64206e.. STR_CMD_LD			db		CR,"send now the SRec data, Offset=",
f5cc : 20627974652873.. STR_CMD_LD2			db		" byte(s) @ addr:",0
f5dd : 72656365707469.. STR_CMD_LD3			db		"reception completed",CR,0
f5f2 : 20636865636b73.. STR_CMD_LD4			db		" checksum error!",0
0000 =                  ByteCount			equ		0					; uchar byte count index
0001 =                  SRecCheckSum		equ		1					; uchar SRecCheckSum index
0002 =                  Offset				equ		2					; uint Offset index
0004 =                  NewAddr				equ		4					; uint new address
f603 : 3440             sCMDld				pshs	u
f605 : 327e             					leas	-2,s				; allocate 16-bit Offset
f607 : 327e             					leas	-2,s				; allocate 16-bit Offset
f609 : 327f             					leas	-1,s				; allocate 8-bit SRecCheckSum
f60b : 327f             					leas	-1,s				; allocate 8-bit ByteCount
f60d : 33e4             					leau	,s					; use the U as pointer
f60f : 4f               					clra
f610 : 5f               					clrb
f611 : ed42             					std		Offset,u 			; set to 0 by default
                        					
                        					;------- extract 'CR' or optional ' ''offset' ---
f613 : bdf8d8           					lbsr	sCMDextr
f616 : c10d             					cmpb	#CR					; no offset
f618 : 270b             					beq		_sCMDld00
f61a : c120             					cmpb	#' '
f61c : 261a             					bne		_sCMDldInvalid		; with offset data
                        					
                        					;------- extract optional 'offset' --------------
f61e : bdf8d8           					lbsr	sCMDextr
f621 : c10d             					cmpb	#CR
f623 : 2613             					bne		_sCMDldInvalid					
                        					
f625 : af42             _sCMDld00			stx		Offset,u			; save the offset data
f627 : 8ef5ab           					ldx		#STR_CMD_LD
f62a : bdf91c           					lbsr	sPUTSTR
f62d : ec42             					ldd		Offset,u
f62f : 3406             					pshs	d
f631 : bdfa98           					lbsr	HEXWORD2MONPORT
f634 : 3262             					leas	2,s
f636 : 2006             					bra		_sCMDld0
f638 : bdf8d1           _sCMDldInvalid		lbsr	sCMDinvalid
f63b : 7ef6c0           					lbra	_sCMDlddone
                        					;------- seek for 'S1' --------------------
f63e : bdf332           _sCMDld0			lbsr	sRbRead 			; read a byte
f641 : 5d               					tstb
f642 : 27fa             					beq		_sCMDld0
f644 : 8153             					cmpa	#'S'
f646 : 26f6             					bne		_sCMDld0
f648 : bdf332           _sCMDld01			lbsr	sRbRead 			; read a byte
f64b : 5d               					tstb
f64c : 27fa             					beq		_sCMDld01
f64e : 8131             					cmpa	#'1'
f650 : 266e             					bne		_sCMDlddone 		; the last line does not conta
f652 : 6f41             					clr		SRecCheckSum,u		; SRecCheckSum = 0
                        					
f654 : 8602             					lda		#2					; read byte count
f656 : bdf8fc           					lbsr	sExtrNByte
f659 : 3404             					pshs	b
f65b : eb41             					addb	SRecCheckSum,u		; SRecCheckSum +=  bytecount
f65d : e741             					stb		SRecCheckSum,u
f65f : 3504             					puls	b
f661 : c003             					subb	#3					; 3 byte already read
f663 : e7c4             					stb		ByteCount,u
AS09 Assembler for M6809 [1.42].                                     Page  255
--------------------------------- merge.a09 ----------------------------------

f665 : c60d             					ldb		#CR
f667 : bdecdf           					lbsr	sMON_PORT_WR
f66a : e6c4             					ldb		ByteCount,u
f66c : 3406             					pshs	d
f66e : bdfacd           					lbsr	HEXBYTE2MONPORT
f671 : 3262             					leas	2,s
f673 : 8ef5cc           					ldx		#STR_CMD_LD2
f676 : bdf91c           					lbsr	sPUTSTR
                        					
f679 : 8604             					lda		#4  				; read addr
f67b : bdf8fc           					lbsr	sExtrNByte
f67e : ed44             					std	    NewAddr,u			; save addr
f680 : ab41             					adda	SRecCheckSum,u		; SRecCheckSum +=  addr hi
f682 : a741             					sta		SRecCheckSum,u
f684 : eb41             					addb	SRecCheckSum,u		; SRecCheckSum +=  addr lo
f686 : e741             					stb		SRecCheckSum,u	
f688 : ec44             					ldd	    NewAddr,u			; addr -= offset
f68a : a342             					subd	Offset,u
f68c : ed44             					std	    NewAddr,u			; save new addr
f68e : 3406             					pshs	d
f690 : bdfa98           					lbsr	HEXWORD2MONPORT
f693 : 3262             					leas	2,s
                        
f695 : 8602             _sCMDld1			lda		#2					; read data
f697 : bdf8fc           					lbsr	sExtrNByte
f69a : 3404             					pshs	b
f69c : eb41             					addb	SRecCheckSum,u		; SRecCheckSum +=  data
f69e : e741             					stb		SRecCheckSum,u
f6a0 : 3504             					puls	b
f6a2 : ae44             					ldx	    NewAddr,u			; get new addr
f6a4 : e780             					stb     ,x+ 				; write to dst addr and inc
f6a6 : af44             					stx	    NewAddr,u			; save new addr
f6a8 : 6ac4             					dec		ByteCount,u
f6aa : 26e9             					bne		_sCMDld1
                        						
f6ac : 8602             					lda		#2					; read checksum
f6ae : bdf8fc           					lbsr	sExtrNByte
f6b1 : e841             					eorb	SRecCheckSum,u 		; checksum xor with sum sho
f6b3 : c1ff             					cmpb	#$ff
f6b5 : 2706             					beq		_sCMDld2
f6b7 : 8ef5f2           					ldx		#STR_CMD_LD4
f6ba : bdf91c           					lbsr	sPUTSTR
f6bd : 7ef63e           _sCMDld2			lbra	_sCMDld0
f6c0 : c60d             _sCMDlddone      	ldb		#CR
f6c2 : bdecdf           					lbsr	sMON_PORT_WR
f6c5 : 8ef5dd           					ldx		#STR_CMD_LD3
f6c8 : bdf91c           					lbsr	sPUTSTR
f6cb : 3261             					leas	1,s					; free 8-bit
f6cd : 3261             					leas	1,s					; free 8-bit
f6cf : 3262             					leas	2,s					; free 16-bit
f6d1 : 3262             					leas	2,s					; free 16-bit
f6d3 : 3540             					puls	u
f6d5 : 39               					rts							; exit
                        
                        ;----------------------------------------------------;
f6d6 : 0d676f20616464.. STR_GO				db		CR,"go address ",0
f6e3 :                  sCMDgo				;------- extract ' ' --------------------
f6e3 : bdf8d8           					lbsr	sCMDextr
f6e6 : c120             					cmpb	#' '
f6e8 : 2607             					bne		_sCMDgoInvalid
                        					
                        					;------- extract 'addr' with 'CR' ---------------
AS09 Assembler for M6809 [1.42].                                     Page  256
--------------------------------- merge.a09 ----------------------------------

f6ea : bdf8d8           					lbsr	sCMDextr
f6ed : c10d             					cmpb	#CR								
f6ef : 2705             					beq		_sCMDgo0			; missing addr param	
f6f1 : bdf8d1           _sCMDgoInvalid		lbsr	sCMDinvalid
f6f4 : 201d             					bra		_sCMDgodone
f6f6 : 3410             _sCMDgo0         	pshs	x					; save go addr
f6f8 : 8ef6d6           					ldx		#STR_GO
f6fb : bdf91c           					lbsr	sPUTSTR					
f6fe : ece4             					ldd		0,s					; get go addr
f700 : 3406             					pshs	d
f702 : bdfa98           					lbsr	HEXWORD2MONPORT
f705 : 3262             					leas	2,s
f707 : ccffff           					ldd		#$ffff
f70a : 830001           _sCMDgo1			subd	#1
f70d : 26fb             					bne		_sCMDgo1			; wait until MONPORT output proce
f70f : 3510             					puls	x
f711 : ad84             					jsr     ,x      			; execute @ addr
f713 : 39               _sCMDgodone			rts							; exit
                        
                        ;----------------------------------------------------;
f714 : 0d73746f702070.. STR_ST				db		CR,"stop process ",0
f723 :                  sCMDStp				;------- extract ' ' --------------------
f723 : bdf8d8           					lbsr	sCMDextr
f726 : c120             					cmpb	#' '
f728 : 2607             					bne		_sCMDstpInvalid
                        					
                        					;------- extract 'process ID' with 'CR' ---------
f72a : bdf8d8           					lbsr	sCMDextr
f72d : c10d             					cmpb	#CR								
f72f : 2705             					beq		_sCMDstp0			; missing ID param	
f731 : bdf8d1           _sCMDstpInvalid		lbsr	sCMDinvalid
f734 : 201d             					bra		_sCMDstpdone
f736 : 3410             _sCMDstp0         	pshs	x					; save process ID
f738 : 8ef714           					ldx		#STR_ST
f73b : bdf91c           					lbsr	sPUTSTR					
f73e : ece4             					ldd		0,s					; get process ID
f740 : 3406             					pshs	d
f742 : bdfacd           					lbsr	HEXBYTE2MONPORT
f745 : 3262             					leas	2,s
f747 : 3506             					puls	d
f749 : c120             					cmpb	#BASIC_PROCESS_ID
f74b : 2606             					bne		_sCMDstpdone
f74d : 7f7ff0           					clr		BasicCallBack		; void the next callback addr
f750 : 7f7ff1           					clr		BasicCallBack+1
f753 : 39               _sCMDstpdone		rts							; exit
                        
                        ;----------------------------------------------------;
f754 : 0d736574206272.. STR_BP				db		CR,"set breakkpoint address ",0
f76e : 0d627265616b6b.. STR_BP1				db		CR,"breakkpoint existing! ",0
f786 :                  sCMDbp				;------- extract ' ' --------------------
f786 : bdf8d8           					lbsr	sCMDextr
f789 : c120             					cmpb	#' '
f78b : 2615             					bne		_sCMDbpInvalid
                        					
                        					;------- extract addr param with 'CR ' ----------
f78d : bdf8d8           					lbsr	sCMDextr
f790 : c10d             					cmpb	#CR
f792 : 260e             					bne		_sCMDbpInvalid
                        					
f794 : 8c0000           					cmpx	#RAM_ORG			; validate address within RAM
f797 : 2509             					blo		_sCMDbpInvalid
f799 : 8c7fff           					cmpx	#RAM_END
AS09 Assembler for M6809 [1.42].                                     Page  257
--------------------------------- merge.a09 ----------------------------------

f79c : 2204             					bhi		_sCMDbpInvalid
                        					
f79e : 3410             					pshs	x 					; save bp addr
f7a0 : 2005             					bra		_sCMDbp1
f7a2 : bdf8d1           _sCMDbpInvalid		lbsr	sCMDinvalid
f7a5 : 2036             					bra		_sCMDbpdone
f7a7 : fc7fbd           _sCMDbp1         	ldd		BrkPtAddr			; verify if breakpo
f7aa : 10830000         					cmpd	#BrkPtOff
f7ae : 270e             					beq		_sCMDbp2			; breakpoint not existing
f7b0 : 10830001         					cmpd	#BrkPtTriggered
f7b4 : 2708             					beq		_sCMDbp2			; breakpoint can be set again				
f7b6 : 8ef76e           					ldx		#STR_BP1
f7b9 : bdf91c           					lbsr	sPUTSTR
f7bc : 201f             					bra		_sCMDbpdone
f7be : 8ef754           _sCMDbp2			ldx		#STR_BP
f7c1 : bdf91c           					lbsr	sPUTSTR
f7c4 : 3506             					puls	d					; restore bp addr
f7c6 : fd7fbd           					std		BrkPtAddr			; save addr
f7c9 : 3406             					pshs	d
f7cb : bdfa98           					lbsr	HEXWORD2MONPORT
f7ce : 3262             					leas	2,s
f7d0 : a69f7fbd         					lda		[BrkPtAddr]			; save instruction
f7d4 : b77fbf           					sta		BrkPtInst
f7d7 : 863f             					lda		#$3f				;swi instruction
f7d9 : a79f7fbd         					sta		[BrkPtAddr]			;replace by swi
f7dd : 39               _sCMDbpdone			rts							; exit
                        
                        ;----------------------------------------------------;
f7de : 0d717569742064.. STR_QBP				db		CR,"quit debugging mode",0
f7f3 : 0d6e6f7420696e.. STR_QBP1			db		CR,"not in debugging mode",0
f80a : fc7fbd           sCMDqbp	    	    ldd		BrkPtAddr			; verify if breakpoi
f80d : 10830000         					cmpd	#BrkPtOff			; Off when not in debug mode
f811 : 271f             					beq		_sCMDqbp1	
f813 : 3406             					pshs	d
f815 : 8ef7de           					ldx		#STR_QBP
f818 : bdf91c           					lbsr	sPUTSTR
f81b : 3506             					puls	d
f81d : 10830001         					cmpd	#BrkPtTriggered		; was triggered
f821 : 2707             					beq		_sCMDqbp0
f823 : b67fbf           					lda		BrkPtInst
f826 : a79f7fbd         					sta		[BrkPtAddr]			; replace initial instruction 
f82a : cc0000           _sCMDqbp0			ldd		#BrkPtOff	
f82d : fd7fbd           					std		BrkPtAddr			; place in off state
f830 : 2006             					bra		_sCMDqbpdone				
f832 : 8ef7f3           _sCMDqbp1			ldx		#STR_QBP1
f835 : bdf91c           					lbsr	sPUTSTR
f838 : 39               _sCMDqbpdone		rts							; exit
                        
                        
                        ;----------------------------------------------------;
f839 : 0d73656e64206e.. STR_CMD_LDBAS		db		CR,"send now the BAS file",CR,0
f851 : 454e440d00       STR_CMD_LDBASEND	db		"END",CR,0
f856 : bdf32c           sCMDldbas			lbsr	sRbReadCmd
f859 : 5d               					tstb
f85a : 10270073         					lbeq	sCMDinvalid				
f85e : 810d             					cmpa	#CR
f860 : 1026006d         					lbne	sCMDinvalid  		; not CR, invalid CMD
f864 : 8ef839           					ldx		#STR_CMD_LDBAS
f867 : bdf91c           					lbsr	sPUTSTR
                        										
                        					;------- read until 'END' --------------------
f86a : 8ef851           _sCMDldbas0 		ldx		#STR_CMD_LDBASEND
AS09 Assembler for M6809 [1.42].                                     Page  258
--------------------------------- merge.a09 ----------------------------------

f86d : bdf332           _sCMDldbas1			lbsr	sRbRead 			; read a byte					
f870 : 5d               					tstb
f871 : 27fa             					beq		_sCMDldbas1
f873 : 810a             					cmpa    #10
f875 : 27f6             					beq		_sCMDldbas1			; remove LF
f877 : 3412             					pshs	a,x
f879 : 1f89             					tfr		a,b
f87b : bdef1f           					lbsr	sAPL_KeyboardData
f87e : bdee9c           _sCMDldbas2			lbsr	BASICprocess		; BASIC process call
f881 : bdef59           					lbsr    isKeyboardData		; check if the data is pr
f884 : 5d               					tstb
f885 : 26f7             					bne		_sCMDldbas2			; loop until the data is compl
f887 : 3512             					puls	x,a
f889 : a180             					cmpa	,x+
f88b : 26dd             					bne		_sCMDldbas0
f88d : 1f10             					tfr		x,d
f88f : 83f851           					subd	#STR_CMD_LDBASEND
f892 : 10830004         					cmpd	#4
f896 : 25d5             					blo		_sCMDldbas1
f898 : 39               					rts
                        
                        ;----------------------------------------------------;
f899 :                  sCMDbas				;------- extract ' ' ----------------------
f899 : bdf8d8           					lbsr	sCMDextr
f89c : c120             					cmpb	#' '
f89e : 2631             					bne		sCMDinvalid
                        					
                        					;------- extract 'BASIC code' with 'CR' ---------
f8a0 : bdf332           _sCMDbas0			lbsr	sRbRead
f8a3 : 5d               					tstb
f8a4 : 2716             					beq		_sCMDbasdone
f8a6 : 3402             					pshs    a
f8a8 : 1f89             					tfr		a,b
f8aa : bdef1f           					lbsr	sAPL_KeyboardData
f8ad : bdee9c           _sCMDbas1			lbsr	BASICprocess		; BASIC process call
f8b0 : bdef59           					lbsr    isKeyboardData		; check if the data is pr
f8b3 : 5d               					tstb
f8b4 : 26f7             					bne		_sCMDbas1			; loop until the data is complet
f8b6 : 3502             					puls    a
f8b8 : 810d             					cmpa    #CR					; CR ends the command
f8ba : 26e4             					bne		_sCMDbas0
f8bc : 39               _sCMDbasdone		rts	
                        
                        ;----------------------------------------------------;
f8bd : 0d696e76616c69.. STR_CMDinvalid		db		CR,"invalid command!!",CR,0
f8d1 : 8ef8bd           sCMDinvalid			ldx		#STR_CMDinvalid
f8d4 : bdf91c           					lbsr	sPUTSTR
f8d7 : 39               					rts
                        ;}
                        
                        ;----------------------------------------------------;
f8d8 :                  sCMDextr ;{
                        ;---------------------------------------------------;
                        ; extract text command (converted in hex) until a ' ' 
                        ; param: 	none
                        ; return: 	cmd value -> X, end condition -> B (NULL wh
                        ;---------------------------------------------------;
f8d8 : 8e0000           					ldx		#0					; clear
f8db : bdf32c           _sCMDextr0			lbsr	sRbReadCmd 			; read a byte
f8de : 5d               					tstb
f8df : 271a             					beq		_sCMDextrEnd			; RB empty, B is NULL
f8e1 : 1f89             					tfr		a,b					; B contains the end condition
AS09 Assembler for M6809 [1.42].                                     Page  259
--------------------------------- merge.a09 ----------------------------------

f8e3 : 8120             					cmpa	#' '				; end value?
f8e5 : 2714             					beq		_sCMDextrEnd  		; return value already in B
f8e7 : 810d             					cmpa	#CR					; or CR ends ?
f8e9 : 2710             					beq		_sCMDextrEnd  		; not expected
f8eb : bdfb13           					lbsr	sTEXT2HEX			; convert
f8ee : 3402             					pshs	a					; save new value on stack
f8f0 : 1f10             					tfr		x,d
f8f2 : bdfa80           					lbsr	sWLSL4bit
f8f5 : ebe0             					addb	,s+					; add the new value and free 8-bit s
f8f7 : 1f01             					tfr		d,x
f8f9 : 20e0             					bra		_sCMDextr0
f8fb : 39               _sCMDextrEnd     	rts
                        ;}
                        ;----------------------------------------------------;
f8fc :                  sExtrNByte ;{
                        ;---------------------------------------------------
                        ; asm call extract (text to hex) 
                        ; param: 	A -> n byte to extract
                        ; return:	out value -> D		
                        ;---------------------------------------------------
f8fc : 3402             					pshs	a					; contains the count
f8fe : 8e0000           					ldx		#0					; clear
f901 : bdf332           _sExtrNByte0		lbsr	sRbRead				; read a byte
f904 : 5d               					tstb
f905 : 27fa             					beq     _sExtrNByte0 		; loop until RB no more em
f907 : bdfb13           					lbsr	sTEXT2HEX			; convert
f90a : 3402             					pshs	a					; save
f90c : 1f10             					tfr		x,d
f90e : bdfa80           					lbsr	sWLSL4bit
f911 : ebe0             					addb	,s+					; free 8-bit stack
f913 : 1f01             					tfr		d,x
f915 : 6ae4             					dec		,s					; decrease the count					
f917 : 26e8             					bne		_sExtrNByte0
f919 : 3261             _sExtrEnd        	leas	1,s					; puls, free end param
f91b : 39               					rts
                        	;}
                        ;}
                        
                        ;----------------------------------------------------;
                        ; asm call send string on debug port
                        ; param: 	X -> pointer
                        ; return:	none
                        ;----------------------------------------------------;
f91c : 3410             sPUTSTR         	pshs	x
f91e : bdfa89           					lbsr	PUTSTR
f921 : 3262             					leas	2,s
f923 : 39               					rts
                        ;}
                        
                        
                        
                        ;{ ---------------------------------------------------
                        					code
                        					
f924 : b6d004           SELECTBANK0			lda		UART+4
f927 : 8a01             					ora		#%00000001		; clear ROM addr line DTR_n=1
f929 : b7d004           					sta		UART+4
f92c : 39               					rts					
f92d : b6d004           SELECTBANK1			lda		UART+4
f930 : 84fe             					anda	#%11111110		; set ROM addr line DTR_n=0
f932 : b7d004           					sta		UART+4
f935 : 39               					rts
AS09 Assembler for M6809 [1.42].                                     Page  260
--------------------------------- merge.a09 ----------------------------------

                        					
                        ;----------------------------------------------------;
                        ; write to EEPROM from RAM
                        ; param: 			0,s -> return addr
                        ;			4th arg:2,s -> protection 	-> 0,u
                        ;			3rd arg:4,s -> len			-> 2,u
                        ;			2nd arg:6,s -> dst 			-> 4,u
                        ;			1st arg:8,s -> src 			-> 6,u
                        ; return:	CheckSum16 value -> D
                        ;----------------------------------------------------;
f936 : 3470             WriteEEP			pshs	u,y,x				; save used pointers (+6 byte
f938 : 3368             					leau	8,s					; set 4th arg to 0,u (8 bytes totall
                        										
f93a : ecc4             					ldd		0,u					; get the protection param					
f93c : 10830000         					cmpd	#0					; 1 is the XICOR protection
f940 : 2702             					beq		_WriteEEP1
f942 : 8d2d             					bsr		DISAXICORWP					
                        				
f944 : 10ae44           _WriteEEP1			ldy		4,u					; get the params (X = src, Y
f947 : ae46             					ldx		6,u	
f949 : ec42             					ldd		2,u					; get length value
f94b : 3406             					pshs	d					; create a length counter variable to 
                        					
f94d : a680             _WriteEEP2			lda		,x+
f94f : a1a4             					cmpa	,y
f951 : 2705             					beq		_no_change
f953 : a7a4             					sta		,y
f955 : bdf9df           					lbsr	DELAY_10MS			; eeprom 10 ms delay loop				
f958 : 3121             _no_change			leay	1,y					; inc the pointer			
f95a : ece4             					ldd		0,s					; dec length counter variable
f95c : 830001           					subd	#1
f95f : ede4             					std		0,s
f961 : 26ea             					bne		_WriteEEP2
f963 : 3262             					leas	2,s					; free the length counter
                        					
f965 : ecc4             					ldd		0,u					; get the protection param
f967 : 10830000         					cmpd	#0					; 1 is the XICOR protection
f96b : 2702             					beq		_WriteEEP5
f96d : 8d41             					bsr		ENAXICORWP				
f96f : 35f0             _WriteEEP5			puls	x,y,u,pc			; restore used registers
                        
                        ;----------------------------------------------------;
                        ; asm call remove XICOR 28C64 / 28C256 eeprom write pr
                        ; param:  none
                        ; return: none
                        ;----------------------------------------------------;
f971 : 3411             DISAXICORWP			pshs	ccr,x				; save ccr (for the disabl
f973 : 1a50             					orcc	#%01010000			; disable interrupts				
f975 : 8db6             					bsr		SELECTBANK1
f977 : 8e9555           					ldx 	#$1555+ROM1_ORG  	; $1555 + base addr / $555
f97a : 86aa             					lda		#$aa
f97c : a784             					sta		,x
f97e : 8da4             					bsr		SELECTBANK0
f980 : 8eaaaa           					ldx 	#$2aaa+ROM1_ORG
f983 : 8655             					lda		#$55
f985 : a784             					sta		,x
f987 : 8da4             					bsr		SELECTBANK1
f989 : 8e9555           					ldx 	#$1555+ROM1_ORG
f98c : 8680             					lda		#$80
f98e : a784             					sta		,x
f990 : 8e9555           					ldx 	#$1555+ROM1_ORG
f993 : 86aa             					lda		#$aa
AS09 Assembler for M6809 [1.42].                                     Page  261
--------------------------------- merge.a09 ----------------------------------

f995 : a784             					sta		,x
f997 : 8d8b             					bsr		SELECTBANK0
f999 : 8eaaaa           					ldx 	#$2aaa+ROM1_ORG
f99c : 8655             					lda		#$55
f99e : a784             					sta		,x
f9a0 : 8d8b             					bsr		SELECTBANK1
f9a2 : 8e9555           					ldx 	#$1555+ROM1_ORG
f9a5 : 8620             					lda		#$20
f9a7 : a784             					sta		,x				
f9a9 : bdf924           					bsr		SELECTBANK0
f9ac : 8d31             					bsr		DELAY_10MS				; eeprom 10 ms delay loop
f9ae : 3591             					puls	x,ccr,pc				; restore registers
                        				
                        ;----------------------------------------------------;
                        ; asm call enable XICOR 28C64 / 28C256 eeprom write pr
                        ; param:  none
                        ; return: none
                        ;----------------------------------------------------;
f9b0 : 3411             ENAXICORWP			pshs	ccr,x				; save ccr (for the disabli
f9b2 : 1a50             					orcc	#%01010000			; disable interrupts				
f9b4 : f68000           					ldb		ROM1_ORG			; get the byte
f9b7 : bdf92d           					bsr		SELECTBANK1
f9ba : 8e9555           					ldx 	#$1555+ROM1_ORG  	;$1555 + base addr 
f9bd : 86aa             					lda		#$aa
f9bf : a784             					sta		,x
f9c1 : bdf924           					bsr		SELECTBANK0
f9c4 : 8eaaaa           					ldx 	#$2aaa+ROM1_ORG
f9c7 : 8655             					lda		#$55
f9c9 : a784             					sta		,x
f9cb : bdf92d           					bsr		SELECTBANK1
f9ce : 8e9555           					ldx 	#$1555+ROM1_ORG
f9d1 : 86a0             					lda		#$a0
f9d3 : a784             					sta		,x
f9d5 : bdf924           					bsr		SELECTBANK0
                        					; re-write the byte
f9d8 : f78000           					stb		ROM1_ORG
f9db : 8d02             					bsr		DELAY_10MS			; eeprom 10 ms delay loop
f9dd : 3591             					puls	x,ccr,pc			; restore registers
                        
f9df : 4f               DELAY_10MS			clra
f9e0 : c60a             					ldb		#10
f9e2 : 3406             					pshs	d
f9e4 : bdfb26           					lbsr	msDelay				; 10 ms delay loop
f9e7 : 3586             					puls	d,pc					
                        
                        ;----------------------------------------------------;
                        ; asm call ROM integrity check
                        ; param:  D -> CheckSum16 calculated value
                        ;         X -> CheckSum16 addr
                        ; return: 0 -> B when succeed
                        ;----------------------------------------------------;
f9e9 : 0d524f4d207665.. ROMcheckSTR0		db		CR,"ROM verified",0
f9f7 : 0d436865636b53.. ROMcheckSTR1		db		CR,"CheckSum16 ",0
fa04 : 20776173206361.. ROMcheckSTR2		db		" was calculated instead ",0
fa1d : 2c20524f4d2066.. ROMcheckSTR3		db		", ROM failure!",CR,0
fa2d : 10a384           sROMcheck			cmpd	,x
fa30 : 272a             					beq		_sROMok
fa32 : 3410             					pshs	x					; save							
fa34 : 3406             					pshs	d					; param for HEXWORD2MONPORT							
fa36 : 8ef9f7           					ldx		#ROMcheckSTR1
fa39 : bdf91c           					lbsr	sPUTSTR
fa3c : bdfa98           					lbsr	HEXWORD2MONPORT	
AS09 Assembler for M6809 [1.42].                                     Page  262
--------------------------------- merge.a09 ----------------------------------

fa3f : 3262             					leas	2,s					; free the last push
fa41 : 8efa04           					ldx		#ROMcheckSTR2
fa44 : bdf91c           					lbsr	sPUTSTR
fa47 : 3510             					puls    x
fa49 : ec84             					ldd		,x
fa4b : 3406             					pshs	d					; param for HEXWORD2MONPORT							
fa4d : bdfa98           					lbsr	HEXWORD2MONPORT
fa50 : 3262             					leas	2,s					; free the last push					
fa52 : 8efa1d           					ldx		#ROMcheckSTR3		; failure
fa55 : bdf91c           					lbsr	sPUTSTR
fa58 : c601             					ldb		#1					; non zero return value
fa5a : 2007             					bra		sROMcheckdone		; to be removed		
fa5c : 8ef9e9           _sROMok				ldx		#ROMcheckSTR0		; success
fa5f : bdf91c           					lbsr	sPUTSTR
fa62 : 5f               					clrb						; zero return value
fa63 : 39               sROMcheckdone		rts
                        
                        ;----------------------------------------------------;
                        ; calculate the 16-bit CheckSum of the ROM
                        ; param: 			0,s -> return addr
                        ;			3rd arg:2,s -> CS16InitialValue -> 0,u
                        ;			2nd arg:4,s -> CS16EndAddr		-> 2,u
                        ;			1st arg 6,s -> start addr 		-> 4,u
                        ; return:	CheckSum16 value -> D
                        ;----------------------------------------------------;
fa64 :                  getCheckSum16	;{	
fa64 : 3450             					pshs	u,x					; save used registers (+4 bytes on s
fa66 : 3366             					leau	6,s					; set arg1 to 0,u (4 bytes after the
fa68 : ae44             					ldx		4,u					; get 3rd arg start addr
fa6a : ec81             _getCheckSum160		ldd		,x++
fa6c : e3c4             					addd	0,u  				; 16-bit checksum
fa6e : edc4             					std		0,u
fa70 : ac42             					cmpx	2,u 				; end
fa72 : 26f6             					bne		_getCheckSum160
fa74 : 35d0             					puls	x,u,pc				; restore used registers
                        ;}
                        
                        ;----------------------------------------------------;
                        ; asm call calculate the string length
                        ; param: 	X -> pointer
                        ; return:	length -> D
                        ;----------------------------------------------------;
fa76 :                  sStrlen  ;{
fa76 : 5f               					clrb
fa77 : a680             _sstrlen1 			lda		,x+
fa79 : 2704             					beq		_sstrlenDone 		; string ends with NULL
fa7b : 5c               					incb
fa7c : 20f9             					bra		_sstrlen1
fa7e : 4f               					clra
fa7f : 39               _sstrlenDone		rts
                        ;}
                        
                        ;----------------------------------------------------;
                        ; asm call shift left D 4-bit
                        ; param: 	D -> value
                        ; return:	out -> D
                        ;----------------------------------------------------;
fa80 : 58               sWLSL4bit	       	lslb
fa81 : 49               					rola
fa82 : 58               					lslb
fa83 : 49               					rola
fa84 : 58               					lslb
AS09 Assembler for M6809 [1.42].                                     Page  263
--------------------------------- merge.a09 ----------------------------------

fa85 : 49               					rola
fa86 : 58               					lslb
fa87 : 49               					rola
fa88 : 39               					rts
                        
                        ;----------------------------------------------------;
                        ; send string on debug port
                        ; param: 	2,s -> string pointer
                        ; return:	none
                        ;----------------------------------------------------;
fa89 :                  PUTSTR
fa89 : 3410             print_De   			pshs	x				; +2 bytes on stack
fa8b : ae64             					ldx		4,s
fa8d : e680             _putstr0			ldb		,x+
fa8f : 2705             					beq		_putstr1 		; string ends with NULL
fa91 : bdecdf           					lbsr	sMON_PORT_WR
fa94 : 20f7             					bra		_putstr0
fa96 : 3590             _putstr1			puls	x,pc
                        
                        ;----------------------------------------------------;
                        ; send Word on debug port, displayed in HEX
                        ; param: 	2,s -> 8-bit high byte
                        ;			3,s -> 8-bit low byte
                        ; return:	none, D is not preserved
                        ;----------------------------------------------------;
fa98 :                  HEXWORD2MONPORT		
fa98 : 3440             HEXWORD2			pshs	u					; +2 bytes on stack
fa9a : 3364             					leau	4,s					; fix arg1 pointer to 0,u	
fa9c : c624             					ldb		#'$'
fa9e : bdecdf           					lbsr	sMON_PORT_WR
faa1 : e6c4             					ldb		0,u		  			; param high byte
faa3 : 3406             					pshs	d
faa5 : bdfaf3           					lbsr	DHEX2TEXT
faa8 : 3262             					leas	2,s 
faaa : 3404             					pshs	b					; save low byte
faac : 1f89             					tfr		a,b
faae : f7c800           					stb		DEBUG_MON_PORT		; write high byte (write dir
fab1 : 3504             					puls	b					; get low byte
fab3 : f7c800           					stb		DEBUG_MON_PORT		; write low byte (write dire
fab6 : e641             					ldb		1,u		  			; param low byte
fab8 : 3406             					pshs	d
faba : bdfaf3           					lbsr	DHEX2TEXT
fabd : 3262             					leas	2,s 
fabf : 3404             					pshs	b					; save low byte
fac1 : 1f89             					tfr		a,b
fac3 : f7c800           					stb		DEBUG_MON_PORT		; write high byte (write dir
fac6 : 3504             					puls	b					; get low byte
fac8 : f7c800           					stb		DEBUG_MON_PORT		; write low byte (write dire
facb : 35c0             					puls	u,pc
                        ;}
                        
                        ;----------------------------------------------------;
                        ; send Byte on debug port, displayed in HEX
                        ; param: 	2,s -> xx
                        ;			3,s -> 8-bit value
                        ; return:	none, D is not preserved
                        ;----------------------------------------------------;
facd :                  HEXBYTE2MONPORT
facd : 3440             HEXBYTE2			pshs	u
facf : 3364             					leau	4,s					; fix arg1 pointer to 0,u		
fad1 : c624             					ldb		#'$'
fad3 : bdecdf           					lbsr	sMON_PORT_WR
AS09 Assembler for M6809 [1.42].                                     Page  264
--------------------------------- merge.a09 ----------------------------------

fad6 : e641             					ldb		1,u
fad8 : 3406             					pshs	d
fada : bdfaf3           					lbsr	DHEX2TEXT
fadd : 3262             					leas	2,s 
fadf : 3404             					pshs	b
fae1 : 1f89             					tfr		a,b
fae3 : f7c800           					stb		DEBUG_MON_PORT			; write high nibble
fae6 : 3504             					puls	b
fae8 : f7c800           					stb		DEBUG_MON_PORT			; write low nibble
faeb : 35c0             					puls	u,pc
                        
                        ;----------------------------------------------------;
                        ; send a byte on debug port
                        ; param: 	2,s -> xx
                        ;			3,s -> 8-bit value
                        ; return:	none
                        ;----------------------------------------------------;
faed :                  BYTE2MONPORT
faed : e663             BYTE2MON			ldb		3,s
faef : bdecdf           					lbsr	sMON_PORT_WR
faf2 : 39               					rts
                        
                        ;----------------------------------------------------;
                        ; convert a byte to ascii hex value
                        ; param: 	2,s -> xx
                        ;			3,s -> 8-bit value
                        ; return:	high nible -> A
                        ;			low nibble -> B
                        ;----------------------------------------------------;
faf3 : a663             DHEX2TEXT	   		lda		3,s
faf5 : 44               					lsra
faf6 : 44               					lsra
faf7 : 44               					lsra
faf8 : 44               					lsra
faf9 : 8d0b             					bsr		sHEX2TEXT
fafb : 1f89             					tfr		a,b
fafd : a663             					lda		3,s
faff : 840f             					anda	#$f					;lower nible
fb01 : 8d03             					bsr		sHEX2TEXT
fb03 : 1e89             					exg		a,b
fb05 : 39               					rts
                        
                        ;----------------------------------------------------;
                        ; asm call hex to dec conversion
                        ; param: 	A -> hex value
                        ; return:	dec out -> A
                        ;----------------------------------------------------;
fb06 : 840f             sHEX2TEXT			anda	#$f					;lower nible
fb08 : 8109             					cmpa	#9
fb0a : 2204             					bhi     sHEX2TEXT_1
fb0c : 8b30             					adda	#'0'				;for number
fb0e : 2002             					bra     sHEX2TEXT_2
fb10 : 8b37             sHEX2TEXT_1	    	adda	#$37				;for letter
fb12 : 39               sHEX2TEXT_2			rts
                        
                        ;----------------------------------------------------;
                        ; asm call dec to hex conversion
                        ; param: 	A -> dec value
                        ; return:	hex out -> A
                        ;----------------------------------------------------;
fb13 : 8139             sTEXT2HEX			cmpa	#'9'
fb15 : 2204             					bhi     sTEXT2HEX_1
AS09 Assembler for M6809 [1.42].                                     Page  265
--------------------------------- merge.a09 ----------------------------------

fb17 : 840f             					anda	#$f					;for number
fb19 : 200a             					bra     sTEXT2HEX_2
fb1b : 8146             sTEXT2HEX_1      	cmpa	#'F'
fb1d : 2204             					bhi     sTEXT2HEX_11
fb1f : 8037             					suba	#$37				;for higher case letter
fb21 : 2002             					bra     sTEXT2HEX_2
fb23 : 8057             sTEXT2HEX_11     	suba	#$57				;for lower case letter
fb25 : 39               sTEXT2HEX_2			rts
                        
                        ;-----------------------------------------------------
                        ; delay in ms (C call compatible)
                        ; param: 	2-3,s -> delay value (16-bit)
                        ; return:	none
                        ;-----------------------------------------------------
fb26 :                  msDelay ;{
fb26 : cc011a           					ldd		#282		; 3 cycles
fb29 : 830001           _msDelay0			subd	#1			; 4 cycles
fb2c : 26fb             					bne		_msDelay0	; 3 cycles
fb2e : ec62             					ldd		2,s			; 5 cycles
fb30 : 830001           					subd	#1			; 4 cycles
fb33 : ed62             					std		2,s			; 5 cycles
fb35 : 10830000         					cmpd	#0			; 5 cycles
fb39 : 26eb             					bne		msDelay		; 3 cycles
fb3b : 39               					rts
                        										; 3 + (4+3 cycles * 282) + 5+4+5+5+3 = 2000 
                        					
                        ;Interrupt service routines
                        				code
                        				
                        ;{ ---------------------------------------------------
fb3c : be7ff8           IRQ            	ldx		IntVectIRQ			; load the new vecto
fb3f : 2702             				beq		_irq0
fb41 : 6e84             				jmp		,x					; execute the re-mapped isr
fb43 : 8e7fc2           _irq0			ldx     #Rbuffer			; get buffer base addr				
fb46 : b67fc0           				lda		RbHead				; head index value
fb49 : 3086             				leax	a,x					; set X to the head pointer
fb4b : 4c               				inca				
fb4c : 8120             				cmpa	#RbSize
fb4e : 2501             				blo		_irq1
fb50 : 4f               				clra
fb51 : b17fc1           _irq1		    cmpa	RbTail
fb54 : 260b             				bne		_irq2				; stop filling before reaching the t
fb56 : a6e4             				lda		,s 					; modify the stacked CCR
fb58 : 8a10             				ora		#%00010000			; disable irq only when fifo ful
fb5a : a7e4             				sta		,s
fb5c : 7c7fe2           				inc 	RbDectCR 			; CR detect on, otherwise the fif
fb5f : 200f             				bra		_irq3
fb61 : b77fc0           _irq2			sta     RbHead
fb64 : b6c000           				lda		sMON_PORT_RD
fb67 : 810d             				cmpa	#CR					; CR compare
fb69 : 2603             				bne		_irq22
fb6b : 7c7fe2           				inc 	RbDectCR 			; CR found
fb6e : a784             _irq22			sta		,x					; store data to RB head pointer
fb70 : 3b               _irq3			rti
                        
fb71 : 7d7ff6           FIRQ  			tst		IntVectFIRQ			; cmp the new vector store
fb74 : 2605             				bne		_firq
fb76 : 7d7ff7           				tst		IntVectFIRQ+1		; cmp the new vector stored
fb79 : 2704             				beq		_firq0
fb7b : 6e9f7ff6         _firq			jmp		[IntVectFIRQ]		; execute the re-mapped is
fb7f : 3b               _firq0			rti
                        
AS09 Assembler for M6809 [1.42].                                     Page  266
--------------------------------- merge.a09 ----------------------------------

fb80 : be7ffc           NMI            	ldx		IntVectNMI			; load the new vecto
fb83 : 2702             				beq		_nmi0
fb85 : 6e84             				jmp		,x					; execute the re-mapped isr
fb87 : 3b               _nmi0			rti
                        ;}
                        
                        ;{ ---------------------------------------------------
fb88 : 0d446562756767.. SWI1_STR1		db		CR,"Debugging Mode: Program execution s
fbd4 : 50432c20532c20.. SWI1_STR2		db		"PC, S, U, Y, X, DP, D, CC",CR,0
fbef : 2c2000           SWI1_STR3		db		", ",0
                        
fbf2 : be7ffa           SWI1            ldx		IntVectSWI1			; load the new vect
fbf5 : 2702             				beq		_swi10
fbf7 : 6e84             				jmp		,x
fbf9 : 8efb88           _swi10          ldx		#SWI1_STR1 			; Breakpoint
fbfc : bdf91c           				lbsr	sPUTSTR
fbff : 8efbd4           				ldx		#SWI1_STR2
fc02 : bdf91c           				lbsr	sPUTSTR
fc05 : ec6a             				ldd		10,s				; PC
fc07 : 830001           				subd	#1					; step back the executed swi instructi
fc0a : ed6a             				std		10,s
fc0c : 3406             				pshs	d
fc0e : bdfa98           				lbsr	HEXWORD2MONPORT
fc11 : 3262             				leas	2,s
fc13 : 8efbef           				ldx		#SWI1_STR3
fc16 : bdf91c           				lbsr	sPUTSTR
fc19 : 1f40             				tfr		s,d		
fc1b : cb0c             				addb	#12					;PS
fc1d : 3406             				pshs	d
fc1f : bdfa98           				lbsr	HEXWORD2MONPORT
fc22 : 3262             				leas	2,s
fc24 : 8efbef           				ldx		#SWI1_STR3
fc27 : bdf91c           				lbsr	sPUTSTR
fc2a : ec68             				ldd		8,s					;US
fc2c : 3406             				pshs	d
fc2e : bdfa98           				lbsr	HEXWORD2MONPORT
fc31 : 3262             				leas	2,s
fc33 : 8efbef           				ldx		#SWI1_STR3
fc36 : bdf91c           				lbsr	sPUTSTR
fc39 : ec66             				ldd		6,s					;Y
fc3b : 3406             				pshs	d
fc3d : bdfa98           				lbsr	HEXWORD2MONPORT
fc40 : 3262             				leas	2,s
fc42 : 8efbef           				ldx		#SWI1_STR3
fc45 : bdf91c           				lbsr	sPUTSTR
fc48 : ec64             				ldd		4,s					;X
fc4a : 3406             				pshs	d
fc4c : bdfa98           				lbsr	HEXWORD2MONPORT
fc4f : 3262             				leas	2,s
fc51 : 8efbef           				ldx		#SWI1_STR3
fc54 : bdf91c           				lbsr	sPUTSTR
fc57 : e663             				ldb		3,s					;DPR
fc59 : 3406             				pshs	d
fc5b : bdfacd           				lbsr	HEXBYTE2MONPORT
fc5e : 3262             				leas	2,s
fc60 : 8efbef           				ldx		#SWI1_STR3
fc63 : bdf91c           				lbsr	sPUTSTR
fc66 : ec62             				ldd		2,s					;D
fc68 : 3406             				pshs	d
fc6a : bdfa98           				lbsr	HEXWORD2MONPORT
fc6d : 3262             				leas	2,s
fc6f : 8efbef           				ldx		#SWI1_STR3
AS09 Assembler for M6809 [1.42].                                     Page  267
--------------------------------- merge.a09 ----------------------------------

fc72 : bdf91c           				lbsr	sPUTSTR
fc75 : e6e4             				ldb		0,s					;CCR
fc77 : 3406             				pshs	d
fc79 : bdfacd           				lbsr	HEXBYTE2MONPORT
fc7c : 3262             				leas	2,s
fc7e : 8efbef           				ldx		#SWI1_STR3
fc81 : bdf91c           				lbsr	sPUTSTR				
                        				
fc84 : b67fbf           				lda		BrkPtInst
fc87 : a79f7fbd         				sta		[BrkPtAddr]			; replace initial instruction a
fc8b : cc0001           				ldd		#BrkPtTriggered
fc8e : fd7fbd           				std		BrkPtAddr			; state to triggered
                        
fc91 : 1cef             				andcc	#ENABLE_MON_INT		; re-enable int
fc93 : bdf357           _swi12			lbsr	sMonProcessCmd		; get next cmd: quit or 
fc96 : fc7fbd           				ldd		BrkPtAddr		
fc99 : 10830001         				cmpd	#BrkPtTriggered		; wait until next command
fc9d : 27f4             				beq		_swi12
fc9f :                  SWI3			
fc9f : 3b               SWI2			rti
                        ;}
                        
                        ;{ ---------------------------------------------------
fff0 =                  				org		ROM_Integrity
fff0 : fbcd             				dw		CheckSum16_ROM0
                        				
fff2 =                  				org    INT_VECTOR
                        
fff2 : fc9f             				dw      SWI3
fff4 : fc9f             				dw 		SWI2
fff6 : fb71             				dw      FIRQ
fff8 : fb3c             				dw      IRQ
fffa : fbf2             				dw      SWI1
fffc : fb80             				dw      NMI
fffe : ed3a             				dw      RESET
                        ;}
                        				end
                        
                        
                        ;{ ---------------------- asm Global Variables and Sta
                        					
7fbd =                  BSS_SEG_ORG			equ     RAM_END+1 -3-35-1-10-4-14 			; a
7fbd =                  GV_StackBeginAddr	equ		BSS_SEG_ORG							; C global va
7d5d =                  LV_StackBeginAddr	equ		BSS_SEG_ORG - _GLOBALS				; loc
                        
                        ;{ ---------------------------------------------------
                        					bss						; bss segment is in RAM (hidden in SRec 
7fbd =                  					org		BSS_SEG_ORG
0000 =                  BrkPtOff			equ     0
0001 =                  BrkPtTriggered		equ     1
7fbd =                  BrkPtAddr	  		ds		2				; BrkPtOff, BrkPtTriggered or 1
7fbf =                  BrkPtInst       	ds		1				; previous instruction where
                        
0020 =                  RbSize				equ     32
7fc0 =                  RbHead		  		ds		1
7fc1 =                  RbTail          	ds		1
7fc2 =                  Rbuffer				ds		RbSize
7fe2 =                  RbDectCR        	ds		1
                        
7fe3 =                  APLstatus			ds		1
                        
0008 =                  KeyboardRbSize		equ     8
AS09 Assembler for M6809 [1.42].                                     Page  268
--------------------------------- merge.a09 ----------------------------------

7fe4 =                  KeyboardRbHead		ds		1
7fe5 =                  KeyboardRbTail     	ds		1
7fe6 =                  KeyboardRbuffer		ds		KeyboardRbSize
                        
7fee =                  MonSavReg_S			ds		2				; monitor context saving regist
7ff0 =                  BasicCallBack		ds		2				; BASIC call address
                        
                        	; addresses re-mapping interrupt table
7ff2 =                  IntVectSWI3			ds		2
7ff4 =                  IntVectSWI2			ds		2
7ff6 =                  IntVectFIRQ			ds		2
7ff8 =                  IntVectIRQ			ds		2
7ffa =                  IntVectSWI1			ds		2
7ffc =                  IntVectNMI			ds		2
7ffe =                  IntVectSTART		ds		2
                        
                        ;}		
                        
                        
                        
No errors in pass 2.
