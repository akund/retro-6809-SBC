AS09 Assembler for M6809 [1.42].                                     Page    1
--------------------------------- merge.a09 ----------------------------------

-------------------------------- Symbol Table --------------------------------

              Symbol   Value        Decimal

                 ABS : $9589          38281
      APLclearscreen : $ef5e          61278
      APLcurBlinking : $ef58          61272
           APLcurOff : $ef5b          61275
             APLdate : $7fe0          32736
          APLgetChar : $ef49          61257
         APLsendChar : $ef4c          61260
            APLsetXY : $ef74          61300
            APLsound : $ef65          61285
           APLstatus : $7fdf          32735
             APLtime : $7fe2          32738
            APL_BUSY : $0032             50
            APL_init : $ef81          61313
    APL_OutputStream : $f01f          61471
           APL_READY : $0031             49
           APL_RESET : $0030             48
       APL_RESET_STR : $ef3d          61245
       APL_UNDEFINED : $0039             57
              ARYDIS : $0008              8
              ARYEND : $001f             31
              ARYTAB : $001d             29
                 ASC : $8fbb          36795
                 ATN : $9918          39192
        BASICprocess : $efff          61439
           BASIC_ORG : $8002          32770
    BASIC_PROCESS_ID : $0020             32
       BasicCallBack : $7ff0          32752
         BasicRAMend : $7cff          31999
       BasicSavReg_S : $006f            111
              BINVAL : $002b             43
            BOOT_SCR : $ee57          61015
              BOTSTK : $0017             23
              BROMHK : $8320          33568
           BrkPtAddr : $7fb9          32697
           BrkPtInst : $7fbb          32699
            BrkPtOff : $0000              0
      BrkPtTriggered : $0001              1
                  BS : $0008              8
         BSS_SEG_ORG : $7fb9          32697
            BYTE2MON : $fcc2          64706
        BYTE2MONPORT : $fcc2          64706
           ByteCount : $0000              0
            bPerSect : $fff1            -15
              CHARAC : $0001              1
              CHARAD : $0083            131
                 CHR : $8fa7          36775
     CheckSum16_ROM0 : $35d7          13783
     CheckSum16_ROM1 : $ee9b          61083
               CLEAR : $878d          34701
                 CLS : $8217          33303
             CMD_TAB : $84ad          33965
              COEFCT : $0055             85
              COEFPT : $0064            100
          COMPARISON : $8c60          35936
              COMVEC : $80fe          33022
                CONT : $877c          34684
                 COS : $98e2          39138
                  CR : $000d             13
AS09 Assembler for M6809 [1.42].                                     Page    2
--------------------------------- merge.a09 ----------------------------------

                 CRA : $d801          55297
                 CRB : $d803          55299
         CSum16_ROM1 : $f1f5          61941
             CS_HIGH : $aba7          43943
              CS_LOW : $abb0          43952
              CURLIN : $0068            104
            clusterN : $fdaa           -598
            convertF : $e69f          59039
      cursorBlinking : $f123          61731
           cursorOff : $f127          61735
                DATA : $8826          34854
                DATE : $8243          33347
              DATPTR : $0033             51
              DATTMP : $0035             53
              DATTXT : $0031             49
      DEBUG_MON_PORT : $c800          51200
                 DEF : $9dcd          40397
                 DEL : $9e87          40583
          DELAY_10MS : $fbb4          64436
              DEVCFW : $006a            106
              DEVLCF : $006b            107
              DEVNUM : $006e            110
              DEVPOS : $006c            108
              DEVWID : $006d            109
           DHEX2TEXT : $fcc8          64712
                 DIM : $8c6a          35946
              DIMFLG : $0005              5
                 DIR : $a57e          42366
         DISAXICORWP : $fb46          64326
            DSK_FDEL : $a6be          42686
            DSK_FDIR : $a5d8          42456
            DSK_FDL1 : $a6d0          42704
             DSK_FRD : $a6d2          42706
            DSK_FRD1 : $a6f5          42741
             DSK_FWR : $a6f9          42745
            deleteFi : $eb51          60241
                EDIT : $9a9a          39578
                ELSE : $8829          34857
      ENABLE_MON_INT : $00ef            239
          ENAXICORWP : $fb85          64389
                 END : $8753          34643
              ENDCHR : $0002              2
              ENDFLG : $0000              0
            ENTRYBAS : $801a          32794
                 ESC : $001b             27
                EXEC : $81a2          33186
              EXECJP : $007a            122
             EXITBAS : $800a          32778
                 EXP : $9a59          39513
             FDIR_10 : $a66d          42605
             FDIR_11 : $a686          42630
              FDIR_2 : $a698          42648
              FDIR_3 : $a5e6          42470
              FDIR_4 : $a61b          42523
              FDIR_5 : $a618          42520
             FDIR_5_ : $a608          42504
              FDIR_6 : $a695          42645
              FDIR_8 : $a651          42577
          FILELENGTH : $000d             13
            FILE_Clo : $b4b8          46264
            FILE_Del : $b4cf          46287
            FILE_Get : $b557          46423
AS09 Assembler for M6809 [1.42].                                     Page    3
--------------------------------- merge.a09 ----------------------------------

            FILE_Lis : $bd86          48518
            FILE_Ope : $b07c          45180
            FILE_Put : $b675          46709
                FIRQ : $fd46          64838
                 FIX : $9a8b          39563
            FL_initi : $ffe7            -25
                 FOR : $8683          34435
                FPA0 : $0050             80
                FPA1 : $005d             93
                FPA2 : $0013             19
              FPCARY : $005b             91
              FPSBYT : $0063             99
              FP0EXP : $004f             79
              FP0SGN : $0054             84
              FP1EXP : $005c             92
              FP1SGN : $0061             97
              FRESPC : $0025             37
              FRETOP : $0021             33
            FUNC_TAB : $832f          33583
              FWR_19 : $a721          42785
              FWR_20 : $a74f          42831
               F_PTR : $0205            517
            fatMapTb : $fdae           -594
            fClstCnU : $ffe8            -24
            fDataSec : $fffb             -5
            freeMemo : $ea64          60004
            frstSect : $fda2           -606
              GARBFL : $0007              7
              GETCCH : $0082            130
              GETNCH : $007c            124
              GET_FN : $a5b2          42418
              GIVABF : $8e10          36368
                  GO : $87cc          34764
   GV_StackBeginAddr : $7fb9          32697
            getBootS : $e000          57344
       getCheckSum16 : $fc39          64569
            getDateF : $e2db          58075
            getFirst : $e2f4          58100
            getKeybo : $f0de          61662
         getKeyboard : $f0de          61662
            getSetFr : $e442          58434
            getSetNC : $e33b          58171
            getTimeF : $e2df          58079
            get_QByt : $e2c6          58054
            get_Word : $e2b8          58040
            HEXBYTE2 : $fca2          64674
     HEXBYTE2MONPORT : $fca2          64674
              HEXDOL : $a0e2          41186
            HEXWORD2 : $fc6d          64621
     HEXWORD2MONPORT : $fc6d          64621
                  IF : $885a          34906
               IFCTR : $0004              4
              IKEYIM : $0073            115
               INKEY : $81cb          33227
              INPFLG : $0009              9
               INPUT : $8935          35125
               INSTR : $9cdb          40155
                 INT : $95e4          38372
              INTCNV : $8d09          36105
          INT_VECTOR : $fff2          65522
         IntVectFIRQ : $7ff6          32758
          IntVectIRQ : $7ff8          32760
AS09 Assembler for M6809 [1.42].                                     Page    4
--------------------------------- merge.a09 ----------------------------------

          IntVectNMI : $7ffc          32764
        IntVectSTART : $7ffe          32766
         IntVectSWI1 : $7ffa          32762
         IntVectSWI2 : $7ff4          32756
         IntVectSWI3 : $7ff2          32754
                 IRQ : $fd11          64785
            initDISK : $a753          42835
             init_10 : $a78e          42894
            init_10_ : $a777          42871
             init_12 : $a7be          42942
            init_12_ : $a7a1          42913
             init_15 : $a7f7          42999
             init_16 : $a7f0          42992
            init_16_ : $a7d6          42966
              init_8 : $a7c7          42951
              init_9 : $a795          42901
            isKeyboa : $f0fb          61691
      isKeyboardData : $f0fb          61691
               KEYIN : $804f          32847
      KeyboardRbHead : $7fe4          32740
      KeyboardRbSize : $0008              8
      KeyboardRbTail : $7fe5          32741
     KeyboardRbuffer : $7fe6          32742
                KILL : $a589          42377
               LAA24 : $832a          33578
               LAA28 : $832e          33582
               LAA29 : $832f          33583
               LAA51 : $8369          33641
               LAA66 : $837e          33662
               LABAF : $84fd          34045
               LABED : $853f          34111
               LABEE : $8540          34112
               LABE1 : $8533          34099
               LABE8 : $853a          34106
               LABFB : $854d          34125
               LABF2 : $8544          34116
               LABF9 : $854b          34123
               LAB1A : $8440          33856
               LAB67 : $84ad          33965
               LACA0 : $85de          34270
               LACA5 : $85e3          34275
               LACA8 : $85e6          34278
               LACC0 : $85fd          34301
               LACC8 : $8605          34309
               LACDD : $8619          34329
               LACEF : $862b          34347
               LACE9 : $8625          34341
               LACF1 : $862d          34349
               LACF7 : $8633          34355
               LAC1A : $856c          34156
               LAC1E : $8570          34160
               LAC16 : $8568          34152
               LAC20 : $8572          34162
               LAC28 : $857a          34170
               LAC32 : $8584          34180
               LAC33 : $8585          34181
               LAC37 : $8589          34185
               LAC44 : $8596          34198
               LAC46 : $8598          34200
               LAC60 : $85a4          34212
               LAC68 : $85ac          34220
               LAC7C : $85c3          34243
AS09 Assembler for M6809 [1.42].                                     Page    5
--------------------------------- merge.a09 ----------------------------------

               LAC73 : $85b7          34231
               LADB1 : $86e8          34536
               LADB4 : $86eb          34539
               LADC0 : $870a          34570
               LADC6 : $8710          34576
               LADD4 : $8722          34594
               LADEA : $873b          34619
               LADEB : $873c          34620
               LADE8 : $8739          34617
               LADFA : $874b          34635
               LADFB : $874c          34636
               LADF0 : $8741          34625
               LAD01 : $863d          34365
               LAD05 : $8641          34369
               LAD12 : $864e          34382
               LAD14 : $8650          34384
               LAD16 : $8652          34386
               LAD19 : $8655          34389
               LAD21 : $865d          34397
               LAD26 : $8662          34402
               LAD33 : $866f          34415
               LAD59 : $8695          34453
               LAD7F : $86bb          34491
               LAD9E : $86da          34522
               LAD90 : $86cc          34508
               LAEA4 : $87ea          34794
               LAEBB : $8801          34817
               LAEBF : $8805          34821
               LAEB6 : $87fc          34812
               LAEDA : $8820          34848
               LAED2 : $8818          34840
               LAED7 : $881d          34845
               LAEEA : $8830          34864
               LAEEB : $8831          34865
               LAEE7 : $882d          34861
               LAEE8 : $882e          34862
               LAEF1 : $8837          34871
               LAEF7 : $883d          34877
               LAE0B : $8759          34649
               LAE11 : $875f          34655
               LAE15 : $8763          34659
               LAE22 : $8770          34672
               LAE40 : $878c          34700
               LAE5A : $87a6          34726
               LAE6F : $87bb          34747
               LAE72 : $87be          34750
               LAE88 : $87ce          34766
               LAE9F : $87e5          34789
               LAFA4 : $88ea          35050
               LAFBE : $8904          35076
               LAFB1 : $88f7          35063
               LAFCE : $8914          35092
               LAFCF : $8915          35093
               LAFDC : $891c          35100
               LAFDF : $891f          35103
               LAFD6 : $891c          35100
               LAFEA : $892a          35114
               LAF0C : $8852          34898
               LAF22 : $8868          34920
               LAF28 : $886e          34926
               LAF39 : $887f          34943
               LAF5D : $88a3          34979
AS09 Assembler for M6809 [1.42].                                     Page    6
--------------------------------- merge.a09 ----------------------------------

               LAF52 : $8898          34968
               LAF54 : $889a          34970
               LAF6B : $88b1          34993
               LAF67 : $88ad          34989
              LASTPT : $000d             13
               LA0F3 : $80e1          32993
               LA077 : $8091          32913
               LA1C1 : $804f          32847
               LA10D : $80e4          32996
               LA123 : $80f0          33008
               LA147 : $8114          33044
               LA156 : $8143          33091
               LA165 : $8145          33093
               LA171 : $801f          32799
               LA172 : $8042          32834
               LA173 : $804a          32842
               LA174 : $804e          32846
               LA3B4 : $8169          33129
               LA3B8 : $816d          33133
               LA3CC : $8181          33153
               LA3CD : $8182          33154
               LA3C2 : $8177          33143
               LA3C8 : $817d          33149
               LA3D9 : $818e          33166
               LA3E8 : $819d          33181
               LA35F : $8146          33094
               LA37C : $814c          33100
               LA38D : $8154          33108
               LA39A : $815b          33115
               LA390 : $8154          33108
               LA5A1 : $81e6          33254
               LA5C7 : $81e7          33255
               LA5C9 : $81e9          33257
               LA5E8 : $9c17          39959
               LA545 : $81a9          33193
               LA549 : $81ad          33197
               LA554 : $81b0          33200
               LA56B : $81d2          33234
               LA59A : $81df          33247
               LA6C6 : $81fc          33276
               LA6C7 : $81fe          33278
               LA8C1 : $8209          33289
               LA8D5 : $8216          33302
               LA928 : $8223          33315
               LA93F : $8229          33321
               LA937 : $8225          33317
               LA942 : $822c          33324
               LA948 : $8234          33332
               LA950 : $8242          33346
               LA960 : $828a          33418
               LA961 : $8292          33426
               LA962 : $829d          33437
               LA963 : $82a9          33449
               LA964 : $82aa          33450
               LA965 : $82ca          33482
               LA966 : $82e4          33508
               LA967 : $82ff          33535
               LA968 : $8317          33559
               LA970 : $831f          33567
               LBAAE : $93a4          37796
               LBABA : $93b0          37808
               LBAB8 : $93ae          37806
AS09 Assembler for M6809 [1.42].                                     Page    7
--------------------------------- merge.a09 ----------------------------------

               LBACA : $93c0          37824
               LBACC : $93c2          37826
               LBAC4 : $93ba          37818
               LBAC5 : $93bb          37819
               LBAD0 : $93c6          37830
               LBA1C : $9312          37650
               LBA1D : $9313          37651
               LBA18 : $930e          37646
               LBA3A : $9330          37680
               LBA3E : $9334          37684
               LBA3F : $9335          37685
               LBA39 : $932f          37679
               LBA4F : $9345          37701
               LBA44 : $933a          37690
               LBA5C : $9352          37714
               LBA66 : $935c          37724
               LBA7B : $9371          37745
               LBA72 : $9368          37736
               LBA78 : $936e          37742
               LBA79 : $936f          37743
               LBA83 : $9379          37753
               LBA9A : $9390          37776
               LBA91 : $9387          37767
               LBA92 : $9388          37768
               LBA97 : $938d          37773
               LBBA4 : $949a          38042
               LBBBD : $94b3          38067
               LBBDE : $94d4          38100
               LBBD0 : $94c6          38086
               LBBFC : $94f2          38130
               LBBF8 : $94ee          38126
               LBB00 : $93f6          37878
               LBB02 : $93f8          37880
               LBB03 : $93f9          37881
               LBB2E : $9424          37924
               LBB2F : $9425          37925
               LBB20 : $9416          37910
               LBB48 : $943e          37950
               LBB5C : $9452          37970
               LBB6A : $9460          37984
               LBB61 : $9457          37975
               LBB63 : $9459          37977
               LBB67 : $945d          37981
               LBB7C : $9472          38002
               LBB7D : $9473          38003
               LBB8F : $9485          38021
               LBB82 : $9478          38008
               LBB89 : $947f          38015
               LBB91 : $9487          38023
               LBbcc : $94c2          38082
               LBCA0 : $9596          38294
               LBCC3 : $95b9          38329
               LBCC8 : $95be          38334
               LBCD7 : $95cd          38349
               LBCE4 : $95da          38362
               LBC0B : $9501          38145
               LBC06 : $94fc          38140
               LBC14 : $950a          38154
               LBC2A : $9520          38176
               LBC2F : $9525          38181
               LBC33 : $9529          38185
               LBC35 : $952b          38187
AS09 Assembler for M6809 [1.42].                                     Page    8
--------------------------------- merge.a09 ----------------------------------

               LBC4A : $9540          38208
               LBC4C : $9542          38210
               LBC5F : $9555          38229
               LBC6D : $9563          38243
               LBC7C : $9572          38258
               LBC71 : $9567          38247
               LBC73 : $9569          38249
               LBC79 : $956f          38255
               LBC82 : $9578          38264
               LBC86 : $957c          38268
               LBC96 : $958c          38284
               LBDA5 : $969b          38555
               LBDBB : $96b1          38577
               LBDB6 : $96ac          38572
               LBDCC : $96c2          38594
               LBDC0 : $96b6          38582
               LBDC5 : $96bb          38587
               LBDDC : $96d2          38610
               LBDD6 : $96cc          38604
               LBDD9 : $96cf          38607
               LBDE4 : $96da          38618
               LBDFF : $96f5          38645
               LBD09 : $95ff          38399
               LBD11 : $9607          38407
               LBD12 : $9608          38408
               LBD2D : $9623          38435
               LBD25 : $961b          38427
               LBD31 : $9627          38439
               LBD35 : $962b          38443
               LBD53 : $9649          38473
               LBD55 : $964b          38475
               LBD59 : $964f          38479
               LBD6F : $9665          38501
               LBD61 : $9657          38487
               LBD65 : $965b          38491
               LBD7F : $9675          38517
               LBD78 : $966e          38510
               LBD86 : $967c          38524
               LBD99 : $968f          38543
               LBEAB : $97a1          38817
               LBEA3 : $9799          38809
               LBEBA : $97b0          38832
               LBEBC : $97b2          38834
               LBEB8 : $97ae          38830
               LBECD : $97c3          38851
               LBEC0 : $97b6          38838
               LBEC5 : $97bb          38843
               LBEC9 : $97bf          38847
               LBEDD : $97d3          38867
               LBED1 : $97c7          38855
               LBED5 : $97cb          38859
               LBED9 : $97cf          38863
               LBEEF : $97e5          38885
               LBEE1 : $97d7          38871
               LBEE5 : $97db          38875
               LBEE9 : $97df          38879
               LBEFC : $97f2          38898
               LBEFF : $97f5          38901
               LBEF0 : $97e6          38886
               LBE01 : $96f7          38647
               LBE09 : $96ff          38655
               LBE1F : $9715          38677
AS09 Assembler for M6809 [1.42].                                     Page    9
--------------------------------- merge.a09 ----------------------------------

               LBE18 : $970e          38670
               LBE36 : $972c          38700
               LBE4B : $9741          38721
               LBE50 : $9746          38726
               LBE72 : $9768          38760
               LBE8C : $9782          38786
               LBE84 : $977a          38778
               LBE98 : $978e          38798
               LBFA6 : $9898          39064
               LBFA9 : $989b          39067
               LBFBD : $98af          39087
               LBFB7 : $98a9          39081
               LBFCD : $98bf          39103
               LBFC2 : $98b4          39092
               LBFC7 : $98b9          39097
               LBFC8 : $98ba          39098
               LBFDC : $98ce          39118
               LBFD2 : $98c4          39108
               LBFD7 : $98c9          39113
               LBFE1 : $98d3          39123
               LBF0C : $9802          38914
               LBF01 : $97f7          38903
               LBF3B : $9831          38961
               LBF38 : $982e          38958
               LBF45 : $9839          38969
              LBUFMX : $00fa            250
               LB0A8 : $89ca          35274
               LB0B9 : $89db          35291
               LB0CD : $89ef          35311
               LB0D5 : $89f7          35319
               LB0E7 : $8a09          35337
               LB0E8 : $8a0a          35338
               LB0FE : $8a20          35360
               LB00F : $8940          35136
               LB01E : $894f          35151
               LB02F : $895c          35164
               LB03F : $896c          35180
               LB035 : $8962          35170
               LB04E : $8977          35191
               LB049 : $8972          35186
               LB069 : $898f          35215
               LB08B : $89ad          35245
               LB09E : $89c0          35264
               LB098 : $89ba          35258
               LB1A7 : $8ac9          35529
               LB1B8 : $8ada          35546
               LB1CB : $8aed          35565
               LB1CC : $8aee          35566
               LB1CE : $8af0          35568
               LB1C6 : $8ae8          35560
               LB1DF : $8b01          35585
               LB1D4 : $8af6          35574
               LB1EA : $8b0c          35596
               LB1E2 : $8b04          35588
               LB1E6 : $8b08          35592
               LB1FA : $8b1c          35612
               LB1F4 : $8b16          35606
               LB10A : $8a2c          35372
               LB10C : $8a2e          35374
               LB101 : $8a23          35363
               LB131 : $8a53          35411
               LB134 : $8a56          35414
AS09 Assembler for M6809 [1.42].                                     Page   10
--------------------------------- merge.a09 ----------------------------------

               LB14F : $8a71          35441
               LB141 : $8a63          35427
               LB143 : $8a65          35429
               LB145 : $8a67          35431
               LB146 : $8a68          35432
               LB148 : $8a6a          35434
               LB15A : $8a7c          35452
               LB153 : $8a75          35445
               LB156 : $8a78          35448
               LB158 : $8a7a          35450
               LB16A : $8a8c          35468
               LB168 : $8a8a          35466
               LB181 : $8aa3          35491
               LB19F : $8ac1          35521
               LB2CE : $8bea          35818
               LB2C7 : $8be3          35811
               LB2C9 : $8be5          35813
               LB2D4 : $8bf0          35824
               LB2D5 : $8bf1          35825
               LB2ED : $8c09          35849
               LB2F1 : $8c0d          35853
               LB2F4 : $8c10          35856
               LB201 : $8b23          35619
               LB203 : $8b25          35621
               LB22C : $8b4e          35662
               LB22F : $8b51          35665
               LB220 : $8b42          35650
               LB222 : $8b44          35652
               LB223 : $8b45          35653
               LB24E : $8b70          35696
               LB244 : $8b66          35686
               LB249 : $8b6b          35691
               LB25F : $8b81          35713
               LB26A : $8b8c          35724
               LB26D : $8b8f          35727
               LB26F : $8b91          35729
               LB262 : $8b84          35716
               LB267 : $8b89          35721
               LB27C : $8b9e          35742
               LB277 : $8b99          35737
               LB284 : $8ba6          35750
               LB287 : $8ba9          35753
               LB29F : $8bbf          35775
               LB290 : $8bb2          35762
               LB3AA : $8cc6          36038
               LB3AB : $8cc7          36039
               LB3A2 : $8cbe          36030
               LB3DC : $8cf8          36088
               LB3DE : $8cfa          36090
               LB3DF : $8cfb          36091
               LB3E4 : $8d00          36096
               LB3E6 : $8d02          36098
               LB3E9 : $8d05          36101
               LB3FE : $8d1a          36122
               LB309 : $8c25          35877
               LB32D : $8c49          35913
               LB328 : $8c44          35908
               LB33F : $8c5b          35931
               LB334 : $8c50          35920
               LB34B : $8c67          35943
               LB348 : $8c64          35940
               LB35A : $8c76          35958
AS09 Assembler for M6809 [1.42].                                     Page   11
--------------------------------- merge.a09 ----------------------------------

               LB35C : $8c78          35960
               LB357 : $8c73          35955
               LB37B : $8c97          35991
               LB371 : $8c8d          35981
               LB373 : $8c8f          35983
               LB385 : $8ca1          36001
               LB395 : $8cb1          36017
               LB4A0 : $8dbc          36284
               LB4A6 : $8dc2          36290
               LB4B9 : $8dd5          36309
               LB4CD : $8de9          36329
               LB4CE : $8dea          36330
               LB4D8 : $8df4          36340
               LB4EB : $8e07          36359
               LB4E6 : $8e02          36354
               LB4F3 : $8e0f          36367
               LB40A : $8d26          36134
               LB404 : $8d20          36128
               LB42A : $8d46          36166
               LB43B : $8d57          36183
               LB44A : $8d66          36198
               LB44C : $8d68          36200
               LB44F : $8d6b          36203
               LB447 : $8d63          36195
               LB46D : $8d89          36233
               LB461 : $8d7d          36221
               LB48C : $8da8          36264
               LB5AA : $8ec6          36550
               LB5A0 : $8ebc          36540
               LB5A8 : $8ec4          36548
               LB5B2 : $8ece          36558
               LB5B4 : $8ed0          36560
               LB5B6 : $8ed2          36562
               LB5CA : $8ee6          36582
               LB5D2 : $8eee          36590
               LB5D8 : $8ef4          36596
               LB5EC : $8f08          36616
               LB5EE : $8f0a          36618
               LB5EF : $8f0b          36619
               LB50D : $8e29          36393
               LB50F : $8e2b          36395
               LB51A : $8e38          36408
               LB51E : $8e3a          36410
               LB511 : $8e2d          36397
               LB516 : $8e32          36402
               LB518 : $8e34          36404
               LB526 : $8e42          36418
               LB533 : $8e4f          36431
               LB537 : $8e53          36435
               LB539 : $8e55          36437
               LB54C : $8e68          36456
               LB543 : $8e5f          36447
               LB555 : $8e71          36465
               LB558 : $8e74          36468
               LB56D : $8e89          36489
               LB56F : $8e8b          36491
               LB585 : $8ea1          36513
               LB591 : $8ead          36525
               LB593 : $8eaf          36527
               LB6AD : $8fc8          36808
               LB6AE : $8fc9          36809
               LB6A4 : $8fbf          36799
AS09 Assembler for M6809 [1.42].                                     Page   12
--------------------------------- merge.a09 ----------------------------------

               LB6B5 : $8fd0          36816
               LB6DE : $8ff8          36856
               LB6F5 : $900f          36879
               LB60F : $8f2a          36650
               LB62A : $8f45          36677
               LB64A : $8f65          36709
               LB64E : $8f69          36713
               LB643 : $8f5e          36702
               LB645 : $8f60          36704
               LB654 : $8f6f          36719
               LB657 : $8f72          36722
               LB659 : $8f74          36724
               LB66F : $8f8a          36746
               LB672 : $8f8d          36749
               LB675 : $8f90          36752
               LB68F : $8faa          36778
               LB680 : $8f9b          36763
               LB683 : $8f9e          36766
               LB686 : $8fa1          36769
               LB69B : $8fb6          36790
               LB69D : $8fb8          36792
               LB7B9 : $90cc          37068
               LB7CB : $90db          37083
               LB7C2 : $90d5          37077
               LB7E0 : $90f0          37104
               LB7E2 : $90f2          37106
               LB7E6 : $90f6          37110
               LB7F1 : $9101          37121
               LB7F3 : $9103          37123
               LB70B : $9025          36901
               LB70E : $9028          36904
               LB706 : $9020          36896
               LB709 : $9023          36899
               LB73D : $9057          36951
               LB734 : $904e          36942
               LB738 : $9052          36946
               LB740 : $905a          36954
               LB78D : $909f          37023
               LB783 : $9097          37015
               LB784 : $9098          37016
               LB789 : $909d          37021
               LB79F : $90b2          37042
               LB797 : $90a9          37033
               LB8A6 : $91b3          37299
               LB8A8 : $91b5          37301
               LB8CE : $91db          37339
               LB8C2 : $91cf          37327
               LB8C6 : $91d3          37331
               LB8D2 : $91df          37343
               LB8D4 : $91e1          37345
               LB8EA : $91f7          37367
               LB8FE : $9209          37385
               LB8F1 : $91fe          37374
               LB80A : $911a          37146
               LB801 : $9111          37137
               LB804 : $9114          37140
               LB814 : $9124          37156
               LB82D : $913a          37178
               LB820 : $9130          37168
               LB821 : $9131          37169
               LB829 : $9136          37174
               LB842 : $914f          37199
AS09 Assembler for M6809 [1.42].                                     Page   13
--------------------------------- merge.a09 ----------------------------------

               LB844 : $9151          37201
               LB85A : $9167          37223
               LB85C : $9169          37225
               LB852 : $915f          37215
               LB86B : $9178          37240
               LB87C : $9189          37257
               LB87E : $918b          37259
               LB873 : $9180          37248
               LB88A : $9197          37271
               LB886 : $9193          37267
               LB89B : $91a8          37288
               LB89D : $91aa          37290
               LB892 : $919f          37279
               LB9AC : $92a2          37538
               LB9AF : $92a5          37541
               LB9A3 : $9299          37529
               LB9BC : $92b2          37554
               LB9B1 : $92a7          37543
               LB9B4 : $92aa          37546
               LB9B9 : $92af          37551
               LB9CD : $92c3          37571
               LB9C2 : $92b8          37560
               LB9C5 : $92bb          37563
               LB9EC : $92e2          37602
               LB9E2 : $92d8          37592
               LB9FB : $92f1          37617
               LB902 : $920d          37389
               LB905 : $9210          37392
               LB907 : $9212          37394
               LB91B : $9220          37408
               LB91D : $9222          37410
               LB911 : $9216          37398
               LB918 : $921d          37405
               LB938 : $923d          37437
               LB949 : $9244          37444
               LB95C : $9257          37463
               LB954 : $924f          37455
               LB958 : $9253          37459
               LB965 : $9260          37472
               LB966 : $9261          37473
               LB97E : $9279          37497
               LB975 : $9270          37488
               LB977 : $9272          37490
               LB98E : $9289          37513
               LB99C : $9292          37522
               LB99F : $9295          37525
               LB992 : $9289          37513
               LB997 : $928e          37518
               LC6EA : $a5cd          42445
               LC6E9 : $a5ba          42426
               LD24F : $a585          42373
               LD25F : $a588          42376
               LD256 : $a588          42376
                LEFT : $8fc6          36806
                 LEN : $8f9c          36764
                 LET : $88cf          35023
                  LF : $000a             10
              LINBUF : $00e1            225
                LINE : $a575          42357
              LINHDR : $00df            223
                LIST : $9078          36984
                LL01 : $8337          33591
AS09 Assembler for M6809 [1.42].                                     Page   14
--------------------------------- merge.a09 ----------------------------------

                LL02 : $835b          33627
                LL03 : $835f          33631
                LL04 : $8361          33633
                LL05 : $8369          33641
                LL06 : $84b3          33971
                LL07 : $84b5          33973
                LL08 : $84b7          33975
                LL09 : $84b9          33977
                LL10 : $84bb          33979
                LL11 : $84bd          33981
                LL12 : $84c1          33985
                LOAD : $a594          42388
                 LOG : $99ae          39342
              LPTCFW : $0076            118
              LPTLCF : $0077            119
              LPTPOS : $0079            121
              LPTWID : $0078            120
              LSTTXT : $0066            102
   LV_StackBeginAddr : $7d59          32089
               L8AAC : $9fb4          40884
               L8AB2 : $9fba          40890
               L8AB9 : $9fc1          40897
               L8AC0 : $9fc8          40904
               L8AC7 : $9fcf          40911
               L8ADD : $9fe5          40933
               L8AD3 : $9fdb          40923
               L8AEB : $9ff3          40947
               L8AED : $9ff5          40949
               L8AEF : $9ff7          40951
               L8AE1 : $9fe9          40937
               L8AE5 : $9fed          40941
               L8AE9 : $9ff1          40945
               L8A02 : $9f0a          40714
               L8A04 : $9f0c          40716
               L8A2D : $9f35          40757
               L8A20 : $9f28          40744
               L8A3A : $9f42          40770
               L8A3D : $9f45          40773
               L8A67 : $9f6f          40815
               L8A68 : $9f70          40816
               L8A71 : $9f79          40825
               L8A77 : $9f7f          40831
               L8A83 : $9f8b          40843
               L8A86 : $9f8e          40846
               L8A9B : $9fa3          40867
               L8A90 : $9f98          40856
               L8A91 : $9f99          40857
               L8A95 : $9f9d          40861
               L8A99 : $9fa1          40865
               L8BAE : $a0b3          41139
               L8BBE : $a0c3          41155
               L8BC9 : $a0ce          41166
               L8BD9 : $a0de          41182
               L8BEA : $a0ef          41199
               L8BE5 : $a0ea          41194
               L8BFF : $a104          41220
               L8B1B : $a020          40992
               L8B13 : $a018          40984
               L8B17 : $a01c          40988
               L8B24 : $a029          41001
               L8B41 : $a046          41030
               L8B55 : $a05a          41050
AS09 Assembler for M6809 [1.42].                                     Page   15
--------------------------------- merge.a09 ----------------------------------

               L8B67 : $a06c          41068
               L8B7B : $a080          41088
               L8B7F : $a084          41092
               L8B71 : $a076          41078
               L8B8A : $a08f          41103
               L8B8C : $a091          41105
               L8C0B : $a110          41232
               L8C07 : $a10c          41228
               L8EAE : $a194          41364
               L8EA8 : $a18e          41358
               L8EBB : $a1a1          41377
               L8EB4 : $a19a          41370
               L8EB7 : $a19d          41373
               L8EB9 : $a19f          41375
               L8EDD : $a1c3          41411
               L8ED2 : $a1b8          41400
               L8ED8 : $a1be          41406
               L8EEF : $a1d5          41429
               L8EE2 : $a1c8          41416
               L8EFB : $a1e1          41441
               L8E3B : $a121          41249
               L8E37 : $a11d          41245
               L8E5F : $a145          41285
               L8E69 : $a14f          41295
               L8E71 : $a157          41303
               L8E82 : $a168          41320
               L8E88 : $a16e          41326
               L8E95 : $a17b          41339
               L8FB3 : $a299          41625
               L8FC4 : $a2aa          41642
               L8FC6 : $a2ac          41644
               L8FD8 : $a2be          41662
               L8FE3 : $a2c9          41673
               L8FE5 : $a2cb          41675
               L8FFA : $a2e0          41696
               L8FF2 : $a2d8          41688
               L8F1A : $a200          41472
               L8F20 : $a206          41478
               L8F24 : $a20a          41482
               L8F26 : $a20c          41484
               L8F4F : $a235          41525
               L8F41 : $a227          41511
               L8F5A : $a240          41536
               L8F74 : $a25a          41562
               L8F8F : $a275          41589
               L8F96 : $a27c          41596
               L8031 : $80d6          32982
               L83AB : $9913          39187
               L83A3 : $990c          39180
               L83A6 : $990f          39183
               L83B8 : $9920          39200
               L83C5 : $992d          39213
               L83DC : $9944          39236
               L83DF : $9947          39239
               L83D7 : $993f          39231
               L83EB : $9953          39251
               L83E0 : $9948          39240
               L83E1 : $9949          39241
               L83E6 : $994e          39246
               L83FA : $9962          39266
               L83FF : $9967          39271
               L83F0 : $9958          39256
AS09 Assembler for M6809 [1.42].                                     Page   16
--------------------------------- merge.a09 ----------------------------------

               L83F5 : $995d          39261
               L837E : $98e8          39144
               L84AC : $9a14          39444
               L84CA : $9a31          39473
               L84CF : $9a36          39478
               L84C4 : $9a2b          39467
               L84C9 : $9a30          39472
               L84DE : $9a45          39493
               L84D4 : $9a3b          39483
               L84D9 : $9a40          39488
               L84ED : $9a54          39508
               L84E3 : $9a4a          39498
               L84E8 : $9a4f          39503
               L840E : $9976          39286
               L8404 : $996c          39276
               L8409 : $9971          39281
               L841D : $9985          39301
               L841E : $9986          39302
               L8413 : $997b          39291
               L8418 : $9980          39296
               L842D : $9995          39317
               L8423 : $998b          39307
               L8428 : $9990          39312
               L843C : $99a4          39332
               L8432 : $999a          39322
               L8437 : $999f          39327
               L8441 : $99a9          39337
               L8489 : $99f1          39409
               L8491 : $99f9          39417
               L85AB : $9b12          39698
               L85AF : $9b16          39702
               L85B3 : $9b1a          39706
               L85B4 : $9b1b          39707
               L85B6 : $9b1d          39709
               L85C2 : $9b29          39721
               L85C3 : $9b2a          39722
               L85C7 : $9b2e          39726
               L85DE : $9b45          39749
               L85D1 : $9b38          39736
               L85D5 : $9b3c          39740
               L85F3 : $9b5a          39770
               L85F5 : $9b5c          39772
               L8501 : $9a68          39528
               L8504 : $9a6b          39531
               L852C : $9a93          39571
               L8529 : $9a90          39568
               L8538 : $9a9f          39583
               L854D : $9ab4          39604
               L855C : $9ac3          39619
               L855D : $9ac4          39620
               L857D : $9ae4          39652
               L8570 : $9ad7          39639
               L858A : $9af1          39665
               L858C : $9af3          39667
               L8581 : $9ae8          39656
               L859D : $9b04          39684
               L8592 : $9af9          39673
               L86A6 : $9c0d          39949
               L86D6 : $9c33          39987
               L86EB : $9c48          40008
               L86FD : $9c5a          40026
               L860F : $9b76          39798
AS09 Assembler for M6809 [1.42].                                     Page   17
--------------------------------- merge.a09 ----------------------------------

               L861E : $9b85          39813
               L8613 : $9b7a          39802
               L862E : $9b95          39829
               L8625 : $9b8c          39820
               L8626 : $9b8d          39821
               L8630 : $9b97          39831
               L8634 : $9b9b          39835
               L864A : $9bb1          39857
               L8646 : $9bad          39853
               L865C : $9bc3          39875
               L8650 : $9bb7          39863
               L8659 : $9bc0          39872
               L866B : $9bd2          39890
               L8665 : $9bcc          39884
               L867C : $9be3          39907
               L8679 : $9be0          39904
               L8685 : $9bec          39916
               L8687 : $9bee          39918
               L8694 : $9bfb          39931
               L87BE : $9d1a          40218
               L87CD : $9d29          40233
               L87DF : $9d3b          40251
               L87D6 : $9d32          40242
               L87D8 : $9d34          40244
               L87D9 : $9d35          40245
               L87EB : $9d47          40263
               L870E : $9c6b          40043
               L872E : $9c8b          40075
               L8724 : $9c81          40065
               L8727 : $9c84          40068
               L873F : $9c9c          40092
               L8746 : $9ca3          40099
               L8748 : $9ca5          40101
               L876B : $9cc8          40136
               L8768 : $9cc5          40133
               L877B : $9cd8          40152
               L8776 : $9cd3          40147
               L879C : $9cf9          40185
               L88A1 : $9dfb          40443
               L88B1 : $9e0b          40459
               L88B4 : $9e0e          40462
               L88D9 : $9e33          40499
               L88EF : $9e49          40521
               L880A : $9d66          40294
               L880C : $9d68          40296
               L880E : $9d6a          40298
               L8800 : $9d5c          40284
               L881F : $9d7b          40315
               L882E : $9d8a          40330
               L8834 : $9d90          40336
               L8845 : $9da1          40353
               L886E : $9dca          40394
               L8862 : $9dbe          40382
               L8866 : $9dc2          40386
               L89AE : $9ec5          40645
               L89BF : $9ed6          40662
               L89B4 : $9ecb          40651
               L89B8 : $9ecf          40655
               L89C0 : $9ed7          40663
               L89D2 : $9edc          40668
               L89E1 : $9eeb          40683
               L89FC : $9f04          40708
AS09 Assembler for M6809 [1.42].                                     Page   18
--------------------------------- merge.a09 ----------------------------------

               L890B : $852f          34095
               L890D : $8531          34097
               L890F : $9e4a          40522
               L891C : $9e57          40535
               L892C : $9e67          40551
               L8927 : $9e62          40546
               L8943 : $9e7e          40574
               L8944 : $9e7f          40575
               L898C : $9ea3          40611
               L899F : $9eb6          40630
               L8990 : $9ea7          40615
               L8992 : $9ea9          40617
               L8993 : $9eaa          40618
               L90AA : $a390          41872
               L90A9 : $a38f          41871
               L90BD : $a3a3          41891
               L90BF : $a3a5          41893
               L90B2 : $a398          41880
               L90B3 : $a399          41881
               L90B8 : $a39e          41886
               L90CB : $a3b1          41905
               L90EA : $a3d0          41936
               L90EE : $a3d4          41940
               L90E2 : $a3c8          41928
               L90FF : $a3e5          41957
               L9011 : $a2f7          41719
               L9015 : $a2fb          41723
               L902C : $a312          41746
               L9023 : $a309          41737
               L9050 : $a336          41782
               L9054 : $a33a          41786
               L9060 : $a346          41798
               L9065 : $a34b          41803
               L907C : $a362          41826
               L909E : $a384          41860
               L9096 : $a37c          41852
               L91A0 : $a486          42118
               L91BA : $a4a0          42144
               L91B6 : $a49c          42140
               L91CC : $a4b2          42162
               L91CD : $a4b3          42163
               L91C4 : $a4aa          42154
               L91D0 : $a4b6          42166
               L91E4 : $a4ca          42186
               L91E9 : $a4cf          42191
               L91F1 : $a4d7          42199
               L910D : $a3f3          41971
               L9108 : $a3ee          41966
               L911B : $a401          41985
               L9116 : $a3fc          41980
               L9129 : $a40f          41999
               L913C : $a422          42018
               L9130 : $a416          42006
               L9141 : $a427          42023
               L915A : $a440          42048
               L916F : $a455          42069
               L9167 : $a44d          42061
               L9177 : $a45d          42077
               L9185 : $a46b          42091
               L919E : $a484          42116
               L9200 : $a4e6          42214
               L9202 : $a4e8          42216
AS09 Assembler for M6809 [1.42].                                     Page   19
--------------------------------- merge.a09 ----------------------------------

               L9211 : $a4f7          42231
               L9213 : $a4f9          42233
               L9235 : $a51b          42267
               L924D : $a533          42291
               L9249 : $a52f          42287
               L9256 : $a53c          42300
               L926A : $a550          42320
               L9262 : $a548          42312
               L9263 : $a549          42313
               L927A : $a560          42336
               L927B : $a561          42337
               L928E : $a574          42356
               L9281 : $a567          42343
              list_i : $fda0           -608
                loop : $ef14          61204
              MAXLIN : $00fa            250
                 MEM : $8e0a          36362
              MEMSIZ : $0027             39
                 MID : $8fe9          36841
            MISO_REA : $abcb          43979
  MONITOR_PROCESS_ID : $0010             16
         MON_VERSION : $f2c7          62151
            MOSI_HIG : $abb9          43961
            MOSI_LOW : $abc2          43970
         MonSavReg_S : $7fee          32750
                main : $ef0e          61198
             msDelay : $fcfb          64763
                 NEW : $8653          34387
             NEWLINE : $8085          32901
                NEXT : $8a1a          35354
             NewAddr : $0004              4
                 NMI : $fd55          64853
         NUM_SEC_FNS : $001d             29
              Offset : $0002              2
              OLDPTR : $002d             45
              OLDTXT : $0029             41
                  ON : $8888          34952
            openFile : $e80b          59403
                PEEK : $906a          36970
             PIAinit : $f24e          62030
            PIA_ClrC : $f276          62070
              PIA_In : $f266          62054
             PIA_Out : $f260          62048
            PIA_SetC : $f26b          62059
                POKE : $9071          36977
               PORTA : $d800          55296
               PORTB : $d802          55298
                 POS : $9c13          39955
               PRINT : $9204          37380
              PROGST : $0207            519
              PUTCHR : $805c          32860
              PUTEND : $8087          32903
             PUTEXIT : $8079          32889
              PUTSTR : $fc5e          64606
               PutWS : $a69c          42652
              PutWS2 : $a6a9          42665
              PutWS3 : $a6b4          42676
            print_De : $fc5e          64606
             RAM_END : $7fff          32767
             RAM_ORG : $0000              0
            RbDectCR : $7fde          32734
              RbHead : $7fbc          32700
AS09 Assembler for M6809 [1.42].                                     Page   20
--------------------------------- merge.a09 ----------------------------------

              RbSize : $0020             32
              RbTail : $7fbd          32701
             Rbuffer : $7fbe          32702
              RdAddr : $0000              0
            RdRepeat : $0002              2
                READ : $896f          35183
              RELFLG : $000a             10
              RELPTR : $003d             61
                 REM : $8829          34857
               RENUM : $9f11          40721
               RESET : $ee9d          61085
              RESSGN : $0062             98
              RESTOR : $8735          34613
              RESVEC : $808b          32907
              RETURN : $8806          34822
               RIGHT : $8fe2          36834
                 RND : $9815          38933
        ROMcheckSTR0 : $fbbe          64446
        ROMcheckSTR1 : $fbcc          64460
        ROMcheckSTR2 : $fbd9          64473
        ROMcheckSTR3 : $fbf2          64498
            ROM0_ORG : $e000          57344
            ROM1_ORG : $8000          32768
       ROM_Integrity : $fff0          65520
               RSEED : $9866          39014
                 RUN : $87c1          34753
              RVSEED : $009e            158
            rCluster : $fff7             -9
            rsvSecCn : $ffed            -19
                SAVE : $a5a0          42400
            SCK_HIGH : $abd4          43988
             SCK_LOW : $abdd          43997
             SD_Init : $adc0          44480
            SD_readS : $af12          44818
            SD_sendC : $acae          44206
            SD_write : $afa0          44960
              SECTOK : $872a          34602
         SELECTBANK0 : $faf9          64249
         SELECTBANK1 : $fb02          64258
                 SET : $81ee          33262
                 SGN : $9570          38256
                 SIN : $986a          39018
                SKP1 : $0021             33
              SKP1LD : $0086            134
                SKP2 : $008c            140
               SOUND : $8237          33335
               SPACE : $0020             32
            SPI_Disa : $aca5          44197
            SPI_Enab : $ac9c          44188
            SPI_Init : $abe6          44006
            SPI_Read : $ac73          44147
            SPI_Rsyn : $ac27          44071
              SPI_R1 : $ac84          44164
            SPI_Writ : $ac0b          44043
           SPI_Write : $ac0b          44043
              SPI_W0 : $ac0f          44047
              SPI_W1 : $ac1c          44060
              SPI_W2 : $ac1e          44062
                 SQR : $99e8          39400
        SRecCheckSum : $0001              1
              STKBUF : $003a             58
                STOP : $8757          34647
AS09 Assembler for M6809 [1.42].                                     Page   21
--------------------------------- merge.a09 ----------------------------------

                 STR : $8e19          36377
              STRBUF : $01dc            476
              STRDES : $0056             86
              STRING : $9cab          40107
              STRSTK : $00b7            183
              STRTAB : $0023             35
           STR_BASIC : $efe3          61411
              STR_BP : $f929          63785
             STR_BP1 : $f943          63811
      STR_CMDinvalid : $fa92          64146
          STR_CMD_LD : $f780          63360
       STR_CMD_LDBAS : $fa0e          64014
    STR_CMD_LDBASEND : $fa26          64038
         STR_CMD_LD2 : $f7a1          63393
         STR_CMD_LD3 : $f7b2          63410
         STR_CMD_LD4 : $f7c7          63431
          STR_CMD_rd : $f5ac          62892
          STR_CMD_wr : $f63c          63036
         STR_COMMAND : $f30a          62218
          STR_EWdone : $f6bc          63164
             STR_EW1 : $f68c          63116
             STR_EW2 : $f696          63126
             STR_EW3 : $f6a5          63141
             STR_EW4 : $f6aa          63146
           STR_EW_CS : $f6d3          63187
              STR_GO : $f8ab          63659
         STR_MONITOR : $f2cf          62159
             STR_QBP : $f9b3          63923
            STR_QBP1 : $f9c8          63944
              STR_ST : $f8e9          63721
         STR_VERSION : $f2ed          62189
                SWI1 : $fdc7          64967
           SWI1_STR1 : $fd5d          64861
           SWI1_STR2 : $fda9          64937
           SWI1_STR3 : $fdc4          64964
                SWI2 : $fe74          65140
                SWI3 : $fe74          65140
       sAPLgetOutput : $f0b6          61622
   sAPL_KeyboardData : $f0c1          61633
             sCMDbas : $fa6e          64110
              sCMDbp : $f95b          63835
              sCMDew : $f6e0          63200
            sCMDextr : $faad          64173
              sCMDgo : $f8b8          63672
            sCMDhelp : $f570          62832
         sCMDinvalid : $faa6          64166
              sCMDld : $f7d8          63448
           sCMDldbas : $fa2b          64043
             sCMDqbp : $f9df          63967
              sCMDrd : $f57f          62847
             sCMDStp : $f8f8          63736
              sCMDwr : $f5f5          62965
          sExtrNByte : $fad1          64209
            searchNe : $e55f          58719
            secPerCl : $ffef            -17
            sectorNu : $fda6           -602
    sendCharToScreen : $f103          61699
     sendClearScreen : $f146          61766
            sendCont : $f1e4          61924
   sendContainerData : $f1e4          61924
            setDateF : $e2e3          58083
         setDateTime : $f219          61977
AS09 Assembler for M6809 [1.42].                                     Page   22
--------------------------------- merge.a09 ----------------------------------

            setDT_01 : $f22e          61998
            setDT_02 : $f230          62000
             setPins : $ab89          43913
            setpoint : $f163          61795
          setpointXY : $f163          61795
            setSound : $f1c7          61895
             setTile : $f187          61831
            setTimeF : $e2e9          58089
             setTone : $f1a7          61863
            set_QByt : $e2c6          58054
            set_Word : $e2be          58046
           sHEX2TEXT : $fcdb          64731
         sHEX2TEXT_1 : $fce5          64741
         sHEX2TEXT_2 : $fce7          64743
        sMONITORMENU : $f4e4          62692
       sMONITORSTART : $f4c2          62658
        sMON_PORT_RD : $c000          49152
        sMON_PORT_WR : $ee42          60994
      sMonProcessCmd : $f52c          62764
             sPUTSTR : $faf1          64241
             sRbInit : $f4f7          62711
             sRbRead : $f507          62727
          sRbReadCmd : $f501          62721
           sROMcheck : $fc02          64514
       sROMcheckdone : $fc38          64568
             sStrlen : $fc4b          64587
           sTEXT2HEX : $fce8          64744
         sTEXT2HEX_1 : $fcf0          64752
        sTEXT2HEX_11 : $fcf8          64760
         sTEXT2HEX_2 : $fcfa          64762
           sWLSL4bit : $fc55          64597
                 TAN : $98ea          39146
              TEMPPT : $000b             11
              TEMPTR : $000f             15
                TIME : $8249          33353
             TIME_01 : $824d          33357
             TIME_02 : $825c          33372
             TIME_03 : $826b          33387
             TIME_04 : $8276          33398
              TINPTR : $002f             47
              TMPLOC : $0003              3
              TMPTR1 : $0011             17
            TOK_DATA : $0086            134
            TOK_ELSE : $0084            132
          TOK_EQUALS : $00b7            183
          TOK_FF_USR : $ff83          65411
              TOK_FN : $00b9            185
              TOK_GO : $0081            129
         TOK_GREATER : $00b6            182
       TOK_HIGH_EXEC : $00a7            167
              TOK_IF : $0085            133
           TOK_INKEY : $0098            152
           TOK_INPUT : $0089            137
            TOK_LEFT : $0095            149
             TOK_MID : $0097            151
           TOK_MINUS : $00b0            176
             TOK_NOT : $00ac            172
            TOK_PLUS : $00af            175
           TOK_PRINT : $0087            135
             TOK_REM : $0082            130
          TOK_SNGL_Q : $0083            131
            TOK_STEP : $00ad            173
AS09 Assembler for M6809 [1.42].                                     Page   23
--------------------------------- merge.a09 ----------------------------------

             TOK_SUB : $00aa            170
             TOK_TAB : $00a8            168
            TOK_THEN : $00ab            171
              TOK_TO : $00a9            169
           TOK_USING : $00ba            186
             TOK_USR : $0083            131
              TOPRAM : $0071            113
              TOSCRN : $8076          32886
              TRCFLG : $008c            140
              TRELFL : $003f             63
               TROFF : $9c0f          39951
                TRON : $9c0e          39950
              TXTTAB : $0019             25
            totalClu : $fff3            -13
                UART : $d000          53248
           UART_Init : $f281          62081
            UartRead : $f2a0          62112
          USB_COM_RD : $c000          49152
          USB_COM_WR : $c800          51200
              USRADR : $008d            141
              USRJMP : $009b            155
                USR0 : $00a3            163
            unusedSe : $ffe9            -23
                 VAB : $0088            136
                 VAC : $0089            137
                 VAD : $008a            138
                 VAE : $008b            139
                 VAL : $9030          36912
              VALTYP : $0006              6
              VARDES : $003b             59
              VARNAM : $0037             55
               VARPT : $9c1b          39963
              VARPTR : $0039             57
              VARTAB : $001b             27
                 VCF : $008f            143
                 VDA : $009a            154
                 VD1 : $0091            145
                 VD3 : $0093            147
                 VD5 : $0095            149
                 VD7 : $0097            151
                 VD8 : $0098            152
                 VD9 : $0099            153
             VERSION : $ee46          60998
                 V4A : $004a             74
                 V4B : $004b             75
                 V4D : $004d             77
                 V40 : $0040             64
                 V41 : $0041             65
                 V42 : $0042             66
                 V43 : $0043             67
                 V44 : $0044             68
                 V45 : $0045             69
                 V46 : $0046             70
                 V47 : $0047             71
                 V48 : $0048             72
            V_SdHigh : $ffff             -1
              WrAddr : $0000              0
              WrData : $0002              2
            WriteEEP : $fb0b          64267
            WrRepeat : $0003              3
             waitCTS : $f2bf          62143
            waitdata : $f2ab          62123
AS09 Assembler for M6809 [1.42].                                     Page   24
--------------------------------- merge.a09 ----------------------------------

        waitSendDone : $f2b7          62135
              XVEC15 : $9da2          40354
              XVEC19 : $9d41          40257
               XVEC9 : $a176          41334
                ZERO : $0074            116
          _APL_init0 : $ef9a          61338
          _APL_init1 : $efc5          61381
          _APL_init2 : $efd1          61393
          _APL_init3 : $efda          61402
          _APL_init4 : $efe0          61408
  _APL_KeyboardData1 : $f0d1          61649
  _APL_KeyboardData2 : $f0db          61659
           _APL_OS_1 : $f0ae          61614
           _APL_OS_4 : $f0ac          61612
  _APL_OutputStream2 : $f056          61526
  _APL_OutputStream3 : $f075          61557
  _APL_OutputStream5 : $f0b0          61616
      _BASICprocess0 : $f018          61464
      _BASICprocess1 : $f01c          61468
      _BASICprocess2 : $f01e          61470
               _firq : $fd50          64848
              _firq0 : $fd54          64852
            _GLOBALS : $0260            608
     _getCheckSum160 : $fc3f          64575
       _getKeyboard1 : $f0f6          61686
       _getKeyboard2 : $f0fa          61690
               _irq0 : $fd18          64792
               _irq1 : $fd26          64806
               _irq2 : $fd36          64822
              _irq22 : $fd43          64835
               _irq3 : $fd45          64837
              _loop1 : $ef2a          61226
              _loop2 : $ef39          61241
           _msDelay0 : $fcfe          64766
               _nmi0 : $fd5c          64860
          _no_change : $fb2d          64301
            _putstr0 : $fc62          64610
            _putstr1 : $fc6b          64619
     _sAPLgetOutput1 : $f0b6          61622
     _sAPLgetOutput2 : $f0c0          61632
        _sCMDbasdone : $fa91          64145
           _sCMDbas0 : $fa75          64117
           _sCMDbas1 : $fa82          64130
         _sCMDbpdone : $f9b2          63922
      _sCMDbpInvalid : $f977          63863
            _sCMDbp1 : $f97c          63868
            _sCMDbp2 : $f993          63891
         _sCMDewdone : $f77c          63356
     _sCMDewInvalid0 : $f718          63256
     _sCMDewInvalid1 : $f716          63254
     _sCMDewInvalid2 : $f714          63252
     _sCMDewInvalid3 : $f712          63250
            _sCMDew1 : $f71e          63262
        _sCMDexe_rd0 : $f5b2          62898
        _sCMDexe_rd1 : $f5b8          62904
        _sCMDexe_rd2 : $f5c6          62918
        _sCMDexe_wr1 : $f649          63049
        _sCMDexe_wr2 : $f657          63063
        _sCMDextrEnd : $fad0          64208
          _sCMDextr0 : $fab0          64176
         _sCMDgodone : $f8e8          63720
      _sCMDgoInvalid : $f8c6          63686
AS09 Assembler for M6809 [1.42].                                     Page   25
--------------------------------- merge.a09 ----------------------------------

            _sCMDgo0 : $f8cb          63691
            _sCMDgo1 : $f8df          63711
           _sCMDhelp : $f57e          62846
         _sCMDldbas0 : $fa3f          64063
         _sCMDldbas1 : $fa42          64066
         _sCMDldbas2 : $fa53          64083
         _sCMDlddone : $f895          63637
      _sCMDldInvalid : $f80d          63501
            _sCMDld0 : $f813          63507
           _sCMDld00 : $f7fa          63482
           _sCMDld01 : $f81d          63517
            _sCMDld1 : $f86a          63594
            _sCMDld2 : $f892          63634
        _sCMDqbpdone : $fa0d          64013
           _sCMDqbp0 : $f9ff          63999
           _sCMDqbp1 : $fa07          64007
         _sCMDrddone : $f5ee          62958
      _sCMDrdinvalid : $f5a7          62887
        _sCMDstpdone : $f928          63784
     _sCMDstpInvalid : $f906          63750
           _sCMDstp0 : $f90b          63755
         _sCMDwrdone : $f683          63107
      _sCMDwrInvalid : $f636          63030
            _sCMDwr1 : $f643          63043
           _sCursor1 : $f129          61737
           _sExtrEnd : $faee          64238
        _sExtrNByte0 : $fad6          64214
       _sendCtnData1 : $f204          61956
            _setGVpt : $e2ef          58095
     _sMonProcessCmd : $f56f          62831
           _sRbRead1 : $f51e          62750
          _sRbRead11 : $f525          62757
           _sRbRead2 : $f529          62761
           _sRbRead3 : $f52b          62763
             _sROMok : $fc31          64561
        _sstrlenDone : $fc54          64596
           _sstrlen1 : $fc4c          64588
             _strcmp : $ab4e          43854
             _strcpy : $ab2c          43820
             _strlen : $aaf9          43769
              _swi10 : $fdce          64974
              _swi12 : $fe68          65128
          _UartRead1 : $f2aa          62122
            _u32_add : $a9df          43487
            _u32_and : $a7fe          43006
            _u32_dec : $a9b1          43441
            _u32_div : $a825          43045
            _u32_equ : $aa95          43669
            _u32_hig : $aac0          43712
            _u32_inc : $aa2e          43566
            _u32_low : $aa5c          43612
            _u32_mul : $a891          43153
            _u32_sub : $a975          43381
          _WriteEEP1 : $fb19          64281
          _WriteEEP2 : $fb22          64290
          _WriteEEP5 : $fb44          64324
          _waitdata1 : $f2ac          62124
          _waitdata2 : $f2b6          62134
              _00001 : $ee0d          60941
              _00009 : $ee27          60967
              _00020 : $ee3d          60989
              _09000 : $ee2c          60972
AS09 Assembler for M6809 [1.42].                                     Page   26
--------------------------------- merge.a09 ----------------------------------

              _09001 : $ee34          60980
              _09009 : $ee3c          60988
                 _10 : $aa91          43665
                _100 : $b53b          46395
                _101 : $b550          46416
                _102 : $b669          46697
                _103 : $b5dc          46556
                _104 : $b5b0          46512
                _105 : $b666          46694
                _106 : $b666          46694
                _107 : $b66e          46702
                _108 : $bd7f          48511
                _109 : $b8cb          47307
                 _11 : $aa8c          43660
                _110 : $b6e7          46823
                _111 : $b71d          46877
                _112 : $b71a          46874
                _113 : $b74a          46922
                _114 : $b799          47001
                _115 : $b76c          46956
                _116 : $b799          47001
                _117 : $b8c8          47304
                _118 : $b7cd          47053
                _119 : $b8bc          47292
                 _12 : $aabc          43708
                _120 : $b855          47189
                _121 : $bd7c          48508
                _122 : $bd7c          48508
                _123 : $b915          47381
                _124 : $b8e2          47330
                _125 : $b902          47362
                _126 : $b936          47414
                _127 : $ba3c          47676
                _128 : $b986          47494
                _129 : $ba21          47649
                 _13 : $aaf5          43765
                _130 : $bd7c          48508
                _131 : $ba50          47696
                _132 : $bc5e          48222
                _133 : $ba67          47719
                _134 : $bc4a          48202
                _135 : $baad          47789
                _136 : $bc4a          48202
                _137 : $bab4          47796
                _138 : $bc39          48185
                _139 : $bae9          47849
                 _14 : $aaf0          43760
                _140 : $bc39          48185
                _141 : $bb01          47873
                _142 : $bb34          47924
                _143 : $bb05          47877
                _144 : $bb2b          47915
                _145 : $bc18          48152
                _146 : $bd2f          48431
                _147 : $bd28          48424
                _148 : $bd2f          48431
                _149 : $bd53          48467
                 _15 : $ab25          43813
                _150 : $bd7f          48511
                _151 : $bdf3          48627
                _152 : $bfed          49133
                _153 : $bfe3          49123
AS09 Assembler for M6809 [1.42].                                     Page   27
--------------------------------- merge.a09 ----------------------------------

                _154 : $bdf7          48631
                _155 : $be1b          48667
                _156 : $bee4          48868
                _157 : $be93          48787
                _158 : $be37          48695
                _159 : $be8a          48778
                 _16 : $ab03          43779
                _160 : $be6a          48746
                _161 : $be8a          48778
                _162 : $bfe3          49123
                _163 : $bfbf          49087
                _164 : $bf84          49028
                _165 : $bfae          49070
                _166 : $e037          57399
                _167 : $e0cd          57549
                _168 : $e079          57465
                _169 : $e0a6          57510
                 _17 : $ab4c          43852
                _170 : $e0cd          57549
                _171 : $e125          57637
                _172 : $e0ea          57578
                _173 : $e11b          57627
                _174 : $e10b          57611
                _175 : $e137          57655
                _176 : $e18a          57738
                _177 : $e14f          57679
                _178 : $e180          57728
                _179 : $e170          57712
                 _18 : $ab44          43844
                _180 : $e19c          57756
                _181 : $e2ac          58028
                _182 : $e2b2          58034
                _183 : $e3e1          58337
                _184 : $e3a9          58281
                _185 : $e3d8          58328
                _186 : $e3cb          58315
                _187 : $e419          58393
                _188 : $e499          58521
                _189 : $e495          58517
                 _19 : $ab32          43826
                _190 : $e4bf          58559
                _191 : $e4bb          58555
                _192 : $e4e5          58597
                _193 : $e4e1          58593
                _194 : $e521          58657
                _195 : $e50d          58637
                _196 : $e53e          58686
                _197 : $e54e          58702
                _198 : $e692          59026
                _199 : $e575          58741
                  _2 : $a88f          43151
                 _20 : $ab85          43909
                _200 : $e66b          58987
                _201 : $e5ed          58861
                _202 : $e662          58978
                _203 : $e662          58978
                _204 : $e6ce          59086
                _205 : $e6a9          59049
                _206 : $e6c5          59077
                _207 : $e6c5          59077
                _208 : $e6df          59103
                _209 : $e70f          59151
AS09 Assembler for M6809 [1.42].                                     Page   28
--------------------------------- merge.a09 ----------------------------------

                 _21 : $ab52          43858
                _210 : $e6e3          59107
                _211 : $e706          59142
                _212 : $e733          59187
                _213 : $e714          59156
                _214 : $e72a          59178
                _215 : $e799          59289
                _216 : $e73f          59199
                _217 : $e790          59280
                _218 : $e774          59252
                _219 : $e790          59280
                 _22 : $ab83          43907
                _220 : $e790          59280
                _221 : $e774          59252
                _222 : $e7fe          59390
                _223 : $e79d          59293
                _224 : $e7f5          59381
                _225 : $e7e0          59360
                _226 : $e7f5          59381
                _227 : $ea5d          59997
                _228 : $ea0a          59914
                _229 : $ea00          59904
                 _23 : $ac09          44041
                _230 : $e837          59447
                _231 : $e995          59797
                _232 : $e84c          59468
                _233 : $e988          59784
                _234 : $e988          59784
                _235 : $e887          59527
                _236 : $e97c          59772
                _237 : $e8b8          59576
                _238 : $e97c          59772
                _239 : $e90e          59662
                 _24 : $abf2          44018
                _240 : $e8d5          59605
                _241 : $e904          59652
                _242 : $e904          59652
                _243 : $e97c          59772
                _244 : $ea00          59904
                _245 : $ea00          59904
                _246 : $e9fb          59899
                _247 : $ea5d          59997
                _248 : $ea9d          60061
                _249 : $ead0          60112
                 _25 : $ac00          44032
                _250 : $eb4d          60237
                _251 : $eb21          60193
                _252 : $eb32          60210
                _253 : $ee09          60937
                _254 : $eb60          60256
                _255 : $ed9b          60827
                _256 : $eb76          60278
                _257 : $ed8e          60814
                _258 : $ebb0          60336
                _259 : $ed8e          60814
                 _26 : $ac6c          44140
                _260 : $ebb5          60341
                _261 : $ed82          60802
                _262 : $ebde          60382
                _263 : $ed82          60802
                _264 : $ec31          60465
                _265 : $ebfd          60413
AS09 Assembler for M6809 [1.42].                                     Page   29
--------------------------------- merge.a09 ----------------------------------

                _266 : $ec23          60451
                _267 : $ec23          60451
                _268 : $ed82          60802
                _269 : $ec92          60562
                 _27 : $ac57          44119
                _270 : $ed0f          60687
                _271 : $ed82          60802
                _272 : $ed0f          60687
                _273 : $ed78          60792
                _274 : $ee06          60934
                _275 : $edff          60927
                 _28 : $ac39          44089
                 _29 : $ac4a          44106
                  _3 : $a837          43063
                 _30 : $ad7f          44415
                 _31 : $ad1e          44318
                 _32 : $ad1e          44318
                 _33 : $ad07          44295
                 _34 : $ad69          44393
                 _35 : $ad73          44403
                 _36 : $adb6          44470
                 _37 : $ada9          44457
                 _38 : $adad          44461
                 _39 : $ae0b          44555
                  _4 : $a86f          43119
                 _40 : $ae03          44547
                 _41 : $addf          44511
                 _42 : $ae03          44547
                 _43 : $ae5e          44638
                 _44 : $ae56          44630
                 _45 : $ae24          44580
                 _46 : $ae56          44630
                 _47 : $aead          44717
                 _48 : $aea5          44709
                 _49 : $ae63          44643
                  _5 : $a9af          43439
                 _50 : $aea5          44709
                 _51 : $af09          44809
                 _52 : $aef0          44784
                 _53 : $aee8          44776
                 _54 : $aec2          44738
                 _55 : $aee8          44776
                 _56 : $af09          44809
                 _57 : $af4d          44877
                 _58 : $af45          44869
                 _59 : $af20          44832
                  _6 : $a9dd          43485
                 _60 : $af45          44869
                 _61 : $af68          44904
                 _62 : $af90          44944
                 _63 : $af6c          44908
                 _64 : $af84          44932
                 _65 : $afdb          45019
                 _66 : $afd3          45011
                 _67 : $afae          44974
                 _68 : $afd3          45011
                 _69 : $b016          45078
                  _7 : $aa2c          43564
                 _70 : $aff3          45043
                 _71 : $b00a          45066
                 _72 : $b047          45127
                 _73 : $b072          45170
AS09 Assembler for M6809 [1.42].                                     Page   30
--------------------------------- merge.a09 ----------------------------------

                 _74 : $b050          45136
                 _75 : $b070          45168
                 _76 : $b0a6          45222
                 _77 : $b4b2          46258
                 _78 : $b1a6          45478
                 _79 : $b1a3          45475
                  _8 : $aa20          43552
                 _80 : $b4a3          46243
                 _81 : $b4a3          46243
                 _82 : $b1ba          45498
                 _83 : $b34f          45903
                 _84 : $b271          45681
                 _85 : $b20c          45580
                 _86 : $b252          45650
                 _87 : $b32e          45870
                 _88 : $b4a3          46243
                 _89 : $b49f          46239
                  _9 : $aa5a          43610
                 _90 : $b3a5          45989
                 _91 : $b3d0          46032
                 _92 : $b416          46102
                 _93 : $b4a3          46243
                 _94 : $b4b2          46258
                 _95 : $b4cd          46285
                 _96 : $b4f0          46320
                 _97 : $b508          46344
                 _98 : $b550          46416
                 _99 : $b53b          46395
            __6809__ : $0001              1

1823 labels used

14950 lines read, no errors in pass 1.
AS09 Assembler for M6809 [1.42].                                     Page   31
--------------------------------- merge.a09 ----------------------------------

                        
                        ; SBC system hardware version 1.0, clock 8.0 MHz
                        ; for AS09 Assembler for M6809 [1.42]
                        
                        ;{ ---------------------------------------------------
                        ;-----------------------CSRAM-------------------------
0000 =                  RAM_ORG				equ		$0000
7fff =                  RAM_END				equ		$7FFF 	; max 32KB size
                        
                        ;-----------------------CS0_1-------------------------
8000 =                  ROM1_ORG			equ		$8000 	; second SBC ROM, 16K section b
                        
                        ;-----------------------CS2---------------------------
c000 =                  USB_COM_RD			equ		$c000
c800 =                  USB_COM_WR			equ		$c800
d000 =                  UART				equ		$d000
d800 =                  PORTA				equ		$d800
d801 =                  CRA					equ		$d801
d802 =                  PORTB				equ		$d802
d803 =                  CRB					equ		$d803
                        
                        ;-----------------------CS3---------------------------
e000 =                  ROM0_ORG  			equ		$e000  	; first SBC ROM, 8K section 
fff0 =                  ROM_Integrity		equ		$fff0 	; SBC ROM0 checksum data ch
fff2 =                  INT_VECTOR			equ		$fff2
                        ;}
                        
                        
                        ******************************************************
                        ;
                        ; Microsoft Color Computer Basic
                        
                        		  direct 0			  ; assembler parameter for optimizatio
                        		  
0008 =                  BS        equ  $8             ; BACKSPACE CODE
000a =                  LF        equ  $A             ; LINE FEED CODE
000d =                  CR        equ  $D             ; ENTER CODE
001b =                  ESC       equ  $1B            ; ESCAPE CODE
0020 =                  SPACE     equ  $20            ; SPACE (BLANK) CODE
003a =                  STKBUF    equ  58             ; STACK BUFFER ROOM
00fa =                  LBUFMX    equ  250            ; MAX NUMBER OF CHARS IN
00fa =                  MAXLIN    equ  $FA            ; MAXIMUM MS BYTE OF LIN
                        * PSEUDO OPS
0021 =                  SKP1      equ  $21            ; OP CODE OF BRN - SKIP 
008c =                  SKP2      equ  $8C            ; OP CODE OF CMPX # - SK
0086 =                  SKP1LD    equ  $86            ; OP CODE OF LDA # - SKI
                        *                             ; AND LOAD THE VALUE OF 
                        *                             ; IS USUALLY USED TO LOA
0000 =                            org  0
0000 : 00               ENDFLG    rmb  1              ; STOP/END FLAG: POSITIV
0001 : 00               CHARAC    rmb  1              ; TERMINATOR FLAG 1
0002 : 00               ENDCHR    rmb  1              ; TERMINATOR FLAG 2
0003 : 00               TMPLOC    rmb  1              ; SCRATCH VARIABLE
0004 : 00               IFCTR     rmb  1              ; IF COUNTER - HOW MANY 
0005 : 00               DIMFLG    rmb  1              ; *DV* ARRAY FLAG 0=EVAL
0006 : 00               VALTYP    rmb  1              ; *DV* *PV TYPE FLAG: 0=
0007 : 00               GARBFL    rmb  1              ; *TV STRING SPACE HOUSE
0008 : 00               ARYDIS    rmb  1              ; DISABLE ARRAY SEARCH: 
0009 : 00               INPFLG    rmb  1              ; *TV INPUT FLAG: READ=0
000a : 00               RELFLG    rmb  1              ; *TV RELATIONAL OPERATO
000b : 0000             TEMPPT    rmb  2              ; *PV TEMPORARY STRING S
000d : 0000             LASTPT    rmb  2              ; *PV ADDR OF LAST USED 
AS09 Assembler for M6809 [1.42].                                     Page   32
--------------------------------- merge.a09 ----------------------------------

000f : 0000             TEMPTR    rmb  2              ; TEMPORARY POINTER
0011 : 0000             TMPTR1    rmb  2              ; TEMPORARY DESCRIPTOR S
0013 : 00000000         FPA2      rmb  4              ; FLOATING POINT ACCUMUL
0017 : 0000             BOTSTK    rmb  2              ; BOTTOM OF STACK AT LAS
0019 : 0000             TXTTAB    rmb  2              ; *PV BEGINNING OF BASIC
001b : 0000             VARTAB    rmb  2              ; *PV START OF VARIABLES
001d : 0000             ARYTAB    rmb  2              ; *PV START OF ARRAYS
001f : 0000             ARYEND    rmb  2              ; *PV END OF ARRAYS (+1)
0021 : 0000             FRETOP    rmb  2              ; *PV START OF STRING ST
0023 : 0000             STRTAB    rmb  2              ; *PV START OF STRING VA
0025 : 0000             FRESPC    rmb  2              ; UTILITY STRING POINTER
0027 : 0000             MEMSIZ    rmb  2              ; *PV TOP OF STRING SPAC
0029 : 0000             OLDTXT    rmb  2              ; SAVED LINE NUMBER DURI
002b : 0000             BINVAL    rmb  2              ; BINARY VALUE OF A CONV
002d : 0000             OLDPTR    rmb  2              ; SAVED INPUT PTR DURING
002f : 0000             TINPTR    rmb  2              ; TEMPORARY INPUT POINTE
0031 : 0000             DATTXT    rmb  2              ; *PV 'DATA' STATEMENT L
0033 : 0000             DATPTR    rmb  2              ; *PV 'DATA' STATEMENT A
0035 : 0000             DATTMP    rmb  2              ; DATA POINTER FOR 'INPU
0037 : 0000             VARNAM    rmb  2              ; *TV TEMP STORAGE FOR A
0039 : 0000             VARPTR    rmb  2              ; *TV POINTER TO A VARIA
003b : 0000             VARDES    rmb  2              ; TEMP POINTER TO A VARI
003d : 0000             RELPTR    rmb  2              ; POINTER TO RELATIONAL 
003f : 00               TRELFL    rmb  1              ; TEMPORARY RELATIONAL O
                        * FLOATING POINT ACCUMULATORS #3,4 & 5 ARE MOSTLY
                        * USED AS SCRATCH PAD VARIABLES.
                        ** FLOATING POINT ACCUMULATOR #3 :PACKED: ($40-$44)
0040 : 00               V40       rmb  1
0041 : 00               V41       rmb  1
0042 : 00               V42       rmb  1
0043 : 00               V43       rmb  1
0044 : 00               V44       rmb  1
                        ** FLOATING POINT ACCUMULATOR #4 :PACKED: ($45-$49)
0045 : 00               V45       rmb  1
0046 : 00               V46       rmb  1
0047 : 00               V47       rmb  1
0048 : 0000             V48       rmb  2
                        ** FLOATING POINT ACCUMULATOR #5 :PACKED: ($4A-$4E)
004a : 00               V4A       rmb  1
004b : 0000             V4B       rmb  2
004d : 0000             V4D       rmb  2
                        ** FLOATING POINT ACCUMULATOR #0
004f : 00               FP0EXP    rmb  1              ; *PV FLOATING POINT ACC
0050 : 00000000         FPA0      rmb  4              ; *PV FLOATING POINT ACC
0054 : 00               FP0SGN    rmb  1              ; *PV FLOATING POINT ACC
0055 : 00               COEFCT    rmb  1              ; POLYNOMIAL COEFFICIENT
0056 : 0000000000       STRDES    rmb  5              ; TEMPORARY STRING DESCR
005b : 00               FPCARY    rmb  1              ; FLOATING POINT CARRY B
                        ** FLOATING POINT ACCUMULATOR #1
005c : 00               FP1EXP    rmb  1              ; *PV FLOATING POINT ACC
005d : 00000000         FPA1      rmb  4              ; *PV FLOATING POINT ACC
0061 : 00               FP1SGN    rmb  1              ; *PV FLOATING POINT ACC
0062 : 00               RESSGN    rmb  1              ; SIGN OF RESULT OF FLOA
0063 : 00               FPSBYT    rmb  1              ; FLOATING POINT SUB BYT
0064 : 0000             COEFPT    rmb  2              ; POLYNOMIAL COEFFICIENT
0066 : 0000             LSTTXT    rmb  2              ; CURRENT LINE POINTER D
0068 : 0000             CURLIN    rmb  2              ; *PV CURRENT LINE # OF 
006a : 00               DEVCFW    rmb  1              ; *TV TAB FIELD WIDTH
006b : 00               DEVLCF    rmb  1              ; *TV TAB ZONE
006c : 00               DEVPOS    rmb  1              ; *TV PRINT POSITION
006d : 00               DEVWID    rmb  1              ; *TV PRINT WIDTH
006e : 00               DEVNUM 	  rmb  1			  ; *PV DEVICE NUMBER: -3=DLOAD, -2
AS09 Assembler for M6809 [1.42].                                     Page   33
--------------------------------- merge.a09 ----------------------------------

006f : 0000             BasicSavReg_S rmb 2
0071 : 0000             TOPRAM    rmb  2              ; *PV TOP OF RAM
0073 : 00               IKEYIM    rmb  1              ; *TV INKEY$ RAM IMAGE
0074 : 0000             ZERO      rmb  2              ; *PV DUMMY - THESE TWO 
                        * THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM
0076 : 00               LPTCFW    rmb  1              ; 16
0077 : 00               LPTLCF    rmb  1              ; 112
0078 : 00               LPTWID    rmb  1              ; 132
0079 : 00               LPTPOS    rmb  1              ; 0
007a : 0000             EXECJP    rmb  2              ; LB4AA
                        
                        * THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM
                        * BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE
                        * INTERPRETED IS STORED AT CHARAD.
007c : 0c84             GETNCH    inc  <CHARAD+1      ; *PV INCREMENT LS BYTE 
007e : 2602                       bne  GETCCH         ; *PV BRANCH IF NOT ZERO
0080 : 0c83                       inc  <CHARAD        ; *PV INCREMENT MS BYTE 
0082 : b6               GETCCH    fcb  $B6            ; *PV OP CODE OF lda EXT
0083 : 0000             CHARAD    rmb  2              ; *PV THESE 2 BYTES CONT
                        *         *    CHARACTER WHICH THE BASIC INTERPRETER I
                        *         *    PROCESSING
0085 : 7e8320                     jmp  BROMHK         ; JUMP BACK INTO THE BAS
                        
0088 : 00               VAB       rmb  1              ; = LOW ORDER FOUR BYTES
0089 : 00               VAC       rmb  1              ; = OF A FLOATING POINT 
008a : 00               VAD       rmb  1              ; = THESE BYTES ARE USE 
008b : 00               VAE       rmb  1              ; = BY THE RND STATEMENT
                        
                        * EXTENDED BASIC VARIABLES
008c : 00               TRCFLG    rmb  1              ; *PV TRACE FLAG 0=OFF E
008d : 0000             USRADR    rmb  2              ; *PV ADDRESS OF THE STA
                        
                        * EXTENDED BASIC SCRATCH PAD VARIABLES
008f : 0000             VCF       rmb  2
0091 : 0000             VD1       rmb  2
0093 : 0000             VD3       rmb  2
0095 : 0000             VD5       rmb  2
0097 : 00               VD7       rmb  1
0098 : 00               VD8       rmb  1
0099 : 00               VD9       rmb  1
009a : 00               VDA       rmb  1
009b : 000000           USRJMP    rmb  3              ; JUMP ADDRESS FOR BASIC
009e : 00               RVSEED    rmb  1              ; * FLOATING POINT RANDO
009f : 00000000                   rmb  4              ; * MANTISSA: INITIALLY 
                        
                        **** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)
00a3 : 0000             USR0      rmb  2              ; USR 0 VECTOR
00a5 : 0000                       rmb  2              ; USR 1
00a7 : 0000                       rmb  2              ; USR 2
00a9 : 0000                       rmb  2              ; USR 3
00ab : 0000                       rmb  2              ; USR 4
00ad : 0000                       rmb  2              ; USR 5
00af : 0000                       rmb  2              ; USR 6
00b1 : 0000                       rmb  2              ; USR 7
00b3 : 0000                       rmb  2              ; USR 8
00b5 : 0000                       rmb  2              ; USR 9
                        
00b7 : 00000000000000.. STRSTK    rmb  8*5            ; STRING DESCRIPTOR STAC
00df : 0000             LINHDR    rmb  2              ; LINE INPUT BUFFER HEAD
00e1 : 00000000000000.. LINBUF    rmb  LBUFMX+1       ; BASIC LINE INPUT BUFFE
01dc : 00000000000000.. STRBUF    rmb  41             ; STRING BUFFER
0205 : 0000             F_PTR     rmb  2              ; POINTER TO THE FILE ST
AS09 Assembler for M6809 [1.42].                                     Page   34
--------------------------------- merge.a09 ----------------------------------

0207 : 00               PROGST    rmb  1              ; START OF PROGRAM SPACE
                        
7cff =                  BasicRAMend			equ	$7cff ; RAM section reserved for BAS
f1f5 =                  CSum16_ROM1			equ $f1f5 ; BASIC ROM CheckSum16
                        
8000 =                            org  ROM1_ORG
8000 : f1f5             		  dw	CSum16_ROM1
                        
8002 :                  BASIC_ORG
                        * JUMP TO BASIC COLD START AT START OF ROM FOR CONVENI
8002 : 1a50             		  orcc #%01010000	  ; ensure init in case of softwar
8004 : 4f               		  clra
8005 : 1f8b             		  tfr  a,dp
8007 : 7e808b           		  lbra RESVEC
                        
                        ; context switching to let run BASIC in parallel
800a : 347f             EXITBAS	  pshs d,x,y,u,cc,dp
800c : 10df6f           		  sts  BasicSavReg_S
800f : be7ff0           		  ldx  BasicCallBack
8012 : cc801a           		  ldd  #ENTRYBAS
8015 : fd7ff0           		  std  BasicCallBack
8018 : 6e84             		  jmp  ,x			  ; EXIT BASIC
801a : 10de6f           ENTRYBAS  lds  BasicSavReg_S  ; ENTRY BASIC
801d : 35ff             		  puls d,x,y,u,cc,dp,pc
                        
                        * CONSOLE IN
801f : fc0205           LA171     ldd  F_PTR		  ; check if file reading open		
8022 : 2726             		  beq  LA173
                        		  
8024 : 3430               		  pshs x,y		  ; Note for generated asm from C: the
                        *		returnStatus = FILE_GetCh(srcFilePtr);
8026 : 3406             		  pshs	d
8028 : bdb557           		  lbsr	FILE_Get
802b : 3262             		  leas	2,s
                        		  
                        * 		if(returnStatus == EOF) {
802d : c11a             		  cmpb	#$1a
802f : 2611             		  bne	LA172  		  
                        * 			FILE_Close(srcFilePtr);
8031 : fc0205           		  ldd	F_PTR
8034 : 3406             		  pshs	d
8036 : bdb4b8           		  lbsr	FILE_Clo
8039 : 3262             		  leas	2,s
803b : 7f0205           		  clr   F_PTR		
803e : 7f0207           		  clr   F_PTR+2
8041 : 5f               		  clrb
                        *		}
8042 : 3530             LA172	  puls	x,y
8044 : 1f98             		  tfr  b,a
8046 : 847f             		  anda #$7F
8048 : 2604             		  bne  LA174
                        
804a : 8d03             LA173	  bsr  KEYIN          ; GET A CHARACTER FROM CON
804c : 27fc             		  beq  LA173          ; LOOP IF NO KEY DOWN
804e : 39               LA174     rts
                        
                        *
                        * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A
                        * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DO
                        *
                        *
804f :                  LA1C1
AS09 Assembler for M6809 [1.42].                                     Page   35
--------------------------------- merge.a09 ----------------------------------

804f : 8db9             KEYIN     bsr  EXITBAS
8051 : 3404             		  pshs b
8053 : bdef49           		  jsr  APLgetChar
8056 : 1f98             		  tfr  b,a
8058 : 847f             		  anda #$7F
805a : 3584                       puls b,pc
                        		  
                        
                        * CONSOLE OUT
805c : 3406             PUTCHR    pshs d              ; PRESERVE ACCD		
805e : 0d6e             		  tst  DEVNUM		  ; CHECK DEVICE NUMBER		  
8060 : 2714             		  beq  TOSCRN		  ; BRANCH IF SCREEN				  
                        		  
8062 : 3436             		  pshs d,x,y		  
8064 : 1f89             		  tfr  a,b	  		  ; char in ACCB
8066 : 3406             		  pshs d		
8068 : fc0205           		  ldd  F_PTR
806b : 3406             		  pshs d
806d : bdb675           		  lbsr FILE_Put	  	  ; Note for BASIC ASM -> C : the
8070 : 3264             		  leas 4,s
8072 : 3536             		  puls d,x,y
8074 : 2003             		  bra  PUTEXIT
                        
8076 : bdef4c           TOSCRN	  jsr  APLsendChar          
8079 : 810d             PUTEXIT	  cmpa #CR            ; IS IT CARRIAGE RETURN?
807b : 2708                       beq  NEWLINE        ; YES
807d : 0c79                       inc  LPTPOS         ; INCREMENT CHARACTER CO
807f : 9679                       lda  LPTPOS         ; CHECK FOR END OF LINE 
8081 : 9178                       cmpa LPTWID         ; AT END OF LINE PRINTER
8083 : 2502                       blo  PUTEND         ; NO
8085 : 0f79             NEWLINE   clr  LPTPOS         ; RESET CHARACTER COUNTE
8087 : 8d81             PUTEND    bsr  EXITBAS
8089 : 3586             		  puls d,pc           ; RESTORE ACCD
                                  
                        
                        *
808b :                  RESVEC
                        
                        * COLD START ENTRY
                        
808b : fe7ff0           		  ldu  BasicCallBack  ; preserve the BasicCallBack b
808e : 8e0208           		  ldx  #PROGST+1      ; POINT X TO CLEAR 1ST 1K OF R
8091 : 6f83             LA077     clr  ,--x           ; MOVE POINTER DOWN TWO-
8093 : 3001             		  leax 1,x            ; ADVANCE POINTER ONE
8095 : 26fa                       bne  LA077          ; KEEP GOING IF NOT AT B
8097 : 8e0207                     ldx  #PROGST        ; SET TO START OF PROGRA
809a : 6f80                       clr  ,x+            ; CLEAR 1ST BYTE OF BASI
809c : 9f19                       stx  TXTTAB         ; BEGINNING OF BASIC PRO
809e : 8e7cff           		  ldx  #BasicRAMend   ; end of BASIC allocated memor
80a1 : ff7ff0           		  stu  BasicCallBack  ; restore the BasicCallBack
80a4 : 9f71             		  stx  TOPRAM         ; SAVE ABSOLUTE TOP OF RAM
80a6 : 9f27                       stx  MEMSIZ         ; SAVE TOP OF STRING SPA
80a8 : 9f23                       stx  STRTAB         ; SAVE START OF STRING V
80aa : 3089ff38                   leax -200,x         ; CLEAR 200 - DEFAULT ST
80ae : 9f21                       stx  FRETOP         ; SAVE START OF STRING S
80b0 : 1f14                       tfr  x,s            ; PUT STACK THERE
80b2 : 8e80e4                     ldx  #LA10D         ; POINT X TO ROM SOURCE 
80b5 : ce0076                     ldu  #LPTCFW        ; POINT U TO RAM DESTINA
80b8 : c612                       ldb  #18            ; MOVE 18 BYTES
80ba : bd81df                     jsr  LA59A          ; MOVE 18 BYTES FROM ROM
80bd : 8639                       lda  #$39
80bf : 97de                       sta  LINHDR-1       ; PUT rts IN LINHDR-1
AS09 Assembler for M6809 [1.42].                                     Page   36
--------------------------------- merge.a09 ----------------------------------

80c1 : bd8655                     jsr  LAD19          ; G0 DO A 'NEW'
                        * EXTENDED BASIC INITIALISATION
80c4 : 8e00a3                     ldx  #USR0          ; INITIALIZE ADDRESS OF 
80c7 : 9f8d                       stx  USRADR         ; USR JUMP TABLE
                        * DISK BASIC INITIALISATION
80c9 : 0f6e             		  clr  DEVNUM		  ; DEFAULT SCREEN
80cb : 7f0205           		  clr  F_PTR
80ce : 7f0207           		  clr  F_PTR+2
                        * INITIALIZE THE USR CALLS TO 'FC ERROR'
80d1 : ce8d66                     ldu  #LB44A         ; ADDRESS OF 'FC ERROR' 
80d4 : c60a                       ldb  #10            ; 10 USR CALLS IN EX BAS
80d6 : ef81             L8031     stu  ,x++           ; STORE 'FC' ERROR AT US
80d8 : 5a                         decb                ; FINISHED ALL 10?
80d9 : 26fb                       bne  L8031          ; NO
                        		  		  
80db : 8e8113                     ldx  #LA147-1       ; POINT X TO COLOR BASIC
80de : bd9292                     jsr  LB99C          ; PRINT 'COLOR BASIC'
80e1 : 7e85b7           LA0F3     jmp  LAC73          ; GO TO MAIN LOOP OF BAS
                        
                        *
                        * THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIR
80e4 : 10               LA10D     fcb  16             ; TAB FIELD WIDTH
80e5 : 40                         fcb  64             ; LAST TAB ZONE
80e6 : 50                         fcb  80             ; PRINTER WIDTH
80e7 : 00                         fcb  0              ; LINE PRINTER POSITION
80e8 : 8d66                       fdb  LB44A          ; ARGUMENT OF EXEC COMMA
                        * LINE INPUT ROUTINE
80ea : 0c84                       inc  CHARAD+1
80ec : 2602                       bne  LA123
80ee : 0c83                       inc  CHARAD
80f0 : b60000           LA123     lda  >0000
80f3 : 7e8320                     jmp  BROMHK
                        *
                        * THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1
80f6 : 7e8d66                     jmp  LB44A          ; USR ADDRESS FOR 8K BAS
80f9 : 80                         fcb  $80            ; *RANDOM SEED
80fa : 4fc7                       fdb  $4FC7          ; *RANDON SEED OF MANTIS
80fc : 5259                       fdb  $5259          ; *.811635157
                        * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE
80fe : 3b               COMVEC    fcb  59             ; 59 BASIC COMMANDS
80ff : 837e                       fdb  LAA66          ; POINTS TO RESERVED WOR
8101 : 84ad                       fdb  LAB67          ; POINTS TO JUMP TABLE F
8103 : 1d                         fcb  29             ; 29 BASIC SECONDARY COM
8104 : 8440                       fdb  LAB1A          ; POINTS TO SECONDARY FU
8106 : 832f                       fdb  LAA29          ; POINTS TO SECONDARY FU
8108 : 0000                       fdb  0              ; NO MORE TABLES (RES WO
810a : 0000                       fdb  0              ; NO MORE TABLES
810c : 0000                       fdb  0              ; NO MORE TABLES
810e : 0000                       fdb  0              ; NO MORE TABLES
8110 : 0000                       fdb  0              ; NO MORE TABLES
8112 : 0000                       fdb  0              ; NO MORE TABLES (SECOND
                        
                        * COPYRIGHT MESSAGES
8114 : 36383039204449.. LA147     fcc  "6809 DISK EXT COLOR BASIC"
812d : 0d                         fcb  CR
812e : 28432920313938..           fcc  "(C) 1982 BY MICROSOFT"
8143 : 0d0d             LA156     fcb  CR,CR
8145 : 00               LA165     fcb  $00
                        
                        
8146 : 3416             LA35F     pshs x,b,a          ; SAVE REGISTERS
8148 : 9e76                       ldx  LPTCFW         ; TAB FIELD WIDTH AND TA
AS09 Assembler for M6809 [1.42].                                     Page   37
--------------------------------- merge.a09 ----------------------------------

814a : dc78                       ldd  LPTWID         ; PRINTER WIDTH AND POSI
814c : 9f6a             LA37C     stx  DEVCFW         ; SAVE TAB FIELD WIDTH A
814e : d76c                       stb  DEVPOS         ; SAVE PRINT POSITION
8150 : 976d                       sta  DEVWID         ; SAVE PRINT WIDTH
8152 : 3596                       puls a,b,x,pc       ; RESTORE REGISTERS
                        
                        * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASI
                        * EXIT WITH BREAK KEY: CARRY = 1
                        * EXIT WITH ENTER KEY: CARRY = 0
8154 :                  LA38D
8154 : 0f73             LA390     clr  IKEYIM         ; RESET BREAK CHECK KEY 
8156 : 8e00e2                     ldx  #LINBUF+1      ; INPUT LINE BUFFER
8159 : c601                       ldb  #1             ; ACCB CHAR COUNTER: SET
815b : bd801f           LA39A     jsr  LA171          ; GO GET A CHARACTER FRO
815e : 8108                       cmpa #BS            ; BACKSPACE
8160 : 2607                       bne  LA3B4          ; NO
8162 : 5a                         decb                ; YES - DECREMENT CHAR C
8163 : 27ef                       beq  LA390          ; BRANCH IF BACK AT STAR
8165 : 301f                       leax -1,x           ; DECREMENT BUFFER POINT
8167 : 2034                       bra  LA3E8          ; ECHO CHAR TO SCREEN
8169 : 8115             LA3B4     cmpa #$15           ; SHIFT RIGHT ARROW?
816b : 260a                       bne  LA3C2          ; NO
                        * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LIN
816d : 5a               LA3B8     decb                ; DEC CHAR CTR
816e : 27e4                       beq  LA390          ; GO BACK TO START IF CH
8170 : 8608                       lda  #BS            ; BACKSPACE?
8172 : bd805c                     jsr  PUTCHR         ; SEND TO CONSOLE OUT (S
8175 : 20f6                       bra  LA3B8          ; KEEP GOING
8177 : 8103             LA3C2     cmpa #3             ; BREAK KEY?
8179 : 1a01                       orcc #1             ; SET CARRY FLAG
817b : 2705                       beq  LA3CD          ; BRANCH IF BREAK KEY DO
817d : 810d             LA3C8     cmpa #CR            ; ENTER KEY?
817f : 260d                       bne  LA3D9          ; NO
8181 : 4f               LA3CC     clra                ; CLEAR CARRY FLAG IF EN
8182 : 3401             LA3CD     pshs cc             ; SAVE CARRY FLAG
8184 : bd9253                     jsr  LB958          ; SEND CR TO SCREEN
8187 : 6f84                       clr  ,x             ; MAKE LAST BYTE IN INPU
8189 : 8e00e1                     ldx  #LINBUF        ; RESET INPUT BUFFER POI
818c : 3581             		  puls cc,pc          ; RESTORE CARRY FLAG
                        
                        * INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER
818e : 8120             LA3D9     cmpa #$20           ; IS IT CONTROL CHAR?
8190 : 25c9                       blo  LA39A          ; BRANCH IF CONTROL CHAR
8192 : 817b                       cmpa #'z'+1         ; *
8194 : 24c5                       bcc  LA39A          ; * IGNORE IF > LOWER CA
8196 : c1fa                       cmpb #LBUFMX        ; HAVE 250 OR MORE CHARA
8198 : 24c1                       bcc  LA39A          ; YES, IGNORE ANY MORE
819a : a780                       sta  ,x+            ; PUT IT IN INPUT BUFFER
819c : 5c                         incb                ; INCREMENT CHARACTER CO
819d : bd805c           LA3E8     jsr  PUTCHR         ; ECHO IT TO SCREEN
81a0 : 20b9                       bra  LA39A          ; GO SET SOME MORE
                        
                        
                        * EXEC
81a2 : 2705             EXEC      beq  LA545          ; BRANCH IF NO ARGUMENT
81a4 : bd9057                     jsr  LB73D          ; EVALUATE ARGUMENT - AR
81a7 : 9f7a                       stx  EXECJP         ; STORE X TO EXEC JUMP A
81a9 : 6e9f007a         LA545     jmp  [EXECJP]       ; GO DO IT
                        
                        * BREAK CHECK
81ad : 7e873c           LA549     jmp  LADEB          ; GO DO BREAK KEY CHECK
                        
AS09 Assembler for M6809 [1.42].                                     Page   38
--------------------------------- merge.a09 ----------------------------------

                        * THIS ROUTINE EVALUATES AN ARGUMENT
                        * AND MAKES SURE IT IS WITHIN LIMITS OF VIDEO DISPLAY 
81b0 : bd8d00           LA554	  jsr  LB3E4		  ; EVALUATE EXPRESSION AND RETURN
81b3 : 1083027f         		  cmpd #639			  ; ONLY 512 VIDEO DISPLAY LOCATIONS (
81b7 : 10220bab         		  lbhi LB44A		  ; BRANCH IF > 511 TO ‘ILLEGAL FUNC
81bb : 3404             		  pshs b  			  ; SAVE LOWER PART 0-31 (5-BIT)
81bd : 58               		  lslb				  ; SHIFT 3-BIT VER VALUE TO ACCA
81be : 49               		  rola
81bf : 58               		  lslb
81c0 : 49               		  rola
81c1 : 58               		  lslb
81c2 : 49               		  rola				  ; VER VALUE IN ACCA
81c3 : 3504             		  puls b
81c5 : c41f             		  andb #$1F			  ; KEEP HOR VALUE
81c7 : bdef74           		  jsr APLsetXY 		  ; GET CHARACTER LOCATION (VER IN 
81ca : 39               		  rts
                        		
                        * INKEY$
81cb : 9673             INKEY     lda  IKEYIM         ; WAS A KEY DOWN IN THE 
81cd : 2603                       bne  LA56B          ; YES
81cf : bd804f                     jsr  KEYIN          ; GO GET A KEY
81d2 : 0f73             LA56B     clr  IKEYIM         ; CLEAR INKEY RAM IMAGE
81d4 : 9753                       sta  FPA0+3         ; STORE THE KEY IN FPA0
81d6 : 10260dd0                   lbne LB68F          ; CONVERT FPA0+3 TO A ST
81da : 9756                       sta  STRDES         ; SET LENGTH OF STRING =
81dc : 7e8fb6                     jmp  LB69B          ; PUT A NULL STRING ONTO
                        
                        * MOVE ACCB BYTES FROM (X) TO (U)
81df : a680             LA59A     lda  ,x+            ; GET BYTE FROM X
81e1 : a7c0                       sta  ,u+            ; STORE IT AT U
81e3 : 5a                         decb                ; MOVED ALL BYTES?
81e4 : 26f9                       bne  LA59A          ; NO
81e6 : 39               LA5A1     rts
                        
                        ** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BAS
                        ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTE
                        ** FOLLOWING THE END OF THE NAME
81e7 : 9d82             LA5C7     jsr  GETCCH         ; GET CURRENT INPUT CHAR
81e9 : 27fb             LA5C9     beq  LA5A1          ; RETURN IF END OF LINE
81eb : 7e8b99                     jmp  LB277          ; SYNTAX ERROR IF ANY MO
                        
                        * SET  ; SET(x,y,col)
81ee : 8d19             SET       bsr LA8C1			; GET ABSOLUTE SCREEN POSITION O
81f0 : 3406             		  pshs d 			; SAVE CHARACTER LOCATION
81f2 : bd9052           		  jsr LB738			; SYNTAX CHECK FOR COMMA - RETURN EXPR
81f5 : 5d               		  tstb				; VALID ARGUMENT?
81f6 : 2704             		  beq LA6C6			; IF ARGUMENT <1, USE DEFAULT
81f8 : c107             		  cmpb #7			; VALID ARGUMENT?
81fa : 2302             		  bls LA6C7			; ILLEGAL COLOR - ‘ILLEGAL FUNCTION 
81fc : c602             LA6C6	  ldb #2			; GREEN DEFAULT VALUE
81fe :                  LA6C7	  					; THE COLOR IN ACCB IS IGNORED
81fe : bd8b89           		  jsr LB267		    ; SYNTAX CHECK FOR ‘)‘
8201 : 3504             		  puls b			; REGET CHARACTER LOCATION (HOR IN ACCB)
8203 : 3502             		  puls a			; REGET CHARACTER LOCATION (VER IN ACCA)
8205 : bdef74           		  jsr APLsetXY
8208 : 39               		  rts
                        
                        *** THIS ROUTINE WILL CHECK SYNTAX AND CHECK FOR LEGAL
                        *** OF SET,RESET & POINT HORIZONTAL AND VERTICAL PARAM
                        *** AND RETURN THEIR ABSOLUTE SCREEN ADDRESS IN THE X 
                        *** WHICH OF THE FOUR PIXELS OF THE GRAPHIC BLOCK SELE
                        *** IS RETURNED IN GRBLOK.
AS09 Assembler for M6809 [1.42].                                     Page   39
--------------------------------- merge.a09 ----------------------------------

8209 : bd8b8c           LA8C1 	  jsr LB26A			; SYNTAX CHECK FOR "("
820c : bd9025           		  jsr LB70B			; EVALUATE EXPRESSION - RETURN VALUE I
                        		  ;cmpb #63			; ONLY 64 HORIZONTAL GRAPHIC BLOCKS
                        		  ;bhi LA948		; ‘ILLEGAL FUNCTION CALL’
820f : 3404             		  pshs b			; SAVE HOR COORD
8211 : bd9052           		  jsr LB738			; SYNTAX CHECK FOR COMMA AND EVALUATE 
8214 : 3502             		  puls a			; KEEP VERT COORD IN ACCB, GET HOR COORD 
                        		  ;cmpb #31
8216 :                  LA8D5 	  ;bhi LA948		; ‘ILLEGAL FUNCTION CALL’		  
8216 : 39               		  rts
                        		  
                        * CLS  ; CLS "color" [the color values are: 1 red, 2 g
8217 : 270a             CLS		  beq LA928			; BRANCH IF NO ARGUMENT
8219 : bd9025           		  jsr LB70B			; CALCULATE ARGUMENT, RETURN VALUE IN 
821c : 5d               		  tstb				; VALID ARGUMENT?
821d : 2704             		  beq LA928			; IF ARGUMENT <1, USE DEFAULT
821f : c107             		  cmpb #7			; VALID ARGUMENT?
8221 : 2302             		  bls LA937			; IF ARGUMENT >7, USE DEFAULT
8223 : c602             LA928	  ldb #2			; GREEN DEFAULT VALUE
8225 : bdef5e           LA937	  jsr APLclearscreen
8228 : 39                         rts
                        
8229 : bd8b8f           LA93F 	  jsr LB26D			; SYNTAX CHECK FOR A COMMA
822c : bd9025           LA942 	  jsr LB70B			; EVALUATE EXPRESSION, RETURN VAL
822f : 5d               		  tstb				; SET FLAGS
8230 : 2610             		  bne LA950			; RETURN IF NON ZERO
8232 : 3261             		  leas 1,s			; CLEAR PUSHED VALUE
8234 : 7e8d66           LA948	  jmp LB44A			; ‘ILLEGAL FUNCTION CALL’ IF Z
                        
                        * SOUND  ; SOUND tone,duration [tone and duration are 
8237 : 8df3             SOUND     bsr LA942			; EVALUATE EXPRESSION (FREQUENCY
8239 : 3404             		  pshs b			; SAVE IT
823b : 8dec             		  lbsr LA93F		; EVALUATE EXPRESSION (SOUND LENGTH), 
823d : 3502             		  puls a			; SAVE FREQuENCY IN ACCA, LENGTH OF SOUND
823f : bdef65           		  jsr  APLsound
8242 : 39               LA950	  rts  
                        
                        * DATE  ; DATE YY,MM,DD [each between 0-255]
8243 : 1fa8             DATE      tfr  ccr,a		; preserve Z flag
8245 : c664             		  ldb  #'d'			; date command
8247 : 2004             		  bra  TIME_01
                        		  
                        * TIME  ; TIME HH,MM,SS [each between 0-255]
8249 : 1fa8             TIME      tfr  ccr,a		; preserve Z flag
824b : c674             		  ldb  #'t'		  		  
824d : 3404             TIME_01	  pshs b			; memorize the intial cmd (t or d)
824f : 8d0b             		  bsr  TIME_02		; 
8251 : 3502             		  puls a			; memorized the intial cmd (i or d)
8253 : 8c0000           		  cmpx #0
8256 : 102700c5         		  lbeq LA970		  
825a : 204e             		  bra  LA964		  
                        
825c : 1f8a             TIME_02	  tfr  a,ccr		; restore Z flag
825e : 272a             		  beq  LA960		; BRANCH IF NO ARGUMENT		  
8260 : 3404             		  pshs b			; cmd param 1
8262 : c164             		  cmpb #'d'
8264 : 2705             		  beq  TIME_03  
8266 : bd9025           		  lbsr LB70B		; EVALUATE EXPRESSION (HH), RETURN VAL
8269 : 200b             		  bra  TIME_04
826b : bd9057           TIME_03	  lbsr LB73D		; EVALUATE EXPRESSION (YYYY), RE
826e : 1f10             		  tfr x,d		  
8270 : 8307bc           		  subd #1980		; validate
AS09 Assembler for M6809 [1.42].                                     Page   40
--------------------------------- merge.a09 ----------------------------------

8273 : 2a01             		  bpl TIME_04
8275 : 5f               		  clrb	  
8276 : 3404             TIME_04	  pshs b			; param 2
8278 : bd8b8f           		  lbsr LB26D		; SYNTAX CHECK FOR A COMMA
827b : bd9025           		  lbsr LB70B		; EVALUATE EXPRESSION (MM or MM), RETU
827e : 3404             		  pshs b			; param 3
8280 : bd8b8f           		  lbsr LB26D		; SYNTAX CHECK FOR A COMMA
8283 : bd9025           		  lbsr LB70B		; EVALUATE EXPRESSION (DD or SS), RETU
8286 : 3404             		  pshs b			; param 4		  
8288 : 2008             		  bra  LA961	  
828a : c664             LA960	  ldb  #'d'			; override with d when no params
828c : 4f               		  clra
828d : 3406             		  pshs d			; date command with 0 0 0 to trigger the 
828f : 5f               		  clrb		  
8290 : 3406             		  pshs d
8292 : bdf219           LA961	  jsr  setDateTime	; launch the date command
8295 : 3264             		  leas 4,s			; clear pushed params
8297 : 7f7fe1           		  clr  APLdate+1	; reset last timestamp lower byte
829a : 8e01f4           		  ldx  #500			; repeat until max 500 reception tenta
829d : bd800a           LA962	  lbsr EXITBAS		; process the income string (tim
82a0 : 301f             		  leax -1,x
82a2 : 2705             		  beq  LA963		; abort
82a4 : 7d7fe1           		  tst  APLdate+1
82a7 : 27f4             		  beq  LA962		; wait until timestamp received		  
82a9 : 39               LA963	  rts
                        		  
82aa : 8174             LA964	  cmpa #'t'
82ac : 2736             		  beq  LA966		; extract the time instead
82ae : 4f               		  clra
82af : f67fe0           		  ldb  APLdate		; year is bit 15-9
82b2 : 54               		  lsrb		  
82b3 : c307bc           		  addd #1980
82b6 : 3440             		  pshs u
82b8 : bd96c2           		  lbsr LBDCC		; CONVERT ACCD TO DECIMAL AND PRINT ON
82bb : 3540             		  puls u
82bd : 862f             		  lda  #'/'
82bf : bd805c           		  lbsr PUTCHR       ; SEND TO CONSOLE OUT (SCREEN)
82c2 : fc7fe0           		  ldd  APLdate		; month is bit 8-5
82c5 : 8401             		  anda #$1
82c7 : 8e0005           		  ldx  #5
82ca : 44               LA965	  lsra
82cb : 56               		  rorb
82cc : 301f             		  leax -1,x
82ce : 26fa             		  bne  LA965
82d0 : 3440             		  pshs u
82d2 : bd96c2           		  lbsr LBDCC		; CONVERT ACCD TO DECIMAL AND PRINT ON
82d5 : 3540             		  puls u
82d7 : 862f             		  lda  #'/'
82d9 : bd805c           		  lbsr PUTCHR       ; SEND TO CONSOLE OUT (SCREEN)
82dc : 4f               		  clra
82dd : f67fe1           		  ldb  APLdate+1	; day is bit 4-0
82e0 : c41f             		  andb #$1f
82e2 : 2033             		  bra  LA968
82e4 : 4f               LA966	  clra
82e5 : f67fe2           		  ldb  APLtime		; hour is bit 15-11
82e8 : 54               		  lsrb
82e9 : 54               		  lsrb
82ea : 54               		  lsrb
82eb : 3440             		  pshs u
82ed : bd96c2           		  lbsr LBDCC		; CONVERT ACCD TO DECIMAL AND PRINT ON
82f0 : 3540             		  puls u
82f2 : 863a             		  lda  #':'
AS09 Assembler for M6809 [1.42].                                     Page   41
--------------------------------- merge.a09 ----------------------------------

82f4 : bd805c           		  lbsr PUTCHR       ; SEND TO CONSOLE OUT (SCREEN)
82f7 : fc7fe2           		  ldd  APLtime		; minute is bit 10-5
82fa : 8407             		  anda #$7
82fc : 8e0005           		  ldx  #5
82ff : 44               LA967	  lsra
8300 : 56               		  rorb
8301 : 301f             		  leax -1,x
8303 : 26fa             		  bne  LA967		  		  
8305 : 3440             		  pshs u
8307 : bd96c2           		  lbsr LBDCC		; CONVERT ACCD TO DECIMAL AND PRINT ON
830a : 3540             		  puls u
830c : 863a             		  lda  #':'
830e : bd805c           		  lbsr PUTCHR       ; SEND TO CONSOLE OUT (SCREEN)
8311 : f67fe3           		  ldb  APLtime+1	; seconde is bit 4-0
8314 : c41f             		  andb #$1f
8316 : 58               		  lslb
8317 : 4f               LA968	  clra
8318 : 3440             		  pshs u
831a : bd96c2           		  lbsr LBDCC		; CONVERT ACCD TO DECIMAL AND PRINT ON
831d : 3540             		  puls u
831f : 39               LA970	  rts
                        
                        * SET CARRY IF NUMERIC - RETURN WITH
                        * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END
                        * OF BASIC LINE OR SUB LINE
8320 : 813a             BROMHK    cmpa #'9'+1         ; IS THIS CHARACTER >=(A
8322 : 240a                       bhs  LAA28          ; BRANCH IF > 9; Z SET I
8324 : 8120                       cmpa #SPACE         ; SPACE?
8326 : 2602                       bne  LAA24          ; NO - SET CARRY IF NUME
8328 : 0e7c                       jmp  GETNCH         ; IF SPACE, GET NECT CHA
832a : 8030             LAA24     suba #'0'           ; * SET CARRY IF
832c : 80d0                       suba #-'0'          ; * CHARACTER > ASCII 0
832e : 39               LAA28     rts
                        
                        * DISPATCH TABLE FOR SECONDARY FUNCTIONS
                        * TOKENS ARE PRECEEDED BY $FF
                        * FIRST SET ALWAYS HAS ONE PARAMETER
832f :                  FUNC_TAB
832f : 9570             LAA29     fdb  SGN            ; SGN
8331 : 95e4                       fdb  INT            ; INT
8333 : 9589                       fdb  ABS            ; ABS
8335 : 009b                       fdb  USRJMP         ; USR
0083 =                  TOK_USR   equ  $83			  ; (LL01-FUNC_TAB)/2+$7F
ff83 =                  TOK_FF_USR equ  $ff83		  ; (LL01-FUNC_TAB)/2+$FF7F
8337 : 9815             LL01      fdb  RND            ; RND
8339 : 986a                       fdb  SIN            ; SIN
833b : 906a                       fdb  PEEK           ; PEEK
833d : 8f9c                       fdb  LEN            ; LEN
833f : 8e19                       fdb  STR            ; STR$
8341 : 9030                       fdb  VAL            ; VAL
8343 : 8fbb                       fdb  ASC            ; ASC
8345 : 8fa7                       fdb  CHR            ; CHR$
8347 : 9918                       fdb  ATN            ; ATN
8349 : 98e2                       fdb  COS            ; COS
834b : 98ea                       fdb  TAN            ; TAN
834d : 9a59                       fdb  EXP            ; EXP
834f : 9a8b                       fdb  FIX            ; FIX
8351 : 99ae                       fdb  LOG            ; LOG
8353 : 9c13                       fdb  POS            ; POS
8355 : 99e8                       fdb  SQR            ; SQR
8357 : a0e2                       fdb  HEXDOL         ; HEX$
                        * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
AS09 Assembler for M6809 [1.42].                                     Page   42
--------------------------------- merge.a09 ----------------------------------

8359 : 8fc6                       fdb  LEFT           ; LEFT$
0095 =                  TOK_LEFT  equ  $95 			  ; ((LL02-FUNC_TAB)/2)+$7F
835b : 8fe2             LL02      fdb  RIGHT          ; RIGHT$
835d : 8fe9                       fdb  MID            ; MID$
0097 =                  TOK_MID   equ  $97			  ; (LL03-FUNC_TAB)/2+$7F
                        * REMAINING FUNCTIONS
835f : 81cb             LL03      fdb  INKEY          ; INKEY$
0098 =                  TOK_INKEY equ  $98			  ;(LL04-FUNC_TAB)/2+$7F
8361 : 8e0a             LL04      fdb  MEM            ; MEM
8363 : 9c1b                       fdb  VARPT          ; VARPTR
8365 : 9cdb                       fdb  INSTR          ; INSTR
8367 : 9cab                       fdb  STRING         ; STRING$
001d =                  NUM_SEC_FNS equ  $1d	      ; (LL05-FUNC_TAB)/2
8369 :                  LL05
                        
                        * THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESS
                        * AND LOGICAL OPERATORS - THE NEGATION OPERATORS DO NO
                        * S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREAT
                        * EXPRESSION EVALUATION ROUTINE. THEY ARE:
                        * UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGAT
                        * THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, 
                        * A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSI
                        *
8369 : 79               LAA51     fcb  $79
836a : 92bb                       fdb  LB9C5          ; +
836c : 79                         fcb  $79
836d : 92b2                       fdb  LB9BC          ; -
836f : 7b                         fcb  $7B
8370 : 93c2                       fdb  LBACC          ; *
8372 : 7b                         fcb  $7B
8373 : 9487                       fdb  LBB91          ; /
8375 : 7f                         fcb  $7F
8376 : 99f1                       fdb  L8489          ; EXPONENTIATION
8378 : 50                         fcb  $50
8379 : 8bf1                       fdb  LB2D5          ; AND
837b : 46                         fcb  $46
837c : 8bf0                       fdb  LB2D4          ; OR
                        
                        * THIS IS THE RESERVED WORD TABLE
                        * FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS
837e : 464f             LAA66     fcc  "FO"           ; 80
8380 : d2                         fcb  $80+'R'
8381 : 47                         fcc  "G"            ; 81
8382 : cf                         fcb  $80+'O'
0081 =                  TOK_GO    equ  $81
8383 : 5245                       fcc  "RE"           ; 82
8385 : cd                         fcb  $80+'M'
8386 : a7                         fcb  $80+$27        ; 83 + '''
8387 : 454c53                     fcc  "ELS"          ; 84
838a : c5                         fcb  $80+'E'
838b : 49                         fcc  "I"            ; 85
838c : c6                         fcb  $80+'F'
838d : 444154                     fcc  "DAT"          ; 86
8390 : c1                         fcb  $80+'A'
8391 : 5052494e                   fcc  "PRIN"         ; 87
8395 : d4                         fcb  $80+'T'
8396 : 4f                         fcc  "O"            ; 88
8397 : ce                         fcb  $80+'N'
8398 : 494e5055                   fcc  "INPU"         ; 89
839c : d4                         fcb  $80+'T'
839d : 454e                       fcc  "EN"           ; 8A
839f : c4                         fcb  $80+'D'
AS09 Assembler for M6809 [1.42].                                     Page   43
--------------------------------- merge.a09 ----------------------------------

83a0 : 4e4558                     fcc  "NEX"          ; 8B
83a3 : d4                         fcb  $80+'T'
83a4 : 4449                       fcc  "DI"           ; 8C
83a6 : cd                         fcb  $80+'M'
83a7 : 524541                     fcc  "REA"          ; 8D
83aa : c4                         fcb  $80+'D'
83ab : 5255                       fcc  "RU"           ; 8E
83ad : ce                         fcb  $80+'N'
83ae : 524553544f52               fcc  "RESTOR"       ; 8F
83b4 : c5                         fcb  $80+'E'
83b5 : 5245545552                 fcc  "RETUR"        ; 90
83ba : ce                         fcb  $80+'N'
83bb : 53544f                     fcc  "STO"          ; 91
83be : d0                         fcb  $80+'P'
83bf : 504f4b                     fcc  "POK"          ; 92
83c2 : c5                         fcb  $80+'E'
83c3 : 434f4e                     fcc  "CON"          ; 93
83c6 : d4                         fcb  $80+'T'
83c7 : 4c4953                     fcc  "LIS"          ; 94
83ca : d4                         fcb  $80+'T'
83cb : 434c4541                   fcc  "CLEA"         ; 95
83cf : d2                         fcb  $80+'R'
83d0 : 4e45                       fcc  "NE"           ; 96
83d2 : d7                         fcb  $80+'W'
83d3 : 5345                       fcc  "SE"           ; 97
83d5 : d4                         fcb  $80+'T'
83d6 : 434c             		  fcc  "CL"           ; 98
83d8 : d3                         fcb  $80+'S'
83d9 : 534f554e         		  fcc  "SOUN"         ; 99
83dd : c4                         fcb  $80+'D'
83de : 455845           		  fcc  "EXE"          ; 9A
83e1 : c3                         fcb  $80+'C'
83e2 : 4445                       fcc  "DE"           ; 9B
83e4 : cc                         fcb  $80+'L'
83e5 : 454449                     fcc  "EDI"          ; 9C
83e8 : d4                         fcb  $80+'T'
83e9 : 54524f                     fcc  "TRO"          ; 9D
83ec : ce                         fcb  $80+'N'
83ed : 54524f46                   fcc  "TROF"         ; 9E
83f1 : c6                         fcb  $80+'F'
83f2 : 4445                       fcc  "DE"           ; 9F
83f4 : c6                         fcb  $80+'F'
83f5 : 4c494e                     fcc  "LIN"          ; A0
83f8 : c5                         fcb  $80+'E'
83f9 : 52454e55                   fcc  "RENU"         ; A1
83fd : cd                         fcb  $80+'M'          
83fe : 4449                       fcc  "DI"           ; A2
8400 : d2                         fcb  $80+'R'
8401 : 4b494c                     fcc  "KIL"          ; A3
8404 : cc                         fcb  $80+'L'
8405 : 4c4f41                     fcc  "LOA"          ; A4
8408 : c4                         fcb  $80+'D'
8409 : 534156                     fcc  "SAV"          ; A5
840c : c5                         fcb  $80+'E'          
840d : 444154                     fcc  "DAT"          ; A6
8410 : c5                         fcb  $80+'E'
8411 : 54494d                     fcc  "TIM"          ; A7
8414 : c5                         fcb  $80+'E'          
                        * END OF EXECUTABLE COMMANDS. THE REMAINDER OF THE TAB
8415 : 544142                     fcc  "TAB"          ; A8
8418 : a8                         fcb  $80+'('
00a8 =                  TOK_TAB   equ  $A8
AS09 Assembler for M6809 [1.42].                                     Page   44
--------------------------------- merge.a09 ----------------------------------

8419 : 54                         fcc  "T"            ; A9
841a : cf                         fcb  $80+'O'
00a9 =                  TOK_TO    equ  $A9
841b : 5355                       fcc  "SU"           ; AA
841d : c2                         fcb  $80+'B'
00aa =                  TOK_SUB   equ  $AA
841e : 544845                     fcc  "THE"          ; AB
8421 : ce                         fcb  $80+'N'
00ab =                  TOK_THEN  equ  $AB
8422 : 4e4f                       fcc  "NO"           ; AC
8424 : d4                         fcb  $80+'T'
00ac =                  TOK_NOT   equ  $AC
8425 : 535445                     fcc  "STE"          ; AD
8428 : d0                         fcb  $80+'P'
00ad =                  TOK_STEP  equ  $AD
8429 : 4f46                       fcc  "OF"           ; AE
842b : c6                         fcb  $80+'F'
842c : ab                         fcb  '+'+$80        ; AF
00af =                  TOK_PLUS  equ  $AF
842d : ad                         fcb  $80+'-'        ; B0
00b0 =                  TOK_MINUS equ  $B0
842e : aa                         fcb  $80+'*'        ; B1
842f : af                         fcb  $80+'/'        ; B2
8430 : de                         fcb  $80+'^'        ; B3
8431 : 414e                       fcc  "AN"           ; B4
8433 : c4                         fcb  $80+'D'
8434 : 4f                         fcc  "O"            ; B5
8435 : d2                         fcb  $80+'R'
8436 : be                         fcb  $80+'>'        ; B6
00b6 =                  TOK_GREATER equ  $B6
8437 : bd                         fcb  $80+'='        ; B7
00b7 =                  TOK_EQUALS equ  $B7
8438 : bc                         fcb  $80+'<'        ; B8
8439 : 46                         fcc  "F"            ; B9
843a : ce                         fcb  $80+'N'
00b9 =                  TOK_FN    equ  $B9
843b : 5553494e                   fcc  "USIN"         ; BA
843f : c7                         fcb  $80+'G'
00ba =                  TOK_USING equ  $BA
                        *
                        
                        * FIRST SET ALWAYS HAS ONE PARAMETER
8440 : 5347             LAB1A     fcc  "SG"           ; 80
8442 : ce                         fcb  $80+'N'
8443 : 494e                       fcc  "IN"           ; 81
8445 : d4                         fcb  $80+'T'
8446 : 4142                       fcc  "AB"           ; 82
8448 : d3                         fcb  $80+'S'
8449 : 5553                       fcc  "US"           ; 83
844b : d2                         fcb  $80+'R'
844c : 524e                       fcc  "RN"           ; 84
844e : c4                         fcb  $80+'D'
844f : 5349                       fcc  "SI"           ; 85
8451 : ce                         fcb  $80+'N'
8452 : 504545                     fcc  "PEE"          ; 86
8455 : cb                         fcb  $80+'K'
8456 : 4c45                       fcc  "LE"           ; 87
8458 : ce                         fcb  $80+'N'
8459 : 535452                     fcc  "STR"          ; 88
845c : a4                         fcb  $80+'$'
845d : 5641                       fcc  "VA"           ; 89
845f : cc                         fcb  $80+'L'
AS09 Assembler for M6809 [1.42].                                     Page   45
--------------------------------- merge.a09 ----------------------------------

8460 : 4153                       fcc  "AS"           ; 8A
8462 : c3                         fcb  $80+'C'
8463 : 434852                     fcc  "CHR"          ; 8B
8466 : a4                         fcb  $80+'$'
8467 : 4154                       fcc  "AT"           ; 8C
8469 : ce                         fcb  $80+'N'
846a : 434f                       fcc  "CO"           ; 8D
846c : d3                         fcb  $80+'S'
846d : 5441                       fcc  "TA"           ; 8E
846f : ce                         fcb  $80+'N'
8470 : 4558                       fcc  "EX"           ; 8F
8472 : d0                         fcb  $80+'P'
8473 : 4649                       fcc  "FI"           ; 90
8475 : d8                         fcb  $80+'X'
8476 : 4c4f                       fcc  "LO"           ; 91
8478 : c7                         fcb  $80+'G'
8479 : 504f                       fcc  "PO"           ; 92
847b : d3                         fcb  $80+'S'
847c : 5351                       fcc  "SQ"           ; 93
847e : d2                         fcb  $80+'R'
847f : 484558                     fcc  "HEX"          ; 94
8482 : a4                         fcb  $80+'$'
                        * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
8483 : 4c454654                   fcc  "LEFT"         ; 95
8487 : a4                         fcb  $80+'$'
8488 : 5249474854                 fcc  "RIGHT"        ; 96
848d : a4                         fcb  $80+'$'
848e : 4d4944                     fcc  "MID"          ; 97
8491 : a4                         fcb  $80+'$'
                        * REMAINING FUNCTIONS
8492 : 494e4b4559                 fcc  "INKEY"        ; 98
8497 : a4                         fcb  $80+'$'
8498 : 4d45                       fcc  "ME"           ; 99
849a : cd                         fcb  $80+'M'
849b : 5641525054                 fcc  "VARPT"        ; 9A
84a0 : d2                         fcb  $80+'R'
84a1 : 494e5354                   fcc  "INST"         ; 9B
84a5 : d2                         fcb  $80+'R'
84a6 : 535452494e47               fcc  "STRING"       ; 9C
84ac : a4                         fcb  $80+'$'
                        
                        *
                        * DISPATCH TABLE FOR COMMANDS TOKEN #
84ad :                  CMD_TAB
84ad : 8683             LAB67     fdb  FOR            ; 80
84af : 87cc                       fdb  GO             ; 81
84b1 : 8829                       fdb  REM            ; 82
0082 =                  TOK_REM   equ  $82			  ; (LL06-CMD_TAB)/2+$7F
84b3 : 8829             LL06      fdb  REM            ; 83 (')
0083 =                  TOK_SNGL_Q equ $83			  ; (LL07-CMD_TAB)/2+$7F
84b5 : 8829             LL07      fdb  REM            ; 84 (ELSE)
0084 =                  TOK_ELSE  equ  $84			  ; (LL08-CMD_TAB)/2+$7F
84b7 : 885a             LL08	  fdb  IF             ; 85
0085 =                  TOK_IF    equ  $85			  ; (LL09-CMD_TAB)/2+$7F
84b9 : 8826             LL09      fdb  DATA           ; 86
0086 =                  TOK_DATA  equ  $86			  ; (LL10-CMD_TAB)/2+$7F
84bb : 9204             LL10      fdb  PRINT          ; 87
0087 =                  TOK_PRINT equ  $87			  ; (LL11-CMD_TAB)/2+$7F
84bd : 8888             LL11      fdb  ON             ; 88
84bf : 8935                       fdb  INPUT          ; 89
0089 =                  TOK_INPUT equ  $89			  ; (LL12-CMD_TAB)/2+$7F
84c1 : 8753             LL12      fdb  END            ; 8A
AS09 Assembler for M6809 [1.42].                                     Page   46
--------------------------------- merge.a09 ----------------------------------

84c3 : 8a1a                       fdb  NEXT           ; 8B
84c5 : 8c6a                       fdb  DIM            ; 8C
84c7 : 896f                       fdb  READ           ; 8D
84c9 : 87c1                       fdb  RUN            ; 8E
84cb : 8735                       fdb  RESTOR         ; 8F
84cd : 8806                       fdb  RETURN         ; 90
84cf : 8757                       fdb  STOP           ; 91
84d1 : 9071                       fdb  POKE           ; 92
84d3 : 877c                       fdb  CONT           ; 93
84d5 : 9078                       fdb  LIST           ; 94
84d7 : 878d                       fdb  CLEAR          ; 95
84d9 : 8653                       fdb  NEW            ; 96
84db : 81ee                       fdb  SET            ; 97
84dd : 8217             		  fdb  CLS            ; 98
84df : 8237             		  fdb  SOUND          ; 99
84e1 : 81a2             		  fdb  EXEC           ; 9A
84e3 : 9e87                       fdb  DEL            ; 9B
84e5 : 9a9a                       fdb  EDIT           ; 9C
84e7 : 9c0e             		  fdb  TRON           ; 9D
84e9 : 9c0f                       fdb  TROFF          ; 9E
84eb : 9dcd                       fdb  DEF            ; 9F
84ed : a575                       fdb  LINE           ; A0
84ef : 9f11                       fdb  RENUM          ; A1    
84f1 : a57e                       fdb  DIR            ; A2
84f3 : a589                       fdb  KILL           ; A3
84f5 : a594                       fdb  LOAD           ; A4
84f7 : a5a0                       fdb  SAVE           ; A5		  
84f9 : 8243                       fdb  DATE           ; A6
84fb : 8249                       fdb  TIME           ; A7
00a7 =                  TOK_HIGH_EXEC equ  $a7 ; (LABAF-CMD_TAB)/2+$7F
                        
                        * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY
84fd : 4e46             LABAF     fcc  "NF"           ; 0 NEXT WITHOUT FOR
84ff : 534e                       fcc  "SN"           ; 1 SYNTAX ERROR
8501 : 5247                       fcc  "RG"           ; 2 RETURN WITHOUT GOSUB
8503 : 4f44                       fcc  "OD"           ; 3 OUT OF DATA
8505 : 4643                       fcc  "FC"           ; 4 ILLEGAL FUNCTION CAL
8507 : 4f56                       fcc  "OV"           ; 5 OVERFLOW
8509 : 4f4d                       fcc  "OM"           ; 6 OUT OF MEMORY
850b : 554c                       fcc  "UL"           ; 7 UNDEFINED LINE NUMBE
850d : 4253                       fcc  "BS"           ; 8 BAD SUBSCRIPT
850f : 4444                       fcc  "DD"           ; 9 REDIMENSIONED ARRAY
8511 : 2f30                       fcc  "/0"           ; 10 DIVISION BY ZERO
8513 : 4944                       fcc  "ID"           ; 11 ILLEGAL DIRECT STAT
8515 : 544d                       fcc  "TM"           ; 12 TYPE MISMATCH
8517 : 4f53                       fcc  "OS"           ; 13 OUT OF STRING SPACE
8519 : 4c53                       fcc  "LS"           ; 14 STRING TOO LONG
851b : 5354                       fcc  "ST"           ; 15 STRING FORMULA TOO 
851d : 434e                       fcc  "CN"           ; 16 CAN'T CONTINUE
851f : 4644                       fcc  "FD"           ; 17 BAD FILE DATA
8521 : 414f                       fcc  "AO"           ; 18 FILE ALREADY OPEN
8523 : 444e                       fcc  "DN"           ; 19 DEVICE NUMBER ERROR
8525 : 494f                       fcc  "IO"           ; 20 I/O ERROR
8527 : 464d                       fcc  "FM"           ; 21 BAD FILE MODE
8529 : 4e4f                       fcc  "NO"           ; 22 FILE NOT OPEN
852b : 4945                       fcc  "IE"           ; 23 INPUT PAST END OF F
852d : 4453                       fcc  "DS"           ; 24 DIRECT STATEMENT IN
                        * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC
852f : 5546             L890B     fcc  "UF"           ; 25 UNDEFINED FUNCTION 
8531 : 4e45             L890D     fcc  "NE"           ; 26 FILE NOT FOUND
                        
8533 : 204552524f52     LABE1     fcc  " ERROR"
AS09 Assembler for M6809 [1.42].                                     Page   47
--------------------------------- merge.a09 ----------------------------------

8539 : 00                         fcb  $00
853a : 20494e20         LABE8     fcc  " IN "
853e : 00                         fcb  $00
853f : 0d               LABED     fcb  CR
8540 : 4f4b             LABEE     fcc  "OK"
8542 : 0d00                       fcb  CR,$00
8544 : 0d               LABF2     fcb  CR
8545 : 425245414b                 fcc  "BREAK"
854a : 00                         fcb  $00
                        
                        * SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DA
                        * THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEI
                        * SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT D
                        * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DA
                        * WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DA
                        * IS CONSIDERED 'GOSUB/RETURN'
854b : 3064             LABF9     leax 4,s            ; POINT X TO 3RD ADDRESS
                        *         FIRST TWO RETURN ADDRESSES ON THE STACK
854d : c612             LABFB     ldb  #18            ; 18 BYTES SAVED ON STAC
854f : 9f0f                       stx  TEMPTR         ; SAVE POINTER
8551 : a684                       lda  ,x             ; GET 1ST BYTE
8553 : 8080                       suba #$80           ; * CHECK FOR TYPE OF ST
8555 : 2615                       bne  LAC1A          ; * BRANCH IF NOT 'FOR/N
8557 : ae01                       ldx  1,x            ; = GET INDEX VARIABLE D
8559 : 9f11                       stx  TMPTR1         ; = POINTER AND SAVE IT 
855b : 9e3b                       ldx  VARDES         ; GET INDEX VARIABLE BEI
855d : 2709                       beq  LAC16          ; BRANCH IF DEFAULT INDE
                        *                             ; FIRST 'FOR/NEXT' DATA 
                        *                             ; IF NO INDEX VARIABLE A
855f : 9c11                       cmpx TMPTR1         ; DOES THE STACK INDEX M
                        *                             ; BEING SEARCHED FOR?
8561 : 2709                       beq  LAC1A          ; YES
8563 : 9e0f                       ldx  TEMPTR         ; * RESTORE INITIAL POIN
8565 : 3a                         abx                 ; * 18 TO IT AND LOOK FO
8566 : 20e5                       bra  LABFB          ; * NEXT BLOCK OF DATA
8568 : 9e11             LAC16     ldx  TMPTR1         ; = GET 1ST INDEX VARIAB
856a : 9f3b                       stx  VARDES         ; = SAVE AS 'NEXT' INDEX
856c : 9e0f             LAC1A     ldx  TEMPTR         ; POINT X TO START OF 'F
856e : 4d                         tsta                ; SET ZERO FLAG IF 'FOR/
856f : 39                         rts
                        * CHECK FOR MEMORY SPACE FOR NEW TOP OF
                        * ARRAYS AND MOVE ARRAYS TO NEW LOCATION
8570 : 8d17             LAC1E     bsr  LAC37          ; ACCD = NEW BOTTOM OF F
                        *                             ; ROOM FOR THE STACK?
                        * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND
                        * SAVE FINAL VALUE OF U IN V45
8572 : de41             LAC20     ldu  V41            ; POINT U TO DESTINATION
8574 : 3341                       leau 1,u            ; ADD ONE TO U - COMPENS
8576 : 9e43                       ldx  V43            ; POINT X TO SOURCE ADDR
8578 : 3001                       leax 1,x            ; ADD ONE - COMPENSATE F
857a : a682             LAC28     lda  ,-x            ; GRAB A BYTE FROM SOURC
857c : 3602                       pshu a              ; MOVE IT TO DESTINATION
857e : 9c47                       cmpx V47            ; DONE?
8580 : 26f8                       bne  LAC28          ; NO - KEEP MOVING BYTES
8582 : df45                       stu  V45            ; SAVE FINAL DESTINATION
8584 : 39               LAC32     rts
                        * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB
                        * BYTES IN FREE RAM - OM ERROR IF NOT
8585 : 4f               LAC33     clra                ; * ACCD CONTAINS NUMBER
8586 : 58                         aslb                ; * BYTES TO PUT ON STAC
8587 : d31f                       addd ARYEND         ; END OF PROGRAM AND VAR
8589 : c3003a           LAC37     addd #STKBUF        ; ADD STACK BUFFER - ROO
AS09 Assembler for M6809 [1.42].                                     Page   48
--------------------------------- merge.a09 ----------------------------------

858c : 2508                       bcs  LAC44          ; BRANCH IF GREATER THAN
858e : 10df17                     sts  BOTSTK         ; CURRENT NEW BOTTOM OF 
8591 : 109317                     cmpd BOTSTK         ; ARE WE GOING TO BE BEL
8594 : 25ee                       bcs  LAC32          ; YES - NO ERROR
8596 : c60c             LAC44     ldb  #6*2           ; OUT OF MEMORY ERROR
                        
                        * ERROR SERVICING ROUTINE
8598 : bd866f           LAC46     jsr  LAD33          ; RESET STACK, STRING ST
859b : bd9257                     jsr  LB95C          ; SEND A CR TO SCREEN
859e : bd92a5                     jsr  LB9AF          ; SEND A '?' TO SCREEN
85a1 : 8e84fd                     ldx  #LABAF         ; POINT TO ERROR TABLE
85a4 : 3a               LAC60     abx                 ; ADD MESSAGE NUMBER OFF
85a5 : 8d37                       bsr  LACA0          ; * GET TWO CHARACTERS F
85a7 : 8d35                       bsr  LACA0          ; * SEND TO CONSOLE OUT 
85a9 : 8e8532                     ldx  #LABE1-1       ; POINT TO "ERROR" MESSA
85ac : bd9292           LAC68     jsr  LB99C          ; PRINT MESSAGE POINTED 
85af : 9668                       lda  CURLIN         ; GET CURRENT LINE NUMBE
85b1 : 4c                         inca                ; TEST FOR DIRECT MODE
85b2 : 2703                       beq  LAC73          ; BRANCH IF DIRECT MODE
85b4 : bd96bb                     jsr  LBDC5          ; PRINT 'IN ****'
                        
                        * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE
85b7 : bd9257           LAC73     jsr  LB95C          ; MOVE CURSOR TO START O
85ba : bdef58                     jsr  APLcurBlinking ; SET THE BLINKING CURSO
85bd : 8e853f           		  ldx  #LABED         ; POINT X TO 'OK', CR MESSAGE
85c0 : bd9292                     jsr  LB99C          ; PRINT 'OK', CR
85c3 : bd8154           LAC7C     jsr  LA390          ; GO GET AN INPUT LINE
85c6 : ceffff                     ldu  #$FFFF         ; THE LINE NUMBER FOR DI
85c9 : df68                       stu  CURLIN         ; SAVE IT IN CURLIN
85cb : 25f6                       bcs  LAC7C          ; BRANCH IF LINE INPUT T
85cd : 9f83                       stx  CHARAD         ; SAVE (X) AS CURRENT IN
                        *         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. TH
                        *         LINE JUST ENTERED WILL BE INTERPRETED
85cf : 9d7c                       jsr  GETNCH         ; GET NEXT CHARACTER FRO
85d1 : 27f0                       beq  LAC7C          ; NO LINE INPUT - GET AN
85d3 : 250e                       bcs  LACA5          ; BRANCH IF NUMER1C - TH
                        *         THE  STATEMENT ENTEREd, SO THIS STATEMENT
                        *         WILL BE MERGED INTO THE BASIC PROGRAM
85d5 : bdef5b                     jsr  APLcurOff	  ; STOP THE BLINKING CURSOR	
85d8 : bd9131           		  jsr  LB821          ; GO CRUNCH LINE
85db : 7e870a                     jmp  LADC0          ; GO EXECUTE THE STATEME
                        *
85de : a680             LACA0     lda  ,x+            ; GET A CHARACTER
85e0 : 7e92a7                     jmp  LB9B1          ; SEND TO CONSOLE OUT
                        * TAKE A LINE FROM THE LINE INPUT BUFFER
                        * AND INSERT IT INTO THE BASIC PROGRAM
85e3 : bd88ad           LACA5     jsr  LAF67          ; CONVERT LINE NUMBER TO
85e6 : 9e2b             LACA8     ldx  BINVAL         ; GET CONVERTED LINE NUM
85e8 : 9fdf                       stx  LINHDR         ; STORE IT IN LINE INPUT
85ea : bd9131                     jsr  LB821          ; GO CRUNCH THE LINE
85ed : d703                       stb  TMPLOC         ; SAVE LINE LENGTH
85ef : 8d4c                       bsr  LAD01          ; FIND OUT WHERE TO INSE
85f1 : 2512                       bcs  LACC8          ; RANCH IF LINE NUMBER D
85f3 : dc47                       ldd  V47            ; GET ABSOLUTE ADDRESS O
85f5 : a384                       subd ,x             ; SUBTRACT ADDRESS OF NE
85f7 : d31b                       addd VARTAB         ; * ADD TO CURRENT END O
85f9 : dd1b                       std  VARTAB         ; * THE LENGTH OF THIS L
85fb : ee84                       ldu  ,x             ; POINT U TO ADDRESS OF 
                        * DELETE OLD LINE FROM BASIC PROGRAM
85fd : 3702             LACC0     pulu a              ; GET A BYTE FROM WHAT'S
85ff : a780                       sta  ,x+            ; MOVE IT DOWN
8601 : 9c1b                       cmpx VARTAB         ; COMPARE TO END OF BASI
AS09 Assembler for M6809 [1.42].                                     Page   49
--------------------------------- merge.a09 ----------------------------------

8603 : 26f8                       bne  LACC0          ; BRANCH IF NOT AT END
8605 : 96e1             LACC8     lda  LINBUF         ; * CHECK TO SEE IF THER
8607 : 271c                       beq  LACE9          ; * THE BUFFER AND BRANC
8609 : dc1b                       ldd  VARTAB         ; = SAVE CURRENT END OF
860b : dd43                       std  V43            ; = PROGRAM IN V43
860d : db03                       addb TMPLOC         ; * ADD LENGTH OF CRUNCH
860f : 8900                       adca #0             ; * PROPOGATE CARRY AND 
8611 : dd41                       std  V41            ; * OF PROGRAM IN V41
8613 : bd8570                     jsr  LAC1E          ; = MAKE SURE THERE'S EN
8616 : ce00dd                     ldu  #LINHDR-2      ; POINT U TO LINE TO BE 
8619 : 3702             LACDD     pulu a              ; GET A BYTE FROM NEW LI
861b : a780                       sta  ,x+            ; INSERT IT IN PROGRAM
861d : 9c45                       cmpx V45            ; * COMPARE TO ADDRESS O
861f : 26f8                       bne  LACDD          ; * LINE AND BRANCH IF N
8621 : 9e41                       ldx  V41            ; = GET AND SAVE
8623 : 9f1b                       stx  VARTAB         ; = END OF PROGRAM
8625 : 8d36             LACE9     bsr  LAD21          ; RESET INPUT POINTER, C
8627 : 8d02                       bsr  LACEF          ; ADJUST START OF NEXT L
8629 : 2098                       bra  LAC7C          ; EENTER BASIC'S INPUT L
                        * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BAS
862b : 9e19             LACEF     ldx  TXTTAB         ; POINT X TO START OF PR
862d : ec84             LACF1     ldd  ,x             ; GET ADDRESS OF NEXT LI
862f : 2721                       beq  LAD16          ; RETURN IF END OF PROGR
8631 : 3304                       leau 4,x            ; POINT U TO START OF BA
8633 : a6c0             LACF7     lda  ,u+            ; * SKIP THROUGH THE LIN
8635 : 26fc                       bne  LACF7          ; * ZERO (END OF LINE) I
8637 : ef84                       stu  ,x             ; SAVE THE NEW START OF 
8639 : ae84                       ldx  ,x             ; POINT X TO START OF NE
863b : 20f0                       bra  LACF1          ; KEEP GOING
                        *
                        * FIND A LINE NUMBER IN THE BASIC PROGRAM
                        * RETURN WITH CARRY SET IF NO MATCH FOUND
863d : dc2b             LAD01     ldd  BINVAL         ; GET THE LINE NUMBER TO
863f : 9e19                       ldx  TXTTAB         ; BEGINNING OF PROGRAM
8641 : ee84             LAD05     ldu  ,x             ; GET ADDRESS OF NEXT LI
8643 : 2709                       beq  LAD12          ; BRANCH IF END OF PROG
8645 : 10a302                     cmpd 2,x            ; IS IT A MATCH?
8648 : 2306                       bls  LAD14          ; CARRY SET IF LOWER; CA
864a : ae84                       ldx  ,x             ; X = ADDRESS OF NEXT LI
864c : 20f3                       bra  LAD05          ; KEEP LOOPING FOR LINE 
864e : 1a01             LAD12     orcc #1             ; SET CARRY FLAG
8650 : 9f47             LAD14     stx  V47            ; SAVE MATCH LINE NUMBER
                        *                             ; WHERE IT SHOULD HAVE B
8652 : 39               LAD16     rts
                        
                        * NEW
8653 : 26fb             NEW       bne  LAD14          ; BRANCH IF ARGUMENT GIV
8655 : 9e19             LAD19     ldx  TXTTAB         ; GET START OF BASIC
8657 : 6f80                       clr  ,x+            ; * PUT 2 ZERO BYTES THE
8659 : 6f80                       clr  ,x+            ; * THE BASIC PROGRAM
865b : 9f1b                       stx  VARTAB         ; AND THE NEXT ADDRESS I
865d : 9e19             LAD21     ldx  TXTTAB         ; GET START OF BASIC
865f : bd8801                     jsr  LAEBB          ; PUT INPUT POINTER ONE 
                        * ERASE ALL VARIABLES
8662 : 9e27             LAD26     ldx  MEMSIZ         ; * RESET START OF STRIN
8664 : 9f23                       stx  STRTAB         ; * TO TOP OF STRING SPA
8666 : bd8735                     jsr  RESTOR         ; RESET 'DATA' POINTER T
8669 : 9e1b                       ldx  VARTAB         ; * GET START OF VARIABL
866b : 9f1d                       stx  ARYTAB         ; * TO RESET START OF AR
866d : 9f1f                       stx  ARYEND         ; RESET END OF ARRAYS
866f : 8e00b7           LAD33     ldx  #STRSTK        ; * RESET STRING STACK P
8672 : 9f0b                       stx  TEMPPT         ; * BOTTOM OF STRING STA
AS09 Assembler for M6809 [1.42].                                     Page   50
--------------------------------- merge.a09 ----------------------------------

8674 : aee4                       ldx  ,s             ; GET RETURN ADDRESS OFF
8676 : 10de21                     lds  FRETOP         ; RESTORE STACK POINTER
8679 : 6fe2                       clr  ,-s            ; PUT A ZERO BYTE ON STA
                        *                             ; FOR/NEXT DATA FROM THE
867b : 0f2d                       clr  OLDPTR         ; RESET 'CONT' ADDRESS S
867d : 0f2e                       clr  OLDPTR+1       ; 'CAN'T CONTINUE'
867f : 0f08                       clr  ARYDIS         ; CLEAR THE ARRAY DISABL
8681 : 6e84                       jmp  ,x             ; RETURN TO CALLING ROUT
                        *                             ; SINCE THE STACK WAS RE
                        *
                        * FOR
                        *
                        * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR
                        * EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE
                        * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);
                        *         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=F
                        *         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO
                        * 9-13=FP VALUE OF 'TO' PARAMETER;
                        * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE 
                        *         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
8683 : 8680             FOR       lda  #$80           ; * SAVE THE DISABLE ARR
8685 : 9708                       sta  ARYDIS         ; * DO NOT ALLOW THE IND
8687 : bd88cf                     jsr  LET            ; SET INDEX VARIABLE TO 
868a : bd854b                     jsr  LABF9          ; SEARCH THE STACK FOR '
868d : 3262                       leas 2,s            ; PURGE RETURN ADDRESS O
868f : 2604                       bne  LAD59          ; BRANCH IF INDEX VARIAB
8691 : 9e0f                       ldx  TEMPTR         ; GET (ADDRESS + 18) OF 
8693 : 3285                       leas b,x            ; MOVE THE STACK POINTER
                        * MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
                        * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY
                        * ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
                        * THIS POINT ON THE STACK
8695 : c609             LAD59     ldb  #$09           ; * CHECK FOR ROOM FOR 1
8697 : bd8585                     jsr  LAC33          ; * IN FREE RAM
869a : bd882e                     jsr  LAEE8          ; GET ADDR OF END OF SUB
869d : dc68                       ldd  CURLIN         ; GET CURRENT LINE NUMBE
869f : 3416                       pshs x,b,a          ; SAVE LINE ADDR AND LIN
86a1 : c6a9                       ldb  #TOK_TO        ; TOKEN FOR 'TO'
86a3 : bd8b91                     jsr  LB26F          ; SYNTAX CHECK FOR 'TO'
86a6 : bd8a65                     jsr  LB143          ; 'TM' ERROR IF INDEX VA
86a9 : bd8a63                     jsr  LB141          ; EVALUATE EXPRESSION
                        *
86ac : d654                       ldb  FP0SGN         ; GET FPA0 MANTISSA SIGN
86ae : ca7f                       orb  #$7F           ; FORM A MASK TO SAVE DA
86b0 : d450                       andb FPA0           ; PUT THE MANTISSA SIGN 
86b2 : d750                       stb  FPA0           ; SAVE THE PACKED HIGH O
86b4 : 108e86bb                   ldy  #LAD7F         ; LOAD FOLLOWING ADDRESS
86b8 : 7e8b0c                     jmp  LB1EA          ; ADDRESS - PUSH FPA0 ON
86bb : 8e93bb           LAD7F     ldx  #LBAC5         ; POINT X TO FLOATING PO
86be : bd950a                     jsr  LBC14          ; MOVE (X) TO FPA0
86c1 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
86c3 : 81ad                       cmpa #TOK_STEP      ; STEP TOKEN
86c5 : 2605                       bne  LAD90          ; BRANCH IF NO 'STEP' VA
86c7 : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
86c9 : bd8a63                     jsr  LB141          ; EVALUATE NUMERIC EXPRE
86cc : bd9563           LAD90     jsr  LBC6D          ; CHECK STATUS OF FPA0
86cf : bd8b08                     jsr  LB1E6          ; SAVE STATUS AND FPA0 O
86d2 : dc3b                       ldd  VARDES         ; * GET DESCRIPTOR POINT
86d4 : 3406                       pshs b,a            ; * VARIABLE AND SAVE IT
86d6 : 8680                       lda  #$80           ; = GET THE 'FOR' FLAG A
86d8 : 3402                       pshs a              ; = SAVE IT ON THE STACK
                        *
AS09 Assembler for M6809 [1.42].                                     Page   51
--------------------------------- merge.a09 ----------------------------------

                        * MAIN COMMAND INTERPRETATION LOOP
86da : 8d60             LAD9E     bsr  LADEB          ; CHECK FOR KEYBOARD BRE
86dc : 9e83                       ldx  CHARAD         ; GET BASIC'S INPUT POIN
86de : 9f2f                       stx  TINPTR         ; SAVE IT
86e0 : a680                       lda  ,x+            ; GET CURRENT INPUT CHAR
86e2 : 2707                       beq  LADB4          ; BRANCH IF END OF LINE
86e4 : 813a                       cmpa #':'            ; CHECK FOR LINE SEPARA
86e6 : 2722                       beq  LADC0          ; BRANCH IF COLON
86e8 : 7e8b99           LADB1     jmp  LB277          ; 'SYNTAX ERROR'-IF NOT 
86eb : a681             LADB4     lda  ,x++           ; GET MS BYTE OF ADDRESS
86ed : 9700                       sta  ENDFLG         ; SAVE IN STOP/END FLAG 
                        *                             ; NEXT LINE ADDRESS IS <
                        *                             ; AN END IF ADDRESS > $8
86ef : 2772                       beq LAE15           ; BRANCH TO 'STOP' - END
86f1 : ec80                       ldd  ,x+            ; GET CURRENT LINE NUMBE
86f3 : dd68                       std  CURLIN         ; SAVE IN CURLIN
86f5 : 9f83                       stx  CHARAD         ; SAVE ADDRESS OF FIRST 
                        * EXTENDED BASIC TRACE
86f7 : 968c                       lda  TRCFLG         ; TEST THE TRACE FLAG
86f9 : 270f                       beq  LADC0          ; BRANCH IF TRACE OFF
86fb : 865b                       lda  #$5B           ; <LEFT HAND MARKER FOR 
86fd : bd805c                     jsr  PUTCHR         ; OUTPUT A CHARACTER
8700 : 9668                       lda  CURLIN         ; GET MS BYTE OF LINE NU
8702 : bd96c2                     jsr  LBDCC          ; CONVERT ACCD TO DECIMA
8705 : 865d                       lda  #$5D           ; > RIGHT HAND MARKER FO
8707 : bd805c                     jsr  PUTCHR         ; OUTPUT A CHARACTER
                        * END OF EXTENDED BASIC TRACE
870a : 9d7c             LADC0     jsr  GETNCH         ; GET A CHARACTER FROM B
870c : 8d02                       bsr  LADC6          ; GO PROCESS COMMAND
870e : 20ca                       bra  LAD9E          ; GO BACK TO MAIN LOOP
8710 : 2729             LADC6     beq  LADEA          ; RETURN IF END OF LINE 
8712 : 4d                         tsta                ; CHECK FOR TOKEN - BIT 
8713 : 102a01b8                   lbpl LET            ; BRANCH IF NOT A TOKEN 
                        * 
8717 : 81ff                       cmpa #$FF           ; SECONDARY TOKEN
8719 : 270f                       beq  SECTOK
871b : 81a7                       cmpa #TOK_HIGH_EXEC ; SKIPF TOKEN - HIGHEST 
871d : 22c9                       bhi  LADB1          ; 'SYNTAX ERROR' IF NON-
871f : be8101                     ldx  COMVEC+3       ; GET ADDRESS OF BASIC'S
8722 : 48               LADD4     asla                ; X2 (2 BYTE/JUMP ADDRES
8723 : 1f89                       tfr  a,b            ; SAVE COMMAND OFFSET IN
8725 : 3a                         abx                 ; NON X POINTS TO COMMAN
8726 : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHAR
                        *
                        * HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
8728 : 6e94                       jmp  [,x]           ; GO DO A COMMAND
872a :                  SECTOK
                        * THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTA
                        * THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHEC
872a : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHAR
872c : 8197                       cmpa #TOK_MID       ; TOKEN FOR "MID$"
872e : 10271501                   lbeq L86D6          ; PROCESS MID$ REPLACEME
8732 : 7e8b99                     jmp  LB277          ; SYNTAX ERROR
                        
                        *
                        * RESTORE
8735 : 9e19             RESTOR    ldx  TXTTAB         ; BEGINNING OF PROGRAM A
8737 : 301f                       leax -1,x           ; MOVE TO ONE BYTE BEFOR
8739 : 9f33             LADE8     stx  DATPTR         ; SAVE NEW DATA POINTER
873b : 39               LADEA     rts
                        *
                        * BREAK CHECK
AS09 Assembler for M6809 [1.42].                                     Page   52
--------------------------------- merge.a09 ----------------------------------

873c : bd804f           LADEB     jsr  LA1C1          ; GET A KEYSTROKE ENTRY
873f : 270a                       beq  LADFA          ; RETURN IF NO INPUT
8741 : 8103             LADF0     cmpa #3             ; CONTROL C? (BREAK)
8743 : 2712                       beq  STOP           ; YES
8745 : 8113                       cmpa #$13           ; CONTROL S? (PAUSE)
8747 : 2703                       beq  LADFB          ; YES
8749 : 9773                       sta  IKEYIM         ; SAVE KEYSTROKE IN INKE
874b : 39               LADFA     rts
874c : bd804f           LADFB     jsr  KEYIN          ; GET A KEY
874f : 27fb                       beq  LADFB          ; BRANCH IF NO KEY DOWN
8751 : 20ee                       bra  LADF0          ; CONTINUE - DO A BREAK 
                        *
                        * END
8753 : 9d82             END       jsr  GETCCH         ; GET CURRENT INPUT CHAR
8755 : 2002                       bra  LAE0B
                        *
                        * STOP
8757 : 1a01             STOP      orcc #$01           ; SET CARRY FLAG
8759 : 2631             LAE0B     bne  LAE40          ; BRANCH IF ARGUMENT EXI
875b : 9e83                       ldx  CHARAD         ; * SAVE CURRENT POSITIO
875d : 9f2f                       stx  TINPTR         ; * BASIC'S INPUT POINTE
875f : 0600             LAE11     ror  ENDFLG         ; ROTATE CARRY INTO BIT 
8761 : 3262                       leas 2,s            ; PURGE RETURN ADDRESS O
8763 : 9e68             LAE15     ldx  CURLIN         ; GET CURRENT LINE NUMBE
8765 : 8cffff                     cmpx #$FFFF         ; DIRECT MODE?
8768 : 2706                       beq  LAE22          ; YES
876a : 9f29                       stx  OLDTXT         ; SAVE CURRENT LINE NUMB
876c : 9e2f                       ldx  TINPTR         ; * GET AND SAVE CURRENT
876e : 9f2d                       stx  OLDPTR         ; * OF BASIC'S INPUT POI
8770 :                  LAE22
8770 : 8e8543                     ldx  #LABF2-1       ; POINT TO CR, 'BREAK' M
8773 : 0d00                       tst  ENDFLG         ; CHECK STOP/END FLAG
8775 : 102afe3e                   lbpl LAC73          ; BRANCH TO MAIN LOOP OF
8779 : 7e85ac                     jmp  LAC68          ; PRINT 'BREAK AT ####' 
                        *                             ; BASIC'S MAIN LOOP IF '
                        
                        * CONT
877c : 260e             CONT      bne  LAE40          ; RETURN IF ARGUMENT GIV
877e : c620                       ldb  #2*16          ; 'CAN'T CONTINUE' ERROR
8780 : 9e2d                       ldx  OLDPTR         ; GET CONTINUE ADDRESS (
8782 : 1027fe12                   lbeq LAC46          ; 'CN' ERROR IF CONTINUE
8786 : 9f83                       stx  CHARAD         ; RESET BASIC'S INPUT PO
8788 : 9e29                       ldx  OLDTXT         ; GET LINE NUMBER
878a : 9f68                       stx  CURLIN         ; RESET CURRENT LINE NUM
878c : 39               LAE40     rts
                        *
                        * CLEAR
878d : 272c             CLEAR     beq  LAE6F          ; BRANCH IF NO ARGUMENT
878f : bd8d02                     jsr  LB3E6          ; EVALUATE ARGUMENT
8792 : 3406                       pshs b,a            ; SAVE AMOUNT OF STRING 
8794 : 9e27                       ldx  MEMSIZ         ; GET CURRENT TOP OF CLE
8796 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
8798 : 270c                       beq  LAE5A          ; BRANCH IF NO NEW TOP O
879a : bd8b8f                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
879d : bd9057                     jsr  LB73D          ; EVALUATE EXPRESSlON; R
87a0 : 301f                       leax -1,x           ; X = TOP OF CLEARED SPA
87a2 : 9c71                       cmpx TOPRAM         ; COMPARE TO TOP OF RAM
87a4 : 2218                       bhi  LAE72          ; 'OM' ERROR IF > TOP OF
87a6 : 1f10             LAE5A     tfr  x,d            ; ACCD = TOP OF CLEARED 
87a8 : a3e1                       subd ,s++           ; SUBTRACT OUT AMOUNT OF
87aa : 2512                       bcs  LAE72          ; 'OM' ERROR IF FREE MEM
87ac : 1f03                       tfr  d,u            ; U = BOTTOM OF CLEARED 
AS09 Assembler for M6809 [1.42].                                     Page   53
--------------------------------- merge.a09 ----------------------------------

87ae : 83003a                     subd #STKBUF        ; SUBTRACT OUT STACK BUF
87b1 : 250b                       bcs  LAE72          ; 'OM' ERROR IF FREE MEM
87b3 : 931b                       subd VARTAB         ; SUBTRACT OUT START OF 
87b5 : 2507                       bcs  LAE72          ; 'OM' ERROR IF FREE MEM
87b7 : df21                       stu  FRETOP         ; SAVE NEW BOTTOM OF CLE
87b9 : 9f27                       stx  MEMSIZ         ; SAVE NEW TOP OF CLEARE
87bb : 7e8662           LAE6F     jmp  LAD26          ; ERASE ALL VARIABLES, I
87be : 7e8596           LAE72     jmp  LAC44          ; 'OM' ERROR
                        *
                        * RUN
87c1 : 9d82             RUN       jsr  GETCCH         ; * GET CURRENT INPUT CH
87c3 : 1027fe96                   lbeq LAD21          ; * IF NO LINE NUMBER
87c7 : bd8662                     jsr  LAD26          ; ERASE ALL VARIABLES
87ca : 2019                       bra  LAE9F          ; 'GOTO' THE RUN ADDRESS
                        *
                        * GO
87cc : 1f89             GO        tfr  a,b            ; SAVE INPUT CHARACTER I
87ce : 9d7c             LAE88     jsr  GETNCH         ; GET A CHARACTER FROM B
87d0 : c1a9                       cmpb #TOK_TO        ; 'TO' TOKEN
87d2 : 2716                       beq  LAEA4          ; BRANCH IF GOTO
87d4 : c1aa                       cmpb #TOK_SUB       ; 'SUB' TOKEN
87d6 : 2645                       bne  LAED7          ; 'SYNTAX ERROR' IF NEIT
87d8 : c603                       ldb  #3             ; =ROOM FOR 6
87da : bd8585                     jsr  LAC33          ; =BYTES ON STACK?
87dd : de83                       ldu  CHARAD         ; * SAVE CURRENT BASIC I
87df : 9e68                       ldx  CURLIN         ; * NUMBER AND SUB TOKEN
87e1 : 86aa                       lda  #TOK_SUB       ; *
87e3 : 3452                       pshs u,x,a          ; *
87e5 : 8d03             LAE9F     bsr  LAEA4          ; GO DO A 'GOTO'
87e7 : 7e86da                     jmp  LAD9E          ; JUMP BACK TO BASIC'S M
                        * GOTO
87ea : 9d82             LAEA4     jsr  GETCCH         ; GET CURRENT INPUT CHAR
87ec : bd88ad                     jsr  LAF67          ; GET LINE NUMBER TO BIN
87ef : 8d40                       bsr  LAEEB          ; ADVANCE BASIC'S POINTE
87f1 : 3001                       leax $01,x          ; POINT TO START OF NEXT
87f3 : dc2b                       ldd  BINVAL         ; GET THE LINE NUMBER TO
87f5 : 109368                     cmpd CURLIN         ; COMPARE TO CURRENT LIN
87f8 : 2202                       bhi  LAEB6          ; IF REO'D LINE NUMBER I
                        *              ; DON'T START LOOKING FROM
                        *              ; START OF PROGRAM
87fa : 9e19                       ldx  TXTTAB         ; BEGINNING OF PROGRAM
87fc : bd8641           LAEB6     jsr  LAD05          ; GO FIND A LINE NUMBER
87ff : 2517                       bcs  LAED2          ; 'UNDEFINED LINE NUMBER
8801 : 301f             LAEBB     leax -1,x           ; MOVE BACK TO JUST BEFO
8803 : 9f83                       stx  CHARAD         ; RESET BASIC'S INPUT PO
8805 : 39               LAEBF     rts
                        *
                        * RETURN
8806 : 26fd             RETURN    bne  LAEBF          ; EXIT ROUTINE IF ARGUME
8808 : 86ff                       lda  #$FF           ; * PUT AN ILLEGAL VARIA
880a : 973b                       sta  VARDES         ; * VARDES WHICH WILL CA
                        *              ; STACK TO BE IGNORED
880c : bd854b                     jsr  LABF9          ; CHECK FOR RETURN DATA 
880f : 1f14                       tfr  x,s            ; RESET STACK POINTER - 
                        *              ; FROM THE STACK
8811 : 812a                       cmpa #TOK_SUB-$80   ; SUB TOKEN - $80
8813 : 270b                       beq  LAEDA          ; BRANCH IF 'RETURN' FRO
8815 : c604                       ldb  #2*2           ; ERROR #2 'RETURN WITHO
8817 : 8c                         fcb  SKP2           ; SKIP TWO BYTES
8818 : c60e             LAED2     ldb  #7*2           ; ERROR #7 'UNDEFINED LI
881a : 7e8598                     jmp  LAC46          ; JUMP TO ERROR HANDLER
881d : 7e8b99           LAED7     jmp  LB277          ; 'SYNTAX ERROR'
AS09 Assembler for M6809 [1.42].                                     Page   54
--------------------------------- merge.a09 ----------------------------------

8820 : 3552             LAEDA     puls a,x,u          ; * RESTORE VALUES OF CU
8822 : 9f68                       stx  CURLIN         ; * BASIC'S INPUT POINTE
8824 : df83                       stu  CHARAD         ; * AND LOAD ACCA WITH S
                        *
                        * DATA
8826 : 8d06             DATA      bsr  LAEE8          ; MOVE INPUT POINTER TO 
8828 : 8c                         fcb  SKP2           ; SKIP 2 BYTES
                        
                        * REM, ELSE
8829 :                  ELSE
8829 : 8d06             REM       bsr  LAEEB          ; MOVE INPUT POINTER TO 
882b : 9f83                       stx  CHARAD         ; RESET BASIC'S INPUT PO
882d : 39               LAEE7     rts
                        * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE
882e : c63a             LAEE8     ldb  #':'            ; COLON = SUBLINE TERMI
8830 : 86               LAEEA     fcb  SKP1LD         ; SKPILD SKIP ONE BYTE; 
                        * ADVANCE BASIC'S INPUT POINTER TO END OF
                        * LINE - RETURN ADDRESS OF END OF LINE+1 IN X
8831 : 5f               LAEEB     clrb                ; 0 = LINE TERMINATOR CH
8832 : d701                       stb  CHARAC         ; TEMP STORE PRIMARY TER
8834 : 5f                         clrb                ; 0 (END OF LINE) = ALTE
8835 : 9e83                       ldx  CHARAD         ; LOAD X W/BASIC'S INPUT
8837 : 1f98             LAEF1     tfr  b,a            ; * CHANGE TERMINATOR CH
8839 : d601                       ldb  CHARAC         ; * FROM ACCB TO CHARAC 
                        *         IN   CHARAC
883b : 9701                       sta  CHARAC         ; SWAP PRIMARY AND SECON
883d : a684             LAEF7     lda  ,x             ; GET NEXT INPUT CHARACT
883f : 27ec                       beq  LAEE7          ; RETURN IF 0 (END OF LI
8841 : 3404                       pshs b              ; SAVE TERMINATOR ON STA
8843 : a1e0                       cmpa ,s+            ; COMPARE TO INPUT CHARA
8845 : 27e6                       beq  LAEE7          ; RETURN IF EQUAL
8847 : 3001                       leax 1,x            ; MOVE POINTER UP ONE
8849 : 8122                       cmpa #'"'            ; CHECK FOR DOUBLE QUOT
884b : 27ea                       beq  LAEF1          ; BRANCH IF " - TOGGLE T
884d : 4c                         inca                ; * CHECK FOR $FF AND BR
884e : 2602                       bne  LAF0C          ; * NOT SECONDARY TOKEN
8850 : 3001                       leax 1,x            ; MOVE INPUT POINTER 1 M
8852 : 8186             LAF0C     cmpa #TOK_IF+1      ; TOKEN FOR IF?
8854 : 26e7                       bne  LAEF7          ; NO - GET ANOTHER INPUT
8856 : 0c04                       inc  IFCTR          ; INCREMENT IF COUNTER -
                        *                             ; 'IF' STATEMENTS ARE NE
8858 : 20e3                       bra  LAEF7          ; GET ANOTHER INPUT CHAR
                        
                        * IF
885a : bd8a63           IF        jsr  LB141          ; EVALUATE NUMERIC EXPRE
885d : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
885f : 8181                       cmpa #TOK_GO        ; TOKEN FOR GO
8861 : 2705                       beq  LAF22          ; TREAT 'GO' THE SAME AS
8863 : c6ab                       ldb  #TOK_THEN      ; TOKEN FOR THEN
8865 : bd8b91                     jsr  LB26F          ; DO A SYNTAX CHECK ON A
8868 : 964f             LAF22     lda  FP0EXP         ; CHECK FOR TRUE/FALSE -
886a : 2613                       bne  LAF39          ; BRANCH IF CONDITION TR
886c : 0f04                       clr  IFCTR          ; CLEAR FLAG - KEEP TRAC
                        *                             ; TO SEARCH FOR IN NESTE
886e : 8db6             LAF28     bsr  DATA           ; MOVE BASIC'S POINTER T
8870 : 4d                         tsta                ; * CHECK TO SEE IF END 
8871 : 27ba                       beq  LAEE7          ; * AND RETURN IF END OF
8873 : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHARACTER
8875 : 8184                       cmpa #TOK_ELSE      ; TOKEN FOR ELSE
8877 : 26f5                       bne  LAF28          ; IGNORE ALL DATA EXCEPT
                        *                             ; END OF LINE (ZERO BYTE
8879 : 0a04                       dec  IFCTR          ; CHECK TO SEE IF YOU MU
AS09 Assembler for M6809 [1.42].                                     Page   55
--------------------------------- merge.a09 ----------------------------------

887b : 2af1                       bpl  LAF28          ; BRANCH TO SEARCH ANOTH
887d : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHARACTER
887f : 9d82             LAF39     jsr  GETCCH         ; GET CURRENT INPUT CHAR
8881 : 1025ff65                   lbcs LAEA4          ; BRANCH TO 'GOTO' IF NU
8885 : 7e8710                     jmp  LADC6          ; RETURN TO MAIN INTERPR
                        
                        * ON
8888 : bd9025           ON        jsr  LB70B          ; EVALUATE EXPRESSION
888b : c681                       ldb  #TOK_GO        ; TOKEN FOR GO
888d : bd8b91                     jsr  LB26F          ; SYNTAX CHECK FOR GO
8890 : 3402                       pshs a              ; SAVE NEW TOKEN (TO,sUB
8892 : 81aa                       cmpa #TOK_SUB       ; TOKEN FOR SUB?
8894 : 2704                       beq  LAF54          ; YES
8896 : 81a9                       cmpa #TOK_TO        ; TOKEN FOR TO?
8898 : 2683             LAF52     lbne LAED7          ; 'SYNTAX' ERROR IF NOT 
889a : 0a53             LAF54     dec  FPA0+3         ; DECREMENT IS BYTE OF M
                        *                             ; IS THE ARGUMENT OF THE
889c : 2605                       bne  LAF5D          ; BRANCH IF NOT AT THE P
889e : 3504                       puls b              ; GET BACK THE TOKEN FOL
88a0 : 7e87ce                     jmp  LAE88          ; GO DO A 'GOTO' OR 'GOS
88a3 : 9d7c             LAF5D     jsr  GETNCH         ; GET A CHARACTER FROM B
88a5 : 8d06                       bsr  LAF67          ; CONVERT BASIC LINE NUM
88a7 : 812c                       cmpa #','           ; IS CHARACTER FOLLOWING
88a9 : 27ef                       beq  LAF54          ; YES
88ab : 3584                       puls b,pc           ; IF NOT, FALL THROUGH T
88ad : 9e74             LAF67     ldx  ZERO           ; DEFAULT LINE NUMBER OF
88af : 9f2b                       stx  BINVAL         ; SAVE IT IN BINVAL
                        *
                        * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINV
                        *
88b1 : 2461             LAF6B     bcc  LAFCE          ; RETURN IF NOT NUMERIC 
88b3 : 8030                       suba #'0'            ; MASK OFF ASCII
88b5 : 9701                       sta  CHARAC         ; SAVE DIGIT IN VO1
88b7 : dc2b                       ldd  BINVAL         ; GET ACCUMULATED LINE N
88b9 : 8118                       cmpa #24            ; LARGEST LINE NUMBER IS
                        *         (24*256+255)*10+9
88bb : 22db                       bhi  LAF52          ; 'SYNTAX' ERROR IF TOO 
                        * MULT ACCD X 10
88bd : 58                         aslb                ; *
88be : 49                         rola                ; * TIMES 2
88bf : 58                         aslb                ; =
88c0 : 49                         rola                ; = TIMES 4
88c1 : d32b                       addd BINVAL         ; ADD 1 = TIMES 5
88c3 : 58                         aslb                ; *
88c4 : 49                         rola                ; * TIMES 10
88c5 : db01                       addb CHARAC         ; ADD NEXT DIGIT
88c7 : 8900                       adca #0             ; PROPAGATE CARRY
88c9 : dd2b                       std  BINVAL         ; SAVE NEW ACCUMULATED L
88cb : 9d7c                       jsr  GETNCH         ; GET NEXT CHARACTER FRO
88cd : 20e2                       bra  LAF6B          ; LOOP- PROCESS NEXT DIG
                        *
                        * LET (EXBAS)
                        * EVALUATE A NON-TOKEN EXPRESSION
                        * TARGET = REPLACEMENT
88cf : bd8c73           LET       jsr  LB357          ; FIND TARGET VARIABLE D
88d2 : 9f3b                       stx  VARDES         ; SAVE DESCRIPTOR ADDRES
88d4 : c6b7                       ldb  #TOK_EQUALS    ; TOKEN FOR "="
88d6 : bd8b91                     jsr  LB26F          ; DO A SYNTAX CHECK FOR 
88d9 : 9606                       lda  VALTYP         ; * GET VARIABLE TYPE AN
88db : 3402                       pshs a              ; * SAVE ON THE STACK
88dd : bd8a78                     jsr  LB156          ; EVALUATE EXPRESSION
88e0 : 3502                       puls a              ; * REGET VARIABLE TYPE 
AS09 Assembler for M6809 [1.42].                                     Page   56
--------------------------------- merge.a09 ----------------------------------

88e2 : 46                         rora                ; * SET CARRY IF STRING
88e3 : bd8a6a                     jsr  LB148          ; TYPE CHECK-TM ERROR IF
                        *                             ; BOTH SIDES OF EQUALS S
88e6 : 10270c3f                   lbeq LBC33          ; GO PUT FPA0 INTO VARIA
                        * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT
                        * FPA0+2 INTO THE STRING SPACE. TRANSFER THE
                        * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES
                        * DON'T MOVE THE STRING IF IT IS ALREADY IN THE
                        * STRING SPACE. REMOVE DESCRIPTOR FROM STRING
                        * STACK IF IT IS LAST ONE ON THE STACK
88ea : 9e52             LAFA4     ldx  FPA0+2         ; POINT X TO DESCRIPTOR 
88ec : dc21                       ldd  FRETOP         ; LOAD ACCD WITH START O
88ee : 10a302                     cmpd 2,x            ; IS THE STRING IN STRIN
88f1 : 2411                       bcc  LAFBE          ; BRANCH IF IT'S NOT IN 
88f3 : 9c1b                       cmpx VARTAB         ; COMPARE DESCRIPTOR ADD
88f5 : 250d                       bcs  LAFBE          ; BRANCH IF DESCRIPTOR A
88f7 : e684             LAFB1     ldb  ,x             ; GET LENGTH OF REPLACEM
88f9 : bd8e29                     jsr  LB50D          ; RESERVE ACCB BYTES OF 
88fc : 9e4d                       ldx  V4D            ; GET DESCRIPTOR ADDRESS
88fe : bd8f5e                     jsr  LB643          ; MOVE STRING INTO STRIN
8901 : 8e0056                     ldx  #STRDES        ; POINT X TO TEMP STRING
8904 : 9f4d             LAFBE     stx  V4D            ; SAVE STRING DESCRIPTOR
8906 : bd8f90                     jsr  LB675          ; REMOVE STRING DESCRIPT
                        *              ; ON STRING STACK
8909 : de4d                       ldu  V4D            ; POINT U TO REPLACEMENT
890b : 9e3b                       ldx  VARDES         ; GET TARGET DESCRIPTOR 
890d : 3726                       pulu a,b,y          ; GET LENGTH AND START O
890f : a784                       sta  ,x             ; * SAVE STRING LENGTH A
8911 : 10af02                     sty  2,x            ; * TARGET DESCRIPTOR LO
8914 : 39               LAFCE     rts
                        
8915 : 3f5245444f       LAFCF     fcc  "?REDO"        ; ?REDO MESSAGE
891a : 0d00                       fcb  CR,$00
                        
891c :                  LAFD6
891c : 7e8598           LAFDC     jmp  LAC46          ; jmp TO ERROR HANDLER
891f : 9609             LAFDF     lda  INPFLG         ; = GET THE INPUT FLAG A
8921 : 2707                       beq  LAFEA          ; = IF 'INPUT'
8923 : 9e31                       ldx  DATTXT         ; * GET LINE NUMBER WHER
8925 : 9f68                       stx  CURLIN         ; * AND USE IT AS THE CU
8927 : 7e8b99                     jmp  LB277          ; 'SYNTAX ERROR'
892a : 8e8914           LAFEA     ldx  #LAFCF-1       ; * POINT X TO '?REDO' A
892d : bd9292                     jsr  LB99C          ; * IT ON THE SCREEN
8930 : 9e2f                       ldx  TINPTR         ; = GET THE SAVED ABSOLU
8932 : 9f83                       stx  CHARAD         ; = INPUT POINTER AND RE
8934 : 39                         rts
                        *
                        * INPUT
8935 : c616             INPUT     ldb  #11*2          ; 'ID' ERROR
8937 : 9e68                       ldx  CURLIN         ; GET CURRENT LINE NUMBE
8939 : 3001                       leax 1,x            ; ADD ONE
893b : 27df                       beq  LAFDC          ; 'ID' ERROR BRANCH IF D
893d : 8d01                       bsr  LB00F          ; GET SOME INPUT DATA - 
893f : 39                         rts
8940 : 8122             LB00F     cmpa #'"'           ; CHECK FOR PROMPT STRIN
8942 : 260b                       bne  LB01E          ; BRANCH IF NO PROMPT ST
8944 : bd8b66                     jsr  LB244          ; PUT PROMPT STRING ON S
8947 : c63b                       ldb  #';'           ; *
8949 : bd8b91                     jsr  LB26F          ; * DO A SYNTAX CHECK FO
894c : bd9295                     jsr  LB99F          ; PRINT MESSAGE TO CONSO
894f : 8e00e1           LB01E     ldx  #LINBUF        ; POINT TO BASIC'S LINE 
8952 : 6f84                       clr  ,x             ; CLEAR 1ST BYTE - FLAG 
AS09 Assembler for M6809 [1.42].                                     Page   57
--------------------------------- merge.a09 ----------------------------------

                        *              ; IN LINE BUFFER
8954 : 8d06                       bsr  LB02F          ; INPUT A STRING TO LINE
8956 : c62c                       ldb  #','           ; * INSERT A COMMA AT TH
8958 : e784                       stb  ,x             ; * OF THE LINE INPUT BU
895a : 2016                       bra  LB049
                        * FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
895c : bd92a5           LB02F     jsr  LB9AF          ; SEND A "?" TO CONSOLE 
895f : bd92a2                     jsr  LB9AC          ; SEND A 'SPACE' TO CONS
8962 : bd8154           LB035     jsr  LA390          ; GO READ IN A BASIC LIN
8965 : 2405                       bcc  LB03F          ; BRANCH IF ENTER KEY EN
8967 : 3264                       leas 4,s            ; PURGE TWO RETURN ADDRE
8969 : 7e875f                     jmp  LAE11          ; GO DO A 'STOP' IF BREA
896c : c62e             LB03F     ldb  #2*23          ; 'INPUT PAST END OF FIL
896e : 39                         rts
                        *
                        * READ
896f : 9e33             READ      ldx  DATPTR         ; GET 'READ' START ADDRE
8971 : 86                         fcb  SKP1LD         ; SKIP ONE BYTE - lda #*
8972 : 4f               LB049     clra                ; 'INPUT' ENTRY POINT: I
8973 : 9709                       sta  INPFLG         ; SET INPUT FLAG; 0 = IN
8975 : 9f35                       stx  DATTMP         ; SAVE 'READ' START ADDR
8977 : bd8c73           LB04E     jsr  LB357          ; EVALUATE A VARIABLE
897a : 9f3b                       stx  VARDES         ; SAVE DESCRIPTOR ADDRES
897c : 9e83                       ldx  CHARAD         ; * GET BASIC'S INPUT PO
897e : 9f2b                       stx  BINVAL         ; * AND SAVE IT
8980 : 9e35                       ldx  DATTMP         ; GET 'READ' ADDRESS STA
8982 : a684                       lda  ,x             ; GET A CHARACTER FROM T
8984 : 2609                       bne  LB069          ; BRANCH IF NOT END OF L
8986 : 9609                       lda  INPFLG         ; * CHECK INPUT FLAG AND
8988 : 2651                       bne  LB0B9          ; * IF LOOKING FOR DATA 
                        * NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
                        * NOT COMING FROM SCREEN
898a : bd92a5                     jsr  LB9AF          ; SEND A '?' TO CONSOLE 
898d : 8dcd                       bsr  LB02F          ; FILL INPUT BUFFER FROM
898f : 9f83             LB069     stx  CHARAD         ; RESET BASIC'S INPUT PO
8991 : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
8993 : d606                       ldb  VALTYP         ; * CHECK VARIABLE TYPE 
8995 : 2723                       beq  LB098          ; * BRANCH IF NUMERIC
                        * READ/INPUT A STRING VARIABLE
8997 : 9e83                       ldx  CHARAD         ; LOAD X WITH CURRENT BA
8999 : 9701                       sta  CHARAC         ; SAVE CURRENT INPUT CHA
899b : 8122                       cmpa #'"'           ; CHECK FOR STRING DELIM
899d : 270e                       beq  LB08B          ; BRANCH IF STRING DELIM
899f : 301f                       leax -1,x           ; BACK UP POINTER
89a1 : 4f                         clra                ; * ZERO = END OF LINE C
89a2 : 9701                       sta  CHARAC         ; * SAVE AS TERMINATOR
89a4 : bd8146                     jsr  LA35F          ; SET UP PRINT PARAMETER
89a7 : 863a                       lda  #':'           ; END OF SUBLINE CHARACT
89a9 : 9701                       sta  CHARAC         ; SAVE AS TERMINATOR I
89ab : 862c                       lda  #','           ; COMMA
89ad : 9702             LB08B     sta  ENDCHR         ; SAVE AS TERMINATOR 2
89af : bd8e3a                     jsr  LB51E          ; STRIP A STRING FROM TH
89b2 : bd8b6b                     jsr  LB249          ; MOVE INPUT POINTER TO 
89b5 : bd88ea                     jsr  LAFA4          ; PUT A STRING INTO THE 
89b8 : 2006                       bra  LB09E          ; CHECK FOR ANOTHER DATA
                        * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM
89ba : bd9608           LB098     jsr  LBD12          ; CONVERT AN ASCII STRIN
89bd : bd9529                     jsr  LBC33          ; PACK FPA0 AND STORE IT
                        *                             ; INPUT OR READ DATA ITE
89c0 : 9d82             LB09E     jsr  GETCCH         ; GET CURRENT INPUT CHAR
89c2 : 2706                       beq  LB0A8          ; BRANCH IF END OF LINE
89c4 : 812c                       cmpa #','            ; CHECK FOR A COMMA
AS09 Assembler for M6809 [1.42].                                     Page   58
--------------------------------- merge.a09 ----------------------------------

89c6 : 1026ff52                   lbne LAFD6          ; BAD FILE DATA' ERROR O
89ca : 9e83             LB0A8     ldx  CHARAD         ; * GET CURRENT INPUT
89cc : 9f35                       stx  DATTMP         ; * POINTER (USED AS A D
89ce : 9e2b                       ldx  BINVAL         ; * RESET INPUT POINTER 
89d0 : 9f83                       stx  CHARAD         ; * READ STATEMENT
89d2 : 9d82                       jsr  GETCCH         ; GET CURRENT CHARACTER 
89d4 : 2721                       beq  LB0D5          ; BRANCH IF END OF LINE 
89d6 : bd8b8f                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
89d9 : 209c                       bra  LB04E          ; GET ANOTHER INPUT OR R
                        * SEARCH FROM ADDRESS IN X FOR
                        * 1ST OCCURENCE OF THE TOKEN FOR DATA
89db : 9f83             LB0B9     stx  CHARAD         ; RESET BASIC'S INPUT PO
89dd : bd882e                     jsr  LAEE8          ; SEARCH FOR END OF CURR
89e0 : 3001                       leax 1,x            ; MOVE X ONE PAST END OF
89e2 : 4d                         tsta                ; CHECK FOR END OF LINE
89e3 : 260a                       bne  LB0CD          ; BRANCH IF END OF SUBLI
89e5 : c606                       ldb  #2*3           ; 'OUT OF DATA' ERROR
89e7 : ee81                       ldu  ,x++           ; GET NEXT 2 CHARACTERS
89e9 : 2741                       beq  LB10A          ; 'OD' ERROR IF END OF P
89eb : ec81                       ldd  ,x++           ; GET BASIC LINE NUMBER 
89ed : dd31                       std  DATTXT         ; SAVE IT IN DATTXT
89ef : a684             LB0CD     lda  ,x             ; GET AN INPUT CHARACTER
89f1 : 8186                       cmpa #TOK_DATA      ; DATA TOKEN?
89f3 : 26e6                       bne  LB0B9          ; NO - KEEP LOOKING
89f5 : 2098                       bra  LB069          ; YES
                        * EXIT READ AND INPUT COMMANDS
89f7 : 9e35             LB0D5     ldx  DATTMP         ; GET DATA POINTER
89f9 : d609                       ldb  INPFLG         ; * CHECK INPUT FLAG
89fb : 1026fd3a                   lbne LADE8          ; * SAVE NEW DATA POINTE
89ff : a684                       lda  ,x             ; = CHECK NEXT CHARACTER
8a01 : 2706                       beq  LB0E7          ; =
8a03 : 8e8a09                     ldx  #LB0E8-1       ; POINT X TO '?EXTRA IGN
8a06 : 7e9292                     jmp  LB99C          ; PRINT THE MESSAGE
8a09 : 39               LB0E7     rts
                        
8a0a : 3f455854524120.. LB0E8     fcc  "?EXTRA IGNORED" ; ?EXTRA IGNORED MESSA
                        
                        
8a18 : 0d00                       fcb  CR,$00
                        
                        * NEXT
8a1a : 2604             NEXT      bne  LB0FE          ; BRANCH IF ARGUMENT GIV
8a1c : 9e74                       ldx  ZERO           ; X = 0: DEFAULT FOR NO 
8a1e : 2003                       bra  LB101
8a20 : bd8c73           LB0FE     jsr  LB357          ; EVALUATE AN ALPHA EXPR
8a23 : 9f3b             LB101     stx  VARDES         ; SAVE VARIABLE DESCRIPT
8a25 : bd854b                     jsr  LABF9          ; GO SCAN FOR 'FOR/NEXT'
8a28 : 2704                       beq  LB10C          ; BRANCH IF DATA FOUND
8a2a : c600                       ldb  #0             ; 'NEXT WITHOUT FOR' ERR
8a2c : 2047             LB10A     bra  LB153          ; PROCESS ERROR
8a2e : 1f14             LB10C     tfr  x,s            ; POINT S TO START OF 'F
8a30 : 3003                       leax 3,x            ; POINT X TO FP VALUE OF
8a32 : bd950a                     jsr  LBC14          ; COPY A FP NUMBER FROM 
8a35 : a668                       lda  8,s            ; GET THE DIRECTION OF S
8a37 : 9754                       sta  FP0SGN         ; SAVE IT AS THE SIGN OF
8a39 : 9e3b                       ldx  VARDES         ; POINT (X) TO INDEX VAR
8a3b : bd92b8                     jsr  LB9C2          ; ADD (X) TO FPA0 (STEP 
8a3e : bd9529                     jsr  LBC33          ; PACK FPA0 AND STORE IT
                        *                             ; CONTAINED IN VARDES
8a41 : 3069                       leax 9,s            ; POINT (X) TO TERMINAL 
8a43 : bd958c                     jsr  LBC96          ; COMPARE CURRENT INDEX 
8a46 : e068                       subb 8,s            ; ACCB = 0 IF TERMINAL V
AS09 Assembler for M6809 [1.42].                                     Page   59
--------------------------------- merge.a09 ----------------------------------

                        *                             ; STEP IS POSITIVE AND C
                        *                             ; STEP IS NEGATIVE AND C
8a48 : 270c                       beq  LB134          ; BRANCH IF 'FOR/NEXT' L
8a4a : ae6e                       ldx  14,s           ; * GET LINE NUMBER AND
8a4c : 9f68                       stx  CURLIN         ; * BASIC POINTER OF
8a4e : aee810                     ldx  16,s           ; * STATEMENT FOLLOWING 
8a51 : 9f83                       stx  CHARAD         ; * PROPER FOR STATEMENT
8a53 : 7e86da           LB131     jmp  LAD9E          ; JUMP BACK TO COMMAND I
8a56 : 32e812           LB134     leas 18,s           ; PULL THE 'FOR-NEXT' DA
8a59 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
8a5b : 812c                       cmpa #','            ; CHECK FOR ANOTHER ARG
8a5d : 26f4                       bne  LB131          ; RETURN IF NONE
8a5f : 9d7c                       jsr  GETNCH         ; GET NEXT CHARACTER FRO
8a61 : 8dbd                       bsr  LB0FE          ; bsr SIMULATES A CALL T
                        
                        
8a63 : 8d13             LB141     bsr  LB156          ; EVALUATE EXPRESSION AN
8a65 : 1cfe             LB143     andcc #$FE          ; CLEAR CARRY FLAG
8a67 : 7d               LB145     fcb  $7D            ; OP CODE OF tst $1A01 -
                        *              ; NOT CHANGE CARRY FLAG)
8a68 : 1a01             LB146     orcc #1             ; SET CARRY
                        
                        * STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VA
                        * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN V
                        * IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP
                        * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERI
                        * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRI
8a6a : 0d06             LB148     tst  VALTYP         ; TEST TYPE FLAG; DO NOT
8a6c : 2503                       bcs  LB14F          ; BRANCH IF STRING
8a6e : 2a99                       bpl  LB0E7          ; RETURN ON PLUS
8a70 : 8c                         fcb  SKP2           ; SKIP 2 BYTES - 'TM' ER
8a71 : 2b96             LB14F     bmi  LB0E7          ; RETURN ON MINUS
8a73 : c618                       ldb  #12*2          ; 'TYPE M1SMATCH' ERROR
8a75 : 7e8598           LB153     jmp  LAC46          ; PROCESS ERROR
                        * EVALUATE EXPRESSION
8a78 : 8d6e             LB156     bsr  LB1C6          ; BACK UP INPUT POINTER
8a7a : 4f               LB158     clra                ; END OF OPERATION PRECE
8a7b : 8c                         fcb  SKP2           ; SKIP TWO BYTES
8a7c : 3404             LB15A     pshs b              ; SAVE FLAG (RELATIONAL 
8a7e : 3402                       pshs a              ; SAVE FLAG (PRECEDENCE 
8a80 : c601                       ldb  #1             ; *
8a82 : bd8585                     jsr  LAC33          ; * SEE IF ROOM IN FREE 
8a85 : bd8b45                     jsr  LB223          ; GO EVALUATE AN EXPRESS
8a88 : 0f3f                       clr  TRELFL         ; RESET RELATIONAL OPERA
8a8a : 9d82             LB168     jsr  GETCCH         ; GET CURRENT INPUT CHAR
                        * CHECK FOR RELATIONAL OPERATORS
8a8c : 80b6             LB16A     suba #TOK_GREATER   ; TOKEN FOR >
8a8e : 2513                       bcs  LB181          ; BRANCH IF LESS THAN RE
8a90 : 8103                       cmpa #3             ; *
8a92 : 240f                       bcc  LB181          ; * BRANCH IF GREATER TH
8a94 : 8101                       cmpa #1             ; SET CARRY IF '>'
8a96 : 49                         rola                ; CARRY TO BIT 0
8a97 : 983f                       eora TRELFL         ; * CARRY SET IF
8a99 : 913f                       cmpa TRELFL         ; * TRELFL = ACCA
8a9b : 2564                       bcs  LB1DF          ; BRANCH IF SYNTAX ERROR
8a9d : 973f                       sta  TRELFL         ; BIT 0: >, BIT 1 =, BIT
8a9f : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHARACTER
8aa1 : 20e9                       bra  LB16A          ; CHECK FOR ANOTHER RELA
                        *
8aa3 : d63f             LB181     ldb  TRELFL         ; GET RELATIONAL OPERATO
8aa5 : 2633                       bne  LB1B8          ; BRANCH IF RELATIONAL C
8aa7 : 1024006b                   lbcc LB1F4          ; BRANCH IF > RELATIONAL
AS09 Assembler for M6809 [1.42].                                     Page   60
--------------------------------- merge.a09 ----------------------------------

8aab : 8b07                       adda #7             ; SEVEN ARITHMETIC/LOGIC
8aad : 2467                       bcc  LB1F4          ; BRANCH IF NOT ARITHMET
8aaf : 9906                       adca VALTYP         ; ADD CARRY, NUMERIC FLA
8ab1 : 10270475                   lbeq LB60F          ; BRANCH IF VALTYP = FF,
                        *                             ; CONCATENATE TWO STRING
8ab5 : 89ff                       adca #-1            ; RESTORE ARITHMETIC/LOG
8ab7 : 3402                       pshs a              ; * STORE OPERATOR NUMBE
8ab9 : 48                         asla                ; * THEN ADD THE STORED 
8aba : abe0                       adda ,s+            ; * X 3; 3 BYTE/TABLE EN
8abc : 8e8369                     ldx  #LAA51         ; JUMP TABLE FOR ARITHME
8abf : 3086                       leax a,x            ; POINT X TO PROPER TABL
8ac1 : 3502             LB19F     puls a              ; GET PRECEDENCE FLAG FR
8ac3 : a184                       cmpa ,x             ; COMPARE TO CURRENT OPE
8ac5 : 2455                       bcc  LB1FA          ; BRANCH IF STACK OPERAT
8ac7 : 8d9c                       bsr  LB143          ; 'TM' ERROR IF VARIABLE
                        
                        * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE TH
8ac9 : 3402             LB1A7     pshs a              ; SAVE PRECEDENCE FLAG
8acb : 8d29                       bsr  LB1D4          ; PUSH OPERATOR ROUTINE 
8acd : 9e3d                       ldx  RELPTR         ; GET POINTER TO ARITHME
                        *                             ; LAST CALCULATED OPERAT
8acf : 3502                       puls a              ; GET PRECEDENCE FLAG OF
8ad1 : 261d                       bne  LB1CE          ; BRANCH IF NOT END OF O
8ad3 : 4d                         tsta                ; CHECK TYPE OF PRECEDEN
8ad4 : 1027006a                   lbeq LB220          ; BRANCH IF END OF EXPRE
8ad8 : 204b                       bra  LB203          ; EVALUATE AN OPERATION
                        
8ada : 0806             LB1B8     asl  VALTYP         ; BIT 7 OF TYPE FLAG TO 
8adc : 59                         rolb                ; SHIFT RELATIONAL FLAG 
8add : 8d09                       bsr  LB1C6          ; MOVE THE INPUT POINTER
8adf : 8e8aed                     ldx  #LB1CB         ; POINT X TO RELATIONAL 
8ae2 : d73f                       stb  TRELFL         ; SAVE RELATIONAL COMPAR
8ae4 : 0f06                       clr  VALTYP         ; SET VARIABLE TYPE TO N
8ae6 : 20d9                       bra  LB19F          ; PERFORM OPERATION OR S
                        
8ae8 : 9e83             LB1C6     ldx  CHARAD         ; * GET BASIC'S INPUT PO
8aea : 7e8801                     jmp  LAEBB          ; * MOVE IT BACK ONE
                        * RELATIONAL COMPARISON JUMP TABLE
8aed : 64               LB1CB     fcb  $64            ; RELATIONAL COMPARISON 
8aee : 8c10             LB1CC     fdb  LB2F4          ; JUMP ADDRESS
                        
8af0 : a184             LB1CE     cmpa ,x             ; COMPARE PRECEDENCE OF 
                        *         NEXT TO BE DONE OPERATION
8af2 : 2431                       bcc  LB203          ; EVALUATE OPERATION IF 
8af4 : 20d3                       bra  LB1A7          ; PUSH OPERATION DATA ON
                        
                        * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK
8af6 : ec01             LB1D4     ldd  1,x            ; GET ADDRESS OF OPERATO
8af8 : 3406                       pshs b,a            ; SAVE IT ON THE STACK
8afa : 8d08                       bsr  LB1E2          ; PUSH FPA0 ONTO STACK
8afc : d63f                       ldb  TRELFL         ; GET BACK RELATIONAL OP
8afe : 7e8a7c                     jmp  LB15A          ; EVALUATE ANOTHER EXPRE
8b01 : 7e8b99           LB1DF     jmp  LB277          ; 'SYNTAX ERROR'
                        * PUSH FPA0 ONTO THE STACK. ,s   = EXPONENT
                        * 1-2,s =HIGH ORDER MANTISSA 3-4,s = LOW ORDER MANTISS
                        * 5,s = SIGN RETURN WITH PRECEDENCE CODE IN ACCA
8b04 : d654             LB1E2     ldb  FP0SGN         ; GET SIGN OF FPA0 MANTI
8b06 : a684                       lda  ,x             ; GET PRECEDENCE CODE TO
8b08 : 3520             LB1E6     puls y              ; GET RETURN ADDRESS FRO
8b0a : 3404                       pshs b              ; SAVE ACCB ON STACK
8b0c : d64f             LB1EA     ldb  FP0EXP         ; * PUSH FPA0 ONTO THE S
8b0e : 9e50                       ldx  FPA0           ; *
AS09 Assembler for M6809 [1.42].                                     Page   61
--------------------------------- merge.a09 ----------------------------------

8b10 : de52                       ldu  FPA0+2         ; *
8b12 : 3454                       pshs u,x,b          ; *
8b14 : 6ea4                       jmp  ,y             ; JUMP TO ADDRESS IN Y
                        
                        * BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALL
8b16 : 9e74             LB1F4     ldx  ZERO           ; POINT X TO DUMMY VALUE
8b18 : a6e0                       lda  ,s+            ; GET PRECEDENCE FLAG FR
8b1a : 2726                       beq  LB220          ; BRANCH IF END OF EXPRE
8b1c : 8164             LB1FA     cmpa #$64           ; * CHECK FOR RELATIONAL
8b1e : 2703                       beq  LB201          ; * AND BRANCH IF RELATI
8b20 : bd8a65                     jsr  LB143          ; 'TM' ERROR IF VARIABLE
8b23 : 9f3d             LB201     stx  RELPTR         ; SAVE POINTER TO OPERAT
8b25 : 3504             LB203     puls b              ; GET RELATIONAL OPERATO
8b27 : 815a                       cmpa #$5A           ; CHECK FOR 'NOT' OPERAT
8b29 : 2719                       beq  LB222          ; RETURN IF 'NOT' - NO R
8b2b : 817d                       cmpa #$7D           ; CHECK FOR NEGATION (UN
8b2d : 2715                       beq  LB222          ; RETURN IF NEGATION - N
                        
                        * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON
                        * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRE
                        * WILL EVALUATE THE OPERATION. THE rts AT END OF ROUTI
                        * TO EVALUATING ROUTINE.
8b2f : 54                         lsrb                ; = ROTATE VALTYP BIT IN
8b30 : d70a                       stb  RELFLG         ; = FLAG AND SAVE NEW RE
8b32 : 3552                       puls a,x,u          ; * PULL A FP VALUE OFF 
8b34 : 975c                       sta  FP1EXP         ; * AND SAVE IT IN FPA1
8b36 : 9f5d                       stx  FPA1           ; *
8b38 : df5f                       stu  FPA1+2         ; *
8b3a : 3504                       puls b              ; = GET MANTISSA SIGN AN
8b3c : d761                       stb  FP1SGN         ; = SAVE IT IN FPA1
8b3e : d854                       eorb FP0SGN         ; EOR IT WITH FPA1 MANTI
8b40 : d762                       stb  RESSGN         ; SAVE IT IN RESULT SIGN
8b42 : d64f             LB220     ldb  FP0EXP         ; GET EXPONENT OF FPA0
8b44 : 39               LB222     rts
                        
8b45 : bd9da2           LB223     jsr  XVEC15         ; CALL EXTENDED BASIC AD
8b48 : 0f06                       clr  VALTYP         ; INITIALIZE TYPE FLAG T
8b4a : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHAR
8b4c : 2403                       bcc  LB22F          ; BRANCH IF NOT NUMERIC
8b4e : 7e9608           LB22C     jmp  LBD12          ; CONVERT ASCII STRING T
                        *         RETURN RESULT IN FPA0
                        * PROCESS A NON NUMERIC FIRST CHARACTER
8b51 : bd8cbe           LB22F     jsr  LB3A2          ; SET CARRY IF NOT ALPHA
8b54 : 2450                       bcc  LB284          ; BRANCH IF ALPHA CHARAC
8b56 : 812e                       cmpa #'.'           ; IS IT '.' (DECIMAL POI
8b58 : 27f4                       beq  LB22C          ; CONVERT ASCII STRING T
8b5a : 81b0                       cmpa #TOK_MINUS     ; MINUS TOKEN
8b5c : 2740                       beq  LB27C          ; YES - GO PROCESS THE M
8b5e : 81af                       cmpa #TOK_PLUS      ; PLUS TOKEN
8b60 : 27e3                       beq  LB223          ; YES - GET ANOTHER CHAR
8b62 : 8122                       cmpa #'"'           ; STRING DELIMITER?
8b64 : 260a                       bne  LB24E          ; NO
8b66 : 9e83             LB244     ldx  CHARAD         ; CURRENT BASIC POINTER 
8b68 : bd8e34                     jsr  LB518          ; SAVE STRING ON STRING 
8b6b : 9e64             LB249     ldx  COEFPT         ; * GET ADDRESS OF END O
8b6d : 9f83                       stx  CHARAD         ; * PUT BASIC'S INPUT PO
8b6f : 39                         rts
8b70 : 81ac             LB24E     cmpa #TOK_NOT       ; NOT TOKEN?
8b72 : 260d                       bne  LB25F          ; NO
                        * PROCESS THE NOT OPERATOR
8b74 : 865a                       lda  #$5A           ; 'NOT' PRECEDENCE FLAG
8b76 : bd8a7c                     jsr  LB15A          ; PROCESS OPERATION FOLL
AS09 Assembler for M6809 [1.42].                                     Page   62
--------------------------------- merge.a09 ----------------------------------

8b79 : bd8d09                     jsr  INTCNV         ; CONVERT FPA0 TO INTEGE
8b7c : 43                         coma                ; * 'NOT' THE INTEGER
8b7d : 53                         comb                ; *
8b7e : 7e8e10                     jmp  GIVABF         ; CONVERT ACCD TO FLOATI
8b81 : 4c               LB25F     inca                ; CHECK FOR TOKENS PRECE
8b82 : 272e                       beq  LB290          ; IT WAS PRECEEDED BY $F
8b84 : 8d06             LB262     bsr  LB26A          ; SYNTAX CHECK FOR A '('
8b86 : bd8a78                     jsr  LB156          ; EVALUATE EXPRESSIONS W
                        *         HIGHEST PRECEDENCE
8b89 : c629             LB267     ldb  #')'           ; SYNTAX CHECK FOR ')'
8b8b : 8c                         fcb  SKP2           ; SKIP 2 BYTES
8b8c : c628             LB26A     ldb  #'('           ; SYNTAX CHECK FOR '('
8b8e : 8c                         fcb  SKP2           ; SKIP 2 BYTES
8b8f : c62c             LB26D     ldb  #','            ; SYNTAX CHECK FOR COMM
8b91 : e19f0083         LB26F     cmpb [CHARAD]       ; * COMPARE ACCB TO CURR
8b95 : 2602                       bne  LB277          ; * CHARACTER - SYNTAX E
8b97 : 0e7c                       jmp  GETNCH         ; GET A CHARACTER FROM B
8b99 : c602             LB277     ldb  #2*1           ; SYNTAX ERROR
8b9b : 7e8598                     jmp  LAC46          ; JUMP TO ERROR HANDLER
                        
                        * PROCESS THE MINUS (UNARY) OPERATOR
8b9e : 867d             LB27C     lda  #$7D           ; MINUS (UNARY) PRECEDEN
8ba0 : bd8a7c                     jsr  LB15A          ; PROCESS OPERATION FOLL
8ba3 : 7e97df                     jmp  LBEE9          ; CHANGE SIGN OF FPA0 MA
                        
                        * EVALUATE ALPHA EXPRESSION
8ba6 : bd8c73           LB284     jsr  LB357          ; FIND THE DESCRIPTOR AD
8ba9 : 9f52             LB287     stx  FPA0+2         ; SAVE DESCRIPTOR ADDRES
8bab : 9606                       lda  VALTYP         ; TEST VARIABLE TYPE
8bad : 2695                       bne  LB222          ; RETURN IF STRING
8baf : 7e950a                     jmp  LBC14          ; COPY A FP NUMBER FROM 
                        
                        * EVALUATING A SECONDARY TOKEN
8bb2 : 9d7c             LB290     jsr  GETNCH         ; GET AN INPUT CHARACTER
8bb4 : 1f89                       tfr  a,b            ; SAVE IT IN ACCB
8bb6 : 58                         aslb                ; X2 & BET RID OF BIT 7
8bb7 : 9d7c                       jsr  GETNCH         ; GET ANOTHER INPUT CHAR
8bb9 : c138                       cmpb #(NUM_SEC_FNS-1)*2 ; 29 SECONDARY FUNCT
8bbb : 2302                       bls  LB29F          ; BRANCH IF COLOR BASIC 
8bbd : 20da                       bra  LB277          ; SYNTAX ERROR
8bbf : 3404             LB29F     pshs b              ; SAVE TOKEN OFFSET ON S
8bc1 : c12a             		  cmpb #(TOK_LEFT-$80)*2 ; CHECK FOR TOKEN WITH AN A
8bc3 : 251e             		  bcs  LB2C7          ; DO SECONDARIES STRING$ OR LE
8bc5 : c130                       cmpb #(TOK_INKEY-$80)*2 ; *
8bc7 : 241c                       bcc  LB2C9          ; * DO SECONDARIES $92 (
8bc9 : 8dc1                       bsr  LB26A          ; SYNTAX CHECK FOR A '('
8bcb : a6e4                       lda  ,s             ; GET TOKEN NUMBER
                        * DO SECONDARIES (LEFT$, RIGHT$, MID$)
8bcd : bd8a78                     jsr  LB156          ; EVALUATE FIRST STRING 
8bd0 : 8dbd                       bsr  LB26D          ; SYNTAX CHECK FOR A COM
8bd2 : bd8a68                     jsr  LB146          ; 'TM' ERROR IF NUMERIC 
8bd5 : 3502                       puls a              ; GET TOKEN OFFSET FROM 
8bd7 : de52                       ldu  FPA0+2         ; POINT U TO STRING DESC
8bd9 : 3442                       pshs u,a            ; SAVE TOKEN OFFSET AND 
8bdb : bd9025                     jsr  LB70B          ; EVALUATE FIRST NUMERIC
8bde : 3502                       puls a              ; GET TOKEN OFFSET FROM 
8be0 : 3406                       pshs b,a            ; SAVE TOKEN OFFSET AND 
8be2 : 8e                         fcb  $8E            ; OP CODE OF ldx# - SKlP
8be3 : 8d9f             LB2C7     bsr  LB262          ; SYNTAX CHECK FOR A '('
8be5 : 3504             LB2C9     puls b              ; GET TOKEN OFFSET
8be7 : be8106                     ldx  COMVEC+8       ; GET SECONDARY FUNCTION
8bea : 3a               LB2CE     abx                 ; ADD IN COMMAND OFFSET
AS09 Assembler for M6809 [1.42].                                     Page   63
--------------------------------- merge.a09 ----------------------------------

                        *
                        * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION
8beb : ad94                       jsr  [,x]           ; GO DO AN SECONDARY FUN
8bed : 7e8a65                     jmp  LB143          ; 'TM' ERROR IF VARIABLE
                        
                        * LOGICAL OPERATOR 'OR' JUMPS HERE
8bf0 : 86               LB2D4     fcb  SKP1LD         ; SKIP ONE BYTE - 'OR' F
                        
                        * LOGICAL OPERATOR 'AND' JUMPS HERE
8bf1 : 4f               LB2D5     clra                ; AND FLAG = 0
8bf2 : 9703                       sta  TMPLOC         ; AND/OR FLAG
8bf4 : bd8d09                     jsr  INTCNV         ; CONVERT FPA0 INTO AN I
8bf7 : dd01                       std  CHARAC         ; TEMP SAVE ACCD
8bf9 : bd9540                     jsr  LBC4A          ; MOVE FPA1 TO FPA0
8bfc : bd8d09                     jsr  INTCNV         ; CONVERT FPA0 INTO AN I
8bff : 0d03                       tst  TMPLOC         ; CHECK AND/OR FLAG
8c01 : 2606                       bne  LB2ED          ; BRANCH IF OR
8c03 : 9401                       anda CHARAC         ; * 'AND' ACCD WITH FPA0
8c05 : d402                       andb ENDCHR         ; * STORED IN ENDCHR
8c07 : 2004                       bra  LB2F1          ; CONVERT TO FP
8c09 : 9a01             LB2ED     ora  CHARAC         ; * 'OR' ACCD WITH FPA0 
8c0b : da02                       orb  ENDCHR         ; * STORED IN CHARAC
8c0d : 7e8e10           LB2F1     jmp  GIVABF         ; CONVERT THE VALUE IN A
                        
                        * RELATIONAL COMPARISON PROCESS HANDLER
8c10 : bd8a6a           LB2F4     jsr  LB148          ; 'TM' ERROR IF TYPE MIS
8c13 : 2610                       bne  LB309          ; BRANCH IF STRING VARIA
8c15 : 9661                       lda  FP1SGN         ; * 'PACK' THE MANTISSA
8c17 : 8a7f                       ora  #$7F           ; * SIGN OF FPA1 INTO
8c19 : 945d                       anda FPA1           ; * BIT 7 OF THE
8c1b : 975d                       sta  FPA1           ; * MANTISSA MS BYTE
8c1d : 8e005c                     ldx  #FP1EXP        ; POINT X TO FPA1
8c20 : bd958c                     jsr  LBC96          ; COMPARE FPA0 TO FPA1
8c23 : 2036                       bra  LB33F          ; CHECK TRUTH OF RELATIO
                        
                        * RELATIONAL COMPARISON OF STRINGS
8c25 : 0f06             LB309     clr  VALTYP         ; SET VARIABLE TYPE TO N
8c27 : 0a3f                       dec  TRELFL         ; REMOVE STRING TYPE FLA
                        *                             ; DESIRED RELATIONAL COM
8c29 : bd8f72                     jsr  LB657          ; GET LENGTH AND ADDRESS
                        *                             ; DESCRIPTOR ADDRESS IS 
8c2c : d756                       stb  STRDES         ; * SAVE LENGTH AND ADDR
8c2e : 9f58                       stx  STRDES+2       ; * DESCRIPTOR (STRING B
8c30 : 9e5f                       ldx  FPA1+2         ; = RETURN LENGTH AND AD
8c32 : bd8f74                     jsr  LB659          ; = WHOSE DESCRIPTOR ADD
8c35 : 9656                       lda  STRDES         ; LOAD ACCA WITH LENGTH 
8c37 : 3404                       pshs b              ; SAVE LENGTH A ON STACK
8c39 : a0e0                       suba ,s+            ; SUBTRACT LENGTH A FROM
8c3b : 2707                       beq  LB328          ; BRANCH IF STRINGS OF E
8c3d : 8601                       lda  #1             ; ; TRUE FLAG
8c3f : 2403                       bcc  LB328          ; TRUE IF LENGTH B > LEN
8c41 : d656                       ldb  STRDES         ; LOAD ACCB WITH LENGTH 
8c43 : 40                         nega                ; SET FLAG = FALSE (1FF)
8c44 : 9754             LB328     sta  FP0SGN         ; SAVE TRUE/FALSE FLAG
8c46 : de58                       ldu  STRDES+2       ; POINT U TO START OF ST
8c48 : 5c                         incb                ; COMPENSATE FOR THE DEC
                        * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING
8c49 : 5a               LB32D     decb                ; DECREMENT SHORTER STRI
8c4a : 2604                       bne  LB334          ; BRANCH IF ALL OF STRIN
8c4c : d654                       ldb  FP0SGN         ; GET TRUE/FALSE FLAB
8c4e : 200b                       bra  LB33F          ; CHECK TRUTH OF RELATIO
8c50 : a680             LB334     lda  ,x+            ; GET A BYTE FROM STRING
AS09 Assembler for M6809 [1.42].                                     Page   64
--------------------------------- merge.a09 ----------------------------------

8c52 : a1c0                       cmpa ,u+            ; COMPARE TO STRING B
8c54 : 27f3                       beq  LB32D          ; CHECK ANOTHER CHARACTE
8c56 : c6ff                       ldb  #$FF           ; FALSE FLAG IF STRING A
8c58 : 2401                       bcc  LB33F          ; BRANCH IF STRING A > S
8c5a : 50                         negb                ; SET FLAG = TRUE
                        
                        * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA
8c5b : cb01             LB33F     addb #1             ; CONVERT $FF,0,1 TO 0,1
8c5d : 59                         rolb                ; NOW IT'S 1,2,4 FOR > =
8c5e : d40a                       andb RELFLG         ; 'AND' THE ACTUAL COMPA
8c60 :                  COMPARISON
8c60 : 2702                       beq  LB348          ; BRANCH IF FALSE (NO MA
8c62 : c6ff                       ldb  #$FF           ; TRUE FLAG
8c64 : 7e9572           LB348     jmp  LBC7C          ; CONVERT ACCB INTO FP N
                        
                        * DIM
8c67 : bd8b8f           LB34B     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
8c6a : c601             DIM       ldb  #1             ; DIMENSION FLAG
8c6c : 8d08                       bsr  LB35A          ; SAVE ARRAY SPACE FOR T
8c6e : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
8c70 : 26f5                       bne  LB34B          ; KEEP DIMENSIONING IF N
8c72 : 39                         rts
                        * EVALUATE A VARIABLE - RETURN X AND
                        * VARPTR POINTING TO VARIABLE DESCRIPTOR
                        * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO
                        * BYTES ARE THE VARIABLE NAME AND THE NEXT 5
                        * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE
                        * FIRST BYTE OF VARlABLE NAME IS SET, THE
                        * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF
                        * THE SECOND BYTE OF VARIABLE NAME IS SET, THE
                        * VARIABLE IS A STRING, OTHERWISE THE VARIABLE
                        * IS NUMERIC.
                        * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS
                        * INSERTED INTO THE VARIABLE SPACE
8c73 : 5f               LB357     clrb                ; DIMENSION FLAG = 0; DO
8c74 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
8c76 : d705             LB35A     stb  DIMFLG         ; SAVE ARRAY FLAG
                        * ENTRY POINT FOR DEF FN VARIABLE SEARCH
8c78 : 9737             LB35C     sta  VARNAM         ; SAVE INPUT CHARACTER
8c7a : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
8c7c : 8d40                       bsr  LB3A2          ; SET CARRY IF NOT ALPHA
8c7e : 1025ff17                   lbcs LB277          ; SYNTAX ERROR IF NOT AL
8c82 : 5f                         clrb                ; DEFAULT 2ND VARIABLE C
8c83 : d706                       stb  VALTYP         ; SET VARIABLE TYPE TO N
8c85 : 9d7c                       jsr  GETNCH         ; GET ANOTHER CHARACTER 
8c87 : 2504                       bcs  LB371          ; BRANCH IF NUMERIC (2ND
                        *                             ; VARIABLE MAY BE NUMERI
8c89 : 8d33                       bsr  LB3A2          ; SET CARRY IF NOT ALPHA
8c8b : 250a                       bcs  LB37B          ; BRANCH IF NOT ALPHA
8c8d : 1f89             LB371     tfr  a,b            ; SAVE 2ND CHARACTER IN 
                        * READ INPUT CHARACTERS UNTIL A NON ALPHA OR
                        * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS
                        * IN VARIABLE NAME AFTER THE 1ST TWO
8c8f : 9d7c             LB373     jsr  GETNCH         ; GET AN INPUT CHARACTER
8c91 : 25fc                       bcs  LB373          ; BRANCH IF NUMERIC
8c93 : 8d29                       bsr  LB3A2          ; SET CARRY IF NOT ALPHA
8c95 : 24f8                       bcc  LB373          ; BRANCH IF ALPHA
8c97 : 8124             LB37B     cmpa #'$'           ; CHECK FOR A STRING VAR
8c99 : 2606                       bne  LB385          ; BRANCH IF IT IS NOT A 
8c9b : 0306                       com  VALTYP         ; SET VARIABLE TYPE TO S
8c9d : cb80                       addb #$80           ; SET BIT 7 OF 2ND CHARA
8c9f : 9d7c                       jsr  GETNCH         ; GET AN INPUT CHARACTER
AS09 Assembler for M6809 [1.42].                                     Page   65
--------------------------------- merge.a09 ----------------------------------

8ca1 : d738             LB385     stb  VARNAM+1       ; SAVE 2ND CHARACTER IN 
8ca3 : 9a08                       ora  ARYDIS         ; OR IN THE ARRAY DISABL
                        *              ; DON'T SEARCH FOR VARIABLES IN THE ARR
8ca5 : 8028                       suba #'('           ; IS THIS AN ARRAY VARIA
8ca7 : 10270075                   lbeq LB404          ; BRANCH IF IT IS
8cab : 0f08                       clr  ARYDIS         ; RESET THE ARRAY DISABL
8cad : 9e1b                       ldx  VARTAB         ; POINT X TO THE START O
8caf : dc37                       ldd  VARNAM         ; GET VARIABLE IN QUESTI
8cb1 : 9c1d             LB395     cmpx ARYTAB         ; COMPARE X TO THE END O
8cb3 : 2712                       beq  LB3AB          ; BRANCH IF END OF VARIA
8cb5 : 10a381                     cmpd ,x++           ; * COMPARE VARIABLE IN 
8cb8 : 273e                       beq  LB3DC          ; * VARIABLE AND BRANCH 
8cba : 3005                       leax 5,x            ; = MOVE POINTER TO NEXT
8cbc : 20f3                       bra  LB395          ; = KEEP LOOKING
                        
                        * SET CARRY IF NOT UPPER CASE ALPHA
8cbe : 8141             LB3A2     cmpa #'A'           ; * CARRY SET IF < 'A'
8cc0 : 2504                       bcs  LB3AA          ; *
8cc2 : 805b                       suba #'Z'+1         ; =
                        *         suba #-('Z'+1)      ; = CARRY CLEAR IF <= 'Z
8cc4 : 80a5                       fcb  $80,$A5
8cc6 : 39               LB3AA     rts
                        * PUT A NEW VARIABLE IN TABLE OF VARIABLES
8cc7 : 8e0074           LB3AB     ldx  #ZERO          ; POINT X TO ZERO LOCATI
8cca : eee4                       ldu  ,s             ; GET CURRENT RETURN ADD
8ccc : 11838ba9                   cmpu #LB287         ; DID WE COME FROM 'EVAL
8cd0 : 2728                       beq  LB3DE          ; YES - RETURN A ZERO VA
8cd2 : dc1f                       ldd  ARYEND         ; * GET END OF ARRAYS AD
8cd4 : dd43                       std  V43            ; * SAVE IT AT V43
8cd6 : c30007                     addd #7             ; = ADD 7 TO END OF ARRA
8cd9 : dd41                       std  V41            ; = VARIABLE = 7 BYTES) 
8cdb : 9e1d                       ldx  ARYTAB         ; * GET END OF VARIABLES
8cdd : 9f47                       stx  V47            ; *
8cdf : bd8570                     jsr  LAC1E          ; MAKE A SEVEN BYTE SLOT
                        *         TOP  OF VARIABLES
8ce2 : 9e41                       ldx  V41            ; = GET NEW END OF ARRAY
8ce4 : 9f1f                       stx  ARYEND         ; =
8ce6 : 9e45                       ldx  V45            ; * GET NEW END OF VARIA
8ce8 : 9f1d                       stx  ARYTAB         ; *
8cea : 9e47                       ldx  V47            ; GET OLD END OF VARIABL
8cec : dc37                       ldd  VARNAM         ; GET NEW VARIABLE NAME
8cee : ed81                       std  ,x++           ; SAVE VARIABLE NAME
8cf0 : 4f                         clra                ; * ZERO OUT THE FP VALU
8cf1 : 5f                         clrb                ; * VARIABLE OR THE LENG
8cf2 : ed84                       std  ,x             ; * OF A STRING VARIABLE
8cf4 : ed02                       std  2,x            ; *
8cf6 : a704                       sta  4,x            ; *
8cf8 : 9f39             LB3DC     stx  VARPTR         ; STORE ADDRESS OF VARIA
8cfa : 39               LB3DE     rts
                        *
8cfb : 9080000000       LB3DF     fcb  $90,$80,$00,$00,$00 ; * FLOATING POINT 
                        *                             ; SMALLEST SIGNED TWO BY
                        *
8d00 : 9d7c             LB3E4     jsr  GETNCH         ; GET AN INPUT CHARACTER
8d02 : bd8a63           LB3E6     jsr  LB141          ; GO EVALUATE NUMERIC EX
8d05 : 9654             LB3E9     lda  FP0SGN         ; GET FPA0 MANTISSA SIGN
8d07 : 2b5d                       bmi  LB44A          ; 'FC' ERROR IF NEGATIVE
                        
                        
8d09 : bd8a65           INTCNV    jsr  LB143          ; 'TM' ERROR IF STRING V
8d0c : 964f                       lda  FP0EXP         ; GET FPA0 EXPONENT
8d0e : 8190                       cmpa #$90           ; * COMPARE TO 32768 - L
AS09 Assembler for M6809 [1.42].                                     Page   66
--------------------------------- merge.a09 ----------------------------------

8d10 : 2508                       bcs  LB3FE          ; * BRANCH IF FPA0 < 327
8d12 : 8e8cfb                     ldx  #LB3DF         ; POINT X TO FP VALUE OF
8d15 : bd958c                     jsr  LBC96          ; COMPARE -32768 TO FPA0
8d18 : 264c                       bne  LB44A          ; 'FC' ERROR IF NOT =
8d1a : bd95be           LB3FE     jsr  LBCC8          ; CONVERT FPA0 TO A TWO 
8d1d : dc52                       ldd  FPA0+2         ; GET THE INTEGER
8d1f : 39                         rts
                        * EVALUATE AN ARRAY VARIABLE
8d20 : dc05             LB404     ldd  DIMFLG         ; GET ARRAY FLAG AND VAR
8d22 : 3406                       pshs b,a            ; SAVE THEM ON STACK
8d24 : 12                         nop                 ; DEAD SPACE CAUSED BY 1
8d25 : 5f                         clrb                ; RESET DIMENSION COUNTE
8d26 : 9e37             LB40A     ldx  VARNAM         ; GET VARIABLE NAME
8d28 : 3414                       pshs x,b            ; SAVE VARIABLE NAME AND
8d2a : 8dd4                       bsr  LB3E4          ; EVALUATE EXPRESSION (D
8d2c : 3534                       puls b,x,y          ; PULL OFF VARIABLE NAME
                        *                             ; ARRAY FLAG
8d2e : 9f37                       stx  VARNAM         ; SAVE VARIABLE NAME AND
8d30 : de52                       ldu  FPA0+2         ; GET DIMENSION LENGTH
8d32 : 3460                       pshs u,y            ; SAVE DIMENSION LENGTH,
8d34 : 5c                         incb                ; INCREASE DIMENSION COU
8d35 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
8d37 : 812c                       cmpa #','           ; CHECK FOR ANOTHER DIME
8d39 : 27eb                       beq  LB40A          ; BRANCH IF MORE
8d3b : d703                       stb  TMPLOC         ; SAVE DIMENSION COUNTER
8d3d : bd8b89                     jsr  LB267          ; SYNTAX CHECK FOR A ')'
8d40 : 3506                       puls a,b            ; * RESTORE VARIABLE TYP
8d42 : dd05                       std  DIMFLG         ; * FLAG - LEAVE DIMENSI
8d44 : 9e1d                       ldx  ARYTAB         ; GET START OF ARRAYS
8d46 : 9c1f             LB42A     cmpx ARYEND         ; COMPARE TO END OF ARRA
8d48 : 2721                       beq  LB44F          ; BRANCH IF NO MATCH FOU
8d4a : dc37                       ldd  VARNAM         ; GET VARIABLE IN QUESTI
8d4c : 10a384                     cmpd ,x             ; COMPARE TO CURRENT VAR
8d4f : 2706                       beq  LB43B          ; BRANCH IF =
8d51 : ec02                       ldd  2,x            ; GET OFFSET TO NEXT ARR
8d53 : 308b                       leax d,x            ; ADD TO CURRENT POINTER
8d55 : 20ef                       bra  LB42A          ; KEEP SEARCHING
8d57 : c612             LB43B     ldb  #2*9           ; 'REDIMENSIONED ARRAY' 
8d59 : 9605                       lda  DIMFLG         ; * TEST ARRAY FLAG - IF
8d5b : 260b                       bne  LB44C          ; * TO REDIMENSION AN AR
8d5d : d603                       ldb  TMPLOC         ; GET NUMBER OF DIMENSIO
8d5f : e104                       cmpb 4,x            ; COMPARE TO THIS ARRAYS
8d61 : 2759                       beq  LB4A0          ; BRANCH IF =
8d63 : c610             LB447     ldb  #8*2           ; 'BAD SUBSCRIPT'
8d65 : 8c                         fcb  SKP2           ; SKIP TWO BYTES
8d66 : c608             LB44A     ldb  #4*2           ; 'ILLEGAL FUNCTION CALL
8d68 : 7e8598           LB44C     jmp  LAC46          ; JUMP TO ERROR SERVICIN
                        
                        * INSERT A NEW ARRAY INTO ARRAY VARIABLES
                        * EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-
                        * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS TH
                        * NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFI
                        * AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LEN
                        * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIM
                        * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIM
                        * SION 2;... 4+N,5+N:LENGTH OF DIMENSION N.
                        
8d6b : cc0005           LB44F     ldd  #5             ; * 5 BYTES/ARRAY ENTRY 
8d6e : dd64                       std  COEFPT         ; *
8d70 : dc37                       ldd  VARNAM         ; = GET NAME OF ARRAY AN
8d72 : ed84                       std  ,x             ; = FIRST 2 BYTES OF DES
8d74 : d603                       ldb  TMPLOC         ; GET NUMBER OF DIMENSIO
AS09 Assembler for M6809 [1.42].                                     Page   67
--------------------------------- merge.a09 ----------------------------------

8d76 : e704                       stb  4,x            ; * 5TH BYTE OF DESCRIPT
8d78 : bd8585                     jsr  LAC33          ; CHECK FOR ROOM FOR DES
8d7b : 9f41                       stx  V41            ; TEMPoraRILY SAVE DESCR
8d7d : c60b             LB461     ldb  #11            ; * DEFAULT DIMENSION VA
8d7f : 4f                         clra                ; *
8d80 : 0d05                       tst  DIMFLG         ; = CHECK ARRAY FLAG AND
8d82 : 2705                       beq  LB46D          ; = NOT DIMENSIONING AN 
8d84 : 3506                       puls a,b            ; GET DIMENSION LENGTH
8d86 : c30001                     addd #1             ; ADD ONE (X(0) HAS A LE
8d89 : ed05             LB46D     std  5,x            ; SAVE LENGTH OF ARRAY D
8d8b : 8d5d                       bsr  LB4CE          ; MULTIPLY ACCUM ARRAY S
                        *                             ; OF NEW DIMENSION
8d8d : dd64                       std  COEFPT         ; TEMP STORE NEW CURRENT
8d8f : 3002                       leax 2,x            ; BUMP POINTER UP TWO
8d91 : 0a03                       dec  TMPLOC         ; * DECREMENT DIMENSION 
8d93 : 26e8                       bne  LB461          ; * NOT DONE WITH ALL DI
8d95 : 9f0f                       stx  TEMPTR         ; SAVE ADDRESS OF (END O
8d97 : d30f                       addd TEMPTR         ; ADD TOTAL SIZE OF NEW 
8d99 : 1025f7f9                   lbcs LAC44          ; 'OM' ERROR IF > $FFFF
8d9d : 1f01                       tfr  d,x            ; SAVE END OF ARRAY IN X
8d9f : bd8589                     jsr  LAC37          ; MAKE SURE THERE IS ENO
8da2 : 830035                     subd #STKBUF-5      ; SUBTRACT OUT THE (STAC
8da5 : dd1f                       std  ARYEND         ; SAVE NEW END OF ARRAYS
8da7 : 4f                         clra                ; ZERO = TERMINATOR BYTE
8da8 : 301f             LB48C     leax -1,x           ; * STORE TWO TERMINATOR
8daa : a705                       sta  5,x            ; * THE END OF THE ARRAY
8dac : 9c0f                       cmpx TEMPTR         ; *
8dae : 26f8                       bne  LB48C          ; *
8db0 : 9e41                       ldx  V41            ; GET ADDRESS OF START O
8db2 : 961f                       lda  ARYEND         ; GET MSB OF END OF ARRA
8db4 : 9341                       subd V41            ; SUBTRACT OUT ADDRESS O
8db6 : ed02                       std  2,x            ; SAVE LENGTH OF (ARRAY 
8db8 : 9605                       lda  DIMFLG         ; * GET ARRAY FLAG AND B
8dba : 262d                       bne  LB4CD          ; * BACK IF DIMENSIONING
                        * CALCULATE POINTER TO CORRECT ELEMENT
8dbc : e604             LB4A0     ldb  4,x            ; GET THE NUMBER OF DIME
8dbe : d703                       stb  TMPLOC         ; TEMPoraRILY SAVE
8dc0 : 4f                         clra                ; * INITIALIZE POINTER
8dc1 : 5f                         clrb                ; * TO ZERO
8dc2 : dd64             LB4A6     std  COEFPT         ; SAVE ACCUMULATED POINT
8dc4 : 3506                       puls a,b            ; * PULL DIMENSION ARGUM
8dc6 : dd52                       std  FPA0+2         ; * STACK AND SAVE IT
8dc8 : 10a305                     cmpd 5,x            ; COMPARE TO STORED 'DIM
8dcb : 243a                       bcc  LB4EB          ; 'BS' ERROR IF > = "DIM
8dcd : de64                       ldu  COEFPT         ; * GET ACCUMULATED POIN
8dcf : 2704                       beq  LB4B9          ; * BRANCH IF 1ST DIMENS
8dd1 : 8d17                       bsr  LB4CE          ; = MULTIPLY ACCUMULATED
8dd3 : d352                       addd FPA0+2         ; = LENGTH AND ADD TO CU
8dd5 : 3002             LB4B9     leax 2,x            ; MOVE POINTER TO NEXT D
8dd7 : 0a03                       dec  TMPLOC         ; * DECREMENT DIMENSION 
8dd9 : 26e7                       bne  LB4A6          ; * BRANCH IF ANY DIMENS
                        * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE
8ddb : ede3                       std  ,--s
8ddd : 58                         aslb
8dde : 49                         rola                ; TIMES 2
8ddf : 58                         aslb
8de0 : 49                         rola                ; TIMES 4
8de1 : e3e1                       addd ,s++           ; TIMES 5
8de3 : 308b                       leax d,x            ; ADD OFFSET TO START OF
8de5 : 3005                       leax 5,x            ; ADJUST POINTER FOR SIZ
8de7 : 9f39                       stx  VARPTR         ; SAVE POINTER TO ARRAY 
8de9 : 39               LB4CD     rts
AS09 Assembler for M6809 [1.42].                                     Page   68
--------------------------------- merge.a09 ----------------------------------

                        * MULTIPLY 2 BYTE NUMBER IN 5,x BY THE 2 BYTE NUMBER
                        * IN COEFPT. RETURN RESULT IN ACCd, BS ERROR IF > $FFF
8dea : 8610             LB4CE     lda  #16            ; 16 SHIFTS TO DO A MULT
8dec : 9745                       sta  V45            ; SHIFT COUNTER
8dee : ec05                       ldd  5,x            ; * GET SIZE OF DIMENSIO
8df0 : dd17                       std  BOTSTK         ; * AND SAVE IT
8df2 : 4f                         clra                ; * ZERO
8df3 : 5f                         clrb                ; * ACCD
8df4 : 58               LB4D8     aslb                ; = SHIFT ACCB LEFT
8df5 : 49                         rola                ; = ONE BIT
8df6 : 250f                       bcs  LB4EB          ; 'BS' ERROR IF CARRY
8df8 : 0865                       asl  COEFPT+1       ; * SHIFT MULTIPLICAND L
8dfa : 0964                       rol  COEFPT         ; * BIT - ADD MULTIPLIER
8dfc : 2404                       bcc  LB4E6          ; * IF CARRY <> 0
8dfe : d317                       addd BOTSTK         ; ADD MULTIPLIER TO ACCD
8e00 : 2505                       bcs  LB4EB          ; 'BS' ERROR IF CARRY (>
8e02 : 0a45             LB4E6     dec  V45            ; * DECREMENT SHIFT COUN
8e04 : 26ee                       bne  LB4D8          ; * IF NOT DONE
8e06 : 39                         rts
8e07 : 7e8d63           LB4EB     jmp  LB447          ; 'BS' ERROR
                        *
                        * MEM
                        * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE
                        * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK
                        * FOR WHICH MEM DOES NOT ALLOW.
                        *
8e0a : 1f40             MEM       tfr  s,d            ; PUT STACK POINTER INTO
8e0c : 931f                       subd ARYEND         ; SUBTRACT END OF ARRAYS
8e0e : 21                         fcb  SKP1           ; SKIP ONE BYTE
                        *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0
8e0f : 4f               LB4F3     clra                ; CLEAR MS BYTE OF ACCD
                        * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMB
8e10 : 0f06             GIVABF    clr  VALTYP         ; SET VARIABLE TYPE TO N
8e12 : dd50                       std  FPA0           ; SAVE ACCD IN TOP OF FA
8e14 : c690                       ldb  #$90           ; EXPONENT REQUIRED IF T
                        *         OF   FPA0 ARE TO BE TREATED AS AN INTEGER IN
8e16 : 7e9578                     jmp  LBC82          ; CONVERT THE REST OF FP
                        
                        * STR$
8e19 : bd8a65           STR       jsr  LB143          ; 'TM' ERROR IF STRING V
8e1c : ce01de                     ldu  #STRBUF+2      ; *CONVERT FP NUMBER TO 
8e1f : bd96d2                     jsr  LBDDC          ; *THE STRING BUFFER
8e22 : 3262                       leas 2,s            ; PURGE THE RETURN ADDRE
8e24 : 8e01dd                     ldx  #STRBUF+1      ; *POINT X TO STRING BUF
8e27 : 200b                       bra  LB518          ; *THE STRING IN THE STR
                        * RESERVE ACCB BYTES OF STRING SPACE. RETURN START
                        * ADDRESS IN (X) AND FRESPC
8e29 : 9f4d             LB50D     stx  V4D            ; SAVE X IN V4D
8e2b : 8d5c             LB50F     bsr  LB56D          ; RESERVE ACCB BYTES IN 
8e2d : 9f58             LB511     stx  STRDES+2       ; SAVE NEW STRING ADDRES
8e2f : d756                       stb  STRDES         ; SAVE LENGTH OF RESERVE
8e31 : 39                         rts
8e32 : 301f             LB516     leax -1,x           ; MOVE POINTER BACK ONE
                        * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO
                        * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR EN
                        * THE RESULTING STRING IS STORED IN THE STRING SPACE
                        * ONLY IF THE START OF THE STRING IS <= STRBUF+2
8e34 : 8622             LB518     lda  #'"'           ; * INITIALIZE
8e36 : 9701                       sta  CHARAC         ; * TERMINATORS
8e38 : 9702             LB51A     sta  ENDCHR         ; * TO "
8e3a : 3001             LB51E     leax 1,x            ; MOVE POINTER UP ONE
8e3c : 9f62                       stx  RESSGN         ; TEMPORARILY SAVE START
AS09 Assembler for M6809 [1.42].                                     Page   69
--------------------------------- merge.a09 ----------------------------------

8e3e : 9f58                       stx  STRDES+2       ; SAVE START OF STRING I
8e40 : c6ff                       ldb  #-1            ; INITIALIZE CHARACTER C
8e42 : 5c               LB526     incb                ; INCREMENT CHARACTER CO
8e43 : a680                       lda  ,x+            ; GET CHARACTER
8e45 : 270c                       beq  LB537          ; BRANCH IF END OF LINE
8e47 : 9101                       cmpa CHARAC         ; * CHECK FOR TERMINATOR
8e49 : 2704                       beq  LB533          ; * IN CHARAC AND ENDCHR
8e4b : 9102                       cmpa ENDCHR         ; * DON'T MOVE POINTER B
8e4d : 26f3                       bne  LB526          ; * ONE IF TERMINATOR IS
8e4f : 8122             LB533     cmpa #'"'           ; = COMPARE CHARACTER TO
8e51 : 2702                       beq  LB539          ; = & DON'T MOVE POINTER
8e53 : 301f             LB537     leax -1,x           ; MOVE POINTER BACK ONE
8e55 : 9f64             LB539     stx  COEFPT         ; SAVE END OF STRING ADD
8e57 : d756                       stb  STRDES         ; SAVE STRING LENGTH IN 
8e59 : de62                       ldu  RESSGN         ; GET INITlAL STRING STA
8e5b : 118301de                   cmpu #STRBUF+2      ; COMPARE TO START OF ST
8e5f : 2207             LB543     bhi  LB54C          ; BRANCH IF > START OF S
8e61 : 8dc6                       bsr  LB50D          ; GO RESERVE SPACE FOR T
8e63 : 9e62                       ldx  RESSGN         ; POINT X TO THE BEGINNI
8e65 : bd8f60                     jsr  LB645          ; MOVE (B) BYTES FROM (X
                        *                             [FRESPC] - MOVE STRING D
                        * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA
                        * ON THE STRING STACK. SET VARIABLE TYPE TO STRING
8e68 : 9e0b             LB54C     ldx  TEMPPT         ; GET NEXT AVAILABLE STR
8e6a : 8c00df                     cmpx #LINHDR        ; COMPARE TO TOP OF STRI
8e6d : 2605                       bne  LB558          ; FORMULA O.K.
8e6f : c61e                       ldb  #15*2          ; STRING FORMULA TOO COM
8e71 : 7e8598           LB555     jmp  LAC46          ; JUMP TO ERROR SERVICIN
8e74 : 9656             LB558     lda  STRDES         ; * GET LENGTH OF STRING
                        *         sta  ,x             ; * IN BYTE 0 OF DESCRIP
8e76 : a700                       fcb  $A7,$00
8e78 : dc58                       ldd  STRDES+2       ; = GET START ADDRESS OF
8e7a : ed02                       std  2,x            ; = AND SAVE IN BYTES 2,
8e7c : 86ff                       lda  #$FF           ; * VARIABLE TYPE = STRI
8e7e : 9706                       sta  VALTYP         ; * SAVE IN VARIABLE TYP
8e80 : 9f0d                       stx  LASTPT         ; = SAVE START OF DESCRI
8e82 : 9f52                       stx  FPA0+2         ; = ADDRESS IN LASTPT AN
8e84 : 3005                       leax 5,x            ; 5 BYTES/STRING DESCRIP
8e86 : 9f0b                       stx  TEMPPT         ; NEXT AVAILABLE STRING 
8e88 : 39                         rts
                        * RESERVE ACCB BYTES IN STRING STORAGE SPACE
                        * RETURN WITH THE STARTING ADDRESS OF THE
                        * RESERVED STRING SPACE IN (X) AND FRESPC
8e89 : 0f07             LB56D     clr  GARBFL         ; CLEAR STRING REORGANIZ
8e8b : 4f               LB56F     clra                ; * PUSH THE LENGTH OF T
8e8c : 3406                       pshs b,a            ; * STRING ONTO THE STAC
8e8e : dc23                       ldd  STRTAB         ; GET START OF STRING VA
8e90 : a3e0                       subd ,s+            ; SUBTRACT STRING LENGTH
8e92 : 109321                     cmpd FRETOP         ; COMPARE TO START OF ST
8e95 : 250a                       bcs  LB585          ; IF BELOW START, THEN R
8e97 : dd23                       std  STRTAB         ; SAVE NEW START OF STRI
8e99 : 9e23                       ldx  STRTAB         ; GET START OF STRING VA
8e9b : 3001                       leax 1,x            ; ADD ONE
8e9d : 9f25                       stx  FRESPC         ; SAVE START ADDRESS OF 
8e9f : 3584                       puls b,pc           ; RESTORE NUMBER OF BYTE
8ea1 : c61a             LB585     ldb  #2*13          ; OUT OF STRING SPACE' E
8ea3 : 0307                       com  GARBFL         ; TOGGLE REORGANIZATiON 
8ea5 : 27ca                       beq  LB555          ; ERROR IF FRESHLY REORG
8ea7 : 8d04                       bsr  LB591          ; GO REORGANIZE STRING S
8ea9 : 3504                       puls b              ; GET BACK THE NUMBER OF
8eab : 20de                       bra  LB56F          ; TRY TO RESERVE ACCB BY
                        * REORGANIZE THE STRING SPACE
AS09 Assembler for M6809 [1.42].                                     Page   70
--------------------------------- merge.a09 ----------------------------------

8ead : 9e27             LB591     ldx  MEMSIZ         ; GET THE TOP OF STRING 
8eaf : 9f23             LB593     stx  STRTAB         ; SAVE TOP OF UNORGANIZE
8eb1 : 4f                         clra                ; * ZERO OUT ACCD
8eb2 : 5f                         clrb                ; * AND RESET VARIABLE
8eb3 : dd4b                       std  V4B            ; * POINTER TO 0
8eb5 : 9e21                       ldx  FRETOP         ; POINT X TO START OF ST
8eb7 : 9f47                       stx  V47            ; SAVE POINTER IN V47
8eb9 : 8e00b7                     ldx  #STRSTK        ; POINT X TO START OF ST
8ebc : 9c0b             LB5A0     cmpx TEMPPT         ; COMPARE TO ADDRESS OF 
8ebe : 2704                       beq  LB5A8          ; BRANCH IF TOP OF STRIN
8ec0 : 8d32                       bsr  LB5D8          ; CHECK FOR STRING IN UN
8ec2 : 20f8                       bra  LB5A0          ; KEEP CHECKING
8ec4 : 9e1b             LB5A8     ldx  VARTAB         ; GET THE END OF BASIC P
8ec6 : 9c1d             LB5AA     cmpx ARYTAB         ; COMPARE TO END OF VARI
8ec8 : 2704                       beq  LB5B2          ; BRANCH IF AT TOP OF VA
8eca : 8d22                       bsr  LB5D2          ; CHECK FOR STRING IN UN
8ecc : 20f8                       bra  LB5AA          ; KEEP CHECKING VARIABLE
8ece : 9f41             LB5B2     stx  V41            ; SAVE ADDRESS OF THE EN
8ed0 : 9e41             LB5B4     ldx  V41            ; GET CURRENT ARRAY POIN
8ed2 : 9c1f             LB5B6     cmpx ARYEND         ; COMPARE TO THE END OF 
8ed4 : 2735                       beq  LB5EF          ; BRANCH IF AT END OF AR
8ed6 : ec02                       ldd  2,x            ; GET LENGTH OF ARRAY AN
8ed8 : d341                       addd V41            ; * ADD TO CURRENT ARRAY
8eda : dd41                       std  V41            ; * AND SAVE IT
8edc : a601                       lda  1,x            ; GET 1ST CHARACTER OF V
8ede : 2af0                       bpl  LB5B4          ; BRANCH IF NUMERIC ARRA
8ee0 : e604                       ldb  4,x            ; GET THE NUMBER OF DIME
8ee2 : 58                         aslb                ; MULTIPLY BY 2
8ee3 : cb05                       addb #5             ; ADD FIVE BYTES (VARIAB
                        *                             ; LENGTH, NUMBER DIMENSI
8ee5 : 3a                         abx                 ; X NOW POINTS TO START 
8ee6 : 9c41             LB5CA     cmpx V41            ; AT END OF THIS ARRAY?
8ee8 : 27e8                       beq  LB5B6          ; YES - CHECK FOR ANOTHE
8eea : 8d08                       bsr  LB5D8          ; CHECK FOR STRING LOCAT
                        *                             ; UNORGANIZED STRING SPA
8eec : 20f8                       bra  LB5CA          ; KEEP CHECKING ELEMENTS
8eee : a601             LB5D2     lda  1,x            ; GET F1RST BYTE OF VARI
8ef0 : 3002                       leax 2,x            ; MOVE POINTER TO DESCRI
8ef2 : 2a14                       bpl  LB5EC          ; BRANCH IF VARIABLE IS 
                        * SEARCH FOR STRING - ENTER WITH X POINTING TO
                        * THE STRING DESCRIPTOR. IF STRING IS STORED
                        * BETWEEN V47 AND STRTAb, SAVE DESCRIPTOR POINTER
                        * IN V4B AND RESET V47 TO STRING ADDRESS
8ef4 : e684             LB5D8     ldb  ,x             ; GET THE LENGTH OF THE 
8ef6 : 2710                       beq  LB5EC          ; BRANCH IF NULL - NO ST
8ef8 : ec02                       ldd  2,x            ; GET STARTING ADDRESS O
8efa : 109323                     cmpd STRTAB         ; COMPARE TO THE START O
8efd : 2209                       bhi  LB5EC          ; BRANCH IF THIS STRING 
                        *              ; THE STRING VARIABLES
8eff : 109347                     cmpd V47            ; COMPARE TO START OF ST
8f02 : 2304                       bls  LB5EC          ; BRANCH IF NOT STORED I
8f04 : 9f4b                       stx  V4B            ; SAVE VARIABLE POINTER 
8f06 : dd47                       std  V47            ; SAVE STRING STARTING A
8f08 : 3005             LB5EC     leax 5,x            ; MOVE TO NEXT VARIABLE 
8f0a : 39               LB5EE     rts
8f0b : 9e4b             LB5EF     ldx  V4B            ; GET ADDRESS OF THE DES
                        *              ; STRING WHICH IS STORED IN THE HIGHEST
                        *              ; THE UNORGANIZED STRING SPACE
8f0d : 27fb                       beq  LB5EE          ; BRANCH IF NONE FOUND A
8f0f : 4f                         clra                ; CLEAR MS BYTE OF LENGT
8f10 : e684                       ldb  ,x             ; GET LENGTH OF STRING
8f12 : 5a                         decb                ; SUBTRACT ONE
AS09 Assembler for M6809 [1.42].                                     Page   71
--------------------------------- merge.a09 ----------------------------------

8f13 : d347                       addd V47            ; ADD LENGTH OF STRING T
8f15 : dd43                       std  V43            ; SAVE AS MOVE STARTING 
8f17 : 9e23                       ldx  STRTAB         ; POINT X TO THE START O
8f19 : 9f41                       stx  V41            ; SAVE AS MOVE ENDING AD
8f1b : bd8572                     jsr  LAC20          ; MOVE STRING FROM CURRE
                        *              ; TOP OF UNORGANIZED STRING SPACE
8f1e : 9e4b                       ldx  V4B            ; POINT X TO STRING DESC
8f20 : dc45                       ldd  V45            ; * GET NEW STARTING ADD
8f22 : ed02                       std  2,x            ; * SAVE IT IN DESCRIPTO
8f24 : 9e45                       ldx  V45            ; GET NEW TOP OF UNORGAN
8f26 : 301f                       leax -1,x           ; MOVE POINTER BACK ONE
8f28 : 2085                       jmp  LB593          ; JUMP BACK AND REORGANI
                        
                        
8f2a : dc52             LB60F     ldd  FPA0+2         ; * GET DESCRIPTOR ADDRE
8f2c : 3406                       pshs b,a            ; * AND SAVE IT ON THE S
8f2e : bd8b45                     jsr  LB223          ; GET DESCRIPTOR ADDRESS
8f31 : bd8a68                     jsr  LB146          ; 'TM' ERROR IF NUMERIC 
8f34 : 3510                       puls x              ; * POINT X TO STRING A 
8f36 : 9f62                       stx  RESSGN         ; * ADDRESS AND SAVE IT 
8f38 : e684                       ldb  ,x             ; GET LENGTH OF STRING A
8f3a : 9e52                       ldx  FPA0+2         ; POINT X TO DESCRIPTOR 
8f3c : eb84                       addb ,x             ; ADD LENGTH OF STRING B
8f3e : 2405                       bcc  LB62A          ; BRANCH IF LENGTH < 256
8f40 : c61c                       ldb  #2*14          ; 'STRING TOO LONG' ERRO
8f42 : 7e8598                     jmp  LAC46          ; JUMP TO ERROR SERVICIN
8f45 : bd8e29           LB62A     jsr  LB50D          ; RESERVE ROOM IN STRING
8f48 : 9e62                       ldx  RESSGN         ; GET DESCRIPTOR ADDRESS
8f4a : e684                       ldb  ,x             ; GET LENGTH OF STRING A
8f4c : 8d10                       bsr  LB643          ; MOVE STRING A INTO RES
8f4e : 9e4d                       ldx  V4D            ; GET DESCRIPTOR ADDRESS
8f50 : 8d22                       bsr  LB659          ; GET LENGTH AND ADDRESS
8f52 : 8d0c                       bsr  LB645          ; MOVE STRING B INTO RES
8f54 : 9e62                       ldx  RESSGN         ; POINT X TO DESCRIPTOR 
8f56 : 8d1c                       bsr  LB659          ; DELETE STRING A IF LAS
8f58 : bd8e68                     jsr  LB54C          ; PUT STRING DESCRIPTOR 
8f5b : 7e8a8a                     jmp  LB168          ; BRANCH BACK TO EXPRESS
                        
                        * MOVE (B) BYTES FROM 2,x TO FRESPC
8f5e : ae02             LB643     ldx  2,x            ; POINT X TO SOURCE ADDR
8f60 : de25             LB645     ldu  FRESPC         ; POINT U TO DESTINATION
8f62 : 5c                         incb                ; COMPENSATION FOR THE D
8f63 : 2004                       bra  LB64E          ; GO MOVE THE BYTES
                        * MOVE B BYTES FROM (X) TO (U)
8f65 : a680             LB64A     lda  ,x+            ; * GET A SOURCE BYTE AN
8f67 : a7c0                       sta  ,u+            ; * TO THE DESTINATION
8f69 : 5a               LB64E     decb                ; DECREMENT BYTE COUNTER
8f6a : 26f9                       bne  LB64A          ; BRANCH IF ALL BYTES NO
8f6c : df25                       stu  FRESPC         ; SAVE ENDING ADDRESS IN
8f6e : 39                         rts
                        * RETURN LENGTH (ACCB) AND ADDRESS (X) OF
                        * STRING WHOSE DESCRIPTOR IS IN FPA0+2
                        * DELETE THE STRING IF IT IS THE LAST ONE
                        * PUT ON THE STRING STACK. REMOVE STRING FROM STRING
                        * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.
8f6f : bd8a68           LB654     jsr  LB146          ; 'TM' ERROR IF VARIABLE
8f72 : 9e52             LB657     ldx  FPA0+2         ; GET ADDRESS OF SELECTE
8f74 : e684             LB659     ldb  ,x             ; GET LENGTH OF STRING
8f76 : 8d18                       bsr  LB675          ; * CHECK TO SEE IF THIS
8f78 : 2613                       bne  LB672          ; * THE LAST ONE PUT ON 
                        *                             ; * BRANCH IF NOT
8f7a : ae07                       ldx  5+2,x          ; GET START ADDRESS OF S
AS09 Assembler for M6809 [1.42].                                     Page   72
--------------------------------- merge.a09 ----------------------------------

8f7c : 301f                       leax -1,x           ; MOVE POINTER DOWN ONE
8f7e : 9c23                       cmpx STRTAB         ; COMPARE TO START OF ST
8f80 : 2608                       bne  LB66F          ; BRANCH IF THIS STRING 
                        *                             ; OF STRING VARIABLES
8f82 : 3404                       pshs b              ; SAVE LENGTH; ACCA WAS 
8f84 : d323                       addd STRTAB         ; * ADD THE LENGTH OF TH
8f86 : dd23                       std  STRTAB         ; * TO THE START OF STRI
                        *                             ; * REMOVE THE STRING FR
8f88 : 3504                       puls b              ; RESTORE LENGTH
8f8a : 3001             LB66F     leax 1,x            ; ADD ONE TO POINTER
8f8c : 39                         rts
8f8d : ae02             LB672     ldx  2,x            ; *POINT X TO ADDRESS OF
8f8f : 39                         rts                 ; *ON THE STRING STACK
                        * REMOVE STRING FROM STRING STACK. ENTER WITH X
                        * POINTING TO A STRING DESCRIPTOR - DELETE THE
                        * STRING FROM STACK IF IT IS ON TOP OF THE
                        * STACK. IF THE STRING IS DELETEd, SET THE ZERO FLAG
8f90 : 9c0d             LB675     cmpx LASTPT         ; *COMPARE TO LAST USED 
8f92 : 2607                       bne  LB680          ; *ON THE STRING STACK, 
                        *                             ; *ADDRESS NOT ON THE ST
8f94 : 9f0b                       stx  TEMPPT         ; SAVE LAST USED DESCRIP
8f96 : 301b                       leax -5,x           ; * MOVE LAST USED DESCR
8f98 : 9f0d                       stx  LASTPT         ; * AND SAVE AS THE LAST
8f9a : 4f                         clra                ; SET ZERO FLAG
8f9b : 39               LB680     rts
                        
                        * LEN
8f9c : 8d03             LEN       bsr  LB686          ; POINT X TO PROPER STRI
8f9e : 7e8e0f           LB683     jmp  LB4F3          ; CONVERT ACCB TO FP NUM
                        * POINT X TO STRING ADDRESS LOAD LENGTH INTO
                        * ACCB. ENTER WITH THE STRING DESCRIPTOR IN
                        * BOTTOM TWO BYTES OF FPA0
8fa1 : 8dcc             LB686     bsr  LB654          ; GET LENGTH AND ADDRESS
8fa3 : 0f06                       clr  VALTYP         ; SET VARIABLE TYPE TO N
8fa5 : 5d                         tstb                ; SET FLAGS ACCORDING TO
8fa6 : 39                         rts
                        
                        * CHR$
8fa7 : bd9028           CHR       jsr  LB70E          ; CONVERT FPA0 TO AN INT
8faa : c601             LB68F     ldb  #1             ; * RESERVE ONE BYTE IN
8fac : bd8e89                     jsr  LB56D          ; * THE STRING SPACE
8faf : 9653                       lda  FPA0+3         ; GET ASCII STRING VALUE
8fb1 : bd8e2d                     jsr  LB511          ; SAVE RESERVED STRING D
8fb4 : a784                       sta  ,x             ; SAVE THE STRING (IT'S 
8fb6 : 3262             LB69B     leas 2,s            ; PURGE THE RETURN ADDRE
8fb8 : 7e8e68           LB69D     jmp  LB54C          ; PUT TEMP DESCRIPTOR DA
                        
                        
8fbb : 8d02             ASC       bsr  LB6A4          ; PUT 1ST CHARACTER OF S
8fbd : 20df                       bra  LB683          ; CONVERT ACCB INTO FP N
8fbf : 8de0             LB6A4     bsr  LB686          ; POINT X TO STRING DESC
8fc1 : 275d                       beq  LB706          ; 'FC' ERROR IF NULL STR
8fc3 : e684                       ldb  ,x             ; GET FIRST BYTE OF STRI
8fc5 : 39                         rts
                        
                        
8fc6 : 8d47             LEFT      bsr  LB6F5          ; GET ARGUMENTS FROM STA
8fc8 : 4f               LB6AD     clra                ; CLEAR STRING POINTER O
8fc9 : e184             LB6AE     cmpb ,x             ; * COMPARE LENGTH PARAM
8fcb : 2303                       bls  LB6B5          ; * STRING AND BRANCH IF
                        *                             ; >= LENGTH PARAMETER
8fcd : e684                       ldb  ,x             ; USE LENGTH OF STRING O
AS09 Assembler for M6809 [1.42].                                     Page   73
--------------------------------- merge.a09 ----------------------------------

8fcf : 4f                         clra                ; CLEAR STRING POINTER O
8fd0 : 3406             LB6B5     pshs b,a            ; PUSH PARAMETERS ONTO S
8fd2 : bd8e2b                     jsr  LB50F          ; RESERVE ACCB BYTES IN 
8fd5 : 9e4d                       ldx  V4D            ; POINT X TO STRING DESC
8fd7 : 8d9b                       bsr  LB659          ; GET ADDRESS OF OLD STR
8fd9 : 3504                       puls b              ; * PULL STRING POINTER 
8fdb : 3a                         abx                 ; * AND ADD IT TO STRING
8fdc : 3504                       puls b              ; PULL LENGTH PARAMETER 
8fde : 8d80                       jsr  LB645          ; MOVE ACCB BYTES FROM (
8fe0 : 20d6                       bra  LB69D          ; PUT TEMP STRING DESCRI
                        
                        * RIGHT$
8fe2 : 8d2b             RIGHT     bsr  LB6F5          ; GET ARGUMENTS FROM STA
8fe4 : a084                       suba ,x             ; ACCA=LENGTH PARAMETER 
8fe6 : 40                         nega                ; NOW ACCA = LENGTH OF O
8fe7 : 20e0                       bra  LB6AE          ; PUT NEW STRING IN THE 
                        
                        * MID$
8fe9 : c6ff             MID       ldb  #$FF           ; * GET DEFAULT VALUE OF
8feb : d753                       stb  FPA0+3         ; * SAVE IT IN FPA0
8fed : 9d82                       jsr  GETCCH         ; GET CURRENT CHARACTER 
8fef : 8129                       cmpa #')'           ; ARGUMENT DELIMITER?
8ff1 : 2705                       beq  LB6DE          ; YES - NO LENGTH PARAME
8ff3 : bd8b8f                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
8ff6 : 8d2d                       bsr  LB70B          ; EVALUATE NUMERIC EXPRE
8ff8 : 8d15             LB6DE     bsr  LB6F5          ; GET ARGUMENTS FROM STA
8ffa : 2724                       beq  LB706          ; 'FC' ERROR IF NULL STR
8ffc : 5f                         clrb                ; CLEAR LENGTH COUNTER (
8ffd : 4a                         deca                ; *SUOTRACT ONE FROM POS
8ffe : a184                       cmpa ,x             ; *ROUTINES EXPECT 1ST P
                        *                             ; *AND COMPARE IT TO LEN
9000 : 24ce                       bcc  LB6B5          ; IF POSITION > LENGTH O
                        *                             ; STRING WILL BE A NULL 
9002 : 1f89                       tfr  a,b            ; SAVE ABSOLUTE POSITION
9004 : e084                       subb ,x             ; ACCB=POSITION-LENGTH O
9006 : 50                         negb                ; NOW ACCB=LENGTH OF OLD
9007 : d153                       cmpb FPA0+3         ; *IF THE AMOUNT OF OLD 
9009 : 23c5                       bls  LB6B5          ; *POSITION IS <= THE LE
                        * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION
                        * INSTEAD OF THE LENGTH PARAMETER
900b : d653                       ldb  FPA0+3         ; GET LENGTH OF NEW STRI
900d : 20c1                       bra  LB6B5          ; PUT NEW STRING IN STRI
                        * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY 
                        * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR 
900f : bd8b89           LB6F5     jsr  LB267          ; SYNTAX CHECK FOR A ")"
9012 : eee4                       ldu  ,s             ; LOAD THE RETURN ADDRES
9014 : ae65                       ldx  5,s            ; * GET ADDRESS OF STRIN
9016 : 9f4d                       stx  V4D            ; * SAVE IT IN V4D
9018 : a664                       lda  4,s            ; = PUT LENGTH OF STRING
901a : e664                       ldb  4,s            ; = BOTH ACCA AND ACCB
901c : 3267                       leas 7,s            ; REMOVE DESCRIPTOR AND 
901e : 1f35                       tfr  u,pc           ; JUMP TO ADDRESS IN U R
9020 : 7e8d66           LB706     jmp  LB44A          ; 'ILLEGAL FUNCTION CALL
                        * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN
                        * ACCB - 'FC' ERROR IF EXPRESSION > 255
9023 : 9d7c             LB709     jsr  GETNCH         ; GET NEXT BASIC INPUT C
9025 : bd8a63           LB70B     jsr  LB141          ; EVALUATE A NUMERIC EXP
9028 : bd8d05           LB70E     jsr  LB3E9          ; CONVERT FPA0 TO INTEGE
902b : 4d                         tsta                ; TEST MS BYTE OF INTEGE
902c : 26f2                       bne  LB706          ; 'FC' ERROR IF EXPRESSI
902e : 0e82                       jmp  GETCCH         ; GET CURRENT INPUT CHAR
                        
AS09 Assembler for M6809 [1.42].                                     Page   74
--------------------------------- merge.a09 ----------------------------------

                        * VAL
9030 : bd8fa1           VAL       jsr  LB686          ; POINT X TO STRING ADDR
9033 : 102702f8                   lbeq LBA39          ; IF NULL STRING SET FPA
9037 : de83                       ldu  CHARAD         ; SAVE INPUT POINTER IN 
9039 : 9f83                       stx  CHARAD         ; POINT INPUT POINTER TO
903b : 3a                         abx                 ; MOVE POINTER TO END OF
903c : a684                       lda  ,x             ; GET LAST BYTE OF STRIN
903e : 3452                       pshs u,x,a          ; SAVE INPUT POINTER, ST
                        *         ADDRESS AND CHARACTER
9040 : 6f84                       clr  ,x             ; CLEAR STRING TERMINATO
9042 : 9d82                       jsr  GETCCH         ; GET CURRENT CHARACTER 
9044 : bd9608                     jsr  LBD12          ; CONVERT AN ASCII STRIN
9047 : 3552                       puls a,x,u          ; RESTORE CHARACTERS AND
9049 : a784                       sta  ,x             ; REPLACE STRING TERMINA
904b : df83                       stu  CHARAD         ; RESTORE INPUT CHARACTE
904d : 39                         rts
                        
904e : 8d07             LB734     bsr  LB73D          ; * EVALUATE AN EXPRESSI
9050 : 9f2b                       stx  BINVAL         ; * THE VALUE IN X; STOR
9052 : bd8b8f           LB738     jsr  LB26D          ; SYNTAX CHECK FOR A COM
9055 : 20ce                       bra  LB70B          ; EVALUATE EXPRESSION IN
                        * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 
                        
9057 : bd8a63           LB73D     jsr  LB141          ; EVALUATE NUMERIC EXPRE
905a : 9654             LB740     lda  FP0SGN         ; GET SIGN OF FPA0 MANTI
905c : 2bc2                       bmi  LB706          ; ILLEGAL FUNCTION CALL'
905e : 964f                       lda  FP0EXP         ; GET EXPONENT OF FPA0
9060 : 8190                       cmpa #$90           ; COMPARE TO LARGEST POS
9062 : 22bc                       bhi  LB706          ; ILLEGAL FUNCTION CALL'
9064 : bd95be                     jsr  LBCC8          ; SHIFT BINARY POINT TO 
9067 : 9e52                       ldx  FPA0+2         ; LOAD X WITH LOWER TWO 
9069 : 39                         rts
                        
                        * PEEK
906a : 8dee             PEEK      bsr  LB740          ; CONVERT FPA0 TO INTEGE
906c : e684                       ldb  ,x             ; GET THE VALUE BEING 'P
906e : 7e8e0f                     jmp  LB4F3          ; CONVERT ACCB INTO A FP
                        
                        * POKE
9071 : 8ddb             POKE      bsr  LB734          ; EVALUATE 2 EXPRESSIONS
9073 : 9e2b                       ldx  BINVAL         ; GET THE ADDRESS TO BE 
9075 : e784                       stb  ,x             ; STORE THE DATA IN THAT
9077 : 39                         rts
                        
                        * LIST
9078 : 3401             LIST      pshs cc             ; SAVE ZERO FLAG ON STAC
907a : bd88ad                     jsr  LAF67          ; CONVERT DECIMAL LINE N
907d : bd863d                     jsr  LAD01          ; * FIND RAM ADDRESS OF 
9080 : 9f66                       stx  LSTTXT         ; * SAVE IT IN LSTTXT
9082 : 3501                       puls cc             ; GET ZERO FLAG FROM STA
9084 : 2712                       beq  LB784          ; BRANCH IF END OF LINE
9086 : 9d82                       jsr  GETCCH         ; GET CURRENT CHARACTER 
9088 : 2713                       beq  LB789          ; BRANCH IF END OF LINE
908a : 81b0                       cmpa #TOK_MINUS     ; MINUS TOKEN (IS IT A R
908c : 2609                       bne  LB783          ; NO - RETURN
908e : 9d7c                       jsr  GETNCH         ; GET NEXT CHARACTER FRO
9090 : 2706                       beq  LB784          ; BRANCH IF END OF LINE
9092 : bd88ad                     jsr  LAF67          ; GET ENDING LINE NUMBER
9095 : 2706                       beq  LB789          ; BRANCH IF LEGAL LINE N
9097 : 39               LB783     rts
                        * LIST THE ENTIRE PROGRAM
9098 : ceffff           LB784     ldu  #$FFFF         ; * SET THE DEFAULT ENDI
AS09 Assembler for M6809 [1.42].                                     Page   75
--------------------------------- merge.a09 ----------------------------------

909b : df2b                       stu  BINVAL         ; * TO $FFFF
909d : 9e66             LB789     ldx  LSTTXT         ; POINT X TO STARTING LI
909f : bd9257           LB78D     jsr  LB95C          ; MOVE CURSOR TO START O
90a2 : bd81ad                     jsr  LA549          ; CHECK FOR A BREAK OR P
90a5 : ec84                       ldd  ,x             ; GET ADDRESS OF NEXT BA
90a7 : 2609                       bne  LB79F          ; BRANCH IF NOT END OF P
90a9 :                  LB797
90a9 : 0d6e                       tst  DEVNUM		  ; null value when screen as o
90ab : 26ea             		  bne  LB783          ; return from call for disk fo
90ad : 3262             		  leas 2,s            ; PURGE RETURN ADDRESS FROM TH
90af : 7e85b7           		  jmp  LAC73          ; RETURN TO BASIC'S MAIN INPUT
90b2 : 9f66             LB79F     stx  LSTTXT         ; SAVE NEW STARTING LINE
90b4 : ec02                       ldd  2,x            ; * GET THE LINE NUMBER 
90b6 : 10932b                     cmpd BINVAL         ; * COMPARE IT TO ENDING
90b9 : 22ee                       bhi  LB797          ; EXIT IF LINE NUMBER > 
90bb : bd96c2                     jsr  LBDCC          ; PRINT THE NUMBER IN AC
90be : bd92a2                     jsr  LB9AC          ; SEND A SPACE TO CONSOL
90c1 : 9e66                       ldx  LSTTXT         ; GET RAM ADDRESS OF THI
90c3 : 8d10                       bsr  LB7C2          ; UNCRUNCH A LINE
90c5 : ae9f0066                   ldx  [LSTTXT]       ; POINT X TO START OF NE
90c9 : ce00e2                     ldu  #LINBUF+1      ; POINT U TO BUFFER FULL
90cc : a6c0             LB7B9     lda  ,u+            ; GET A BYTE FROM THE BU
90ce : 27cf                       beq  LB78D          ; BRANCH IF END OF BUFFE
90d0 : bd92a7                     jsr  LB9B1          ; SEND CHARACTER TO CONS
90d3 : 20f7                       bra  LB7B9          ; GET ANOTHER CHARACTER
                        
                        * UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
90d5 : 3004             LB7C2     leax 4,x            ; MOVE POINTER PAST ADDR
90d7 : 108e00e2                   ldy  #LINBUF+1      ; UNCRUNCH LINE INTO LIN
90db : a680             LB7CB     lda  ,x+            ; GET A CHARACTER
90dd : 2751                       beq  LB820          ; BRANCH IF END OF LINE
90df : 2b15                       bmi  LB7E6          ; BRANCH IF IT'S A TOKEN
90e1 : 813a                       cmpa #':'           ; CHECK FOR END OF SUB L
90e3 : 260d                       bne  LB7E2          ; BRNCH IF NOT END OF SU
90e5 : e684                       ldb  ,x             ; GET CHARACTER FOLLOWIN
90e7 : c184                       cmpb #TOK_ELSE      ; TOKEN FOR ELSE?
90e9 : 27f0                       beq  LB7CB          ; YES - DON'T PUT IT IN 
90eb : c183                       cmpb #TOK_SNGL_Q    ; TOKEN FOR REMARK?
90ed : 27ec                       beq  LB7CB          ; YES - DON'T PUT IT IN 
90ef : 8c                         fcb  SKP2           ; SKIP TWO BYTES
90f0 : 8621             LB7E0     lda  #'!'           ; EXCLAMATION POINT
90f2 : 8d30             LB7E2     bsr  LB814          ; PUT CHARACTER IN BUFFE
90f4 : 20e5                       bra  LB7CB          ; GET ANOTHER CHARACTER
                        
90f6 : ce80f4           LB7E6     ldu  #COMVEC-10     ; FIRST DO COMMANDS
90f9 : 81ff                       cmpa #$FF           ; CHECK FOR SECONDARY TO
90fb : 2604                       bne  LB7F1          ; BRANCH IF NON SECONDAR
90fd : a680                       lda  ,x+            ; GET SECONDARY TOKEN
90ff : 3345                       leau 5,u            ; BUMP IT UP TO SECONDAR
9101 : 847f             LB7F1     anda #$7F           ; MASK OFF BIT 7 OF TOKE
9103 : 334a             LB7F3     leau 10,u           ; MOVE TO NEXT COMMAND T
9105 : 6dc4                       tst  ,u             ; IS THIS TABLE ENABLED?
9107 : 27e7                       beq  LB7E0          ; NO - ILLEGAL TOKEN
9109 : a0c4                       suba ,u             ; SUBTRACT THE NUMBER OF
910b : 2af6                       bpl  LB7F3          ; BRANCH IF TOKEN NOT IN
910d : abc4                       adda ,u             ; RESTORE TOKEN NUMBER R
910f : ee41                       ldu  1,u            ; POINT U TO COMMAND DIC
9111 : 4a               LB801     deca                ; DECREMENT TOKEN NUMBER
9112 : 2b06                       bmi  LB80A          ; BRANCH IF THIS IS THE 
                        * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN
9114 : 6dc0             LB804     tst  ,u+            ; GRAB A BYTE
9116 : 2afc                       bpl  LB804          ; BRANCH IF BIT 7 NOT SE
AS09 Assembler for M6809 [1.42].                                     Page   76
--------------------------------- merge.a09 ----------------------------------

9118 : 20f7                       bra  LB801          ; GO SEE IF THIS IS THE 
911a : a6c4             LB80A     lda  ,u             ; GET A CHARACTER FROM D
911c : 8d06                       bsr  LB814          ; PUT CHARACTER IN BUFFE
911e : 6dc0                       tst  ,u+            ; CHECK FOR START OF NEX
9120 : 2af8                       bpl  LB80A          ; BRANCH IF NOT DONE WIT
9122 : 20b7                       bra  LB7CB          ; GO GET ANOTHER CHARACT
9124 : 108c01db         LB814     cmpy #LINBUF+LBUFMX ; TEST FOR END OF LINE I
9128 : 2406                       bcc  LB820          ; BRANCH IF AT END OF BU
912a : 847f                       anda #$7F           ; MASK OFF BIT 7
912c : a7a0                       sta  ,y+            ; * SAVE CHARACTER IN BU
912e : 6fa4                       clr  ,y             ; * CLEAR NEXT CHARACTER
9130 : 39               LB820     rts
                        *
                        * CRUNCH THE LINE THAT THE INPUT POINTER IS
                        * POINTING TO INTO THE LINE INPUT BUFFER
                        * RETURN LENGTH OF CRUNCHED LINE IN ACCD
                        *
9131 : 9e83             LB821     ldx  CHARAD         ; GET BASIC'S INPUT POIN
9133 : ce00e1                     ldu  #LINBUF        ; POINT X TO LINE INPUT 
9136 : 0f43             LB829     clr  V43            ; CLEAR ILLEGAL TOKEN FL
9138 : 0f44                       clr  V44            ; CLEAR DATA FLAG
913a : a680             LB82D     lda  ,x+            ; GET INPUT CHAR
913c : 2721                       beq  LB852          ; BRANCH IF END OF LINE
913e : 0d43                       tst  V43            ; * CHECK ILLEGAL TOKEN 
9140 : 270f                       beq  LB844          ; * PROCESSING AN ILLEGA
9142 : bd8cbe                     jsr  LB3A2          ; SET CARRY IF NOT UPPER
9145 : 2418                       bcc  LB852          ; BRANCH IF UPPER CASE A
9147 : 8130                       cmpa #'0'            ; * DON'T CRUNCH ASCII 
9149 : 2504                       blo  LB842          ; * BRANCH IF NOT NUMERI
914b : 8139                       cmpa #'9'           ; *
914d : 2310                       bls  LB852          ; * BRANCH IF NUMERIC
                        * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC
914f : 0f43             LB842     clr  V43            ; CLEAR ILLEGAL TOKEN FL
9151 : 8120             LB844     cmpa #SPACE         ; SPACE?
9153 : 270a                       beq  LB852          ; DO NOT REMOVE SPACES
9155 : 9742                       sta  V42            ; SAVE INPUT CHARACTER A
9157 : 8122                       cmpa #'"'           ; CHECK FOR STRING DELIM
9159 : 2738                       beq  LB886          ; BRANCH IF STRING
915b : 0d44                       tst  V44            ; * CHECK DATA FLAG AND 
915d : 2719                       beq  LB86B          ; * DO NOT CRUNCH DATA
915f : a7c0             LB852     sta  ,u+            ; SAVE CHARACTER IN BUFF
9161 : 2706                       beq  LB85C          ; BRANCH IF END OF LINE
9163 : 813a                       cmpa #':'           ; * CHECK FOR END OF SUB
9165 : 27cf                       beq  LB829          ; * AND RESET FLAGS IF E
9167 : 20d1             LB85A     bra  LB82D          ; GO GET ANOTHER CHARACT
9169 : 6fc0             LB85C     clr  ,u+            ; * DOUBLE ZERO AT END O
916b : 6fc0                       clr  ,u+            ; *
916d : 1f30                       tfr  u,d            ; SAVE ADDRESS OF END OF
916f : 8300df                     subd #LINHDR        ; LENGTH OF LINE IN ACCD
9172 : 8e00e0                     ldx  #LINBUF-1      ; * SET THE INPUT POINTE
9175 : 9f83                       stx  CHARAD         ; * THE START OF THE CRU
9177 : 39                         rts                 ; EXIT 'CRUNCH'
9178 : 813f             LB86B     cmpa #'?'           ; CHECK FOR "?" - PRINT 
917a : 2604                       bne  LB873          ; BRANCH IF NOT PRINT AB
917c : 8687                       lda  #TOK_PRINT     ; * GET THE PRINT TOKEN 
917e : 20df                       bra  LB852          ; * IN BUFFER
9180 : 8127             LB873     cmpa #$27           ; #''' APOSTROPHE IS SAM
9182 : 2613                       bne  LB88A          ; BRANCH IF NOT REMARK
9184 : cc3a83                     ldd  #$3A00+TOK_SNGL_Q ; COLON, REM TOKEN
9187 : edc1                       std  ,u++           ; SAVE IN BUFFER
9189 : 0f42             LB87C     clr  V42            ; SET DELIMITER = 0 (END
918b : a680             LB87E     lda  ,x+            ; SCAN TILL WE MATCH [V4
AS09 Assembler for M6809 [1.42].                                     Page   77
--------------------------------- merge.a09 ----------------------------------

918d : 27d0                       beq  LB852          ; BRANCH IF END OF LINE
918f : 9142                       cmpa V42            ; DELIMITER?
9191 : 27cc                       beq  LB852          ; BRANCH OUT IF SO
9193 : a7c0             LB886     sta  ,u+            ; DON'T CRUNCH REMARKS O
9195 : 20f4                       bra  LB87E          ; GO GET MORE STRING OR 
9197 : 8130             LB88A     cmpa #'0'            ; * LESS THAN ASCII ZER
9199 : 2504                       bcs  LB892          ; * BRANCH IF SO
919b : 813c                       cmpa #';'+1         ; = CHECK FOR NUMERIC VA
919d : 25c0                       bcs  LB852          ; = AND INSERT IN BUFFER
919f : 301f             LB892     leax -1,x           ; MOVE INPUT POINTER BAC
91a1 : 3450                       pshs u,x            ; SAVE POINTERS TO INPUT
91a3 : 0f41                       clr  V41            ; TOKEN FLAG 0 = COMMANd
91a5 : ce80f4                     ldu  #COMVEC-10     ; POINT U TO COMMAND INT
                        *                             ; TABLE FOR BASIC - 10
91a8 : 0f42             LB89B     clr  V42            ; INITIALIZE V42 AS TOKE
91aa : 334a             LB89D     leau 10,u           ; MOVE TO NEXT COMMAND I
91ac : a6c4                       lda  ,u             ; GET NUMBER OF COMMANDS
91ae : 2731                       beq  LB8D4          ; GO DO SECONDARY FUNCTI
91b0 : 10ae41                     ldy  1,u            ; POINT Y TO COMMAND DIC
91b3 : aee4             LB8A6     ldx  ,s             ; GET POINTER TO INPUT S
91b5 : e6a0             LB8A8     ldb  ,y+            ; GET A BYTE FROM DICTIO
91b7 : e080                       subb ,x+            ; SUBTRACT INPUT CHARACT
91b9 : 27fa                       beq  LB8A8          ; LOOP IF SAME
91bb : c180                       cmpb #$80           ; LAST CHAR IN RESERVED 
                        *                             ; BIT 7 SET, SO IF WE HA
                        *                             ; THEN IT IS A GOOD COMP
91bd : 2638                       bne  LB8EA          ; BRANCH IF NO MATCH - C
91bf : 3262                       leas 2,s            ; DELETE OLD INPUT POINT
91c1 : 3540                       puls u              ; GET POINTER TO OUTPUT 
91c3 : da42                       orb  V42            ; OR IN THE TABLE POSITI
                        *                             ; - NOTE THAT B ALREADY 
91c5 : 9641                       lda  V41            ; * CHECK TOKEN FLAG AND
91c7 : 2606                       bne  LB8C2          ; * IF SECONDARY
91c9 : c184                       cmpb #TOK_ELSE      ; IS IT ELSE TOKEN?
91cb : 2606                       bne  LB8C6          ; NO
91cd : 863a                       lda  #':'           ; PUT A COLON (SUBLINE) 
91cf : edc1             LB8C2     std  ,u++           ; SECONDARY TOKENS PRECE
91d1 : 2094                       bra  LB85A          ; GO PROCESS MORE INPUT 
91d3 : e7c0             LB8C6     stb  ,u+            ; SAVE THIS TOKEN
91d5 : c186                       cmpb #TOK_DATA      ; DATA TOKEN?
91d7 : 2602                       bne  LB8CE          ; NO
91d9 : 0c44                       inc  V44            ; SET DATA FLAG
91db : c182             LB8CE     cmpb #TOK_REM       ; REM TOKEN?
91dd : 27aa                       beq  LB87C          ; YES
91df : 2086             LB8D2     lbra LB85A          ; GO PROCESS MORE INPUT 
                        * CHECK FOR A SECONDARY TOKEN
91e1 : ce80f9           LB8D4     ldu  #COMVEC-5      ; NOW DO SECONDARY FUNCT
91e4 : 0341                       com  V41            ; TOGGLE THE TOKEN FLAG
91e6 : 26c0                       bne  LB89B          ; BRANCH IF NOW CHECKING
                        
                        * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CR
                        * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN
91e8 : 3550                       puls x,u            ; RESTORE INPUT AND OUTP
91ea : a680                       lda  ,x+            ; * MOVE THE FIRST CHARA
91ec : a7c0                       sta  ,u+            ; * ILLEGAL TOKEN
91ee : bd8cbe                     jsr  LB3A2          ; SET CARRY IF NOT ALPHA
91f1 : 25ec                       bcs  LB8D2          ; BRANCH IF NOT ALPHA
91f3 : 0343                       com  V43            ; SET ILLEGAL TOKEN FLAG
91f5 : 20e8                       bra  LB8D2          ; PROCESS MORE INPUT CHA
91f7 : 0c42             LB8EA     inc  V42            ; INCREMENT TOKEN COUNTE
91f9 : 4a                         deca                ; DECR COMMAND COUNTER
91fa : 27ae                       beq  LB89D          ; GET ANOTHER COMMAND TA
AS09 Assembler for M6809 [1.42].                                     Page   78
--------------------------------- merge.a09 ----------------------------------

91fc : 313f                       leay -1,y           ; MOVE POINTER BACK ONE
91fe : e6a0             LB8F1     ldb  ,y+            ; * GET TO NEXT
9200 : 2afc                       bpl  LB8F1          ; * RESERVED WORD
9202 : 20af                       bra  LB8A6          ; GO SEE IF THIS WORD IS
                        
                        * PRINT
9204 : 274d             PRINT     beq  LB958          ; BRANCH IF NO ARGUMENT
9206 : 8d01                       bsr  LB8FE          ; CHECK FOR ALL PRINT OP
9208 : 39                         rts
                        
9209 : 8140             LB8FE	cmpa #'@'	; CHECK FOR PRINT @
920b : 2605             		bne	LB907	; NOT PRINT @
920d : bd81b0           LB902	jsr	LA554	; MOVE CURSOR TO PROPER PRINT LOCATION
9210 : 2004             LB905	bra	LB911	; GO PRINT THE DATA
9212 : 8123             LB907	cmpa #'#'	; CHECK FOR PRINT NUMBER
9214 : 2607             		bne	LB918	; NOT PRINT#
                        		;jsr	LA5A5	; CHECK FOR A VALID DEVICE NUMBER
                        		;jsr	LA406	; CHECK FOR A VALID OUTPUT FILE
9216 : 9d82             LB911	jsr	GETCCH	; GET CURRENT INPUT CHARACTER
9218 : 2739             		beq	LB958	; BRANCH IF END OF LINE
921a : bd8b8f           		jsr	LB26D	; SYNTAX CHECK FOR COMMA
                        
921d : bda176           LB918     jsr  XVEC9          ; CALL EXTENDED BASIC AD
9220 : 273e             LB91B     beq  LB965          ; RETURN IF END OF LINE
9222 : 81a8             LB91D     cmpa #TOK_TAB       ; TOKEN FOR TAB( ?
9224 : 2753                       beq  LB97E          ; YES
9226 : 812c                       cmpa #','           ; COMMA?
9228 : 2737                       beq  LB966          ; YES - ADVANCE TO NEXT 
922a : 813b                       cmpa #';'           ; SEMICOLON?
922c : 2760                       beq  LB997          ; YES - DO NOT ADVANCE C
922e : bd8a78                     jsr  LB156          ; EVALUATE EXPRESSION
9231 : 9606                       lda  VALTYP         ; * GET VARIABLE TYPE AN
9233 : 3402                       pshs a              ; * SAVE IT ON THE STACK
9235 : 2606                       bne  LB938          ; BRANCH IF STRING VARIA
9237 : bd96cf                     jsr  LBDD9          ; CONVERT FP NUMBER TO A
923a : bd8e32                     jsr  LB516          ; PARSE A STRING FROM (X
                        *                             ; DESCRIPTOR ON STRING S
923d : 8d56             LB938     bsr  LB99F          ; PRINT STRING POINTED T
923f : 3504                       puls b              ; GET VARIABLE TYPE BACK
9241 : bd8146                     jsr  LA35F          ; SET UP TAB WIDTH ZONE,
9244 : 5d               LB949     tstb                ; CHECK CURRENT PRINT PO
9245 : 2608                       bne  LB954          ; BRANCH IF NOT AT START
9247 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
9249 : 812c                       cmpa #','            ; COMMA?
924b : 2714                       beq  LB966          ; SKIP TO NEXT TAB FIELD
924d : 8d53                       bsr  LB9AC          ; SEND A SPACE TO CONSOL
924f : 9d82             LB954     jsr  GETCCH         ; GET CURRENT INPUT CHAR
9251 : 26cf                       bne  LB91D          ; BRANCH IF NOT END OF L
9253 : 860d             LB958     lda  #CR            ; * SEND A CR TO
9255 : 2050                       bra  LB9B1          ; * CONSOLE OUT
9257 : bd8146           LB95C     jsr  LA35F          ; SET UP TAB WIDTH, ZONE
925a : 27f7                       beq  LB958          ; BRANCH IF WIDTH = ZERO
925c : 966c                       lda  DEVPOS         ; GET PRINT POSITION
925e : 26f3                       bne  LB958          ; BRANCH IF NOT AT START
9260 : 39               LB965     rts
                        * SKIP TO NEXT TAB FIELD
9261 : bd8146           LB966     jsr  LA35F          ; SET UP TAB WIDTH, ZONE
9264 : 270a                       beq  LB975          ; BRANCH IF LINE WIDTH =
9266 : d66c                       ldb  DEVPOS         ; GET CURRENT POSITION
9268 : d16b                       cmpb DEVLCF         ; COMPARE TO LAST TAB ZO
926a : 2506                       bcs  LB977          ; BRANCH IF < LAST TAB Z
926c : 8de5                       bsr  LB958          ; SEND A CARRIAGE RETURN
AS09 Assembler for M6809 [1.42].                                     Page   79
--------------------------------- merge.a09 ----------------------------------

926e : 201e                       bra  LB997          ; GET MORE DATA
9270 : d66c             LB975     ldb  DEVPOS         ; *
9272 : d06a             LB977     subb DEVCFW         ; * SUBTRACT TAB FIELD W
9274 : 24fc                       bcc  LB977          ; * POSITION UNTIL CARRY
9276 : 50                         negb                ; * REMAINDER LEAVES THE
                        *              ; * TAB ZONE IN ACCB
9277 : 2010                       bra  LB98E          ; GO ADVANCE TO NEXT TAB
                        
                        * PRINT TAB(
9279 : bd9023           LB97E     jsr  LB709          ; EVALUATE EXPRESSION - 
927c : 8129                       cmpa #')'           ; * 'SYNTAX' ERROR IF NO
927e : 1026f917                   lbne LB277          ; *
9282 : bd8146                     jsr  LA35F          ; SET UP TAB WIDTH, ZONE
9285 : d06c                       subb DEVPOS         ; GET DIFFERENCE OF PRIN
9287 : 2305                       bls  LB997          ; BRANCH IF TAB POSITION
9289 :                  LB98E
9289 : 8d17             LB992     bsr  LB9AC          ; SEND A SPACE TO CONSOL
928b : 5a                         decb                ; DECREMENT DIFFERENCE C
928c : 26fb                       bne  LB992          ; BRANCH UNTIL CURRENT P
928e : 9d7c             LB997     jsr  GETNCH         ; GET NEXT CHARACTER FRO
9290 : 208e                       jmp  LB91B          ; LOOK FOR MORE PRINT DA
                        * COPY A STRING FROM (X) TO CONSOLE OUT
9292 : bd8e34           LB99C     jsr  LB518          ; PARSE A STRING FROM X 
9295 : bd8f72           LB99F     jsr  LB657          ; GET LENGTH OF STRING A
9298 : 5c                         incb                ; COMPENSATE FOR DECB BE
9299 : 5a               LB9A3     decb                ; DECREMENT COUNTER
929a : 27c4                       beq  LB965          ; EXIT ROUTINE
929c : a680                       lda  ,x+            ; GET A CHARACTER FROM X
929e : 8d07                       bsr  LB9B1          ; SEND TO CONSOLE OUT
92a0 : 20f7                       bra  LB9A3          ; KEEP LOOPING
92a2 : 8620             LB9AC     lda  #SPACE         ; SPACE TO CONSOLE OUT
92a4 : 8c                         fcb  SKP2           ; SKIP NEXT TWO BYTES
92a5 : 863f             LB9AF     lda  #'?'           ; QUESTION MARK TO CONSO
92a7 : 7e805c           LB9B1     jmp  PUTCHR         ; JUMP TO CONSOLE OUT
                        
                        * FLOATING POINT MATH PACKAGE
                        
                        * ADD .5 TO FPA0
92aa : 8e97b6           LB9B4     ldx  #LBEC0         ; FLOATING POINT CONstaN
92ad : 2009                       bra  LB9C2          ; ADD .5 TO FPA0
                        * SUBTRACT FPA0 FROM FP NUMBER POINTED
                        * TO BY (X), LEAVE RESULT IN FPA0
92af : bd9425           LB9B9     jsr  LBB2F          ; COPY PACKED FP DATA FR
                        
                        * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 
                        * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 I
92b2 : 0354             LB9BC     com  FP0SGN         ; CHANGE MANTISSA SIGN O
92b4 : 0362                       com  RESSGN         ; REVERSE RESULT SIGN FL
92b6 : 2003                       bra  LB9C5          ; GO ADD FPA1 AND FPA0
                        * ADD FP NUMBER POINTED TO BY
                        * (X) TO FPA0 - LEAVE RESULT IN FPA0
92b8 : bd9425           LB9C2     jsr  LBB2F          ; UNPACK PACKED FP DATA 
                        *         FPA1; RETURN EXPONENT OF FPA1 IN ACCA
                        
                        * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO
                        
92bb : 5d               LB9C5     tstb                ; CHECK EXPONENT OF FPA0
92bc : 10270280                   lbeq LBC4A          ; COPY FPA1 TO FPA0 IF F
92c0 : 8e005c                     ldx  #FP1EXP        ; POINT X TO FPA1
92c3 : 1f89             LB9CD     tfr  a,b            ; PUT EXPONENT OF FPA1 I
92c5 : 5d                         tstb                ; CHECK EXPONENT
92c6 : 276c                       beq LBA3E           ; RETURN IF EXPONENT = 0
AS09 Assembler for M6809 [1.42].                                     Page   80
--------------------------------- merge.a09 ----------------------------------

92c8 : d04f                       subb FP0EXP         ; SUBTRACT EXPONENT OF F
92ca : 2769                       beq LBA3F           ; BRANCH IF EXPONENTS AR
92cc : 250a                       bcs  LB9E2          ; BRANCH IF EXPONENT FPA
92ce : 974f                       sta  FP0EXP         ; REPLACE FPA0 EXPONENT 
92d0 : 9661                       lda  FP1SGN         ; * REPLACE FPA0 MANTISS
92d2 : 9754                       sta  FP0SGN         ; * WITH FPA1 MANTISSA S
92d4 : 8e004f                     ldx  #FP0EXP        ; POINT X TO FPA0
92d7 : 50                         negb                ; NEGATE DIFFERENCE OF E
92d8 : c1f8             LB9E2     cmpb #-8            ; TEST DIFFERENCE OF EXP
92da : 2f59                       ble  LBA3F          ; BRANCH IF DIFFERENCE O
92dc : 4f                         clra                ; CLEAR OVERFLOW BYTE
92dd : 6401                       lsr  1,x            ; SHIFT MS BYTE OF MANTI
92df : bd93b0                     jsr  LBABA          ; GO SHIFT MANTISSA OF (
92e2 : d662             LB9EC     ldb  RESSGN         ; GET SIGN FLAG
92e4 : 2a0b                       bpl  LB9FB          ; BRANCH IF FPA0 AND FPA
92e6 : 6301                       com  1,x            ; * COMPLEMENT MANTISSA 
92e8 : 6302                       com  2,x            ; * TO BY (X) THE
92ea : 6303                       com  3,x            ; * adca BELOW WILL
92ec : 6304                       com  4,x            ; * CONVERT THIS OPERATI
92ee : 43                         coma                ; * INTO A NEG (MANTISSA
92ef : 8900                       adca #0             ; ADD ONE TO ACCA - coma
                        * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA
                        *
                        * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0
92f1 : 9763             LB9FB     sta  FPSBYT         ; SAVE FPA SUB BYTE
92f3 : 9653                       lda  FPA0+3         ; * ADD LS BYTE
92f5 : 9960                       adca FPA1+3         ; * OF MANTISSA
92f7 : 9753                       sta  FPA0+3         ; SAVE IN FPA0 LSB
92f9 : 9652                       lda  FPA0+2         ; * ADD NEXT BYTE
92fb : 995f                       adca FPA1+2         ; * OF MANTISSA
92fd : 9752                       sta  FPA0+2         ; SAVE IN FPA0
92ff : 9651                       lda  FPA0+1         ; * ADD NEXT BYTE
9301 : 995e                       adca FPA1+1         ; * OF MANTISSA
9303 : 9751                       sta  FPA0+1         ; SAVE IN FPA0
9305 : 9650                       lda  FPA0           ; * ADD MS BYTE
9307 : 995d                       adca FPA1           ; * OF MANTISSA
9309 : 9750                       sta  FPA0           ; SAVE IN FPA0
930b : 5d                         tstb                ; TEST SIGN FLAG
930c : 2a44                       bpl  LBA5C          ; BRANCH IF FPA0 & FPA1 
930e : 2502             LBA18     bcs  LBA1C          ; BRANCH IF POSITIVE MAN
9310 : 8d5d                       bsr  LBA79          ; NEGATE FPA0 MANTISSA
                        
                        * NORMALIZE FPA0
9312 : 5f               LBA1C     clrb                ; CLEAR TEMPORARY EXPONE
9313 : 9650             LBA1D     lda  FPA0           ; TEST MSB OF MANTISSA
9315 : 262e                       bne  LBA4F          ; BRANCH IF <> 0
9317 : 9651                       lda  FPA0+1         ; * IF THE MSB IS
9319 : 9750                       sta  FPA0           ; * 0, THEN SHIFT THE
931b : 9652                       lda  FPA0+2         ; * MANTISSA A WHOLE BYT
931d : 9751                       sta  FPA0+1         ; * AT A TIME. THIS
931f : 9653                       lda  FPA0+3         ; * IS FASTER THAN ONE
9321 : 9752                       sta  FPA0+2         ; * BIT AT A TIME
9323 : 9663                       lda  FPSBYT         ; * BUT USES MORE MEMORY
9325 : 9753                       sta  FPA0+3         ; * FPSBYT, THE CARRY IN
9327 : 0f63                       clr  FPSBYT         ; * BYTE, REPLACES THE M
9329 : cb08                       addb #8             ; SHIFTING ONE BYTE = 8 
932b : c128                       cmpb #5*8           ; CHECK FOR 5 SHIFTS
932d : 2de4                       blt  LBA1D          ; BRANCH IF < 5 SHIFTS, 
932f : 4f               LBA39     clra                ; A ZERO EXPONENT = 0 FL
9330 : 974f             LBA3A     sta  FP0EXP         ; ZERO OUT THE EXPONENT
9332 : 9754                       sta  FP0SGN         ; ZERO OUT THE MANTISSA 
9334 : 39               LBA3E     rts
AS09 Assembler for M6809 [1.42].                                     Page   81
--------------------------------- merge.a09 ----------------------------------

9335 : 8d6d             LBA3F     bsr LBAAE           ; SHIFT FPA0 MANTISSA TO
9337 : 5f                         clrb                ; CLEAR CARRY FLAG
9338 : 20a8                       bra  LB9EC
                        * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7
                        * OF MATISSA MS BYTE = 1
933a : 5c               LBA44     incb                ; ADD ONE TO EXPONENT AC
933b : 0863                       asl  FPSBYT         ; SHIFT SUB BYTE ONE LEF
933d : 0953                       rol  FPA0+3         ; SHIFT LS BYTE
933f : 0952                       rol  FPA0+2         ; SHIFT NS BYTE
9341 : 0951                       rol  FPA0+1         ; SHIFT NS BYTE
9343 : 0950                       rol  FPA0           ; SHIFT MS BYTE
9345 : 2af3             LBA4F     bpl  LBA44          ; BRANCH IF NOT YET NORM
9347 : 964f                       lda  FP0EXP         ; GET CURRENT EXPONENT
9349 : 3404                       pshs b              ; SAVE EXPONENT MODIFIER
934b : a0e0                       suba ,s+            ; SUBTRACT ACCUMULATED E
934d : 974f                       sta  FP0EXP         ; SAVE AS NEW EXPONENT
934f : 23de                       bls  LBA39          ; SET FPA0 = 0 IF THE NO
                        *         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE
                        *         SIZE OF THE EXPONENT
9351 : 8c                         fcb  SKP2           ; SKIP 2 BYTES
9352 : 2508             LBA5C     bcs  LBA66          ; BRANCH IF MANTISSA OVE
9354 : 0863                       asl  FPSBYT         ; SUB BYTE BIT 7 TO CARR
                        *                             ; FLAG (TRUNCATE THE RES
9356 : 8600                       lda  #0             ; clra, BUT DO NOT CHANG
9358 : 9763                       sta  FPSBYT         ; CLEAR THE SUB BYTE
935a : 200c                       bra  LBA72          ; GO ROUND-OFF RESULT
935c : 0c4f             LBA66     inc  FP0EXP         ; INCREMENT EXPONENT - M
935e : 2728                       beq  LBA92          ; OVERFLOW ERROR IF CARR
9360 : 0650                       ror  FPA0           ; * SHIFT MANTISSA
9362 : 0651                       ror  FPA0+1         ; * ONE TO
9364 : 0652                       ror  FPA0+2         ; * THE RIGHT -
9366 : 0653                       ror  FPA0+3         ; * DIVIDE BY TWO
9368 : 2404             LBA72     bcc  LBA78          ; BRANCH IF NO ROUND-OFF
936a : 8d0d                       bsr  LBA83          ; ADD ONE TO MANTISSA - 
936c : 27ee                       beq  LBA66          ; BRANCH iF OVERFLOW - M
936e : 39               LBA78     rts
                        * NEGATE FPA0 MANTISSA
936f : 0354             LBA79     com  FP0SGN         ; TOGGLE SIGN OF MANTISS
9371 : 0350             LBA7B     com  FPA0           ; * COMPLEMENT ALL 4 MAN
9373 : 0351                       com  FPA0+1         ; *
9375 : 0352                       com  FPA0+2         ; *
9377 : 0353                       com  FPA0+3         ; *
                        * ADD ONE TO FPA0 MANTISSA
9379 : 9e52             LBA83     ldx  FPA0+2         ; * GET BOTTOM 2 MANTISS
937b : 3001                       leax 1,x            ; * BYTES, ADD ONE TO
937d : 9f52                       stx  FPA0+2         ; * THEM AND SAVE THEM
937f : 2606                       bne  LBA91          ; BRANCH IF NO OVERFLOW
9381 : 9e50                       ldx  FPA0           ; * IF OVERFLOW ADD ONE
9383 : 3001                       leax 1,x            ; * TO TOP 2 MANTISSA
9385 : 9f50                       stx  FPA0           ; * BYTES AND SAVE THEM
9387 : 39               LBA91     rts
9388 : c60a             LBA92     ldb  #2*5           ; OV' OVERFLOW ERROR
938a : 7e8598                     jmp  LAC46          ; PROCESS AN ERROR
938d : 8e0012           LBA97     ldx  #FPA2-1        ; POINT X TO FPA2
                        * SHIFT FPA POINTED TO BY (X) TO
                        * THE RIGHT -(B) TIMES. EXIT WITH
                        * ACCA CONTAINING DATA SHIFTED OUT
                        * TO THE RIGHT (SUB BYTE) AND THE DATA
                        * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY
9390 : a604             LBA9A     lda  4,x            ; GET LS BYTE OF MANTISS
9392 : 9763                       sta  FPSBYT         ; SAVE IN FPA SUB BYTE
9394 : a603                       lda  3,x            ; * SHIFT THE NEXT THREE
AS09 Assembler for M6809 [1.42].                                     Page   82
--------------------------------- merge.a09 ----------------------------------

9396 : a704                       sta  4,x            ; * MANTISSA RIGHT ONE C
9398 : a602                       lda  2,x            ; *
939a : a703                       sta  3,x            ; *
939c : a601                       lda  1,x            ; *
939e : a702                       sta  2,x            ; *
93a0 : 965b                       lda  FPCARY         ; GET THE CARRY IN BYTE
93a2 : a701                       sta  1,x            ; STORE AS THE MS MANTIS
93a4 : cb08             LBAAE     addb #8             ; ADD 8 TO DIFFERENCE OF
93a6 : 2fe8                       ble  LBA9A          ; BRANCH IF EXPONENT DIF
93a8 : 9663                       lda  FPSBYT         ; GET FPA SUB BYTE
93aa : c008                       subb #8             ; CAST OUT THE 8 ADDED I
93ac : 270c                       beq  LBAC4          ; BRANCH IF EXPONENT DIF
                        
                        
93ae : 6701             LBAB8     asr  1,x            ; * SHIFT MANTISSA AND S
93b0 : 6602             LBABA     ror  2,x            ; *
93b2 : 6603                       ror  3,x            ; *
93b4 : 6604                       ror  4,x            ; *
93b6 : 46                         rora                ; *
93b7 : 5c                         incb                ; ADD ONE TO EXPONENT DI
93b8 : 26f4                       bne  LBAB8          ; BRANCH IF EXPONENTS NO
93ba : 39               LBAC4     rts
93bb : 8100000000       LBAC5     fcb  $81,$00,$00,$00,$00 ; FLOATING POINT CO
                        
                        * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY
                        * FPA0 BY (X) - RETURN PRODUCT IN FPA0
93c0 : 8d63             LBACA     bsr  LBB2F          ; MOVE PACKED FPA FROM (
93c2 : 2760             LBACC     beq  LBB2E          ; BRANCH IF EXPONENT OF 
93c4 : 8d78                       bsr  LBB48          ; CALCULATE EXPONENT OF 
                        * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE
                        * HIGH ORDER BYTES OF PRODUCT IN FPA0. THE
                        * LOW ORDER FOUR BYTES OF THE PRODUCT WILL
                        * BE STORED IN VAB-VAE.
93c6 : 8600             LBAD0     lda  #0             ; * ZERO OUT MANTISSA OF
93c8 : 9713                       sta  FPA2           ; *
93ca : 9714                       sta  FPA2+1         ; *
93cc : 9715                       sta  FPA2+2         ; *
93ce : 9716                       sta  FPA2+3         ; *
93d0 : d653                       ldb  FPA0+3         ; GET LS BYTE OF FPA0
93d2 : 8d22                       bsr  LBB00          ; MULTIPLY BY FPA1
93d4 : d663                       ldb  FPSBYT         ; * TEMPORARILY SAVE SUB
93d6 : d78b                       stb  VAE            ; *
93d8 : d652                       ldb  FPA0+2         ; GET NUMBER 3 MANTISSA 
93da : 8d1a                       bsr  LBB00          ; MULTIPLY BY FPA1
93dc : d663                       ldb  FPSBYT         ; * TEMPORARILY SAVE SUB
93de : d78a                       stb  VAD            ; *
93e0 : d651                       ldb  FPA0+1         ; GET NUMBER 2 MANTISSA 
93e2 : 8d12                       bsr  LBB00          ; MULTIPLY BY FPA1
93e4 : d663                       ldb  FPSBYT         ; * TEMPORARILY SAVE SUB
93e6 : d789                       stb  VAC            ; *
93e8 : d650                       ldb  FPA0           ; GET MS BYTE OF FPA0 MA
93ea : 8d0c                       bsr  LBB02          ; MULTIPLY BY FPA1
93ec : d663                       ldb  FPSBYT         ; * TEMPORARILY SAVE SUB
93ee : d788                       stb  VAB            ; *
93f0 : bd9501                     jsr  LBC0B          ; COPY MANTISSA FROM FPA
93f3 : 7e9312                     jmp  LBA1C          ; NORMALIZE FPA0
93f6 : 2795             LBB00     lbeq LBA97          ; SHIFT FPA2 ONE BYTE TO
93f8 : 43               LBB02     coma                ; SET CARRY FLAG
                        * MULTIPLY FPA1 MANTISSA BY ACCB AND
                        * ADD PRODUCT TO FPA2 MANTISSA
93f9 : 9613             LBB03     lda  FPA2           ; GET FPA2 MS BYTE
93fb : 56                         rorb                ; ROTATE CARRY FLAG INTO
AS09 Assembler for M6809 [1.42].                                     Page   83
--------------------------------- merge.a09 ----------------------------------

                        *         DATA BIT INTO CARRY
93fc : 2726                       beq  LBB2E          ; BRANCH WHEN 8 SHIFTS D
93fe : 2416                       bcc  LBB20          ; DO NOT ADD FPA1 IF DAT
9400 : 9616                       lda  FPA2+3         ; * ADD MANTISSA LS BYTE
9402 : 9b60                       adda FPA1+3         ; *
9404 : 9716                       sta  FPA2+3         ; *
9406 : 9615                       lda  FPA2+2         ; = ADD MANTISSA NUMBER 
9408 : 995f                       adca FPA1+2         ; =
940a : 9715                       sta  FPA2+2         ; =
940c : 9614                       lda  FPA2+1         ; * ADD MANTISSA NUMBER 
940e : 995e                       adca FPA1+1         ; *
9410 : 9714                       sta  FPA2+1         ; *
9412 : 9613                       lda  FPA2           ; = ADD MANTISSA MS BYTE
9414 : 995d                       adca FPA1           ; =
9416 : 46               LBB20     rora                ; * ROTATE CARRY INTO MS
9417 : 9713                       sta  FPA2           ; *
9419 : 0614                       ror  FPA2+1         ; = ROTATE FPA2 ONE BIT 
941b : 0615                       ror  FPA2+2         ; =
941d : 0616                       ror  FPA2+3         ; =
941f : 0663                       ror  FPSBYT         ; =
9421 : 4f                         clra                ; CLEAR CARRY FLAG
9422 : 20d5                       bra  LBB03          ; KEEP LOOPING
9424 : 39               LBB2E     rts
                        * UNPACK A FP NUMBER FROM (X) TO FPA1
9425 : ec01             LBB2F     ldd  1,x            ; GET TWO MSB BYTES OF M
                        *         FPA  POINTED TO BY X
9427 : 9761                       sta  FP1SGN         ; SAVE PACKED MANTISSA S
9429 : 8a80                       ora  #$80           ; FORCE BIT 7 OF MSB MAN
942b : dd5d                       std  FPA1           ; SAVE 2 MSB BYTES IN FP
942d : d661                       ldb  FP1SGN         ; * GET PACKED MANTISSA 
942f : d854                       eorb FP0SGN         ; * SIGN - NEW SIGN POSI
9431 : d762                       stb  RESSGN         ; * NEG IF BOTH OLD SIGN
                        *                             ; * MANTISSA SIGN BYTE
9433 : ec03                       ldd  3,x            ; = GET 2 LSB BYTES OF M
9435 : dd5f                       std  FPA1+2         ; = AND PUT IN FPA1
9437 : a684                       lda  ,x             ; * GET EXPONENT FROM (X
9439 : 975c                       sta  FP1EXP         ; * PUT IN EXPONENT OF F
943b : d64f                       ldb  FP0EXP         ; GET EXPONENT OF FPA0
943d : 39                         rts
                        * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1
                        * ENTER WITH EXPONENT OF FPA1 IN ACCA
943e : 4d               LBB48     tsta                ; TEST EXPONENT OF FPA1
943f : 2716                       beq  LBB61          ; PURGE RETURN ADDRESS &
9441 : 9b4f                       adda FP0EXP         ; ADD FPA1 EXPONENT TO F
9443 : 46                         rora                ; ROTATE CARRY INTO BIT 
9444 : 49                         rola                ; SET OVERFLOW FLAG
9445 : 2810                       bvc  LBB61          ; BRANCH IF EXPONENT TOO
9447 : 8b80                       adda #$80           ; ADD $80 BIAS TO EXPONE
9449 : 974f                       sta  FP0EXP         ; SAVE NEW EXPONENT
944b : 270c                       beq  LBB63          ; SET FPA0
944d : 9662                       lda  RESSGN         ; GET MANTISSA SIGN
944f : 9754                       sta  FP0SGN         ; SAVE AS MANTISSA SIGN 
9451 : 39                         rts
                        * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0
                        * = IS NEGATIVE THEN FPA0 = 0
9452 : 9654             LBB5C     lda  FP0SGN         ; GET MANTISSA SIGN OF F
9454 : 43                         coma                ; CHANGE SIGN OF FPA0 MA
9455 : 2002                       bra  LBB63
9457 : 3262             LBB61     leas 2,s            ; PURGE RETURN ADDRESS F
9459 : 102afed2         LBB63     lbpl LBA39          ; ZERO FPA0 MANTISSA SIG
945d : 7e9388           LBB67     jmp  LBA92          ; 'OV' OVERFLOW ERROR
                        * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0
AS09 Assembler for M6809 [1.42].                                     Page   84
--------------------------------- merge.a09 ----------------------------------

9460 : bd9555           LBB6A     jsr  LBC5F          ; TRANSFER FPA0 TO FPA1
9463 : 270d                       beq  LBB7C          ; BRANCH IF EXPONENT = 0
9465 : 8b02                       adda #2             ; ADD 2 TO EXPONENT (TIM
9467 : 25f4                       bcs  LBB67          ; 'OV' ERROR IF EXPONENT
9469 : 0f62                       clr  RESSGN         ; CLEAR RESULT SIGN BYTE
946b : bd92c3                     jsr  LB9CD          ; ADD FPA1 TO FPA0 (TIME
946e : 0c4f                       inc  FP0EXP         ; ADD ONE TO EXPONENT (T
9470 : 27eb                       beq  LBB67          ; 'OV' ERROR IF EXPONENT
9472 : 39               LBB7C     rts
9473 : 8420000000       LBB7D     fcb  $84,$20,$00,$00,$00 ; FLOATING POINT CO
                        * DIVIDE FPA0 BY 10
9478 : bd9555           LBB82     jsr  LBC5F          ; MOVE FPA0 TO FPA1
947b : 8e9473                     ldx  #LBB7D         ; POINT TO FLOATING POIN
947e : 5f                         clrb                ; ZERO MANTISSA SIGN BYT
947f : d762             LBB89     stb  RESSGN         ; STORE THE QUOTIENT MAN
9481 : bd950a                     jsr  LBC14          ; UNPACK AN FP NUMBER FR
9484 : 8c                         fcb  SKP2           ; SKIP TWO BYTES
                        * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0
9485 : 8d9e             LBB8F     bsr  LBB2F          ; GET FP NUMBER FROM (X)
                        
                        * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY 
                        * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY tsta)
                        
                        * DIVIDE FPA1 BY FPA0
9487 : 2773             LBB91     beq  LBC06          ; '/0' DIVIDE BY ZERO ER
9489 : 004f                       neg  FP0EXP         ; GET EXPONENT OF RECIPR
948b : 8db1                       bsr  LBB48          ; CALCULATE EXPONENT OF 
948d : 0c4f                       inc  FP0EXP         ; INCREMENT EXPONENT
948f : 27cc                       beq  LBB67          ; 'OV' OVERFLOW ERROR
9491 : 8e0013                     ldx  #FPA2          ; POINT X TO MANTISSA OF
                        *                             ; TEMPORARY QUOTIENT IN 
9494 : c604                       ldb  #4             ; 5 BYTE DIVIDE
9496 : d703                       stb  TMPLOC         ; SAVE BYTE COUNTER
9498 : c601                       ldb  #1             ; SHIFT COUNTER-AND TEMP
                        * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -
                        * SET CARRY FLAG IF FPA1 >= FPA0
949a : 9650             LBBA4     lda  FPA0           ; * COMPARE THE TWO MS B
949c : 915d                       cmpa FPA1           ; * OF FPA0 AND FPA1 AND
949e : 2613                       bne  LBBBD          ; * BRANCH IF <>
94a0 : 9651                       lda  FPA0+1         ; = COMPARE THE NUMBER 2
94a2 : 915e                       cmpa FPA1+1         ; = BYTES AND
94a4 : 260d                       bne  LBBBD          ; = BRANCH IF <>
94a6 : 9652                       lda  FPA0+2         ; * COMPARE THE NUMBER 3
94a8 : 915f                       cmpa FPA1+2         ; * BYTES AND
94aa : 2607                       bne  LBBBD          ; * BRANCH IF <>
94ac : 9653                       lda  FPA0+3         ; = COMPARE THE LS BYTES
94ae : 9160                       cmpa FPA1+3         ; = AND BRANCH
94b0 : 2601                       bne  LBBBD          ; = IF <>
94b2 : 43                         coma                ; SET CARRY FLAG IF FPA0
94b3 : 1fa8             LBBBD     tfr  cc,a           ; SAVE CARRY FLAG STATUS
                        *         CLEAR IF FPA0 > FPA1
94b5 : 59                         rolb                ; ROTATE CARRY INTO TEMP
94b6 : 240a                       bcc  LBbcc          ; CARRY WILL BE SET AFTE
94b8 : e780                       stb  ,x+            ; SAVE TEMPORARY QUOTIEN
94ba : 0a03                       dec  TMPLOC         ; DECREMENT BYTE COUNTER
94bc : 2b34                       bmi  LBBFC          ; BRANCH IF DONE
94be : 272e                       beq  LBBF8          ; BRANCH IF LAST BYTE
94c0 : c601                       ldb  #1             ; RESET SHIFT COUNTER AN
94c2 : 1f8a             LBbcc     tfr  a,cc           ; RESTORE CARRY FLAG AND
94c4 : 250e                       bcs  LBBDE          ; BRANCH IF FPA0 =< FPA1
94c6 : 0860             LBBD0     asl  FPA1+3         ; * SHIFT FPA1 MANTISSA 
94c8 : 095f                       rol  FPA1+2         ; *
AS09 Assembler for M6809 [1.42].                                     Page   85
--------------------------------- merge.a09 ----------------------------------

94ca : 095e                       rol  FPA1+1         ; *
94cc : 095d                       rol  FPA1           ; *
94ce : 25e3                       bcs  LBBBD          ; BRANCH IF CARRY - ADD 
94d0 : 2bc8                       bmi  LBBA4          ; IF MSB OF HIGH ORDER M
                        *         SET, CHECK THE MAGNITUDES OF FPA0, FPA1
94d2 : 20df                       bra  LBBBD          ; CARRY IS CLEAR, CHECK 
                        * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1
94d4 : 9660             LBBDE     lda  FPA1+3         ; * SUBTRACT THE LS BYTE
94d6 : 9053                       suba FPA0+3         ; *
94d8 : 9760                       sta  FPA1+3         ; *
94da : 965f                       lda  FPA1+2         ; = THEN THE NEXT BYTE
94dc : 9252                       sbca FPA0+2         ; =
94de : 975f                       sta  FPA1+2         ; =
94e0 : 965e                       lda  FPA1+1         ; * AND THE NEXT
94e2 : 9251                       sbca FPA0+1         ; *
94e4 : 975e                       sta  FPA1+1         ; *
94e6 : 965d                       lda  FPA1           ; = AND FINALLY, THE MS 
94e8 : 9250                       sbca FPA0           ; =
94ea : 975d                       sta  FPA1           ; =
94ec : 20d8                       bra  LBBD0          ; GO SHIFT FPA1
94ee : c640             LBBF8     ldb  #$40           ; USE ONLY TWO BITS OF T
94f0 : 20d0                       bra  LBbcc          ; GO SHIFT THE LAST BYTE
94f2 : 56               LBBFC     rorb                ; * SHIFT CARRY (ALWAYS 
94f3 : 56                         rorb                ; * BIT 5 AND MOVE
94f4 : 56                         rorb                ; * BITS 1,0 TO BITS 7,6
94f5 : d763                       stb  FPSBYT         ; SAVE SUB BYTE
94f7 : 8d08                       bsr  LBC0B          ; MOVE MANTISSA OF FPA2 
94f9 : 7e9312                     jmp  LBA1C          ; NORMALIZE FPA0
94fc : c614             LBC06     ldb  #2*10          ; /0' ERROR
94fe : 7e8598                     jmp  LAC46          ; PROCESS THE ERROR
                        * COPY MANTISSA FROM FPA2 TO FPA0
9501 : 9e13             LBC0B     ldx  FPA2           ; * MOVE TOP 2 BYTES
9503 : 9f50                       stx  FPA0           ; *
9505 : 9e15                       ldx  FPA2+2         ; = MOVE BOTTOM 2 BYTES
9507 : 9f52                       stx  FPA0+2         ; =
9509 : 39                         rts
                        * COPY A PACKED FP NUMBER FROM (X) TO FPA0
950a : 3402             LBC14     pshs a              ; SAVE ACCA
950c : ec01                       ldd  1,x            ; GET TOP TWO MANTISSA B
950e : 9754                       sta  FP0SGN         ; SAVE MS BYTE OF MANTIS
9510 : 8a80                       ora  #$80           ; UNPACK MS BYTE
9512 : dd50                       std  FPA0           ; SAVE UNPACKED TOP 2 MA
9514 : 0f63                       clr  FPSBYT         ; CLEAR MANTISSA SUB BYT
9516 : e684                       ldb  ,x             ; GET EXPONENT TO ACCB
9518 : ae03                       ldx  3,x            ; * MOVE LAST 2
951a : 9f52                       stx  FPA0+2         ; * MANTISSA BYTES
951c : d74f                       stb  FP0EXP         ; SAVE EXPONENT
951e : 3582                       puls a,pc           ; RESTORE ACCA AND RETUR
                        
9520 : 8e0045           LBC2A     ldx  #V45           ; POINT X TO MANTISSA OF
9523 : 2006                       bra  LBC35          ; MOVE FPA0 TO FPA4
9525 : 8e0040           LBC2F     ldx  #V40           ; POINT X TO MANTISSA OF
9528 : 8c                         fcb  SKP2           ; SKIP TWO BYTES
9529 : 9e3b             LBC33     ldx  VARDES         ; POINT X TO VARIABLE DE
                        * PACK FPA0 AND MOVE IT TO ADDRESS IN X
952b : 964f             LBC35     lda  FP0EXP         ; * COPY EXPONENT
952d : a784                       sta  ,x             ; *
952f : 9654                       lda  FP0SGN         ; GET MANTISSA SIGN BIT
9531 : 8a7f                       ora  #$7F           ; MASK THE BOTTOM 7 BITS
9533 : 9450                       anda FPA0           ; AND BIT 7 OF MANTISSA 
9535 : a701                       sta  1,x            ; SAVE MS BYTE
9537 : 9651                       lda  FPA0+1         ; * MOVE 2ND MANTISSA BY
AS09 Assembler for M6809 [1.42].                                     Page   86
--------------------------------- merge.a09 ----------------------------------

9539 : a702                       sta  2,x            ; *
953b : de52                       ldu  FPA0+2         ; = MOVE BOTTOM 2 MANTIS
953d : ef03                       stu  3,x            ; =
953f : 39                         rts
                        * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA
9540 : 9661             LBC4A     lda  FP1SGN         ; * COPY MANTISSA SIGN F
9542 : 9754             LBC4C     sta  FP0SGN         ; * FPA1 TO FPA0
9544 : 9e5c                       ldx  FP1EXP         ; = COPY EXPONENT + MS B
9546 : 9f4f                       stx  FP0EXP         ; = FPA1 TO FPA0
9548 : 0f63                       clr  FPSBYT         ; CLEAR MANTISSA SUB BYT
954a : 965e                       lda  FPA1+1         ; * COPY 2ND MANTISSA BY
954c : 9751                       sta  FPA0+1         ; * FROM FPA1 TO FPA0
954e : 9654                       lda  FP0SGN         ; GET MANTISSA SIGN
9550 : 9e5f                       ldx  FPA1+2         ; * COPY 3RD AND 4TH MAN
9552 : 9f52                       stx  FPA0+2         ; * FROM FPA1 TO FPA0
9554 : 39                         rts
                        * TRANSFER FPA0 TO FPA1
9555 : dc4f             LBC5F     ldd  FP0EXP         ; * TRANSFER EXPONENT & 
9557 : dd5c                       std  FP1EXP         ; *
9559 : 9e51                       ldx  FPA0+1         ; = TRANSFER MIDDLE TWO 
955b : 9f5e                       stx  FPA1+1         ; =
955d : 9e53                       ldx  FPA0+3         ; * TRANSFER BOTTOM TWO 
955f : 9f60                       stx  FPA1+3         ; *
9561 : 4d                         tsta                ; SET FLAGS ACCORDING TO
9562 : 39                         rts
                        * CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,
                        * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = PO
9563 : d64f             LBC6D     ldb  FP0EXP         ; GET EXPONENT
9565 : 2708                       beq  LBC79          ; BRANCH IF FPA0 = 0
9567 : d654             LBC71     ldb  FP0SGN         ; GET SIGN OF MANTISSA
9569 : 59               LBC73     rolb                ; BIT 7 TO CARRY
956a : c6ff                       ldb  #$FF           ; NEGATIVE FLAG
956c : 2501                       bcs  LBC79          ; BRANCH IF NEGATIVE MAN
956e : 50                         negb                ; ACCB = 1 IF POSITIVE M
956f : 39               LBC79     rts
                        
                        * SGN
9570 : 8df1             SGN       bsr  LBC6D          ; SET ACCB ACCORDING TO 
                        * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POIN
9572 : d750             LBC7C     stb  FPA0           ; SAVE ACCB IN FPA0
9574 : 0f51                       clr  FPA0+1         ; CLEAR NUMBER 2 MANTISS
9576 : c688                       ldb  #$88           ; EXPONENT REQUIRED IF F
9578 : 9650             LBC82     lda  FPA0           ; GET MS BYTE OF MANTISS
957a : 8080                       suba #$80           ; SET CARRY IF POSITIVE 
957c : d74f             LBC86     stb  FP0EXP         ; SAVE EXPONENT
957e : dc74                       ldd  ZERO           ; * ZERO OUT ACCD AND
9580 : dd52                       std  FPA0+2         ; * BOTTOM HALF OF FPA0
9582 : 9763                       sta  FPSBYT         ; CLEAR SUB BYTE
9584 : 9754                       sta  FP0SGN         ; CLEAR SIGN OF FPA0 MAN
9586 : 7e930e                     jmp  LBA18          ; GO NORMALIZE FPA0
                        
                        * ABS
9589 : 0f54             ABS       clr  FP0SGN         ; FORCE MANTISSA SIGN OF
958b : 39                         rts
                        * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO
                        * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN
                        * ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF
                        * FPA0 > (X); ACCB = $FF IF FPA0 < (X)
958c : e684             LBC96     ldb  ,x             ; CHECK EXPONENT OF (X)
958e : 27d3                       beq  LBC6D          ; BRANCH IF FPA = 0
9590 : e601                       ldb  1,x            ; GET MS BYTE OF MANTISS
9592 : d854                       eorb FP0SGN         ; EOR WITH SIGN OF FPA0
AS09 Assembler for M6809 [1.42].                                     Page   87
--------------------------------- merge.a09 ----------------------------------

9594 : 2bd1                       bmi  LBC71          ; BRANCH IF SIGNS NOT =
                        * COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).
                        * FPA0 IS NORMALIZEd, (X) IS PACKED.
9596 : d64f             LBCA0     ldb  FP0EXP         ; * GET EXPONENT OF
9598 : e184                       cmpb ,x             ; * FPA0, COMPARE TO EXP
959a : 261d                       bne  LBCC3          ; * (X) AND BRANCH IF <>
959c : e601                       ldb  1,x            ; * GET MS BYTE OF (X), 
959e : ca7f                       orb  #$7F           ; * THE SIGN BIT - 'AND'
95a0 : d450                       andb FPA0           ; * BITS OF FPA0 INTO AC
95a2 : e101                       cmpb 1,x            ; = COMPARE THE BOTTOM 7
95a4 : 2613                       bne  LBCC3          ; = MS BYTE AND BRANCH I
95a6 : d651                       ldb  FPA0+1         ; * COMPARE 2ND BYTE
95a8 : e102                       cmpb 2,x            ; * OF MANTISSa,
95aa : 260d                       bne  LBCC3          ; * BRANCH IF <>
95ac : d652                       ldb  FPA0+2         ; = COMPARE 3RD BYTE
95ae : e103                       cmpb 3,x            ; = OF MANTISSa,
95b0 : 2607                       bne  LBCC3          ; = BRANCH IF <>
95b2 : d653                       ldb  FPA0+3         ; * SUBTRACT LS BYTE
95b4 : e004                       subb 4,x            ; * OF (X) FROM LS BYTE 
95b6 : 2601                       bne  LBCC3          ; * FPA0, BRANCH IF <>
95b8 : 39                         rts                 ; RETURN IF FP (X) = FPA
95b9 : 56               LBCC3     rorb                ; SHIFT CARRY TO BIT 7; 
95ba : d854                       eorb FP0SGN         ; TOGGLE SIZE COMPARISON
95bc : 20ab                       bra  LBC73          ; GO SET ACCB ACCORDING 
                        * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BIN
                        * OF THE leasT SIGNIFICANT BYTE OF THE MANTISSA
95be : d64f             LBCC8     ldb  FP0EXP         ; GET EXPONENT OF FPA0
95c0 : 273d                       beq  LBD09          ; ZERO MANTISSA IF FPA0 
95c2 : c0a0                       subb #$A0           ; SUBTRACT $A0 FROM FPA0
                        *                             ; THE NUMBER OF SHIFTS R
                        *                             ; THE EXPONENT OF FPA0 I
                        *                             ; WILL BE TO THE RIGHT O
95c4 : 9654                       lda  FP0SGN         ; TEST SIGN OF FPA0 MANT
95c6 : 2a05                       bpl  LBCD7          ; BRANCH IF POSITIVE
95c8 : 035b                       com  FPCARY         ; COMPLEMENT CARRY IN BY
95ca : bd9371                     jsr  LBA7B          ; NEGATE MANTISSA OF FPA
95cd : 8e004f           LBCD7     ldx  #FP0EXP        ; POINT X TO FPA0
95d0 : c1f8                       cmpb #-8            ; EXPONENT DIFFERENCE < 
95d2 : 2e06                       bgt  LBCE4          ; YES
95d4 : bd93a4                     jsr  LBAAE          ; SHIFT FPA0 RIGHT UNTIL
95d7 : 0f5b                       clr  FPCARY         ; CLEAR CARRY IN BYTE
95d9 : 39                         rts
95da : 0f5b             LBCE4     clr  FPCARY         ; CLEAR CARRY IN BYTE
95dc : 9654                       lda  FP0SGN         ; * GET SIGN OF FPA0 MAN
95de : 49                         rola                ; * ROTATE IT INTO THE C
95df : 0650                       ror  FPA0           ; ROTATE CARRY (MANTISSA
                        *                             ; OF LS BYTE OF MANTISSA
95e1 : 7e93b0                     jmp  LBABA          ; DE-NORMALIZE FPA0
                        
                        * INT
                        * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS 
                        * TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EX
                        * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE F
                        * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUS
                        * ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.
                        *
95e4 : d64f             INT       ldb  FP0EXP         ; GET EXPONENT OF FPA0
95e6 : c1a0                       cmpb #$A0           ; LARGEST POSSIBLE INTEG
95e8 : 241d                       bcc  LBD11          ; RETURN IF FPA0 >= 3276
95ea : 8dd2                       bsr  LBCC8          ; SHIFT THE BINARY POINT
                        *                             ; LS BYTE OF THE FPA0 MA
95ec : d763                       stb  FPSBYT         ; ACCB = 0: ZERO OUT THE
AS09 Assembler for M6809 [1.42].                                     Page   88
--------------------------------- merge.a09 ----------------------------------

95ee : 9654                       lda  FP0SGN         ; GET MANTISSA SIGN
95f0 : d754                       stb  FP0SGN         ; FORCE MANTISSA SIGN TO
95f2 : 8080                       suba #$80           ; SET CARRY IF MANTISSA
95f4 : 86a0                       lda  #$A0           ; * GET DENORMALIZED EXP
95f6 : 974f                       sta  FP0EXP         ; * SAVE IT IN FPA0 EXPO
95f8 : 9653                       lda  FPA0+3         ; = GET LS BYTE OF FPA0 
95fa : 9701                       sta  CHARAC         ; = SAVE IT IN CHARAC
95fc : 7e930e                     jmp  LBA18          ; NORMALIZE FPA0
                        
95ff : d750             LBD09     stb  FPA0           ; * LOAD MANTISSA OF FPA
9601 : d751                       stb  FPA0+1         ; *
9603 : d752                       stb  FPA0+2         ; *
9605 : d753                       stb  FPA0+3         ; *
9607 : 39               LBD11     rts                 ; *
                        
                        * CONVERT ASCII STRING TO FLOATING POINT
9608 : 9e74             LBD12     ldx  ZERO           ; (X) = 0
960a : 9f54                       stx  FP0SGN         ; * ZERO OUT FPA0 & THE 
960c : 9f4f                       stx  FP0EXP         ; *
960e : 9f51                       stx  FPA0+1         ; *
9610 : 9f52                       stx  FPA0+2         ; *
9612 : 9f47                       stx  V47            ; INITIALIZE EXPONENT & 
9614 : 9f45                       stx  V45            ; INITIALIZE RIGHT DECIM
9616 : 2564                       bcs  LBD86          ; IF CARRY SET (NUMERIC 
                        *         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE 
9618 : bd9d41                     jsr  XVEC19         ; CALL EXTENDED BASIC AD
961b : 812d             LBD25     cmpa #'-'           ; * CHECK FOR A LEADING 
961d : 2604                       bne  LBD2D          ; * IF NO MINUS SIGN
961f : 0355                       com  COEFCT         ; TOGGLE SIGN; 0 = +; FF
9621 : 2004                       bra  LBD31          ; INTERPRET THE REST OF 
9623 : 812b             LBD2D     cmpa #'+'           ; * CHECK FOR LEADING PL
9625 : 2604                       bne  LBD35          ; * IF NOT A PLUS SIGN
9627 : 9d7c             LBD31     jsr  GETNCH         ; GET NEXT INPUT CHARACT
9629 : 2551                       bcs  LBD86          ; BRANCH IF NUMERIC CHAR
962b : 812e             LBD35     cmpa #'.'           ; DECIMAL POlNT?
962d : 2728                       beq  LBD61          ; YES
962f : 8145                       cmpa #'E'           ; "E" SHORTHAND FORM (SC
9631 : 2628                       bne  LBD65          ; NO
                        * EVALUATE EXPONENT OF EXPONENTIAL FORMAT
9633 : 9d7c                       jsr  GETNCH         ; GET NEXT INPUT CHARACT
9635 : 2564                       bcs  LBDA5          ; BRANCH IF NUMERIC
9637 : 81b0                       cmpa #TOK_MINUS     ; MINUS TOKEN?
9639 : 270e                       beq  LBD53          ; YES
963b : 812d                       cmpa #'-'           ; ASCII MINUS?
963d : 270a                       beq  LBD53          ; YES
963f : 81af                       cmpa #TOK_PLUS      ; PLUS TOKEN?
9641 : 2708                       beq  LBD55          ; YES
9643 : 812b                       cmpa #'+'           ; ASCII PLUS?
9645 : 2704                       beq  LBD55          ; YES
9647 : 2006                       bra  LBD59          ; BRANCH IF NO SIGN FOUN
9649 : 0348             LBD53     com  V48            ; SET EXPONENT SIGN FLAG
                        * STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT T
964b : 9d7c             LBD55     jsr  GETNCH         ; GET NEXT INPUT CHARACT
964d : 254c                       bcs  LBDA5          ; IF NUMERIC CHARACTER, 
964f : 0d48             LBD59     tst  V48            ; * CHECK EXPONENT SIGN 
9651 : 2708                       beq  LBD65          ; * AND BRANCH IF POSITI
9653 : 0047                       neg  V47            ; NEGATE VALUE OF EXPONE
9655 : 2004                       bra  LBD65
9657 : 0346             LBD61     com  V46            ; *TOGGLE DECIMAL PT FLA
9659 : 26cc                       bne  LBD31          ; *CHARACTER IF <> 0 - T
                        *         IF   SECOND DECIMAL POINT
                        * ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47
AS09 Assembler for M6809 [1.42].                                     Page   89
--------------------------------- merge.a09 ----------------------------------

965b : 9647             LBD65     lda  V47            ; * GET EXPONENT, SUBTRA
965d : 9045                       suba V45            ; * PLACES TO THE RIGHT 
965f : 9747                       sta  V47            ; * AND RESAVE IT.
9661 : 2712                       beq  LBD7F          ; EXIT ROUTINE IF ADJUST
9663 : 2a09                       bpl  LBD78          ; BRANCH IF POSITIVE EXP
9665 : bd9478           LBD6F     jsr  LBB82          ; DIVIDE FPA0 BY 10
9668 : 0c47                       inc  V47            ; INCREMENT EXPONENT COU
966a : 26f9                       bne  LBD6F          ; KEEP MULTIPLYING
966c : 2007                       bra  LBD7F          ; EXIT ROUTINE
966e : bd9460           LBD78     jsr  LBB6A          ; MULTIPLY FPA0 BY 10
9671 : 0a47                       dec  V47            ; DECREMENT EXPONENT COU
9673 : 26f9                       bne  LBD78          ; KEEP MULTIPLYING
9675 : 9655             LBD7F     lda  COEFCT         ; GET THE SIGN FLAG
9677 : 2a8e                       lbpl  LBD11         ; RETURN IF POSITIVE
9679 : 7e97df                     jmp  LBEE9          ; TOGGLE MANTISSA SIGN O
                        *MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT
967c : d645             LBD86     ldb  V45            ; *GET THE RIGHT DECIMAL
967e : d046                       subb V46            ; *THE DECIMAL POINT FLA
9680 : d745                       stb  V45            ; *FLAG=0, NOTHING HAPPE
                        *                             -1, THEN RIGHT DECIMAL C
9682 : 3402                       pshs a              ; SAVE NEW DIGIT ON STAC
9684 : bd9460                     jsr  LBB6A          ; MULTIPLY FPA0 BY 10
9687 : 3504                       puls b              ; GET NEW DIGIT BACK
9689 : c030                       subb #'0'            ; MASK OFF ASCII
968b : 8d02                       bsr  LBD99          ; ADD ACCB TO FPA0
968d : 2098                       bra  LBD31          ; GET ANOTHER CHARACTER 
968f : bd9525           LBD99     jsr  LBC2F          ; PACK FPA0 AND SAVE IT 
9692 : bd9572                     jsr  LBC7C          ; CONVERT ACCB TO FP NUM
9695 : 8e0040                     ldx  #V40           ; * ADD FPA0 TO
9698 : 7e92b8                     jmp  LB9C2          ; * FPA3
                        
                        
969b : d647             LBDA5     ldb  V47
969d : 58                         aslb                ; TIMES 2
969e : 58                         aslb                ; TIMES 4
969f : db47                       addb V47            ; ADD 1 = TIMES 5
96a1 : 58                         aslb                ; TIMES 10
96a2 : 8030                       suba #'0'            ; *MASK OFF ASCII FROM 
96a4 : 3404                       pshs b              ; *RESULT ONTO THE STACK
96a6 : abe0                       adda ,s+            ; ADD lT TO ACCB
96a8 : 9747                       sta  V47            ; SAVE IN V47
96aa : 209f                       bra  LBD55          ; INTERPRET ANOTHER CHAR
                        *
96ac : 9b3ebc1ffd       LBDB6     fcb  $9b,$3E,$BC,$1F,$FD ; * 99999999.9
96b1 : 9e6e6b27fd       LBDBB     fcb  $9E,$6E,$6b,$27,$FD ; * 999999999
96b6 : 9e6e6b2800       LBDC0     fcb  $9E,$6E,$6b,$28,$00 ; * 1E + 09
                        *
96bb : 8e8539           LBDC5     ldx  #LABE8-1       ; POINT X TO " IN " MESS
96be : 8d0c                       bsr  LBDD6          ; COPY A STRING FROM (X)
96c0 : dc68                       ldd  CURLIN         ; GET CURRENT BASIC LINE
                        * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER AND PRIN
96c2 : dd50             LBDCC     std  FPA0           ; SAVE ACCD IN TOP HALF 
96c4 : c690                       ldb  #$90           ; REQ'D EXPONENT IF TOP 
96c6 : 43                         coma                ; SET CARRY FLAG - FORCE
96c7 : bd957c                     jsr  LBC86          ; ZERO BOTTOM HALF AND S
96ca : 8d03                       bsr  LBDD9          ; CONVERT FP NUMBER TO A
96cc : 7e9292           LBDD6     jmp  LB99C          ; COPY A STRING FROM (X)
                        
                        * CONVERT FP NUMBER TO ASCII STRING
96cf : ce01df           LBDD9     ldu  #STRBUF+3      ; POINT U TO BUFFER WHIC
                        *                             ; THE STRING TO BE STORE
96d2 : 8620             LBDDC     lda  #SPACE         ; SPACE = DEFAULT SIGN F
AS09 Assembler for M6809 [1.42].                                     Page   90
--------------------------------- merge.a09 ----------------------------------

96d4 : d654                       ldb  FP0SGN         ; GET SIGN OF FPA0
96d6 : 2a02                       bpl  LBDE4          ; BRANCH IF POSITIVE
96d8 : 862d                       lda  #'-'           ; ASCII MINUS SIGN
96da : a7c0             LBDE4     sta  ,u+            ; STORE SIGN OF NUMBER
96dc : df64                       stu  COEFPT         ; SAVE BUFFER POINTER
96de : 9754                       sta  FP0SGN         ; SAVE SIGN (IN ASCII)
96e0 : 8630                       lda  #'0'            ; ASCII ZERO IF EXPONEN
96e2 : d64f                       ldb  FP0EXP         ; GET FPA0 EXPONENT
96e4 : 102700c6                   lbeq LBEB8          ; BRANCH IF FPA0 = 0
96e8 : 4f                         clra                ; BASE 10 EXPONENT=0 FOR
96e9 : c180                       cmpb #$80           ; CHECK EXPONENT
96eb : 2208                       bhi  LBDFF          ; BRANCH IF FP NUMBER > 
                        * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE 
96ed : 8e96b6                     ldx  #LBDC0         ; POINT X TO FP 1E+09
96f0 : bd93c0                     jsr  LBACA          ; MULTIPLY FPA0 BY (X)
96f3 : 86f7                       lda  #-9            ; BASE 10 EXPONENT = -9
96f5 : 9745             LBDFF     sta  V45            ; BASE 10 EXPONENT
                        * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE R
                        * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST
                        * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE
                        * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING
                        * SCIENTIFIC NOTATION
96f7 : 8e96b1           LBE01     ldx  #LBDBB         ; POINT X TO FP 999,999,
96fa : bd9596                     jsr  LBCA0          ; COMPARE FPA0 TO 999,99
96fd : 2e0f                       bgt  LBE18          ; BRANCH IF > 999,999,99
96ff : 8e96ac           LBE09     ldx  #LBDB6         ; POINT X TO FP 99,999,9
9702 : bd9596                     jsr  LBCA0          ; COMPARE FPA0 TO 99,999
9705 : 2e0e                       bgt  LBE1F          ; BRANCH IF > 99,999,999
9707 : bd9460                     jsr  LBB6A          ; MULTIPLY FPA0 BY 10
970a : 0a45                       dec  V45            ; SUBTRACT ONE FROM DECI
970c : 20f1                       bra  LBE09          ; PSEUDO - NORMALIZE SOM
970e : bd9478           LBE18     jsr  LBB82          ; DIVIDE FPA0 BY 10
9711 : 0c45                       inc  V45            ; ADD ONE TO BASE 10 EXP
9713 : 20e2                       bra  LBE01          ; PSEUDO - NORMALIZE SOM
9715 : bd92aa           LBE1F     jsr  LB9B4          ; ADD .5 TO FPA0 (ROUND 
9718 : bd95be                     jsr  LBCC8          ; CONVERT FPA0 TO AN INT
971b : c601                       ldb  #1             ; DEFAULT DECIMAL POINT 
971d : 9645                       lda  V45            ; * GET BASE 10 EXPONENT
971f : 8b0a                       adda #9+1           ; * (NUMBER 'NORMALIZED'
9721 : 2b09                       bmi  LBE36          ; BRANCH IF NUMBER < 1.0
9723 : 810b                       cmpa #9+2           ; NINE PLACES MAY BE DIS
                        *         USING SCIENTIFIC NOTATION
9725 : 2405                       bcc  LBE36          ; BRANCH IF SCIENTIFIC N
9727 : 4a                         deca                ; * SUBTRACT 1 FROM MODI
9728 : 1f89                       tfr  a,b            ; * AND SAVE IT IN ACCB 
972a : 8602                       lda  #2             ; FORCE EXPONENT = 0 - D
972c : 4a               LBE36     deca                ; * SUBTRACT TWO (WITHOU
972d : 4a                         deca                ; * FROM BASE 10 EXPONEN
972e : 9747                       sta  V47            ; SAVE EXPONENT - ZERO E
                        *         IN   SCIENTIFIC NOTATION
9730 : d745                       stb  V45            ; DECIMAL POINT FLAG - N
                        *         LEFT OF DECIMAL POINT
9732 : 2e0d                       bgt  LBE4B          ; BRANCH IF >= 1
9734 : de64                       ldu  COEFPT         ; POINT U TO THE STRING 
9736 : 862e                       lda  #'.'           ; * STORE A PERIOD
9738 : a7c0                       sta  ,u+            ; * IN THE BUFFER
973a : 5d                         tstb                ; CHECK DECIMAL POINT FL
973b : 2704                       beq  LBE4B          ; BRANCH IF NOTHING TO L
973d : 8630                       lda  #'0'            ; * STORE A ZERO
973f : a7c0                       sta  ,u+            ; * IN THE BUFFER
                        
                        * CONVERT FPA0 INTO A STRING OF ASCII DIGITS
AS09 Assembler for M6809 [1.42].                                     Page   91
--------------------------------- merge.a09 ----------------------------------

9741 : 8e97bb           LBE4B     ldx  #LBEC5         ; POINT X TO FP POWER OF
9744 : c680                       ldb  #0+$80         ; INITIALIZE DIGIT COUNT
                        * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 M
                        * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT 
                        * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF 
                        * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.
9746 : 9653             LBE50     lda  FPA0+3         ; * ADD MANTISSA LS
9748 : ab03                       adda 3,x            ; * BYTE OF FPA0
974a : 9753                       sta  FPA0+3         ; * AND (X)
974c : 9652                       lda  FPA0+2         ; = ADD MANTISSA
974e : a902                       adca 2,x            ; = NUMBER 3 BYTE OF
9750 : 9752                       sta  FPA0+2         ; = FPA0 AND (X)
9752 : 9651                       lda  FPA0+1         ; * ADD MANTISSA
9754 : a901                       adca 1,x            ; * NUMBER 2 BYTE OF
9756 : 9751                       sta  FPA0+1         ; * FPA0 AND (X)
9758 : 9650                       lda  FPA0           ; = ADD MANTISSA
975a : a984                       adca ,x             ; = MS BYTE OF
975c : 9750                       sta  FPA0           ; = FPA0 AND (X)
975e : 5c                         incb                ; ADD ONE TO DIGIT COUNT
975f : 56                         rorb                ; ROTATE CARRY INTO BIT 
9760 : 59                         rolb                ; *SET OVERFLOW FLAG AND
9761 : 28e3                       bvc  LBE50          ; *POSITIVE MANTISSA OR 
9763 : 2403                       bcc  LBE72          ; BRANCH IF NEGATIVE MAN
9765 : c00b                       subb #10+1          ; * TAKE THE 9'S COMPLEM
9767 : 50                         negb                ; * ADDING MANTISSA
9768 : cb2f             LBE72     addb #'0'-1          ; ADD ASCII OFFSET TO D
976a : 3004                       leax 4,x            ; MOVE TO NEXT POWER OF 
976c : 1f98                       tfr  b,a            ; SAVE DIGIT IN ACCA
976e : 847f                       anda #$7F           ; MASK OFF BIT 7 (ADD/SU
9770 : a7c0                       sta  ,u+            ; STORE DIGIT IN STRING 
9772 : 0a45                       dec  V45            ; DECREMENT DECIMAL POIN
9774 : 2604                       bne  LBE84          ; BRANCH IF NOT TIME FOR
9776 : 862e                       lda  #'.'           ; * STORE DECIMAL POINT 
9778 : a7c0                       sta  ,u+            ; * STRING BUFFER
977a : 53               LBE84     comb                ; TOGGLE BIT 7 (ADD/SUBT
977b : c480                       andb #$80           ; MASK OFF ALL BUT ADD/S
977d : 8c97df                     cmpx #LBEC5+36      ; COMPARE X TO END OF MA
9780 : 26c4                       bne  LBE50          ; BRANCH IF NOT AT END O
                        * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY
9782 : a6c2             LBE8C     lda  ,-u            ; GET THE LAST CHARACTER
9784 : 8130                       cmpa #'0'            ; WAS IT A ZERO?
9786 : 27fa                       beq  LBE8C          ; IGNORE TRAILING ZEROS 
9788 : 812e                       cmpa #'.'           ; CHECK FOR DECIMAL POIN
978a : 2602                       bne  LBE98          ; BRANCH IF NOT DECIMAL 
978c : 335f                       leau -1,u           ; STEP OVER THE DECIMAL 
978e : 862b             LBE98     lda  #'+'           ; ASCII PLUS SIGN
9790 : d647                       ldb  V47            ; GET SCIENTIFIC NOTATIO
9792 : 271c                       beq  LBEBA          ; BRANCH IF NOT SCIENTIF
9794 : 2a03                       bpl  LBEA3          ; BRANCH IF POSITIVE EXP
9796 : 862d                       lda  #'-'           ; ASCII MINUS SIGN
9798 : 50                         negb                ; NEGATE EXPONENT IF NEG
9799 : a742             LBEA3     sta  2,u            ; STORE EXPONENT SIGN IN
979b : 8645                       lda  #'E'           ; * GET ASCII 'E' (SCIEN
979d : a741                       sta  1,u            ; * FLAG) AND SAVE IT IN
979f : 862f                       lda  #'0'-1          ; INITIALIZE ACCA TO AS
                        
                        
97a1 : 4c               LBEAB     inca                ; ADD ONE TO 10'S DIGIT 
97a2 : c00a                       subb #10            ; SUBTRACT 10 FROM ACCB
97a4 : 24fb                       bcc  LBEAB          ; ADD 1 TO 10'S DIGIT IF
97a6 : cb3a                       addb #'9'+1         ; CONVERT UNITS DIGIT TO
97a8 : ed43                       std  3,u            ; SAVE EXPONENT IN STRIN
AS09 Assembler for M6809 [1.42].                                     Page   92
--------------------------------- merge.a09 ----------------------------------

97aa : 6f45                       clr  5,u            ; CLEAR LAST BYTE (TERMI
97ac : 2004                       bra  LBEBC          ; GO RESET POINTER
97ae : a7c4             LBEB8     sta  ,u             ; STORE LAST CHARACTER
97b0 : 6f41             LBEBA     clr  1,u            ; CLEAR LAST BYTE (TERMI
                        *         PRINT SUBROUTINES)
97b2 : 8e01df           LBEBC     ldx  #STRBUF+3      ; RESET POINTER TO START
97b5 : 39                         rts
                        *
97b6 : 8000000000       LBEC0     fcb  $80,$00,$00,$00,$00 ; FLOATING POINT .5
                        *
                        *** TABLE OF UNNORMALIZED POWERS OF 10
97bb : fa0a1f00         LBEC5     fcb  $Fa,$0a,$1F,$00 ; -100000000
97bf : 00989680         LBEC9     fcb  $00,$98,$96,$80 ; 10000000
97c3 : fff0bdc0         LBECD     fcb  $FF,$F0,$Bd,$C0 ; -1000000
97c7 : 000186a0         LBED1     fcb  $00,$01,$86,$A0 ; 100000
97cb : ffffd8f0         LBED5     fcb  $FF,$FF,$D8,$F0 ; -10000
97cf : 000003e8         LBED9     fcb  $00,$00,$03,$E8 ; 1000
97d3 : ffffff9c         LBEDD     fcb  $FF,$FF,$FF,$9C ; -100
97d7 : 0000000a         LBEE1     fcb  $00,$00,$00,$0A ; 10
97db : ffffffff         LBEE5     fcb  $FF,$FF,$FF,$FF ; -1
                        *
                        *
97df : 964f             LBEE9     lda  FP0EXP         ; GET EXPONENT OF FPA0
97e1 : 2702                       beq  LBEEF          ; BRANCH IF FPA0 = 0
97e3 : 0354                       com  FP0SGN         ; TOGGLE MANTISSA SIGN O
97e5 : 39               LBEEF     rts
                        * EXPAND A POLYNOMIAL OF THE FORM
                        * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0
                        * AND THE X REGISTER POINTS TO A TABLE OF
                        * COEFFICIENTS A,B,C,D....
97e6 : 9f64             LBEF0     stx  COEFPT         ; SAVE COEFFICIENT TABLE
97e8 : bd9525                     jsr  LBC2F          ; MOVE FPA0 TO FPA3
97eb : 8d05                       bsr  LBEFC          ; MULTIPLY FPA3 BY FPA0
97ed : 8d08                       bsr  LBF01          ; EXPAND POLYNOMIAL
97ef : 8e0040                     ldx  #V40           ; POINT X TO FPA3
97f2 : 7e93c0           LBEFC     jmp  LBACA          ; MULTIPLY (X) BY FPA0
                        
                        * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
                        * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
                        * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
                        * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
                        * OF PACKED FLOATING POINT NUMBERS. THE
                        * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
                        * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0...YN)
97f5 : 9f64             LBEFF     stx  COEFPT         ; SAVE COEFFICIENT TABLE
97f7 : bd9520           LBF01     jsr  LBC2A          ; MOVE FPA0 TO FPA4
97fa : 9e64                       ldx  COEFPT         ; GET THE COEFFICIENT PO
97fc : e680                       ldb  ,x+            ; GET THE TOP OF COEFFIC
97fe : d755                       stb  COEFCT         ; * USE AND STORE IT IN 
9800 : 9f64                       stx  COEFPT         ; SAVE NEW COEFFICIENT P
9802 : 8dee             LBF0C     bsr  LBEFC          ; MULTIPLY (X) BY FPA0
9804 : 9e64                       ldx  COEFPT         ; *GET COEFFICIENT POINT
9806 : 3005                       leax 5,x            ; *MOVE TO NEXT FP NUMBE
9808 : 9f64                       stx  COEFPT         ; *SAVE NEW COEFFICIENT 
980a : bd92b8                     jsr  LB9C2          ; ADD (X) AND FPA0
980d : 8e0045                     ldx  #V45           ; POINT (X) TO FPA4
9810 : 0a55                       dec  COEFCT         ; DECREMENT TEMP COUNTER
9812 : 26ee                       bne  LBF0C          ; BRANCH IF MORE COEFFIC
9814 : 39                         rts
                        
                        * RND
9815 : bd9563           RND       jsr  LBC6D          ; TEST FPA0
AS09 Assembler for M6809 [1.42].                                     Page   93
--------------------------------- merge.a09 ----------------------------------

9818 : 2b1f                       bmi  LBF45          ; BRANCH IF FPA0 = NEGAT
981a : 2715                       beq  LBF3B          ; BRANCH IF FPA0 = 0
981c : 8d10                       bsr  LBF38          ; CONVERT FPA0 TO AN INT
981e : bd9525                     jsr  LBC2F          ; PACK FPA0 TO FPA3
9821 : 8d0e                       bsr  LBF3B          ; GET A RANDOM NUMBER: F
9823 : 8e0040                     ldx  #V40           ; POINT (X) TO FPA3
9826 : 8dca                       bsr  LBEFC          ; MULTIPLY (X) BY FPA0
9828 : 8e93bb                     ldx  #LBAC5         ; POINT (X) TO FP VALUE 
982b : bd92b8                     jsr  LB9C2          ; ADD 1.0 TO FPA0
982e : 7e95e4           LBF38     jmp  INT            ; CONVERT FPA0 TO AN INT
                        * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.
9831 : 9e9f             LBF3B     ldx  RVSEED+1       ; * MOVE VARIABLE
9833 : 9f50                       stx  FPA0           ; * RANDOM NUMBER
9835 : 9ea1                       ldx  RVSEED+3       ; * SEED TO
9837 : 9f52                       stx  FPA0+2         ; * FPA0
9839 : be9866           LBF45     ldx  RSEED          ; = MOVE FIXED
983c : 9f5d                       stx  FPA1           ; = RANDOM NUMBER
983e : be9868                     ldx  RSEED+2        ; = SEED TO
9841 : 9f5f                       stx  FPA1+2         ; = MANTISSA OF FPA0
9843 : bd93c6                     jsr  LBAD0          ; MULTIPLY FPA0 X FPA1
9846 : dc8a                       ldd  VAD            ; GET THE TWO LOWEST ORD
9848 : c3658b                     addd #$658B         ; ADD A CONSTANT
984b : dda1                       std  RVSEED+3       ; SAVE NEW LOW ORDER VAR
984d : dd52                       std  FPA0+2         ; SAVE NEW LOW ORDER BYT
984f : dc88                       ldd  VAB            ; GET 2 MORE LOW ORDER P
9851 : c9b0                       adcb #$B0           ; ADD A CONSTANT
9853 : 8905                       adca #5             ; ADD A CONSTANT
9855 : dd9f                       std  RVSEED+1       ; SAVE NEW HIGH ORDER VA
9857 : dd50                       std  FPA0           ; SAVE NEW HIGH ORDER FP
9859 : 0f54                       clr  FP0SGN         ; FORCE FPA0 MANTISSA = 
985b : 8680                       lda  #$80           ; * SET FPA0 BIASED EXPO
985d : 974f                       sta  FP0EXP         ; * TO 0 1 < FPA0 < 0
985f : 9615                       lda  FPA2+2         ; GET A BYTE FROM FPA2 (
9861 : 9763                       sta  FPSBYT         ; SAVE AS SUB BYTE
9863 : 7e9312                     jmp  LBA1C          ; NORMALIZE FPA0
                        *
9866 : 40e6             RSEED     fdb  $40E6          ; *CONSTANT RANDOM NUMBE
9868 : 4dab                       fdb  $4DAB          ; *
                        
                        * SIN
                        * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND
                        * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ON
                        * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, TH
                        * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.
                        
                        * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES 
                        * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)
986a : bd9555           SIN       jsr  LBC5F          ; COPY FPA0 TO FPA1
986d : 8e98af                     ldx  #LBFBD         ; POINT (X) TO 2*PI
9870 : d661                       ldb  FP1SGN         ; *GET MANTISSA SIGN OF 
9872 : bd947f                     jsr  LBB89          ; *AND DIVIDE FPA0 BY 2*
9875 : bd9555                     jsr  LBC5F          ; COPY FPA0 TO FPA1
9878 : 8db4                       bsr  LBF38          ; CONVERT FPA0 TO AN INT
987a : 0f62                       clr  RESSGN         ; SET RESULT SIGN = POSI
987c : 965c                       lda  FP1EXP         ; *GET EXPONENT OF FPA1
987e : d64f                       ldb  FP0EXP         ; *GET EXPONENT OF FPA0
9880 : bd92b2                     jsr  LB9BC          ; *SUBTRACT FPA0 FROM FP
                        * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUME
9883 : 8e98b4                     ldx  #LBFC2         ; POINT X TO FP (.25)
9886 : bd92af                     jsr  LB9B9          ; SUBTRACT FPA0 FROM .25
9889 : 9654                       lda  FP0SGN         ; GET MANTISSA SIGN OF F
988b : 3402                       pshs a              ; SAVE IT ON STACK
AS09 Assembler for M6809 [1.42].                                     Page   94
--------------------------------- merge.a09 ----------------------------------

988d : 2a09                       bpl  LBFA6          ; BRANCH IF MANTISSA POS
988f : bd92aa                     jsr  LB9B4          ; ADD .5 (PI) TO FPA0
9892 : 9654                       lda  FP0SGN         ; GET SIGN OF FPA0
9894 : 2b05                       bmi  LBFA9          ; BRANCH IF NEGATIVE
9896 : 030a                       com  RELFLG         ; com IF +(3*PI)/2 >= AR
9898 : bd97df           LBFA6     jsr  LBEE9          ; TOGGLE MANTISSA SIGN O
989b : 8e98b4           LBFA9     ldx  #LBFC2         ; POINT X TO FP (.25)
989e : bd92b8                     jsr  LB9C2          ; ADD .25 (PI/2) TO FPA0
98a1 : 3502                       puls a              ; GET OLD MANTISSA SIGN
98a3 : 4d                         tsta                ; * BRANCH IF OLD
98a4 : 2a03                       bpl  LBFB7          ; * SIGN WAS POSITIVE
98a6 : bd97df                     jsr  LBEE9          ; TOGGLE MANTISSA SIGN
98a9 : 8e98b9           LBFB7     ldx  #LBFC7         ; POINT X TO TABLE OF CO
98ac : 7e97e6                     jmp  LBEF0          ; GO CALCULATE POLYNOMIA
                        
98af : 83490fdaa2       LBFBD     fcb  $83,$49,$0F,$Da,$A2 ; 6.28318531 (2*PI)
98b4 : 7f00000000       LBFC2     fcb  $7F,$00,$00,$00,$00 ; .25
                        
                        
98b9 : 05               LBFC7     fcb  6-1            ; SIX COEFFICIENTS
98ba : 84e61a2d1b       LBFC8     fcb  $84,$E6,$1a,$2d,$1B ; * -((2*PI)**11)/1
98bf : 862807fbf8       LBFCD     fcb  $86,$28,$07,$Fb,$F8 ; * ((2*PI)**9)/9!
98c4 : 8799688901       LBFD2     fcb  $87,$99,$68,$89,$01 ; * -((2*PI)**7)/7!
98c9 : 872335dfe1       LBFD7     fcb  $87,$23,$35,$DF,$E1 ; * ((2*PI)**5)/5!
98ce : 86a55de728       LBFDC     fcb  $86,$A5,$5d,$E7,$28 ; * -((2*PI)**3)/3!
98d3 : 83490fdaa2       LBFE1     fcb  $83,$49,$0F,$Da,$A2 ; *
                        
98d8 : a154468f13                 fcb  $A1,$54,$46,$8F,$13 ; UNUSED GARBAGE BY
98dd : 8f524389cd                 fcb  $8F,$52,$43,$89,$CD ; UNUSED GARBAGE BY
                        * EXTENDED BASIC
                        
                        * COS
                        * THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTI
98e2 : 8e9913           COS       ldx  #L83AB         ; POINT X TO FP CONSTANT
98e5 : bd92b8                     jsr  LB9C2          ; ADD FPA0 TO (X)
98e8 : 2080             L837E     jmp  SIN            ; JUMP TO SIN ROUTINE
                        
                        * TAN
                        * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTI
98ea : bd9525           TAN       jsr  LBC2F          ; PACK FPA0 AND MOVE IT 
98ed : 0f0a                       clr  RELFLG         ; RESET QUADRANT FLAG
98ef : 8df7                       bsr  L837E          ; CALCULATE SIN OF ARGUM
98f1 : 8e004a                     ldx  #V4A           ; POINT X TO FPA5
98f4 : bd952b                     jsr  LBC35          ; PACK FPA0 AND MOVE IT 
98f7 : 8e0040                     ldx  #V40           ; POINT X TO FPA3
98fa : bd950a                     jsr  LBC14          ; MOVE FPA3 TO FPA0
98fd : 0f54                       clr  FP0SGN         ; FORCE FPA0 MANTISSA TO
98ff : 960a                       lda  RELFLG         ; GET THE QUADRANT FLAG 
9901 : 8d0c                       bsr  L83A6          ; CALCULATE VALUE OF COS
9903 : 0d4f                       tst  FP0EXP         ; CHECK EXPONENT OF FPA0
9905 : 1027fa7f                   beq  LBA92          ; 'OV' ERROR IF COS(X)=0
9909 : 8e004a                     ldx  #V4A           ; POINT X TO FPA5
990c : 7e9485           L83A3     jmp  LBB8F          ; DIVIDE (X) BY FPA0 - S
990f : 3402             L83A6     pshs a              ; SAVE SIGN FLAG ON STAC
9911 : 2085                       jmp  LBFA6          ; EXPAND POLYNOMIAL
                        
9913 : 81490fdaa2       L83AB     fcb  $81,$49,$0F,$Da,$A2 ; 1.57079633 (PI/2)
                        
                        * ATN
                        * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE
                        * ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED
                        * TO EVALUATE THE EXPRESSION DEPENDING UPON
AS09 Assembler for M6809 [1.42].                                     Page   95
--------------------------------- merge.a09 ----------------------------------

                        * WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0
                        
                        * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .
                        * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5
                        
9918 : 9654             ATN       lda  FP0SGN         ; * GET THE SIGN OF THE 
991a : 3402                       pshs a              ; * SAVE IT ON THE STACK
991c : 2a02                       bpl  L83B8          ; BRANCH IF POSITIVE MAN
991e : 8d24                       bsr  L83DC          ; CHANGE SIGN OF FPA0
9920 : 964f             L83B8     lda  FP0EXP         ; * GET EXPONENT OF FPA0
9922 : 3402                       pshs a              ; * SAVE IT ON THE STACK
9924 : 8181                       cmpa #$81           ; IS FPAO < 1.0?
9926 : 2505                       blo  L83C5          ; YES
9928 : 8e93bb                     ldx  #LBAC5         ; POINT X TO FP CONSTANT
992b : 8ddf                       bsr  L83A3          ; GET RECIPROCAL OF FPA0
992d : 8e9948           L83C5     ldx  #L83E0         ; POINT (X) TO TAYLOR SE
9930 : bd97e6                     jsr  LBEF0          ; EXPAND POLYNOMIAL
9933 : 3502                       puls a              ; GET EXPONENT OF ARGUME
9935 : 8181                       cmpa #$81           ; WAS ARGUMENT < 1.0?
9937 : 2506                       blo  L83D7          ; YES
9939 : 8e9913                     ldx  #L83AB         ; POINT (X) TO FP NUMBER
993c : bd92af                     jsr  LB9B9          ; SUBTRACT FPA0 FROM (PI
993f : 3502             L83D7     puls a              ; * GET SIGN OF INITIAL 
9941 : 4d                         tsta                ; * AND SET FLAGS ACCORD
9942 : 2a03                       bpl  L83DF          ; RETURN IF ARGUMENT WAS
9944 : 7e97df           L83DC     jmp  LBEE9          ; CHANGE MANTISSA SIGN O
9947 : 39               L83DF     rts
                        *
                        * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR A
9948 : 0b               L83E0     fcb  $0B            ; TWELVE COEFFICIENTS
9949 : 76b383bdd3       L83E1     fcb  $76,$B3,$83,$Bd,$D3 ; -6.84793912E-04 1
994e : 791ef4a6f5       L83E6     fcb  $79,$1E,$F4,$A6,$F5 ; +4.85094216E-03 1
9953 : 7b83fcb010       L83EB     fcb  $7b,$83,$FC,$B0,$10 ; -0.0161117018
9958 : 7c0c1f67ca       L83F0     fcb  $7C,$0C,$1F,$67,$CA ; 0.0342096381
995d : 7cde53cbc1       L83F5     fcb  $7C,$DE,$53,$Cb,$C1 ; -0.0542791328
9962 : 7d1464704c       L83FA     fcb  $7d,$14,$64,$70,$4C ; 0.0724571965
9967 : 7db7ea517a       L83FF     fcb  $7d,$B7,$Ea,$51,$7A ; -0.0898023954
996c : 7d6330887e       L8404     fcb  $7d,$63,$30,$88,$7E ; 0.110932413
9971 : 7e9244993a       L8409     fcb  $7E,$92,$44,$99,$3A ; -0.142839808
9976 : 7e4ccc91c7       L840E     fcb  $7E,$4C,$CC,$91,$C7 ; 0.199999121
997b : 7faaaaaa13       L8413     fcb  $7F,$Aa,$Aa,$Aa,$13 ; -0.333333316
9980 : 8100000000       L8418     fcb  $81,$00,$00,$00,$00 ; 1
                        *
                        *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR
                        *
9985 : 03               L841D     fcb  3              ; FOUR COEFFICIENTS
9986 : 7f5e56cb79       L841E     fcb  $7F,$5E,$56,$Cb,$79 ; 0.434255942
998b : 80139b0b64       L8423     fcb  $80,$13,$9b,$0b,$64 ; 0.576584541
9990 : 8076389316       L8428     fcb  $80,$76,$38,$93,$16 ; 0.961800759
9995 : 8238aa3b20       L842D     fcb  $82,$38,$Aa,$3b,$20 ; 2.88539007
                        
999a : 803504f334       L8432     fcb  $80,$35,$04,$F3,$34 ; 1/SQR(2)
                        
999f : 813504f334       L8437     fcb  $81,$35,$04,$F3,$34 ; SQR(2)
                        
99a4 : 8080000000       L843C     fcb  $80,$80,$00,$00,$00 ; -0.5
                        
99a9 : 80317217f8       L8441     fcb  $80,$31,$72,$17,$F8 ; LN(2)
                        *
                        * LOG - NATURAL LOGARITHM (LN)
                        
                        * THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USIN
AS09 Assembler for M6809 [1.42].                                     Page   96
--------------------------------- merge.a09 ----------------------------------

                        * MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*
                        * NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE
                        * LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WI
                        * TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)
                        * THE TERMS OF THE LATTER EXPRESSION ARE CONstaNTS EXC
                        * LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLO
99ae : bd9563           LOG       jsr  LBC6D          ; CHECK STATUS OF FPA0
99b1 : 102ff3b1                   ble  LB44A          ; 'FC' ERROR IF NEGATIVE
99b5 : 8e999a                     ldx  #L8432         ; POINT (X) TO FP NUMBER
99b8 : 964f                       lda  FP0EXP         ; *GET EXPONENT OF ARGUM
99ba : 8080                       suba #$80           ; *SUBTRACT OFF THE BIAS
99bc : 3402                       pshs a              ; *SAVE IT ON THE STACK
99be : 8680                       lda  #$80
99c0 : 974f                       sta  FP0EXP
99c2 : bd92b8                     jsr  LB9C2          ; ADD FPA0 TO (X)
99c5 : 8e999f                     ldx  #L8437         ; POINT X TO SQR(2)
99c8 : bd9485                     jsr  LBB8F          ; DIVIDE SQR(2) BY FPA0
99cb : 8e93bb                     ldx  #LBAC5         ; POINT X TO FP VALUE OF
99ce : bd92af                     jsr  LB9B9          ; SUBTRACT FPA0 FROM (X)
                        *         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE 
99d1 : 8e9985                     ldx  #L841D         ; POINT X TO TABLE OF CO
99d4 : bd97e6                     jsr  LBEF0          ; EXPAND POLYNOMIAL
99d7 : 8e99a4                     ldx  #L843C         ; POINT X TO FP VALUE OF
99da : bd92b8                     jsr  LB9C2          ; ADD FPA0 TO X
99dd : 3504                       puls b              ; GET EXPONENT OF ARGUME
99df : bd968f                     jsr  LBD99          ; ADD ACCB TO FPA0
99e2 : 8e99a9                     ldx  #L8441         ; POINT X TO LN(2)
99e5 : 7e93c0                     jmp  LBACA          ; MULTIPLY FPA0 * LN(2)
                        
                        * SQR
99e8 : bd9555           SQR       jsr  LBC5F          ; MOVE FPA0 TO FPA1
99eb : 8e97b6                     ldx  #LBEC0         ; POINT (X) TO FP NUMBER
99ee : bd950a                     jsr  LBC14          ; COPY A PACKED NUMBER F
                        
                        * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS
                        * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION
                        * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.718281
99f1 : 2766             L8489     beq  EXP            ; DO A NATURAL EXPONENTI
99f3 : 4d                         tsta                ; *CHECK VALUE BEING EXP
99f4 : 2603                       bne  L8491          ; *AND BRANCH IF IT IS <
99f6 : 7e9330                     jmp  LBA3A          ; FPA0=0 IF RAISING ZERO
99f9 : 8e004a           L8491     ldx  #V4A           ; * PACK FPA0 AND SAVE
99fc : bd952b                     jsr  LBC35          ; * IT IN FPA5 (ARGUMENT
99ff : 5f                         clrb                ; ACCB=DEFAULT RESULT SI
9a00 : 9661                       lda  FP1SGN         ; *CHECK THE SIGN OF ARG
9a02 : 2a10                       bpl  L84AC          ; *BRANCH IF POSITIVE
9a04 : bd95e4                     jsr  INT            ; CONVERT EXPONENT INTO 
9a07 : 8e004a                     ldx  #V4A           ; POINT X TO FPA5 (ORIGI
9a0a : 9661                       lda  FP1SGN         ; GET MANTISSA SIGN OF F
9a0c : bd9596                     jsr  LBCA0          ; *COMPARE FPA0 TO (X) A
9a0f : 2603                       bne  L84AC          ; *BRANCH IF NOT EQUAL
9a11 : 43                         coma                ; TOGGLE FPA1 MANTISSA S
9a12 : d601                       ldb  CHARAC         ; GET LS BYTE OF INTEGER
9a14 : bd9542           L84AC     jsr  LBC4C          ; COPY FPA1 TO FPA0; ACC
9a17 : 3404                       pshs b              ; PUT RESULT SIGN FLAG O
9a19 : 8d93                       jsr  LOG
9a1b : 8e004a                     ldx  #V4A           ; POINT (X) TO FPA5
9a1e : bd93c0                     jsr  LBACA          ; MULTIPLY FPA0 BY FPA5
9a21 : 8d36                       bsr  EXP            ; CALCULATE E**(FPA0)
9a23 : 3502                       puls a              ; * GET RESULT SIGN FLAG
9a25 : 46                         rora                ; * AND BRANCH IF NEGATI
9a26 : 1025fdb5                   bcs  LBEE9          ; CHANGE SIGN OF FPA0 MA
AS09 Assembler for M6809 [1.42].                                     Page   97
--------------------------------- merge.a09 ----------------------------------

9a2a : 39                         rts
                        
                        * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION
9a2b : 8138aa3b29       L84C4     fcb  $81,$38,$Aa,$3b,$29 ; 1.44269504 ( CF )
                        *
                        * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E
                        *
9a30 : 07               L84C9     fcb  7              ; EIGHT COEFFICIENTS
9a31 : 7134583e56       L84CA     fcb  $71,$34,$58,$3E,$56 ; 2.14987637E-05: 1
9a36 : 74167eb31b       L84CF     fcb  $74,$16,$7E,$B3,$1B ; 1.4352314E-04 : 1
9a3b : 772feee385       L84D4     fcb  $77,$2F,$EE,$E3,$85 ; 1.34226348E-03: 1
9a40 : 7a1d841c2a       L84D9     fcb  $7A,$1D,$84,$1C,$2A ; 9.61401701E-03: 1
9a45 : 7c6359580a       L84DE     fcb  $7C,$63,$59,$58,$0A ; 0.0555051269
9a4a : 7e75fde7c6       L84E3     fcb  $7E,$75,$FD,$E7,$C6 ; 0.240226385
9a4f : 8031721810       L84E8     fcb  $80,$31,$72,$18,$10 ; 0.693147186
9a54 : 8100000000       L84ED     fcb  $81,$00,$00,$00,$00 ; 1
                        *
                        * EXP ( E**X)
                        * THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTI
                        * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS 
                        * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFL
                        * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A 
                        * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED T
                        * THE CF MULTIPLICATION AT THE START OF THE EVALUATION
                        
9a59 : 8e9a2b           EXP       ldx  #L84C4         ; POINT X TO THE CORRECT
9a5c : bd93c0                     jsr  LBACA          ; MULTIPLY FPA0 BY (X)
9a5f : bd9525                     jsr  LBC2F          ; PACK FPA0 AND STORE IT
9a62 : 964f                       lda  FP0EXP         ; *GET EXPONENT OF FPA0 
9a64 : 8188                       cmpa #$88           ; *COMPARE TO THE MAXIMU
9a66 : 2503                       blo  L8504          ; BRANCH IF FPA0 < 128
9a68 : 7e9452           L8501     jmp  LBB5C          ; SET FPA0 = 0 OR 'OV' E
9a6b : bd95e4           L8504     jsr  INT            ; CONVERT FPA0 TO INTEGE
9a6e : 9601                       lda  CHARAC         ; GET LS BYTE OF INTEGER
9a70 : 8b81                       adda #$81           ; * WAS THE ARGUMENT =12
9a72 : 27f4                       beq  L8501          ; * THEN 'OV' ERROR; THI
                        *              ; * REQUIRED WHEN THE NEW EXPONENT IS C
9a74 : 4a                         deca                ; DECREMENT ONE FROM THE
9a75 : 3402                       pshs a              ; SAVE EXPONENT OF INTEG
9a77 : 8e0040                     ldx  #V40           ; POINT (X) TO FPA3
9a7a : bd92af                     jsr  LB9B9          ; SUBTRACT FPA0 FROM (X)
9a7d : 8e9a30                     ldx  #L84C9         ; POINT X TO COEFFICIENT
9a80 : bd97f5                     jsr  LBEFF          ; EVALUATE POLYNOMIAL FO
9a83 : 0f62                       clr  RESSGN         ; FORCE THE MANTISSA TO 
9a85 : 3502                       puls a              ; GET INTEGER EXPONENT F
9a87 : bd943e                     jsr  LBB48          ; * CALCULATE EXPONENT O
                        *              ; * INTEGER AND FRACTIONAL PARTS
9a8a : 39                         rts
                        
                        * FIX
9a8b : bd9563           FIX       jsr  LBC6D          ; CHECK STATUS OF FPA0
9a8e : 2b03                       bmi  L852C          ; BRANCH IF FPA0 = NEGAT
9a90 : 7e95e4           L8529     jmp  INT            ; CONVERT FPA0 TO INTEGE
9a93 : 0354             L852C     com  FP0SGN         ; TOGGLE SIGN OF FPA0 MA
9a95 : 8df9                       bsr  L8529          ; CONVERT FPA0 TO INTEGE
9a97 : 7e97df                     jmp  LBEE9          ; TOGGLE SIGN OF FPA0
                        
                        * EDIT
9a9a : bd9ec5           EDIT      jsr  L89AE          ; GET LINE NUMBER FROM B
9a9d : 3262                       leas $02,s          ; PURGE RETURN ADDRESS O
9a9f : 8601             L8538     lda  #$01           ; 'LIST' FLAG
9aa1 : 9798                       sta  VD8            ; SET FLAG TO LIST LINE
AS09 Assembler for M6809 [1.42].                                     Page   98
--------------------------------- merge.a09 ----------------------------------

9aa3 : bd863d                     jsr  LAD01          ; GO FIND THE LINE NUMBE
9aa6 : 1025ed6e                   bcs  LAED2          ; ERROR #7 'UNDEFINED LI
9aaa : bd90d5                     jsr  LB7C2          ; GO UNCRUNCH LINE INTO 
9aad : 1f20                       tfr  y,d            ; PUT ABSOLUTE ADDRESS O
9aaf : 8300e3                     subd #LINBUF+2      ; SUBTRACT OUT THE START
9ab2 : d797                       stb  VD7            ; SAVE LENGTH OF LINE
9ab4 : dc2b             L854D     ldd  BINVAL         ; GET THE HEX VALUE OF L
9ab6 : bd96c2                     jsr  LBDCC          ; LIST THE LINE NUMBER O
9ab9 : bd92a2                     jsr  LB9AC          ; PRINT A SPACE
9abc : 8e00e2                     ldx  #LINBUF+1      ; POINT X TO BUFFER
9abf : d698                       ldb  VD8            ; * CHECK TO SEE IF LINE
9ac1 : 2625                       bne  L8581          ; * LISTED TO SCREEN - B
9ac3 : 5f               L855C     clrb                ; RESET DIGIT ACCUMULATO
9ac4 : bd9bee           L855D     jsr  L8687          ; GET KEY STROKE
9ac7 : bda390                     jsr  L90AA          ; SET CARRY IF NOT NUMER
9aca : 250b                       blo  L8570          ; BRANCH IF NOT NUMERIC
9acc : 8030                       suba #'0'            ; MASK OFF ASCII
9ace : 3402                       pshs a              ; SAVE IT ON STACK
9ad0 : 860a                       lda  #10            ; NUMBER BEING CONVERTED
9ad2 : 3d                         mul                 ; MULTIPLY ACCUMULATED V
9ad3 : ebe0                       addb ,s+            ; ADD DIGIT TO ACCUMULAT
9ad5 : 20ed                       bra  L855D          ; CHECK FOR ANOTHER DIGI
9ad7 : c001             L8570     subb #$01           ; * REPEAT PARAMETER IN 
9ad9 : c901                       adcb #$01           ; *IS 0, THEN MAKE IT '1
9adb : 8141                       cmpa #'A'           ; ABORT?
9add : 2605                       bne  L857D          ; NO
9adf : bd9253                     jsr  LB958          ; PRINT CARRIAGE RETURN 
9ae2 : 20bb                       bra  L8538          ; RESTART EDIT PROCESS -
9ae4 : 814c             L857D     cmpa #'L'           ; LIST?
9ae6 : 260b                       bne  L858C          ; NO
9ae8 : 8d31             L8581     bsr  L85B4          ; LIST THE LINE
9aea : 0f98                       clr  VD8            ; RESET THE LIST FLAG TO
9aec : bd9253                     jsr  LB958          ; PRINT CARRIAGE RETURN
9aef : 20c3                       bra  L854D          ; GO INTERPRET ANOTHER E
9af1 : 3262             L858A     leas $02,s          ; PURGE RETURN ADDRESS O
9af3 : 810d             L858C     cmpa #CR            ; ENTER KEY?
9af5 : 260d                       bne  L859D          ; NO
9af7 : 8d22                       bsr  L85B4          ; ECHO THE LINE TO THE S
9af9 : bd9253           L8592     jsr  LB958          ; PRINT CARRIAGE RETURN
9afc : 8e00e2                     ldx  #LINBUF+1      ; * RESET BASIC'S INPUT 
9aff : 9f83                       stx  CHARAD         ; * TO THE LINE INPUT BU
9b01 : 7e85e6                     jmp  LACA8          ; GO PUT LINE BACK IN PR
9b04 : 8145             L859D     cmpa #'E'           ; EXIT?
9b06 : 27f1                       beq  L8592          ; YES - SAME AS ENTER EX
9b08 : 8151                       cmpa #'Q'           ; QUIT?
9b0a : 2606                       bne  L85AB          ; NO
9b0c : bd9253                     jsr  LB958          ; PRINT CARRIAGE RETURN 
9b0f : 7e85b7                     jmp  LAC73          ; GO TO COMMAND LEVEL - 
9b12 : 8d02             L85AB     bsr  L85AF          ; INTERPRET THE REMAININ
9b14 : 20ad                       bra  L855C          ; GO INTERPRET ANOTHER E
9b16 : 8120             L85AF     cmpa #SPACE         ; SPACE BAR?
9b18 : 2610                       bne  L85C3          ; NO
9b1a : 8c               L85B3     fcb  SKP2           ; SKIP TWO BYTES
                        * DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFE
                        *
9b1b : c6f9             L85B4     ldb  #LBUFMX-1      ; 250 BYTES MAX IN BUFFE
9b1d : a684             L85B6     lda  ,x             ; GET A CHARACTER FROM B
9b1f : 2708                       beq  L85C2          ; EXIT IF IT'S A 0
9b21 : bd805c                     jsr  PUTCHR         ; SEND CHAR TO CONSOLE O
9b24 : 3001                       leax $01,x          ; MOVE POINTER UP ONE
9b26 : 5a                         decb                ; DECREMENT CHARACTER CO
9b27 : 26f4                       bne  L85B6          ; LOOP IF NOT DONE
AS09 Assembler for M6809 [1.42].                                     Page   99
--------------------------------- merge.a09 ----------------------------------

9b29 : 39               L85C2     rts
9b2a : 8144             L85C3     cmpa #'D'           ; DELETE?
9b2c : 2648                       bne  L860F          ; NO
9b2e : 6d84             L85C7     tst  ,x             ; * CHECK FOR END OF LIN
9b30 : 27f7                       beq  L85C2          ; * AND BRANCH IF SO
9b32 : 8d04                       bsr  L85D1          ; REMOVE A CHARACTER
9b34 : 5a                         decb                ; DECREMENT REPEAT PARAM
9b35 : 26f7                       bne  L85C7          ; BRANCH IF NOT DONE
9b37 : 39                         rts
                        * REMOVE ONE CHARACTER FROM BUFFER
9b38 : 0a97             L85D1     dec  VD7            ; DECREMENT LENGTH OF BU
9b3a : 311f                       leay -1,x           ; POINT Y TO ONE BEFORE 
9b3c : 3121             L85D5     leay $01,y          ; INCREMENT TEMPORARY BU
9b3e : a621                       lda  $01,y          ; GET NEXT CHARACTER
9b40 : a7a4                       sta  ,y             ; PUT IT IN CURRENT POSI
9b42 : 26f8                       bne  L85D5          ; BRANCH IF NOT END OF L
9b44 : 39                         rts
9b45 : 8149             L85DE     cmpa #'I'           ;  INSERT?
9b47 : 2713                       beq  L85F5          ; YES
9b49 : 8158                       cmpa #'X'           ; EXTEND?
9b4b : 270d                       beq  L85F3          ; YES
9b4d : 8148                       cmpa #'H'           ; HACK?
9b4f : 265c                       bne  L8646          ; NO
9b51 : 6f84                       clr  ,x             ; TURN CURRENT BUFFER PO
9b53 : 1f10                       tfr  x,d            ; PUT CURRENT BUFFER POI
9b55 : 8300e3                     subd #LINBUF+2      ; SUBTRACT INITIAL POINT
9b58 : d797                       stb  VD7            ; SAVE NEW BUFFER LENGTH
9b5a : 8dbf             L85F3     bsr  L85B4          ; DISPLAY THE LINE ON TH
9b5c : bd9bee           L85F5     jsr  L8687          ; GET A KEYSTROKE
9b5f : 810d                       cmpa #CR            ; ENTER KEY?
9b61 : 278e                       beq  L858A          ; YES - INTERPRET ANOTHE
9b63 : 811b                       cmpa #ESC           ; ESCAPE?
9b65 : 2725                       beq  L8625          ; YES - RETURN TO COMMAN
9b67 : 8108                       cmpa #BS            ; BACK SPACE?
9b69 : 2622                       bne  L8626          ; NO
9b6b : 8c00e2                     cmpx #LINBUF+1      ; COMPARE POINTER TO STA
9b6e : 27ec                       beq  L85F5          ; DO NOT ALLOW BS IF AT 
9b70 : 8d45                       bsr  L8650          ; MOVE POINTER BACK ONE,
9b72 : 8dc4                       bsr  L85D1          ; REMOVE ONE CHARACTER F
9b74 : 20e6                       bra  L85F5          ; GET INSERT SUB COMMAND
9b76 : 8143             L860F     cmpa #'C'           ; CHANGE?
9b78 : 26cb                       bne  L85DE          ; NO
9b7a : 6d84             L8613     tst  ,x             ; CHECK CURRENT BUFFER C
9b7c : 270e                       beq  L8625          ; BRANCH IF END OF LINE
9b7e : bd9bee                     jsr  L8687          ; GET A KEYSTROKE
9b81 : 2502                       blo  L861E          ; BRANCH IF LEGITIMATE K
9b83 : 20f5                       bra  L8613          ; TRY AGAIN IF ILLEGAL K
9b85 : a780             L861E     sta  ,x+            ; INSERT NEW CHARACTER I
9b87 : 8d37                       bsr  L8659          ; SEND NEW CHARACTER TO 
9b89 : 5a                         decb                ; DECREMENT REPEAT PARAM
9b8a : 26ee                       bne  L8613          ; BRANCH IF NOT DONE
9b8c : 39               L8625     rts
9b8d : d697             L8626     ldb  VD7            ; GET LENGTH OF LINE
9b8f : c1f9                       cmpb #LBUFMX-1      ; COMPARE TO MAXIMUM LEN
9b91 : 2602                       bne  L862E          ; BRANCH IF NOT AT MAXIM
9b93 : 20c7                       bra  L85F5          ; IGNORE INPUT IF LINE A
9b95 : 3410             L862E     pshs x              ; SAVE CURRENT BUFFER PO
9b97 : 6d80             L8630     tst  ,x+            ; * SCAN THE LINE UNTIL 
9b99 : 26fc                       bne  L8630          ; * LINE (0) IS FOUND
9b9b : e682             L8634     ldb  ,-x            ; DECR TEMP LINE POINTER
9b9d : e701                       stb  $01,x          ; PUT CHARACTER BACK DOW
9b9f : ace4                       cmpx ,s             ; HAVE WE REACHED STARTI
AS09 Assembler for M6809 [1.42].                                     Page  100
--------------------------------- merge.a09 ----------------------------------

9ba1 : 26f8                       bne  L8634          ; NO - KEEP GOING
9ba3 : 3262                       leas $02,s          ; PURGE BUFFER POINTER F
9ba5 : a780                       sta  ,x+            ; INSERT NEW CHARACTER I
9ba7 : 8d17                       bsr  L8659          ; SEND A CHARACTER TO CO
9ba9 : 0c97                       inc  VD7            ; ADD ONE TO BUFFER LENG
9bab : 20af                       bra  L85F5          ; GET INSERT SUB COMMAND
9bad : 8108             L8646     cmpa #BS            ; BACKSPACE?
9baf : 2612                       bne  L865C          ; NO
9bb1 : 8d04             L864A     bsr  L8650          ; MOVE POINTER BACK 1, S
9bb3 : 5a                         decb                ; DECREMENT REPEAT PARAM
9bb4 : 26fb                       bne  L864A          ; LOOP UNTIL DONE
9bb6 : 39                         rts
9bb7 : 8c00e2           L8650     cmpx #LINBUF+1      ; COMPARE POINTER TO STA
9bba : 27d0                       beq  L8625          ; DO NOT ALLOW BS IF AT 
9bbc : 301f                       leax -1,x           ; MOVE POINTER BACK ONE
9bbe : 8608                       lda  #BS            ; BACK SPACE
9bc0 : 7e805c           L8659     jmp  PUTCHR         ; SEND TO CONSOLE OUT
9bc3 : 814b             L865C     cmpa #'K'           ; KILL?
9bc5 : 2705                       beq  L8665          ; YES
9bc7 : 8053                       suba #'S'           ; SEARCH?
9bc9 : 2701                       beq  L8665          ; YES
9bcb : 39                         rts
9bcc : 3402             L8665     pshs a              ; SAVE KILL/SEARCH FLAG 
9bce : 8d1e                       bsr  L8687          ; * GET A KEYSTROKE (TAR
9bd0 : 3402                       pshs a              ; * AND SAVE IT ON STACK
9bd2 : a684             L866B     lda  ,x             ; GET CURRENT BUFFER CHA
9bd4 : 2716                       beq  L8685          ; AND RETURN IF END OF L
9bd6 : 6d61                       tst  $01,s          ; CHECK KILL/SEARCH FLAG
9bd8 : 2606                       bne  L8679          ; BRANCH IF KILL
9bda : 8de4                       bsr  L8659          ; SEND A CHARACTER TO CO
9bdc : 3001                       leax $01,x          ; INCREMENT BUFFER POINT
9bde : 2003                       bra  L867C          ; CHECK NEXT INPUT CHARA
9be0 : bd9b38           L8679     jsr  L85D1          ; REMOVE ONE CHARACTER F
9be3 : a684             L867C     lda  ,x             ; GET CURRENT INPUT CHAR
9be5 : a1e4                       cmpa ,s             ; COMPARE TO TARGET CHAR
9be7 : 26e9                       bne  L866B          ; BRANCH IF NO MATCH
9be9 : 5a                         decb                ; DECREMENT REPEAT PARAM
9bea : 26e6                       bne  L866B          ; BRANCH IF NOT DONE
9bec : 35a0             L8685     puls y,pc           ; THE Y PULL WILL CLEAN 
                        *
                        * GET A KEYSTRKE
9bee : bd801f           L8687     jsr  LA171          ; CALL CONSOLE IN : DEV 
9bf1 : 817f                       cmpa #$7F           ; GRAPHIC CHARACTER?
9bf3 : 24f9                       bcc  L8687          ; YES - GET ANOTHER CHAR
9bf5 : 815f                       cmpa #$5F           ; SHIFT UP ARROW (QUIT I
9bf7 : 2602                       bne  L8694          ; NO
9bf9 : 861b                       lda  #ESC           ; REPLACE W/ESCAPE CODE
9bfb : 810d             L8694     cmpa #CR            ; ENTER KEY
9bfd : 270e                       beq  L86A6          ; YES
9bff : 811b                       cmpa #ESC           ; ESCAPE?
9c01 : 270a                       beq  L86A6          ; YES
9c03 : 8108                       cmpa #BS            ; BACKSPACE?
9c05 : 2706                       beq  L86A6          ; YES
9c07 : 8120                       cmpa #SPACE         ; SPACE
9c09 : 25e3                       blo  L8687          ; GET ANOTHER CHAR IF CO
9c0b : 1a01                       orcc #$01           ; SET CARRY
9c0d : 39               L86A6     rts
                        
                        * TRON
9c0e : 86               TRON      fcb  SKP1LD         ; SKIP ONE BYTE AND lda 
                        
                        * TROFF
AS09 Assembler for M6809 [1.42].                                     Page  101
--------------------------------- merge.a09 ----------------------------------

9c0f : 4f               TROFF     clra                ; TROFF FLAG
9c10 : 978c                       sta  TRCFLG         ; TRON/TROFF FLAG:0=TROF
9c12 : 39                         rts
                        
                        * POS
                        
9c13 : 8600             POS       lda  #0             ; GET DEVICE NUMBER
9c15 : d679                       ldb  LPTPOS         ; GET PRINT POSITION
9c17 : 1d               LA5E8     sex                 ; CONVERT ACCB TO 2 DIGI
9c18 : 7e8e10                     jmp  GIVABF         ; CONVERT ACCD TO FLOATI
                        
                        
                        * VARPTR
9c1b : bd8b8c           VARPT     jsr  LB26A          ; SYNTAX CHECK FOR '('
9c1e : dc1f                       ldd  ARYEND         ; GET ADDR OF END OF ARR
9c20 : 3406                       pshs b,a            ; SAVE IT ON STACK
9c22 : bd8c73                     jsr  LB357          ; GET VARIABLE DESCRIPTO
9c25 : bd8b89                     jsr  LB267          ; SYNTAX CHECK FOR ')'
9c28 : 3506                       puls a,b            ; GET END OF ARRAYS ADDR
9c2a : 1e10                       exg  x,d            ; SWAP END OF ARRAYS AND
9c2c : 9c1f                       cmpx ARYEND         ; COMPARE TO NEW END OF 
9c2e : 2651                       bne  L8724          ; 'FC' ERROR IF VARIABLE
9c30 : 7e8e10                     jmp  GIVABF         ; CONVERT VARIABLE DESCR
                        
                        * MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT
9c33 : 9d7c             L86D6     jsr  GETNCH         ; GET INPUT CHAR FROM BA
9c35 : bd8b8c                     jsr  LB26A          ; SYNTAX CHECK FOR '('
9c38 : bd8c73                     jsr  LB357          ; * GET VARIABLE DESCRIP
9c3b : 3410                       pshs x              ; * SAVE IT ON THE STACK
9c3d : ec02                       ldd  $02,x          ; POINT ACCD TO START OF
9c3f : 109321                     cmpd FRETOP         ; COMPARE TO START OF CL
9c42 : 2304                       bls  L86EB          ; BRANCH IF <=
9c44 : 9327                       subd MEMSIZ         ; SUBTRACT OUT TOP OF CL
9c46 : 2312                       bls  L86FD          ; BRANCH IF STRING IN ST
9c48 : e684             L86EB     ldb  ,x             ; GET LENGTH OF OLDSTRIN
9c4a : bd8e89                     jsr  LB56D          ; RESERVE ACCB BYTES IN 
9c4d : 3410                       pshs x              ; SAVE RESERVED SPACE ST
9c4f : ae62                       ldx  $02,s          ; POINT X TO OLDSTRING D
9c51 : bd8f5e                     jsr  LB643          ; MOVE OLDSTRING INTO ST
9c54 : 3550                       puls x,u            ; * GET OLDSTRING DESCRI
9c56 : af42                       stx  $02,u          ; * ADDRESS AND SAVE RES
9c58 : 3440                       pshs u              ; SAVE OLDSTRING DESCRIP
9c5a : bd9052           L86FD     jsr  LB738          ; SYNTAX CHECK FOR COMMA
9c5d : 3404                       pshs b              ; SAVE POSITION PARAMETE
9c5f : 5d                         tstb                ; * CHECK POSITION PARAM
9c60 : 271f                       beq  L8724          ; * IF START OF STRING
9c62 : c6ff                       ldb  #$FF           ; DEFAULT REPLACEMENT LE
9c64 : 8129                       cmpa #')'           ; * CHECK FOR END OF MID
9c66 : 2703                       beq  L870E          ; * BRANCH IF AT END OF 
9c68 : bd9052                     jsr  LB738          ; SYNTAX CHECK FOR COMMA
9c6b : 3404             L870E     pshs b              ; SAVE LENGTH PARAMETER 
9c6d : bd8b89                     jsr  LB267          ; SYNTAX CHECK FOR ')'
9c70 : c6b7                       ldb  #TOK_EQUALS    ; TOKEN FOR =
9c72 : bd8b91                     jsr  LB26F          ; SYNTAX CHECK FOR '='
9c75 : 8d2e                       bsr  L8748          ; EVALUATE REPLACEMENT S
9c77 : 1f13                       tfr  x,u            ; SAVE REPLACEMENT STRIN
9c79 : ae62                       ldx  $02,s          ; POINT X TO OLOSTRING D
9c7b : a684                       lda  ,x             ; GET LENGTH OF OLDSTRIN
9c7d : a061                       suba $01,s          ; SUBTRACT POSITION PARA
9c7f : 2403                       bcc  L8727          ; INSERT REPLACEMENT STR
9c81 : 7e8d66           L8724     jmp  LB44A          ; 'FC' ERROR IF POSITION
9c84 : 4c               L8727     inca                ; * NOW ACCA = NUMBER OF
AS09 Assembler for M6809 [1.42].                                     Page  102
--------------------------------- merge.a09 ----------------------------------

                        *                             ; * (INCLUSIVE) OF THE P
9c85 : a1e4                       cmpa ,s
9c87 : 2402                       bcc  L872E          ; BRANCH IF NEW STRING W
9c89 : a7e4                       sta  ,s             ; IF NOT, USE AS MUCH OF
9c8b : a661             L872E     lda  $01,s          ; GET POSITION PARAMETER
9c8d : 1e89                       exg  a,b            ; ACCA=LENGTH OF REPL ST
9c8f : ae02                       ldx  $02,x          ; POINT X TO OLDSTRING A
9c91 : 5a                         decb                ; * BASIC'S POSITION PAR
                        *                             ; * WANTS IT TO START AT
9c92 : 3a                         abx                 ; POINT X TO POSITION IN
9c93 : 4d                         tsta                ; * IF THE LENGTH OF THE
9c94 : 270d                       beq  L8746          ; * THEN RETURN
9c96 : a1e4                       cmpa ,s
9c98 : 2302                       bls  L873F          ; ADJUSTED LENGTH PARAME
9c9a : a6e4                       lda  ,s             ; OTHERWISE USE AS MUCH 
9c9c : 1f89             L873F     tfr  a,b            ; SAVE NUMBER OF BYTES T
9c9e : 1e31                       exg  u,x            ; SWAP SOURCE AND DESTIN
9ca0 : bd81df                     jsr  LA59A          ; MOVE (B) BYTES FROM (X
9ca3 : 3596             L8746     puls a,b,x,pc
9ca5 : bd8a78           L8748     jsr  LB156          ; EVALUATE EXPRESSION
9ca8 : 7e8f6f                     jmp  LB654          ; *'TM' ERROR IF NUMERIC
                        *                             ; *TO STRING, ACCB = LEN
                        
                        * STRING
9cab : bd8b8c           STRING    jsr  LB26A          ; SYNTAX CHECK FOR '('
9cae : bd9025                     jsr  LB70B          ; EVALUATE EXPRESSION; E
9cb1 : 3404                       pshs b              ; SAVE LENGTH OF STRING
9cb3 : bd8b8f                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
9cb6 : bd8a78                     jsr  LB156          ; EVALUATE EXPRESSION
9cb9 : bd8b89                     jsr  LB267          ; SYNTAX CHECK FOR ')'
9cbc : 9606                       lda  VALTYP         ; GET VARIABLE TYPE
9cbe : 2605                       bne  L8768          ; BRANCH IF STRING
9cc0 : bd9028                     jsr  LB70E          ; CONVERT FPA0 INTO AN I
9cc3 : 2003                       bra  L876B          ; SAVE THE STRING IN STR
9cc5 : bd8fbf           L8768     jsr  LB6A4          ; GET FIRST BYTE OF STRI
9cc8 : 3404             L876B     pshs b              ; SAVE FIRST BYTE OF EXP
9cca : e661                       ldb  $01,s          ; GET LENGTH OF STRING
9ccc : bd8e2b                     jsr  LB50F          ; RESERVE ACCB BYTES IN 
9ccf : 3506                       puls a,b            ; GET LENGTH OF STRING A
9cd1 : 2705                       beq  L877B          ; BRANCH IF NULL STRING
9cd3 : a780             L8776     sta  ,x+            ; SAVE A CHARACTER IN ST
9cd5 : 5a                         decb                ; DECREMENT LENGTH
9cd6 : 26fb                       bne  L8776          ; BRANCH IF NOT DONE
9cd8 : 7e8fb6           L877B     jmp  LB69B          ; PUT STRING DESCRIPTOR 
                        
                        * INSTR
9cdb : bd8b8c           INSTR     jsr  LB26A          ; SYNTAX CHECK FOR '('
9cde : bd8a78                     jsr  LB156          ; EVALUATE EXPRESSION
9ce1 : c601                       ldb  #$01           ; DEFAULT POSITION = 1 (
9ce3 : 3404                       pshs b              ; SAVE START
9ce5 : 9606                       lda  VALTYP         ; GET VARIABLE TYPE
9ce7 : 2610                       bne  L879C          ; BRANCH IF STRING
9ce9 : bd9028                     jsr  LB70E          ; CONVERT FPA0 TO INTEGE
9cec : e7e4                       stb  ,s             ; SAVE START SEARCH VALU
9cee : 2791                       beq  L8724          ; BRANCH IF START SEARCH
9cf0 : bd8b8f                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
9cf3 : bd8a78                     jsr  LB156          ; EVALUATE EXPRESSION - 
9cf6 : bd8a68                     jsr  LB146          ; 'TM' ERROR IF NUMERIC
9cf9 : 9e52             L879C     ldx  FPA0+2         ; SEARCH STRING DESCRIPT
9cfb : 3410                       pshs x              ; SAVE ON THE STACK
9cfd : bd8b8f                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
9d00 : 8da3                       jsr  L8748          ; EVALUATE TARGET STRING
AS09 Assembler for M6809 [1.42].                                     Page  103
--------------------------------- merge.a09 ----------------------------------

9d02 : 3414                       pshs x,b            ; SAVE ADDRESS AND LENGT
9d04 : bd8b89                     jsr  LB267          ; SYNTAX CHECK FOR ')'
9d07 : ae63                       ldx  $03,s          ; * LOAD X WITH SEARCH S
9d09 : bd8f74                     jsr  LB659          ; * AND GET THE LENGTH A
9d0c : 3404                       pshs b              ; SAVE LENGTH ON STACK
                        *
                        * AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATIO
                        * ON IT: 0,s-SEARCH LENGTH; 1,s-TARGET LENGTH; 2 3,s-T
                        * ADDRESS; 4 5,s-SEARCH DESCRIPTOR ADDRESS; 6,s-SEARCH
9d0e : e166                       cmpb $06,s          ; COMPARE LENGTH OF SEAR
9d10 : 2523                       blo  L87D9          ; POSITION; RETURN 0 IF 
9d12 : a661                       lda  $01,s          ; GET LENGTH OF TARGET S
9d14 : 271c                       beq  L87D6          ; BRANCH IF TARGET STRIN
9d16 : e666                       ldb  $06,s          ; GET START POSITION
9d18 : 5a                         decb                ; MOVE BACK ONE
9d19 : 3a                         abx                 ; POINT X TO POSITION IN
9d1a : 3184             L87BE     leay ,x             ; POINT Y TO SEARCH POSI
9d1c : ee62                       ldu  $02,s          ; POINT U TO START OF TA
9d1e : e661                       ldb  $01,s          ; LOAD ACCB WITH LENGTH 
9d20 : a6e4                       lda  ,s             ; LOAD ACCA WITH LENGTH 
9d22 : a066                       suba $06,s          ; SUBTRACT SEARCH POSITI
9d24 : 4c                         inca                ; ADD ONE
9d25 : a161                       cmpa $01,s          ; COMPARE TO TARGET LENG
9d27 : 250c                       blo  L87D9          ; RETURN 0 IF TARGET LEN
9d29 : a680             L87CD     lda  ,x+            ; GET A CHARACTER FROM S
9d2b : a1c0                       cmpa ,u+            ; COMPARE IT TO TARGET S
9d2d : 260c                       bne  L87DF          ; BRANCH IF NO MATCH
9d2f : 5a                         decb                ; DECREMENT TARGET LENGT
9d30 : 26f7                       bne  L87CD          ; CHECK ANOTHER CHARACTE
9d32 : e666             L87D6     ldb  $06,s          ; GET MATCH POSITION
9d34 : 21               L87D8     fcb  SKP1           ; SKIP NEXT BYTE
9d35 : 5f               L87D9     clrb                ; MATCH ADDRESS = 0
9d36 : 3267                       leas $07,s          ; CLEAN UP THE STACK
9d38 : 7e8e0f                     jmp  LB4F3          ; CONVERT ACCB TO FP NUM
9d3b : 6c66             L87DF     inc  $06,s          ; INCREMENT SEARCH POSIT
9d3d : 3021                       leax $01,y          ; MOVE X TO NEXT SEARCH 
9d3f : 20d9                       bra  L87BE          ; KEEP LOOKING FOR A MAT
                        
                        * EXTENDED BASIC RVEC19 HOOK CODE
9d41 : 8126             XVEC19    cmpa #'&'           ; *
9d43 : 265c                       bne  L8845          ; * RETURN IF NOT HEX OR
9d45 : 3262                       leas $02,s          ; PURGE RETURN ADDRESS F
                        * PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
9d47 : 0f52             L87EB     clr  FPA0+2         ; * CLEAR BOTTOM TWO
9d49 : 0f53                       clr  FPA0+3         ; * BYTES OF FPA0
9d4b : 8e0052                     ldx  #FPA0+2        ; BYTES 2,3 OF FPA0 = (T
9d4e : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
9d50 : 814f                       cmpa #'O'
9d52 : 2712                       beq  L880A          ; YES
9d54 : 8148                       cmpa #'H'
9d56 : 2723                       beq  L881F          ; YES
9d58 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
9d5a : 200c                       bra  L880C          ; DEFAULT TO OCTAL (&O)
9d5c : 8138             L8800     cmpa #'8'
9d5e : 1022ee37                   bhi  LB277
9d62 : c603                       ldb  #$03           ; BASE 8 MULTIPLIER
9d64 : 8d2a                       bsr  L8834          ; ADD DIGIT TO TEMPORARY
                        * EVALUATE AN &O VARIABLE
9d66 : 9d7c             L880A     jsr  GETNCH         ; GET A CHARACTER FROM B
9d68 : 25f2             L880C     blo  L8800          ; BRANCH IF NUMERIC
9d6a : 0f50             L880E     clr  FPA0           ; * CLEAR 2 HIGH ORDER
9d6c : 0f51                       clr  FPA0+1         ; * BYTES OF FPA0
AS09 Assembler for M6809 [1.42].                                     Page  104
--------------------------------- merge.a09 ----------------------------------

9d6e : 0f06                       clr  VALTYP         ; SET VARXABLE TYPE TO N
9d70 : 0f63                       clr  FPSBYT         ; ZERO OUT SUB BYTE OF F
9d72 : 0f54                       clr  FP0SGN         ; ZERO OUT MANTISSA SIGN
9d74 : c6a0                       ldb  #$A0           ; * SET EXPONENT OF FPA0
9d76 : d74f                       stb  FP0EXP         ; *
9d78 : 7e9312                     jmp  LBA1C          ; GO NORMALIZE FPA0
                        * EVALUATE AN &H VARIABLE
9d7b : 9d7c             L881F     jsr  GETNCH         ; GET A CHARACTER FROM B
9d7d : 250b                       blo  L882E          ; BRANCH IF NUMERIC
9d7f : bd8cbe                     jsr  LB3A2          ; SET CARRY IF NOT ALPHA
9d82 : 25e6                       blo  L880E          ; BRANCH IF NOT ALPHA OR
9d84 : 8147                       cmpa #'G'           ; CHECK FOR LETTERS A-F
9d86 : 24e2                       bcc  L880E          ; BRANCH IF >= G (ILLEGA
9d88 : 8007                       suba #7             ; SUBTRACT ASCII DIFFERE
9d8a : c604             L882E     ldb  #$04           ; BASE 16 DIGIT MULTIPLI
9d8c : 8d02                       bsr  L8834          ; ADD DIGIT TO TEMPORARY
9d8e : 20eb                       bra  L881F          ; KEEP EVALUATING VARIAB
9d90 : 6801             L8834     asl  $01,x          ; * MULTIPLY TEMPORARY
9d92 : 6984                       rol  ,x             ; * ACCUMULATOR BY TWO
9d94 : 1025f5f0                   bcs  LBA92          ; 'OV' OVERFLOW ERROR
9d98 : 5a                         decb                ; DECREMENT SHIFT COUNTE
9d99 : 26f5                       bne  L8834          ; MULTIPLY TEMPORARY ACC
9d9b : 8030                       suba #'0'            ; MASK OFF ASCII
9d9d : ab01                       adda $01,x          ; * ADD DIGIT TO TEMPORA
9d9f : a701                       sta  $01,x          ; * ACCUMULATOR AND SAVE
9da1 : 39               L8845     rts
                        
9da2 : 3540             XVEC15    puls u              ; PULL RETURN ADDRESS AN
9da4 : 0f06                       clr  VALTYP         ; SET VARIABLE TYPE TO N
9da6 : 9e83                       ldx  CHARAD         ; CURRENT INPUT POINTER 
9da8 : 9d7c                       jsr  GETNCH         ; GET CHARACTER FROM BAS
9daa : 8126                       cmpa #'&'           ; HEX AND OCTAL VARIABLE
9dac : 2799                       beq  L87EB          ; PROCESS A '&' VARIABLE
9dae : 81b9                       cmpa #TOK_FN        ; TOKEN FOR FN
9db0 : 275c                       beq  L88B4          ; PROCESS FN CALL
9db2 : 81ff                       cmpa #$FF           ; CHECK FOR SECONDARY TO
9db4 : 2608                       bne  L8862          ; NOT SECONDARY
9db6 : 9d7c                       jsr  GETNCH         ; GET CHARACTER FROM BAS
9db8 : 8183                       cmpa #TOK_USR       ; TOKEN FOR USR
9dba : 102700a9                   lbeq L892C          ; PROCESS USR CALL
9dbe : 9f83             L8862     stx  CHARAD         ; RESTORE BASIC'S INPUT 
9dc0 : 6ec4                       jmp  ,u             ; RETURN TO CALLING ROUT
9dc2 : 9e68             L8866     ldx  CURLIN         ; GET CURRENT LINE NUMBE
9dc4 : 3001                       leax $01,x          ; IN DIRECT MODE?
9dc6 : 26d9                       bne  L8845          ; RETURN IF NOT IN DIREC
9dc8 : c616                       ldb  #2*11          ; 'ILLEGAL DIRECT STATEM
9dca : 7e8598           L886E     jmp  LAC46          ; PROCESS ERROR
                        
9dcd : ae9f0083         DEF       ldx  [CHARAD]       ; GET TWO INPUT CHARS
9dd1 : 8cff83                     cmpx #TOK_FF_USR    ; TOKEN FOR USR
9dd4 : 2774                       beq  L890F          ; BRANCH IF DEF USR
9dd6 : 8d23                       bsr  L88A1          ; GET DESCRIPTOR ADDRESS
9dd8 : 8de8                       bsr  L8866          ; DON'T ALLOW DEF FN IF 
9dda : bd8b8c                     jsr  LB26A          ; SYNTAX CHECK FOR '('
9ddd : c680                       ldb  #$80           ; * GET THE FLAG TO INDI
9ddf : d708                       stb  ARYDIS         ; * AND SAVE IT IN THE A
9de1 : bd8c73                     jsr  LB357          ; GET VARIABLE DESCRIPTO
9de4 : 8d25                       bsr  L88B1          ; 'TM' ERROR IF STRING
9de6 : bd8b89                     jsr  LB267          ; SYNTAX CHECK FOR ')'
9de9 : c6b7                       ldb  #TOK_EQUALS    ; TOKEN FOR '='
9deb : bd8b91                     jsr  LB26F          ; DO A SYNTAX CHECK FOR 
9dee : 9e4b                       ldx  V4B            ; GET THE ADDRESS OF THE
AS09 Assembler for M6809 [1.42].                                     Page  105
--------------------------------- merge.a09 ----------------------------------

9df0 : dc83                       ldd  CHARAD         ; * GET THE CURRENT INPU
9df2 : ed84                       std  ,x             ; * SAVE IT IN FIRST 2 B
9df4 : dc39                       ldd  VARPTR         ; = GET THE DESCRIPTOR A
9df6 : ed02                       std  $02,x          ; = VARIABLE AND SAVE IT
9df8 : 7e8826                     jmp  DATA           ; MOVE INPUT POINTER TO 
9dfb : c6b9             L88A1     ldb  #TOK_FN        ; TOKEN FOR FN
9dfd : bd8b91                     jsr  LB26F          ; DO A SYNTAX CHECK FOR 
9e00 : c680                       ldb  #$80           ; * GET THE FLAG TO INDI
9e02 : d708                       stb  ARYDIS         ; * AND SAVE IT IN ARRAY
9e04 : 8a80                       ora  #$80           ; SET BIT 7 OF CURRENT I
9e06 : bd8c78                     jsr  LB35C          ; * GET THE DESCRIPTOR A
9e09 : 9f4b                       stx  V4B            ; * VARIABLE AND SAVE IT
9e0b : 7e8a65           L88B1     jmp  LB143          ; 'TM' ERROR IF STRING V
                        * EVALUATE AN FN CALL
9e0e : 8deb             L88B4     bsr  L88A1          ; * GET THE DESCRIPTOR O
9e10 : 3410                       pshs x              ; * VARIABLE AND SAVE IT
9e12 : bd8b84                     jsr  LB262          ; SYNTAX CHECK FOR '(' &
9e15 : 8df4                       bsr  L88B1          ; 'TM' ERROR IF STRING V
9e17 : 3540                       puls u              ; POINT U TO FN NAME DES
9e19 : c632                       ldb  #2*25          ; 'UNDEFINED FUNCTION CA
9e1b : ae42                       ldx  $02,u          ; POINT X TO ARGUMENT VA
9e1d : 27ab                       beq  L886E          ; BRANCH TO ERROR HANDLE
9e1f : 109e83                     ldy  CHARAD         ; SAVE CURRENT INPUT POI
9e22 : eec4                       ldu  ,u             ; * POINT U TO START OF 
9e24 : df83                       stu  CHARAD         ; * SAVE IT IN INPUT POI
9e26 : a604                       lda  $04,x          ; = GET FP VALUE OF
9e28 : 3402                       pshs a              ; = ARGUMENT VARIABLE, C
9e2a : ec84                       ldd  ,x             ; = POINTER, AND ADDRESS
9e2c : ee02                       ldu  $02,x          ; = OF FN FORMULA AND SA
9e2e : 3476                       pshs u,y,x,b,a      ; = THEM ON THE STACK
9e30 : bd952b                     jsr  LBC35          ; PACK FPA0 AND SAVE IT 
9e33 : bd8a63           L88D9     jsr  LB141          ; EVALUATE FN EXPRESSION
9e36 : 3576                       puls a,b,x,y,u      ; RESTORE REGISTERS
9e38 : ed84                       std  ,x             ; * GET THE FP
9e3a : ef02                       stu  $02,x          ; * VALUE OF THE ARGUMEN
9e3c : 3502                       puls a              ; * VARIABLE OFF OF THE
9e3e : a704                       sta  $04,x          ; * STACK AND RE-SAVE IT
9e40 : 9d82                       jsr  GETCCH         ; GET FINAL CHARACTER OF
9e42 : 1026ed53                   lbne LB277          ; 'SYNTAX' ERROR IF NOT 
9e46 : 109f83                     sty  CHARAD         ; RESTORE INPUT POINTER
9e49 : 39               L88EF     rts
                        
                        
                        
                        * DEF USR
9e4a : 9d7c             L890F     jsr  GETNCH         ; SKIP PAST SECOND BYTE 
9e4c : 8d09                       bsr  L891C          ; GET FN NUMBER
9e4e : 3410                       pshs x              ; SAVE FN EXEC ADDRESS S
9e50 : 8d2d                       bsr  L8944          ; CALCULATE EXEC ADDRESS
9e52 : 3540                       puls u              ; GET FN EXEC ADDRESS ST
9e54 : afc4                       stx  ,u             ; SAVE EXEC ADDRESS
9e56 : 39                         rts
9e57 : 5f               L891C     clrb                ; DEFAULT TO USR0 IF NO 
9e58 : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
9e5a : 2406                       bcc  L8927          ; BRANCH IF NOT NUMERIC
9e5c : 8030                       suba #'0'            ; MASK OFF ASCII
9e5e : 1f89                       tfr  a,b            ; SAVE USR NUMBER IN ACC
9e60 : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
9e62 : 9e8d             L8927     ldx  USRADR         ; GET ADDRESS OF STORAGE
9e64 : 58                         aslb                ; X2 - 2 BYTES/USR ADDRE
9e65 : 3a                         abx                 ; ADD OFFSET TO START AD
9e66 : 39                         rts
AS09 Assembler for M6809 [1.42].                                     Page  106
--------------------------------- merge.a09 ----------------------------------

                        * PROCESS A USR CALL
9e67 : 8dee             L892C     bsr  L891C          ; GET STORAGE LOC OF EXE
9e69 : ae84                       ldx  ,x             ; * GET EXEC ADDRESS AND
9e6b : 3410                       pshs x              ; * PUSH IT ONTO STACK
9e6d : bd8b84                     jsr  LB262          ; SYNTAX CHECK FOR '(' &
9e70 : 8e004f                     ldx  #FP0EXP        ; POINT X TO FPA0
9e73 : 9606                       lda  VALTYP         ; GET VARIABLE TYPE
9e75 : 2707                       beq  L8943          ; BRANCH IF NUMERIC, STR
9e77 : bd8f72                     jsr  LB657          ; GET LENGTH & ADDRESS O
9e7a : 9e52                       ldx  FPA0+2         ; GET POINTER TO STRING 
9e7c : 9606                       lda  VALTYP         ; GET VARIABLE TYPE
9e7e : 39               L8943     rts                 ; JUMP TO USR ROUTINE (p
9e7f : c6b7             L8944     ldb  #TOK_EQUALS    ; TOKEN FOR '='
9e81 : bd8b91                     jsr  LB26F          ; DO A SYNTAX CHECK FOR 
9e84 : 7e9057                     jmp  LB73D          ; EVALUATE EXPRESSION, R
                        
                        
                        
                        * DEL
9e87 : 1027eedb         DEL       beq  LB44A          ; 'FC' ERROR IF NO ARGUM
9e8b : bd88ad                     jsr  LAF67          ; CONVERT A DECIMAL BASi
9e8e : bd863d                     jsr  LAD01          ; FIND RAM ADDRESS OF ST
9e91 : 9f93                       stx  VD3            ; SAVE RAM ADDRESS OF ST
9e93 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
9e95 : 2710                       beq  L8990          ; BRANCH IF END OF LINE
9e97 : 81b0                       cmpa #TOK_MINUS     ; TOKEN FOR '-'
9e99 : 263b                       bne  L89BF          ; TERMINATE COMMAND IF L
9e9b : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
9e9d : 2704                       beq  L898C          ; IF END OF LINE, USE DE
9e9f : 8d24                       bsr  L89AE          ; * CONVERT ENDING LINE 
9ea1 : 2004                       bra  L8990          ; * AND SAVE IT IN BINVA
9ea3 : 86ff             L898C     lda  #$FF           ; = USE $FFXX AS DEFAULT
9ea5 : 972b                       sta  BINVAL         ; = LINE NUMBER - SAVE I
9ea7 : de93             L8990     ldu  VD3            ; POINT U TO STARTING LI
9ea9 : 8c               L8992     fcb  SKP2           ; SKIP TWO BYTES
9eaa : eec4             L8993     ldu  ,u             ; POINT U TO START OF NE
9eac : ecc4                       ldd  ,u             ; CHECK FOR END OF PROGR
9eae : 2706                       beq  L899F          ; BRANCH IF END OF PROGR
9eb0 : ec42                       ldd  $02,u          ; LOAD ACCD WITH THIS LI
9eb2 : 932b                       subd BINVAL         ; SUBTRACT ENDING LINE N
9eb4 : 23f4                       bls  L8993          ; BRANCH IF = < ENDING L
9eb6 : 9e93             L899F     ldx  VD3            ; GET STARTING LINE NUMB
9eb8 : 8d15                       bsr  L89B8          ; MOVE (U) TO (X) UNTIL 
9eba : bd865d                     jsr  LAD21          ; RESET BASIC'S INPUT PO
9ebd : 9e93                       ldx  VD3            ; GET STARTING LINE NUMB
9ebf : bd862d                     jsr  LACF1          ; RECOMPUTE START OF NEX
9ec2 : 7e85b7                     jmp  LAC73          ; JUMP TO BASIC'S MAIN C
9ec5 : bd88ad           L89AE     jsr  LAF67          ; GO GET LINE NUMBER CON
9ec8 : 7e81e7                     jmp  LA5C7          ; MAKE SURE THERE'S NO M
9ecb : a6c0             L89B4     lda  ,u+            ; GET A BYTE FROM (U)
9ecd : a780                       sta  ,x+            ; MOVE THE BYTE TO (X)
9ecf : 11931b           L89B8     cmpu VARTAB         ; COMPARE TO END OF BASI
9ed2 : 26f7                       bne  L89B4          ; BRANCH IF NOT AT END
9ed4 : 9f1b                       stx  VARTAB         ; SAVE (X) AS NEW END OF
9ed6 : 39               L89BF     rts
                        
                        
9ed7 : bd9dc2           L89C0     jsr  L8866          ; 'BS' ERROR IF IN DIREC
9eda : 9d7c                       jsr  GETNCH         ; GET A CHAR FROM BASIC
9edc : 8122             L89D2     cmpa #'"'           ; CHECK FOR PROMPT STRIN
9ede : 260b                       bne  L89E1          ; BRANCH IF NO PROMPT ST
9ee0 : bd8b66                     jsr  LB244          ; STRIP OFF PROMPT STRIN
AS09 Assembler for M6809 [1.42].                                     Page  107
--------------------------------- merge.a09 ----------------------------------

9ee3 : c63b                       ldb  #';'           ; *
9ee5 : bd8b91                     jsr  LB26F          ; * DO A SYNTAX CHECK FO
9ee8 : bd9295                     jsr  LB99F          ; REMOVE PROMPT STRING F
9eeb : 327e             L89E1     leas -2,s           ; RESERVE TWO STORAGE SL
9eed : bd8962                     jsr  LB035          ; INPUT A LINE FROM CURR
9ef0 : 3262                       leas $02,s          ; CLEAN UP THE STACK
9ef2 : bd8c73                     jsr  LB357          ; SEARCH FOR A VARIABLE
9ef5 : 9f3b                       stx  VARDES         ; SAVE POINTER TO VARIAB
9ef7 : bd8a68                     jsr  LB146          ; 'TM' ERROR IF VARIABLE
9efa : 8e00e1                     ldx  #LINBUF        ; POINT X TO THE STRING 
9efd : 4f                         clra                ; TERMINATOR CHARACTER 0
9efe : bd8e38                     jsr  LB51A          ; PARSE THE INPUT STRING
9f01 : 7e88ea                     jmp  LAFA4          ; REMOVE DESCRIPTOR FROM
                        		  		  
9f04 : bd88ad           L89FC     jsr  LAF67          ; STRIP A DECIMAL NUMBER
9f07 : 9e2b                       ldx  BINVAL         ; GET BINARY VALUE
9f09 : 39                         rts
9f0a : 9e91             L8A02     ldx  VD1            ; GET CURRENT OLD NUMBER
9f0c : 9f2b             L8A04     stx  BINVAL         ; SAVE THE LINE NUMBER B
9f0e : 7e863d                     jmp  LAD01          ; GO FIND THE LINE NUMBE
                        
                        * RENUM
9f11 : bd8662           RENUM     jsr  LAD26          ; ERASE VARIABLES
9f14 : cc000a                     ldd  #10            ; DEFAULT LINE NUMBER IN
9f17 : dd95                       std  VD5            ; SAVE DEFAULT RENUMBER 
9f19 : dd8f                       std  VCF            ; SAVE DEFAULT INTERVAL
9f1b : 5f                         clrb                ; NOW ACCD = 0
9f1c : dd91                       std  VD1            ; DEFAULT LINE NUMBER OF
9f1e : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
9f20 : 2406                       bcc  L8A20          ; BRANCH IF NOT NUMERIC
9f22 : 8de0                       bsr  L89FC          ; CONVERT DECIMAL NUMBER
9f24 : 9f95                       stx  VD5            ; SAVE LINE NUMBER WHERE
9f26 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
9f28 : 271b             L8A20     beq  L8A3D          ; BRANCH IF END OF LINE
9f2a : bd8b8f                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
9f2d : 2406                       bcc  L8A2D          ; BRANCH IF NEXT CHARACT
9f2f : 8dd3                       bsr  L89FC          ; CONVERT DECIMAL NUMBER
9f31 : 9f91                       stx  VD1            ; SAVE NEW RENUMBER LINE
9f33 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
9f35 : 270e             L8A2D     beq  L8A3D          ; BRANCH IF END OF LINE
9f37 : bd8b8f                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
9f3a : 2406                       bcc  L8A3A          ; BRANCH IF NEXT CHARACT
9f3c : 8dc6                       bsr  L89FC          ; CONVERT DECIMAL NUMBER
9f3e : 9f8f                       stx  VCF            ; SAVE NEW INTERVAL
9f40 : 2749                       beq  L8A83          ; 'FC' ERROR
9f42 : bd81e7           L8A3A     jsr  LA5C7          ; CHECK FOR MORE CHARACT
9f45 : 8dc3             L8A3D     bsr  L8A02          ; GO GET ADDRESS OF OLD 
9f47 : 9f93                       stx  VD3            ; SAVE ADDRESS
9f49 : 9e95                       ldx  VD5            ; GET NEXT RENUMBERED LI
9f4b : 8dbf                       bsr  L8A04          ; FIND THE LINE NUMBER I
9f4d : 9c93                       cmpx VD3            ; COMPARE TO ADDRESS OF 
9f4f : 253a                       blo  L8A83          ; 'FC' ERROR IF NEW ADDR
9f51 : 8d1c                       bsr  L8A67          ; MAKE SURE RENUMBERED L
9f53 : bd9fe5                     jsr  L8ADD          ; CONVERT ASCII LINE NUM
9f56 : bd862b                     jsr  LACEF          ; RECALCULATE NEXT LINE 
9f59 : 8daf                       bsr  L8A02          ; GET RAM ADDRESS OF FIR
9f5b : 9f93                       stx  VD3            ; SAVE IT
9f5d : 8d3a                       bsr  L8A91          ; MAKE SURE LINE NUMBERS
9f5f : 8d0f                       bsr  L8A68          ; INSERT NEW LINE NUMBER
9f61 : 8d36                       bsr  L8A91          ; INSERT NEW LINE NUMBER
9f63 : bda080                     jsr  L8B7B          ; CONVERT PACKED BINARY 
9f66 : bd8662                     jsr  LAD26          ; ERASE VARIABLES
AS09 Assembler for M6809 [1.42].                                     Page  108
--------------------------------- merge.a09 ----------------------------------

9f69 : bd862b                     jsr  LACEF          ; RECALCULATE NEXT LINE 
9f6c : 7e85b7                     jmp  LAC73          ; GO BACK TO BASIC'S MAI
9f6f : 86               L8A67     fcb  SKP1LD         ; SKIP ONE BYTE - lda #$
9f70 : 4f               L8A68     clra                ; NEW LINE NUMBER FLAG -
9f71 : 9798                       sta  VD8            ; SAVE NEW LINE NUMBER F
9f73 : 9e93                       ldx  VD3            ; GET ADDRESS OF OLD LIN
9f75 : dc95                       ldd  VD5            ; GET THE CURRENT RENUMB
9f77 : 8d15                       bsr  L8A86          ; RETURN IF END OF PROGR
9f79 : 0d98             L8A71     tst  VD8            ; CHECK NEW LINE NUMBER 
9f7b : 2602                       bne  L8A77          ; BRANCH IF NOT INSERTIN
9f7d : ed02                       std  $02,x          ; STORE THE NEW LINE NUM
9f7f : ae84             L8A77     ldx  ,x             ; POINT X TO THE NEXT LI
9f81 : 8d0b                       bsr  L8A86          ; RETURN IF END OF PROGR
9f83 : d38f                       addd VCF            ; ADD INTERVAL TO CURREN
9f85 : 2504                       blo  L8A83          ; 'FC' ERROR IF LINE NUM
9f87 : 81fa                       cmpa #MAXLIN        ; LARGEST LINE NUMBER = 
9f89 : 25ee                       blo  L8A71          ; BRANCH IF LEGAL LINE N
9f8b : 7e8d66           L8A83     jmp  LB44A          ; 'FC' ERROR IF LINE NUM
                        * TEST THE TWO BYTES POINTED TO BY (X).
                        * NORMAL RETURN IF <> 0. IF = 0 (END OF
                        * PROGRAM) RETURN IS PULLED OFF STACK AND
                        * YOU RETURN TO PREVIOUS SUBROUTINE CALL.
9f8e : 3406             L8A86     pshs b,a            ; SAVE ACCD
9f90 : ec84                       ldd  ,x             ; TEST THE 2 BYTES POINT
9f92 : 3506                       puls a,b            ; RESTORE ACCD
9f94 : 2602                       bne  L8A90          ; BRANCH IF NOT END OF P
9f96 : 3262                       leas $02,s          ; PURGE RETURN ADDRESS F
9f98 : 39               L8A90     rts
9f99 : 9e19             L8A91     ldx  TXTTAB         ; GET START OF BASIC PRO
9f9b : 301f                       leax -1,x           ; MOVE POINTER BACK ONE
9f9d : 3001             L8A95     leax $01,x          ; MOVE POINTER UP ONE
9f9f : 8ded                       bsr  L8A86          ; RETURN IF END OF PROGR
9fa1 : 3003             L8A99     leax $03,x          ; SKIP OVER NEXT LINE AD
9fa3 : 3001             L8A9B     leax $01,x          ; MOVE POINTER TO NEXT C
9fa5 : a684                       lda  ,x             ; CHECK CURRENT CHARACTE
9fa7 : 27f4                       beq  L8A95          ; BRANCH IF END OF LINE
9fa9 : 9f0f                       stx  TEMPTR         ; SAVE CURRENT POINTER
9fab : 4a                         deca                ; =
9fac : 270c                       beq  L8AB2          ; =BRANCH IF START OF PA
9fae : 4a                         deca                ; *
9faf : 272a                       beq  L8AD3          ; *BRANCH IF LINE NUMBER
9fb1 : 4a                         deca                ; =
9fb2 : 26ef                       bne  L8A9B          ; =MOVE TO NEXT CHARACTE
9fb4 : 8603             L8AAC     lda  #$03           ; * SET 1ST BYTE = 3 TO 
9fb6 : a780                       sta  ,x+            ; * NUMBER DOESN'T CURRE
9fb8 : 20e7                       bra  L8A99          ; GO GET ANOTHER CHARACT
9fba : ec01             L8AB2     ldd  $01,x          ; GET MS BYTE OF LINE NU
9fbc : 6a02                       dec  $02,x          ; DECREMENT ZERO CHECK B
9fbe : 2701                       beq  L8AB9          ; BRANCH IF MS BYTE <> 0
9fc0 : 4f                         clra                ; CLEAR MS BYTE
9fc1 : e603             L8AB9     ldb  $03,x          ; GET LS BYTE OF LINE NU
9fc3 : 6a04                       dec  $04,x          ; DECREMENT ZERO CHECK F
9fc5 : 2701                       beq  L8AC0          ; BRANCH IF IS BYTE <> 0
9fc7 : 5f                         clrb                ; CLEAR LS BYTE
9fc8 : ed01             L8AC0     std  $01,x          ; SAVE BINARY LINE NUMBE
9fca : dd2b                       std  BINVAL         ; SAVE TRIAL LINE NUMBER
9fcc : bd863d                     jsr  LAD01          ; FIND RAM ADDRESS OF A 
9fcf : 9e0f             L8AC7     ldx  TEMPTR         ; GET BACK POINTER TO ST
9fd1 : 25e1                       blo  L8AAC          ; BRANCH IF NO LINE NUMB
9fd3 : dc47                       ldd  V47            ; GET START ADDRESS OF L
9fd5 : 6c80                       inc  ,x+            ; * SET 1ST BYTE = 2, TO
                        *              ; * EXISTENCE OF LINE NUMBER, SET IT = 
AS09 Assembler for M6809 [1.42].                                     Page  109
--------------------------------- merge.a09 ----------------------------------

                        
9fd7 : ed84                       std  ,x             ; SAVE RAM ADDRESS OF CO
9fd9 : 20c6                       bra  L8A99          ; GO GET ANOTHER CHARACT
9fdb : 6f84             L8AD3     clr  ,x             ; CLEAR CARRY FLAG AND 1
9fdd : ae01                       ldx  $01,x          ; POINT X TO RAM ADDRESS
9fdf : ae02                       ldx  $02,x          ; PUT CORRECT LINE NUMBE
9fe1 : 9f47                       stx  V47            ; SAVE IT TEMPoraRILY
9fe3 : 20ea                       bra  L8AC7          ; GO INSERT IT INTO BASI
9fe5 : 9e19             L8ADD     ldx  TXTTAB         ; GET BEGINNING OF BASIC
9fe7 : 2004                       bra  L8AE5
9fe9 : 9e83             L8AE1     ldx  CHARAD         ; *GET CURRENT INPUT POI
9feb : 3001                       leax $01,x          ; *AND BUMP IT ONE
9fed : 8d9f             L8AE5     bsr  L8A86          ; RETURN IF END OF PROGR
9fef : 3002                       leax $02,x          ; SKIP PAST NEXT LINE AD
9ff1 : 3001             L8AE9     leax $01,x          ; ADVANCE POINTER BY ONE
9ff3 : 9f83             L8AEB     stx  CHARAD         ; SAVE NEW BASIC INPUT P
9ff5 : 9d7c             L8AED     jsr  GETNCH         ; GET NEXT CHARACTER FRO
9ff7 : 4d               L8AEF     tsta                ; CHECK THE CHARACTER
9ff8 : 27ef                       beq  L8AE1          ; BRANCH IF END OF LINE
9ffa : 2af9                       bpl  L8AED          ; BRANCH IF NOT A TOKEN
9ffc : 9e83                       ldx  CHARAD         ; GET CURRENT INPUT POIN
9ffe : 81ff                       cmpa #$FF           ; IS THIS A SECONDARY TO
a000 : 27ef                       beq  L8AE9          ; YES - IGNORE IT
a002 : 81ab                       cmpa #TOK_THEN      ; TOKEN FOR THEN?
a004 : 2712                       beq  L8B13          ; YES
a006 : 8184                       cmpa #TOK_ELSE      ; TOKEN FOR ELSE?
a008 : 270e                       beq  L8B13          ; YES
a00a : 8181                       cmpa #TOK_GO        ; TOKEN FOR GO?
a00c : 26e7                       bne  L8AED          ; NO
a00e : 9d7c                       jsr  GETNCH         ; GET A CHARACTER FROM B
a010 : 81a9                       cmpa #TOK_TO        ; TOKEN FOR TO?
a012 : 2704                       beq  L8B13          ; YES
a014 : 81aa                       cmpa #TOK_SUB       ; TOKEN FOR SUB?
a016 : 26db                       bne  L8AEB          ; NO
a018 : 9d7c             L8B13     jsr  GETNCH         ; GET A CHARACTER FROM B
a01a : 2504                       blo  L8B1B          ; BRANCH IF NUMERIC
a01c : 9d82             L8B17     jsr  GETCCH         ; GET CURRENT BASIC INPU
a01e : 20d7                       bra  L8AEF          ; KEEP CHECKING THE LINE
a020 : 9e83             L8B1B     ldx  CHARAD         ; GET CURRENT INPUT ADDR
a022 : 3410                       pshs x              ; SAVE IT ON THE STACK
a024 : bd88ad                     jsr  LAF67          ; CONVERT DECIMAL BASIC 
a027 : 9e83                       ldx  CHARAD         ; GET CURRENT INPUT POIN
a029 : a682             L8B24     lda  ,-x            ; GET PREVIOUS INPUT CHA
a02b : bda390                     jsr  L90AA          ; CLEAR CARRY IF NUMERIC
a02e : 25f9                       blo  L8B24          ; BRANCH IF NON-NUMERIC
a030 : 3001                       leax $01,x          ; MOVE POINTER UP ONE
a032 : 1f10                       tfr  x,d            ; NOW ACCD POINTS TO ONE
a034 : e061                       subb $01,s          ; SUBTRACT PRE-NUMERIC P
a036 : c005                       subb #$05           ; MAKE SURE THERE ARE AT
                        *
a038 : 2720                       beq  L8B55          ; BRANCH IF EXACTLY 5
a03a : 250a                       blo  L8B41          ; BRANCH IF < 5
a03c : 3384                       leau ,x             ; TRANSFER X TO U
a03e : 50                         negb                ; NEGATE B
a03f : 3085                       leax b,x            ; MOVE X BACK B BYTES
a041 : bd9ecf                     jsr  L89B8          ; *MOVE BYTES FROM (U) T
                        *         *U   = END OF BASIC; (I) = NEW END OF BASIC
a044 : 2014                       bra  L8B55
                        * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER
a046 : 9f47             L8B41     stx  V47            ; SAVE END OF NUMERIC VA
a048 : 9e1b                       ldx  VARTAB         ; GET END OF BASIC PROGR
a04a : 9f43                       stx  V43            ; SAVE IT
AS09 Assembler for M6809 [1.42].                                     Page  110
--------------------------------- merge.a09 ----------------------------------

a04c : 50                         negb                ; NEGATE B
a04d : 3085                       leax b,x            ; ADD IT TO END OF NUMER
a04f : 9f41                       stx  V41            ; SAVE POINTER
a051 : 9f1b                       stx  VARTAB         ; STORE END OF BASIC PRO
a053 : bd8570                     jsr  LAC1E          ; ACCD = TOP OF ARRAYS -
a056 : 9e45                       ldx  V45            ; * GET AND SAVE THE
a058 : 9f83                       stx  CHARAD         ; * NEW CURRENT INPUT PO
a05a : 3510             L8B55     puls x              ; RESTORE POINTER TO STA
a05c : 8601                       lda  #$01           ; NEW LINE NUMBER FLAG
a05e : a784                       sta  ,x             ; * SAVE NEW LINE FLAG
a060 : a702                       sta  $02,x          ; *
a062 : a704                       sta  $04,x          ; *
a064 : d62b                       ldb  BINVAL         ; GET MS BYTE OF BINARY 
a066 : 2604                       bne  L8B67          ; BRANCH IF IT IS NOT ZE
a068 : c601                       ldb  #$01           ; ; SAVE A 1 IF BYTE IS 
                        *              ; THINK IT IS THE END OF A LINE
a06a : 6c02                       inc  $02,x          ; IF 2,x = 2, THEN PREVI
a06c : e701             L8B67     stb  $01,x          ; SAVE MS BYTE OF BINARY
a06e : d62c                       ldb  BINVAL+1       ; GET IS BYTE OF BINARY 
a070 : 2604                       bne  L8B71          ; BRANCH IF NOT A ZERO B
a072 : c601                       ldb  #$01           ; SAVE A 1 IF BYTE IS A 
a074 : 6c04                       inc  $04,x          ; IF 4,x = 2, THEN PREVI
a076 : e703             L8B71     stb  $03,x          ; SAVE LS BYTE OF BINARY
a078 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
a07a : 812c                       cmpa #','            ; IS IT A COMMA?
a07c : 279a                       beq  L8B13          ; YES - PROCESS ANOTHER 
a07e : 209c                       bra  L8B17          ; NO - GO GET AND PROCES
a080 : 9e19             L8B7B     ldx  TXTTAB         ; POINT X TO START OF BA
a082 : 301f                       leax -1,x           ; MOVE POINTER BACK ONE
a084 : 3001             L8B7F     leax $01,x          ; MOVE POINTER UP ONE
a086 : ec02                       ldd  $02,x          ; GET ADDRESS OF NEXT LI
a088 : dd68                       std  CURLIN         ; SAVE IT IN CURLIN
a08a : bd9f8e                     jsr  L8A86          ; RETURN IF END OF PROGR
a08d : 3003                       leax $03,x          ; SKIP OVER ADDRESS OF N
a08f : 3001             L8B8A     leax $01,x          ; MOVE POINTER UP ONE
a091 : a684             L8B8C     lda  ,x             ; GET CURRENT CHARACTER
a093 : 27ef                       beq  L8B7F          ; BRANCH IF END OF LINE
a095 : 4a                         deca                ; INPUT CHARACTER = 1? -
a096 : 271b                       beq  L8BAE          ; YES
a098 : 8002                       suba #$02           ; INPUT CHARACTER 3? - U
a09a : 26f3                       bne  L8B8A          ; NO
a09c : 3410                       pshs x              ; SAVE CURRENT POSITION 
a09e : 8ea0dd                     ldx  #L8BD9-1       ; POINT X TO 'UL' MESSAG
a0a1 : bd9292                     jsr  LB99C          ; PRINT STRING TO THE SC
a0a4 : aee4                       ldx  ,s             ; GET INPUT POINTER
a0a6 : ec01                       ldd  $01,x          ; GET THE UNDEFINED LINE
a0a8 : bd96c2                     jsr  LBDCC          ; CONVERT NUMBER IN ACCD
a0ab : bd96bb                     jsr  LBDC5          ; PRINT 'IN XXXX' XXXX =
a0ae : bd9253                     jsr  LB958          ; SEND A CR TO CONSOLE O
a0b1 : 3510                       puls x              ; GET INPUT POINTER BACK
a0b3 : 3410             L8BAE     pshs x              ; SAVE CURRENT POSITION 
a0b5 : ec01                       ldd  $01,x          ; LOAD ACCD WITH BINARY 
a0b7 : dd52                       std  FPA0+2         ; SAVE IN BOTTOM 2 BYTES
a0b9 : bd9d6a                     jsr  L880E          ; ADJUST REST OF FPA0 AS
a0bc : bd96cf                     jsr  LBDD9          ; CONVERT FPA0 TO ASCII,
a0bf : 3540                       puls u              ; LOAD U WITH PREVIOUS A
a0c1 : c605                       ldb  #$05           ; EACH EXPANDED LINE NUM
a0c3 : 3001             L8BBE     leax $01,x          ; MOVE POINTER FORWARD O
a0c5 : a684                       lda  ,x             ; GET AN ASCII BYTE
a0c7 : 2705                       beq  L8BC9          ; BRANCH IF END OF NUMBE
a0c9 : 5a                         decb                ; DECREMENT BYTE COUNTER
a0ca : a7c0                       sta  ,u+            ; STORE ASCII NUMBER IN 
AS09 Assembler for M6809 [1.42].                                     Page  111
--------------------------------- merge.a09 ----------------------------------

a0cc : 20f5                       bra  L8BBE          ; CHECK FOR ANOTHER DIGI
a0ce : 30c4             L8BC9     leax ,u             ; TRANSFER NEW LINE POIN
a0d0 : 5d                         tstb                ; DOES THE NEW LINE NUMB
a0d1 : 27be                       beq  L8B8C          ; YES - GO GET ANOTHER I
a0d3 : 31c4                       leay ,u             ; SAVE NEW LINE POINTER 
a0d5 : 33c5                       leau b,u            ; POINT U TO END OF 5 BY
a0d7 : bd9ecf                     jsr  L89B8          ; MOVE BYTES FROM (U) TO
a0da : 30a4                       leax ,y             ; LOAD (X) WITH NEW LINE
a0dc : 20b3                       bra  L8B8C          ; GO GET ANOTHER INPUT C
                        
a0de : 554c20           L8BD9     fcc  "UL "          ; UNKNOWN LINE NUMBER ME
a0e1 : 00                         fcb  0
                        
                        
a0e2 : bd905a           HEXDOL    jsr  LB740          ; CONVERT FPA0 INTO A PO
a0e5 : 8e01de                     ldx  #STRBUF+2      ; POINT TO TEMPORARY BUF
a0e8 : c604                       ldb  #$04           ; CONVERT 4 NIBBLES
a0ea : 3404             L8BE5     pshs b              ; SAVE NIBBLE COUNTER
a0ec : 5f                         clrb                ; CLEAR CARRY FLAG
a0ed : 8604                       lda  #$04           ; 4 SHIFTS
a0ef : 0853             L8BEA     asl  FPA0+3         ; * SHIFT BOTTOM TWO BYT
a0f1 : 0952                       rol  FPA0+2         ; * FPA0 LEFT ONE BIT (X
a0f3 : 59                         rolb                ; IF OVERFLOW, ACCB <> 0
a0f4 : 4a                         deca                ; * DECREMENT SHIFT COUN
a0f5 : 26f8                       bne  L8BEA          ; * BRANCH IF NOT DONE
a0f7 : 5d                         tstb                ; CHECK FOR OVERFLOW
a0f8 : 260a                       bne  L8BFF          ; BRANCH IF OVERFLOW
a0fa : a6e4                       lda  ,s             ; * GET NIBBLE COUNTER,
a0fc : 4a                         deca                ; * DECREMENT IT AND
a0fd : 2705                       beq  L8BFF          ; * BRANCH IF DONE
a0ff : 8c01de                     cmpx #STRBUF+2      ; DO NOT DO A CONVERSION
a102 : 270c                       beq  L8C0B          ; BYTE IS FOUND - LEADIN
a104 : cb30             L8BFF     addb #'0'            ; ADD IN ASCII ZERO
a106 : c139                       cmpb #'9'           ; COMPARE TO ASCII 9
a108 : 2302                       bls  L8C07          ; BRANCH IF < 9
a10a : cb07                       addb #7             ; ADD ASCII OFFSET IF HE
a10c : e780             L8C07     stb  ,x+            ; STORE HEX VALUE AND AD
a10e : 6f84                       clr  ,x             ; CLEAR NEXT BYTE - END 
a110 : 3504             L8C0B     puls b              ; * GET NIBBLE COUNTER,
a112 : 5a                         decb                ; * DECREMENT IT AND
a113 : 26d5                       bne  L8BE5          ; * BRANCH IF NOT DONE
a115 : 3262                       leas $02,s          ; PURGE RETURN ADDRESS O
a117 : 8e01dd                     ldx  #STRBUF+1      ; RESET POINTER
a11a : 7e8e34                     jmp  LB518          ; SAVE STRING ON STRING 
                        * PROCESS EXCLAMATION POINT
a11d : 8601             L8E37     lda  #$01           ; * SET SPACES
a11f : 9799                       sta  VD9            ; * COUNTER = 1		 
                        * PROCESS STRING ITEM - LIST
a121 : 5a               L8E3B     decb                ; DECREMENT FORMAT STRIN
a122 : bda2be                     jsr  L8FD8          ; SEND A '+' TO CONSOLE 
a125 : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
a127 : 10270093                   lbeq L8ED8          ; EXIT PRINT USING IF EN
a12b : d793                       stb  VD3            ; SAVE REMAINDER FORMAT 
a12d : bd8a78                     jsr  LB156          ; EVALUATE EXPRESSION
a130 : bd8a68                     jsr  LB146          ; 'TM' ERROR IF NUMERIC 
a133 : 9e52                       ldx  FPA0+2         ; * GET ITEM - LIST DESC
a135 : 9f4d                       stx  V4D            ; * AND SAVE IT IN V4D
a137 : d699                       ldb  VD9            ; GET SPACES COUNTER
a139 : bd8fc8                     jsr  LB6AD          ; PUT ACCB BYTES INTO ST
a13c : bd9295                     jsr  LB99F          ; PRINT THE FORMATTED ST
                        * PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING 
a13f : 9e52                       ldx  FPA0+2         ; POINT X TO FORMATTED S
AS09 Assembler for M6809 [1.42].                                     Page  112
--------------------------------- merge.a09 ----------------------------------

a141 : d699                       ldb  VD9            ; GET SPACES COUNTER
a143 : e084                       subb ,x             ; SUBTRACT LENGTH OF FOR
a145 : 5a               L8E5F     decb                ; DECREMENT DIFFERENCE
a146 : 102b014f                   lbmi L8FB3          ; GO INTERPRET ANOTHER I
a14a : bd92a2                     jsr  LB9AC          ; PAD FORMAT STRING WITH
a14d : 20f6                       bra  L8E5F          ; KEEP PADDING
                        * PERCENT SIGN - PROCESS A %SPACES% COMMAND
a14f : d793             L8E69     stb  VD3            ; * SAVE THE CURRENT FOR
a151 : 9f0f                       stx  TEMPTR         ; * COUNTER AND POINTER
a153 : 8602                       lda  #$02           ; INITIAL SPACES COUNTER
a155 : 9799                       sta  VD9            ; SAVE IN SPACES COUNTER
a157 : a684             L8E71     lda  ,x             ; GET A CHARACTER FROM F
a159 : 8125                       cmpa #'%'           ; COMPARE TO TERMINATOR 
a15b : 27c4                       beq  L8E3B          ; BRANCH IF END OF SPACE
a15d : 8120                       cmpa #' '           ; BLANK
a15f : 2607                       bne  L8E82          ; BRANCH IF ILLEGAL CHAR
a161 : 0c99                       inc  VD9            ; ADD ONE TO SPACES COUN
a163 : 3001                       leax $01,x          ; MOVE FORMAT POINTER UP
a165 : 5a                         decb                ; DECREMENT LENGTH COUNT
a166 : 26ef                       bne  L8E71          ; BRANCH IF NOT END OF F
a168 : 9e0f             L8E82     ldx  TEMPTR         ; * RESTORE CURRENT FORM
a16a : d693                       ldb  VD3            ; * AND POINTER TO POSIT
a16c : 8625                       lda  #'%'           ; SEND A '%' TO CONSOLE 
                        * ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN
a16e : bda2be           L8E88     jsr  L8FD8          ; SEND A '+' TO CONSOLE 
a171 : bd805c                     jsr  PUTCHR         ; SEND CHARACTER TO CONS
a174 : 2029                       bra  L8EB9          ; GET NEXT CHARACTER IN 
                        
                        * PRINT RAM HOOK
a176 : 81ba             XVEC9     cmpa #TOK_USING     ; USING TOKEN
a178 : 2701                       beq  L8E95          ; BRANCH IF PRINT USING
a17a : 39                         rts
                        
                        * PRINT USING
                        * VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE
                        * BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FOR
                        * BIT 3 = PRE SIGN FORCE; BIT 2 = POST SIGN FORCE; BIT
a17b : 3262             L8E95     leas $02,s          ; PURGE RETURN ADDRESS O
a17d : bd8a7a                     jsr  LB158          ; EVALUATE FORMAT STRING
a180 : bd8a68                     jsr  LB146          ; 'TM' ERROR IF VARIABLE
a183 : c63b                       ldb  #';'           ; CHECK FOR ITEM LIST SE
a185 : bd8b91                     jsr  LB26F          ; SYNTAX CHECK FOR ;
a188 : 9e52                       ldx  FPA0+2         ; * GET FORMAT STRING DE
a18a : 9f95                       stx  VD5            ; * AND SAVE IT IN VD5
a18c : 2006                       bra  L8EAE          ; GO PROCESS FORMAT STRI
a18e : 9697             L8EA8     lda  VD7            ; *CHECK NEXT PRINT ITEM
a190 : 2708                       beq  L8EB4          ; *'FC' ERROR IF NO FURT
a192 : 9e95                       ldx  VD5            ; RESET FORMAT STRING PO
a194 : 0f97             L8EAE     clr  VD7            ; RESET NEXT PRINT ITEM 
a196 : e684                       ldb  ,x             ; GET LENGTH OF FORMAT S
a198 : 2603                       bne  L8EB7          ; INTERPRET FORMAT STRIN
a19a : 7e8d66           L8EB4     jmp  LB44A          ; 'FC' ERROR IF FORMAT S
a19d : ae02             L8EB7     ldx  $02,x          ; POINT X TO START OF FO
                        * INTERPRET THE FORMAT STRING
a19f : 0f9a             L8EB9     clr  VDA            ; CLEAR THE STATUS BYTE
a1a1 : 0f99             L8EBB     clr  VD9            ; CLEAR LEFT DIGIT COUNT
a1a3 : a680                       lda  ,x+            ; GET A CHARACTER FROM F
a1a5 : 8121                       cmpa #'!'           ; EXCLAMATION POINT?
a1a7 : 1027ff72                   beq L8E37           ; YES - STRING TYPE FORM
a1ab : 8123                       cmpa #'#'           ; NUMBER SIGN? (DIGIT LO
a1ad : 275b                       beq  L8F24          ; YES - NUMERIC TYPE FOR
a1af : 5a                         decb                ; DECREMENT FORMAT STRIN
AS09 Assembler for M6809 [1.42].                                     Page  113
--------------------------------- merge.a09 ----------------------------------

a1b0 : 2616                       bne  L8EE2          ; BRANCH IF NOT DONE
a1b2 : bda2be                     jsr  L8FD8          ; SEND A '+' TO CONSOLE 
a1b5 : bd805c                     jsr  PUTCHR         ; SEND CHARACTER TO CONS
a1b8 : 9d82             L8ED2     jsr  GETCCH         ; GET CURRENT CHARACTER 
a1ba : 26d2                       bne  L8EA8          ; BRANCH IF NOT END OF L
a1bc : 9697                       lda  VD7            ; GET NEXT PRINT ITEM FL
a1be : 2603             L8ED8     bne  L8EDD          ; BRANCH IF MORE PRINT I
a1c0 : bd9253                     jsr  LB958          ; SEND A CARRIAGE RETURN
a1c3 : 9e95             L8EDD     ldx  VD5            ; POINT X TO FORMAT STRI
a1c5 : 7e8f74                     jmp  LB659          ; RETURN ADDRESS AND LEN
a1c8 : 812b             L8EE2     cmpa #'+'           ; CHECK FOR '+' (PRE-SIG
a1ca : 2609                       bne  L8EEF          ; NO PLUS
a1cc : bda2be                     jsr  L8FD8          ; SEND A '+' TO CONSOLE 
a1cf : 8608                       lda  #$08           ; * LOAD THE STATUS BYTE
a1d1 : 979a                       sta  VDA            ; * PRE-SIGN FORCE FLAG
a1d3 : 20cc                       bra  L8EBB          ; INTERPRET THE REST OF 
a1d5 : 812e             L8EEF     cmpa #'.'           ; DECIMAL POINT?
a1d7 : 274e                       beq  L8F41          ; YES
a1d9 : 8125                       cmpa #'%'           ; PERCENT SIGN?
a1db : 1027ff70                   lbeq L8E69          ; YES
a1df : a184                       cmpa ,x             ; COMPARE THE PRESENT FO
                        *              ; CHARACTER TO THE NEXT ONE IN THE STRI
a1e1 : 268b             L8EFB     bne  L8E88          ; NO MATCH - ILLEGAL CHA
                        * TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING
a1e3 : 8124                       cmpa #'$'           ; DOLLAR SIGN?
a1e5 : 2719                       beq  L8F1A          ; YES - MAKE THE DOLLAR 
a1e7 : 812a                       cmpa #'*'           ; ASTERISK?
a1e9 : 26f6                       bne  L8EFB          ; NO - ILLEGAL CHARACTER
a1eb : 969a                       lda  VDA            ; * GRAB THE STATUS BYTE
a1ed : 8a20                       ora  #$20           ; * TO INDICATE THAT THE
a1ef : 979a                       sta  VDA            ; * BE LEFT PADDED WITH 
a1f1 : c102                       cmpb #2             ; * CHECK TO SEE IF THE 
a1f3 : 2511                       blo  L8F20          ; * CHARACTERS IN THE FO
a1f5 : a601                       lda  $01,x          ; GET THE NEXT CHARACTER
a1f7 : 8124                       cmpa #'$'           ; CHECK FOR **$
a1f9 : 260b                       bne  L8F20          ; CHECK FOR MORE CHARACT
a1fb : 5a                         decb                ; DECREMENT STRING LENGT
a1fc : 3001                       leax $01,x          ; MOVE FORMAT STRING POI
a1fe : 0c99                       inc  VD9            ; ADD ONE TO LEFT DIGIT 
                        *              ; FLOATING DOLLAR SIGN COMBINATION
a200 : 969a             L8F1A     lda  VDA            ; * GET THE STATUS BYTE 
a202 : 8a10                       ora  #$10           ; * BIT 4 TO INDICATE A
a204 : 979a                       sta  VDA            ; * FLOATING DOLLAR SIGN
a206 : 3001             L8F20     leax $01,x          ; MOVE FORMAT STRING POI
a208 : 0c99                       inc  VD9            ; ADD ONE TO LEFT DIGIT 
                        * PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT 
a20a : 0f98             L8F24     clr  VD8            ; CLEAR THE RIGHT DIGIT 
a20c : 0c99             L8F26     inc  VD9            ; ADD ONE TO LEFT DIGIT 
a20e : 5a                         decb                ; DECREMENT FORMAT STRIN
a20f : 2749                       beq  L8F74          ; BRANCH IF END OF FORMA
a211 : a680                       lda  ,x+            ; GET THE NEXT FORMAT CH
a213 : 812e                       cmpa #'.'           ; DECIMAL POINT?
a215 : 271e                       beq  L8F4F          ; YES
a217 : 8123                       cmpa #'#'           ; NUMBER SIGN?
a219 : 27f1                       beq  L8F26          ; YES
a21b : 812c                       cmpa #','            ; COMMA?
a21d : 2621                       bne  L8F5A          ; NO
a21f : 969a                       lda  VDA            ; * GET THE STATUS BYTE
a221 : 8a40                       ora  #$40           ; * AND SET BIT 6 WHICH 
a223 : 979a                       sta  VDA            ; * COMMA SEPARATOR FLAG
a225 : 20e5                       bra  L8F26          ; PROCESS MORE CHARACTER
                        * PROCESS DECIMAL POINT IF NO DIGITS TO LEFT OF IT
AS09 Assembler for M6809 [1.42].                                     Page  114
--------------------------------- merge.a09 ----------------------------------

a227 : a684             L8F41     lda  ,x             ; GET NEXT FORMAT CHARAC
a229 : 8123                       cmpa #'#'           ; IS IT A NUMBER SIGN?
a22b : 1026ff3f                   lbne L8E88          ; NO
a22f : 8601                       lda  #1             ; * SET THE RIGHT DIGIT 
a231 : 9798                       sta  VD8            ; * ALLOW ONE SPOT FOR D
a233 : 3001                       leax $01,x          ; MOVE FORMAT POINTER UP
                        * PROCESS DIGITS TO RIGHT OF DECIMAL POINT
a235 : 0c98             L8F4F     inc  VD8            ; ADD ONE TO RIGHT DIGIT
a237 : 5a                         decb                ; DECREMENT FORMAT LENGT
a238 : 2720                       beq  L8F74          ; BRANCH IF END OF FORMA
a23a : a680                       lda  ,x+            ; GET A CHARACTER FROM F
a23c : 8123                       cmpa #'#'           ; IS IT NUMBER SIGN?
a23e : 27f5                       beq  L8F4F          ; YES - KEEP CHECKING
                        * CHECK FOR EXPONENTIAL FORCE
a240 : 815e             L8F5A     cmpa #$5E           ; CHECK FOR UP ARROW
a242 : 2616                       bne  L8F74          ; NO UP ARROW
a244 : a184                       cmpa ,x             ; IS THE NEXT CHARACTER 
a246 : 2612                       bne  L8F74          ; NO
a248 : a101                       cmpa $01,x          ; AND THE NEXT CHARACTER
a24a : 260e                       bne  L8F74          ; NO
a24c : a102                       cmpa $02,x          ; HOW ABOUT THE 4TH CHAR
a24e : 260a                       bne  L8F74          ; NO, ALSO
a250 : c104                       cmpb #4             ; * CHECK TO SEE IF THE 
a252 : 2506                       blo  L8F74          ; * FORMAT STRING AND BR
a254 : c004                       subb #4             ; * MOVE POINTER UP 4 AN
a256 : 3004                       leax $04,x          ; * FOUR FROM LENGTH
a258 : 0c9a                       inc  VDA            ; INCREMENT STATUS BYTE 
                        
                        * CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMA
a25a : 301f             L8F74     leax -1,x           ; MOVE POINTER BACK ONE
a25c : 0c99                       inc  VD9            ; ADD ONE TO LEFT DIGIT 
a25e : 969a                       lda  VDA            ; * PRE-SIGN
a260 : 8508                       bita #$08           ; * FORCE AND
a262 : 2618                       bne  L8F96          ; * BRANCH IF SET
a264 : 0a99                       dec  VD9            ; DECREMENT LEFT DIGIT -
a266 : 5d                         tstb                ; * CHECK LENGTH COUNTER
a267 : 2713                       beq  L8F96          ; * IF END OF FORMAT STR
a269 : a684                       lda  ,x             ; GET NEXT FORMAT STRING
a26b : 802d                       suba #'-'           ; CHECK FOR MINUS SIGN
a26d : 2706                       beq  L8F8F          ; BRANCH IF MINUS SIGN
a26f : 81fe                       cmpa #$FE           ; * WAS cmpa #('+')-('-'
a271 : 2609                       bne  L8F96          ; BRANCH IF NO PLUS SIGN
a273 : 8608                       lda  #$08           ; GET THE PRE-SIGN FORCE
a275 : 8a04             L8F8F     ora  #$04           ; 'OR' IN POST-SIGN FORC
a277 : 9a9a                       ora  VDA            ; 'OR' IN THE STATUS BYT
a279 : 979a                       sta  VDA            ; SAVE THE STATUS BYTE
a27b : 5a                         decb                ; DECREMENT FORMAT STRIN
                        
                        * EVALUATE NUMERIC ITEM-LIST
a27c : 9d82             L8F96     jsr  GETCCH         ; GET CURRENT CHARACTER
a27e : 1027ff3c                   lbeq L8ED8          ; BRANCH IF END OF LINE
a282 : d793                       stb  VD3            ; SAVE FORMAT STRING LEN
a284 : bd8a63                     jsr  LB141          ; EVALUATE EXPRESSION
a287 : 9699                       lda  VD9            ; GET THE LEFT DIGIT COU
a289 : 9b98                       adda VD8            ; ADD IT TO THE RIGHT DI
a28b : 8111                       cmpa #17            ; *
a28d : 1022ead5                   lbhi LB44A          ; *'FC' ERROR IF MORE TH
a291 : bda2cb                     jsr  L8FE5          ; CONVERT ITEM-LIST TO F
a294 : 301f                       leax -1,x           ; MOVE BUFFER POINTER BA
a296 : bd9292                     jsr  LB99C          ; DISPLAY THE FORMATTED 
a299 : 0f97             L8FB3     clr  VD7            ; RESET NEXT PRINT ITEM 
a29b : 9d82                       jsr  GETCCH         ; GET CURRENT INPUT CHAR
AS09 Assembler for M6809 [1.42].                                     Page  115
--------------------------------- merge.a09 ----------------------------------

a29d : 270d                       beq  L8FC6          ; BRANCH IF END OF LINE
a29f : 9797                       sta  VD7            ; SAVE CURRENT CHARACTER
a2a1 : 813b                       cmpa #';'           ; * CHECK FOR ; - ITEM-L
a2a3 : 2705                       beq  L8FC4          ; * BRANCH IF SEMICOLON
a2a5 : bd8b8f                     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
a2a8 : 2002                       bra  L8FC6          ; PROCESS NEXT PRINT ITE
a2aa : 9d7c             L8FC4     jsr  GETNCH         ; GET NEXT INPUT CHARACT
a2ac : 9e95             L8FC6     ldx  VD5            ; GET FORMAT STRING DESC
a2ae : e684                       ldb  ,x             ; GET LENGTH OF FORMAT S
a2b0 : d093                       subb VD3            ; SUBTRACT AMOUNT OF FOR
a2b2 : ae02                       ldx  $02,x          ; *GET FORMAT STRING STA
a2b4 : 3a                         abx                 ; *POINTER TO START OF U
a2b5 : d693                       ldb  VD3            ; * GET AMOUNT OF UNUSED
a2b7 : 1026fee4                   lbne L8EB9          ; * REINTERPRET FORMAT S
a2bb : 7ea1b8                     jmp  L8ED2          ; REINTERPRET FORMAT STR
                        *         USED ON LAST PRINT ITEM
                        
                        * PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
a2be : 3402             L8FD8     pshs a              ; RESTORE ACCA AND RETUR
a2c0 : 862b                       lda  #'+'           ; GET ASCII PLUS SIGN
a2c2 : 0d9a                       tst  VDA            ; * CHECK THE STATUS BYT
a2c4 : 2703                       beq  L8FE3          ; * RETURN IF = 0
a2c6 : bd805c                     jsr  PUTCHR         ; SEND A CHARACTER TO CO
a2c9 : 3582             L8FE3     puls a,pc           ; RETURN ACCA AND RETURN
                        
                        * CONVERT ITEM-LIST TO DECIMAL ASCII STRING
a2cb : ce01e0           L8FE5     ldu  #STRBUF+4      ; POINT U TO STRING BUFF
a2ce : c620                       ldb  #SPACE         ; BLANK
a2d0 : 969a                       lda  VDA            ; * GET THE STATUS FLAG 
a2d2 : 8508                       bita #$08           ; * CHECK FOR A PRE-SIGN
a2d4 : 2702                       beq  L8FF2          ; * BRANCH IF NO PRE-SIG
a2d6 : c62b                       ldb  #'+'           ; PLUS SIGN
a2d8 : 0d54             L8FF2     tst  FP0SGN         ; CHECK THE SIGN OF FPA0
a2da : 2a04                       bpl  L8FFA          ; BRANCH IF POSITIVE
a2dc : 0f54                       clr  FP0SGN         ; FORCE FPA0 SIGN TO BE 
a2de : c62d                       ldb  #'-'           ; MINUS SIGN
a2e0 : e7c0             L8FFA     stb  ,u+            ; SAVE THE SIGN IN BUFFE
a2e2 : c630                       ldb  #'0'            ; * PUT A ZERO INTO THE
a2e4 : e7c0                       stb  ,u+            ; *
a2e6 : 8401                       anda #$01           ; * CHECK THE EXPONENTIA
a2e8 : 10260107                   lbne L910D          ; * THE STATUS BYTE - BR
a2ec : 8e96b6                     ldx  #LBDC0         ; POINT X TO FLOATING PO
a2ef : bd9596                     jsr  LBCA0          ; COMPARE FPA0 TO (X)
a2f2 : 2b15                       bmi  L9023          ; BRANCH IF FPA0 < 1E+09
a2f4 : bd96cf                     jsr  LBDD9          ; CONVERT FP NUMBER TO A
a2f7 : a680             L9011     lda  ,x+            ; * ADVANCE POINTER TO E
a2f9 : 26fc                       bne  L9011          ; * ASCII STRING (ZERO B
a2fb : a682             L9015     lda  ,-x            ; MOVE THE
a2fd : a701                       sta  $01,x          ; ENTIRE STRING
a2ff : 8c01df                     cmpx #STRBUF+3      ; UP ONE
a302 : 26f7                       bne  L9015          ; BYTE
a304 : 8625                       lda  #'%'           ; * INSERT A % SIGN AT S
a306 : a784                       sta  ,x             ; * STRING - OVERFLOW ER
a308 : 39                         rts
                        
a309 : 964f             L9023     lda  FP0EXP         ; GET EXPONENT OF FPA0
a30b : 9747                       sta  V47            ; AND SAVE IT IN V74
a30d : 2703                       beq  L902C          ; BRANCH IF FPA0 = 0
a30f : bda4b3                     jsr  L91CD          ; CONVERT FPA0 TO NUMBER
                        *              ; PLACES TO LEFT OF DECIMAL POINT
a312 : 9647             L902C     lda  V47            ; GET BASE 10 EXPONENT O
a314 : 102b0081                   lbmi L90B3          ; BRANCH IF FPA0 < 100,0
AS09 Assembler for M6809 [1.42].                                     Page  116
--------------------------------- merge.a09 ----------------------------------

a318 : 40                         nega                ; * CALCULATE THE NUMBER
a319 : 9b99                       adda VD9            ; * SUBTRACT BASE 10 EXP
a31b : 8009                       suba #$09           ; * 9 PLACES TO LEFT OF 
a31d : bda3d0                     jsr  L90EA          ; PUT ACCA ZEROES IN STR
a320 : bda549                     jsr  L9263          ; INITIALIZE DECIMAL POI
a323 : bda4e8                     jsr  L9202          ; CONVERT FPA0 TO DECIMA
a326 : 9647                       lda  V47            ; * GET BASE 10 EXPONENT
a328 : bda567                     jsr  L9281          ; * ZEROES IN STRING BUF
a32b : 9647                       lda  V47            ; WASTED INSTRUCTION - S
a32d : bda52f                     jsr  L9249          ; CHECK FOR DECIMAL POIN
a330 : 9698                       lda  VD8            ; GET THE RIGHT DIGIT CO
a332 : 2602                       bne  L9050          ; BRANCH IF RIGHT DIGlT 
a334 : 335f                       leau -1,u           ; * MOVE BUFFER POINTER 
                        *                             ; * DECIMAL POINT IF NO 
a336 : 4a               L9050     deca                ; SUBTRACT ONE (DECIMAL 
a337 : bda3d0                     jsr  L90EA          ; PUT ACCA ZEROES INTO B
a33a : bda46b           L9054     jsr  L9185          ; INSERT ASTERISK PADDIN
a33d : 4d                         tsta                ; WAS THERE A POST-SIGN?
a33e : 2706                       beq  L9060          ; NO
a340 : c12a                       cmpb #'*'           ; IS THE FIRST CHARACTER
a342 : 2702                       beq  L9060          ; YES
a344 : e7c0                       stb  ,u+            ; STORE THE POST-SIGN
a346 : 6fc4             L9060     clr  ,u             ; CLEAR THE LAST CHARACT
                        *
                        * REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE
                        * STRING BUFFER TO THE LEFT OF THE DECIMAL POINT
a348 : 8e01df                     ldx  #STRBUF+3      ; POINT X TO THE START O
a34b : 3001             L9065     leax $01,x          ; MOVE BUFFER POINTER UP
a34d : 9f0f                       stx  TEMPTR         ; SAVE BUFFER POINTER IN
a34f : 963a                       lda  VARPTR+1       ; * GET ADDRESS OF DECIM
a351 : 9010                       suba TEMPTR+1       ; * CURRENT POSITION AND
a353 : 9099                       suba VD9            ; * THE RESULT WILL BE Z
                        *              ; * TO THE FIRST DIGIT OF THE FORMAT ST
a355 : 2738                       beq  L90A9          ; RETURN IF NO DIGITS TO
a357 : a684                       lda  ,x             ; GET THE CURRENT BUFFER
a359 : 8120                       cmpa #SPACE         ; SPACE?
a35b : 27ee                       beq  L9065          ; YES - ADVANCE POINTER
a35d : 812a                       cmpa #'*'           ; ASTERISK?
a35f : 27ea                       beq  L9065          ; YES - ADVANCE POINTER
a361 : 4f                         clra                ; A ZERO ON THE STACK IS
a362 : 3402             L907C     pshs a              ; PUSH A CHARACTER ONTO 
a364 : a680                       lda  ,x+            ; GET NEXT CHARACTER FRO
a366 : 812d                       cmpa #'-'           ; MINUS SIGN?
a368 : 27f8                       beq  L907C          ; YES
a36a : 812b                       cmpa #'+'           ; PLUS SIGN?
a36c : 27f4                       beq  L907C          ; YES
a36e : 8124                       cmpa #'$'           ; DOLLAR SIGN?
a370 : 27f0                       beq  L907C          ; YES
a372 : 8130                       cmpa #'0'            ; ZERO?
a374 : 260e                       bne  L909E          ; NO - ERROR
a376 : a601                       lda  $01,x          ; GET CHARACTER FOLLOWIN
a378 : 8d16                       bsr  L90AA          ; CLEAR CARRY IF NUMERIC
a37a : 2508                       blo  L909E          ; BRANCH IF NOT A NUMERI
a37c : 3502             L9096     puls a              ; * PULL A CHARACTER OFF
a37e : a782                       sta  ,-x            ; * AND PUT IT BACK IN T
a380 : 26fa                       bne  L9096          ; * KEEP GOING UNTIL ZER
a382 : 20c7                       bra  L9065          ; KEEP CLEANING UP THE I
a384 : 3502             L909E     puls a              ;
a386 : 4d                         tsta                ; * THE STACK AND EXIT W
a387 : 26fb                       bne  L909E          ; * ZERO FLAG FOUND
a389 : 9e0f                       ldx  TEMPTR         ; GET THE STRING BUFFER 
a38b : 8625                       lda  #'%'           ; * PUT A % SIGN BEFORE 
AS09 Assembler for M6809 [1.42].                                     Page  117
--------------------------------- merge.a09 ----------------------------------

a38d : a782                       sta  ,-x            ; * INDICATE AN ERROR
a38f : 39               L90A9     rts
                        *
                        * CLEAR CARRY IF NUMERIC
a390 : 8130             L90AA     cmpa #'0'            ; ASCII ZERO
a392 : 2504                       blo  L90B2          ; RETURN IF ACCA < ASCII
a394 : 803a                       suba #$3A           ; *  #'9'+1
a396 : 80c6                       suba #$C6           ; * #-('9'+1)  CARRY CLE
a398 : 39               L90B2     rts
                        *
                        * PROCESS AN ITEM-LIST WHICH IS < 100,000,000
a399 : 9698             L90B3     lda  VD8            ; GET RIGHT DIGIT COUNTE
a39b : 2701                       beq  L90B8          ; BRANCH IF NO FORMATTED
a39d : 4a                         deca                ; SUBTRACT ONE FOR DECIM
a39e : 9b47             L90B8     adda V47            ; *ADD THE BASE 10 EXPON
                        *         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO
                        *         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMA
a3a0 : 2b01                       bmi  L90BD          ; IF ACCA >= 0 THEN NO S
a3a2 : 4f                         clra                ; FORCE SHIFT COUNTER = 
a3a3 : 3402             L90BD     pshs a              ; SAVE INITIAL SHIFT COU
a3a5 : 2a0a             L90BF     bpl  L90CB          ; EXIT ROUTINE IF POSITI
a3a7 : 3402                       pshs a              ; SAVE SHIFT COUNTER ON 
a3a9 : bd9478                     jsr  LBB82          ; DIVIDE FPA0 BY 10 - SH
a3ac : 3502                       puls a              ; GET SHIFT COUNTER FROM
a3ae : 4c                         inca                ; BUMP SHIFT COUNTER UP 
a3af : 20f4                       bra  L90BF          ; CHECK FOR FURTHER DIVI
a3b1 : 9647             L90CB     lda  V47            ; * GET BASE 10 EXPONENT
a3b3 : a0e0                       suba ,s+            ; * AND SAVE NEW BASE 10
a3b5 : 9747                       sta  V47            ; * FPA0 WAS SHIFTED ABO
a3b7 : 8b09                       adda #$09           ; * ADD NINE (SIGNIFICAN
a3b9 : 2b19                       bmi  L90EE          ; * ZEROES TO THE LEFT O
a3bb : 9699                       lda  VD9            ; *DETERMINE HOW MANY FI
a3bd : 8009                       suba #$09           ; *POINT. GET THE NUMBER
a3bf : 9047                       suba V47            ; *POINT, SUBTRACT THE B
a3c1 : 8d0d                       bsr  L90EA          ; *(UNNORMALIZATION)-THE
a3c3 : bda549                     jsr  L9263          ; INITIALIZE DECIMAL POI
a3c6 : 201d                       bra  L90FF          ; PROCESS THE REMAINDER 
                        *
                        * PUT (ACCA+1) ASCII ZEROES IN BUFFER
a3c8 : 3402             L90E2     pshs a              ; SAVE ZERO COUNTER
a3ca : 8630                       lda  #'0'            ; * INSERT A ZERO INTO
a3cc : a7c0                       sta  ,u+            ; * THE BUFFER
a3ce : 3502                       puls a              ; RESTORE ZERO COUNTER
                        
                        * PUT ACCA ASCII ZEROES INTO THE BUFFER
a3d0 : 4a               L90EA     deca                ; DECREMENT ZERO COUNTER
a3d1 : 2af5                       bpl  L90E2          ; BRANCH IF NOT DONE
a3d3 : 39                         rts
                        
a3d4 : 9699             L90EE     lda  VD9            ; * GET THE LEFT DIGIT C
a3d6 : 8df8                       bsr  L90EA          ; * THAT MANY ZEROES IN 
a3d8 : bda533                     jsr  L924D          ; PUT THE DECIMAL POINT 
a3db : 86f7                       lda  #-9            ; *DETERMINE HOW MANY FI
a3dd : 9047                       suba V47            ; *AND SIGNIFICANT DATA.
a3df : 8def                       bsr  L90EA          ; *(UNNORMALIZATION) AND
a3e1 : 0f45                       clr  V45            ; CLEAR THE DECIMAL POIN
a3e3 : 0f97                       clr  VD7            ; CLEAR THE COMMA COUNTE
a3e5 : bda4e8           L90FF     jsr  L9202          ; DECODE FPA0 INTO A DEC
a3e8 : 9698                       lda  VD8            ; GET THE RIGHT DIGIT CO
a3ea : 2602                       bne  L9108          ; BRANCH IF RIGHT DIGIT 
a3ec : de39                       ldu  VARPTR         ; RESET BUFFER PTR TO TH
a3ee : 9b47             L9108     adda V47            ; *ADD BASE 10 EXPONENT 
AS09 Assembler for M6809 [1.42].                                     Page  118
--------------------------------- merge.a09 ----------------------------------

                        * *FILLER ZEROES TO BE OUTPUT ; TO THE RIGHT OF LAST S
                        *         *SIGNIFICANT DATA
a3f0 : 7ea336                     jmp  L9050          ; INSERT LEADING ASTERIS
                        *
                        * FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FO
a3f3 : 964f             L910D     lda  FP0EXP         ; * GET EXPONENT OF FPA0
a3f5 : 3402                       pshs a              ; * SAVE IT ON THE STACK
a3f7 : 2703                       beq  L9116          ; BRANCH IF FPA0 = 0
a3f9 : bda4b3                     jsr  L91CD          ; *CONVERT FPA0 INTO A N
                        *         *DIGITS TO THE LEFT OF THE DECIMAL POINT
a3fc : 9698             L9116     lda  VD8            ; GET THE RIGHT DIGIT CO
a3fe : 2701                       beq  L911B          ; BRANCH IF NO FORMATTED
a400 : 4a                         deca                ; SUBTRACT ONE FOR THE D
a401 : 9b99             L911B     adda VD9            ; ADD TO THE LEFT DIGIT 
a403 : 7f01df                     clr  STRBUF+3       ; CLEAR BUFFER BYTE AS T
a406 : d69a                       ldb  VDA            ; * GET THE STATUS BYTE 
a408 : c404                       andb #$04           ; * POST-BYTE FORCE; BRA
a40a : 2603                       bne  L9129          ; * A POST-BYTE FORCE
a40c : 7301df                     com  STRBUF+3       ; TOGGLE BUFFER BYTE TO 
a40f : bb01df           L9129     adda STRBUF+3       ; SUBTRACT 1 IF NO POST 
a412 : 8009                       suba #$09           ; *SUBTRACT 9 (DUE TO TH
                        *         *SIGNIFICANT DIGITS TO LEFT OF DECIMAL POINT
a414 : 3402                       pshs a              ; * SAVE SHIFT COUNTER O
                        *         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE 
                        *         FORMATTED PLACES TO THE RIGHT OF THE DECIMAL
a416 : 2a0a             L9130     bpl  L913C          ; NO MORE SHIFTS WHEN AC
a418 : 3402                       pshs a              ; SAVE SHIFT COUNTER
a41a : bd9478                     jsr  LBB82          ; DIVIDE FPA0 BY 10 - SH
a41d : 3502                       puls a              ; RESTORE THE SHIFT COUN
a41f : 4c                         inca                ; ADD 1 TO SHIFT COUNTER
a420 : 20f4                       bra  L9130          ; CHECK FOR FURTHER SHIF
a422 : a6e4             L913C     lda  ,s             ; *GET THE INITIAL VALUE
a424 : 2b01                       bmi  L9141          ; *AND BRANCH IF SHIFTIN
a426 : 4f                         clra                ; RESET ACCA IF NO SHIFT
a427 : 40               L9141     nega                ; *CALCULATE THE POSITIO
a428 : 9b99                       adda VD9            ; *NEGATING SHIFT COUNTE
a42a : 4c                         inca                ; *PLUS ONE AND THE POST
a42b : bb01df                     adda STRBUF+3       ; *
a42e : 9745                       sta  V45            ; SAVE DECIMAL POINT COU
a430 : 0f97                       clr  VD7            ; CLEAR COMMA COUNTER - 
a432 : bda4e8                     jsr  L9202          ; CONVERT FPA0 INTO ASCI
a435 : 3502                       puls a              ; * GET THE INITIAL VALU
a437 : bda567                     jsr  L9281          ; * INSERT THAT MANY ZER
a43a : 9698                       lda  VD8            ; *GET THE RIGHT DIGIT C
a43c : 2602                       bne  L915A          ; *IF NOT ZERO
a43e : 335f                       leau -1,u           ; MOVE BUFFER POINTER BA
                        
                        * CALCULATE VALUE OF EXPONENT AND PUT IN STRING BUFFER
a440 : e6e0             L915A     ldb  ,s+            ; GET ORIGINAL EXPONENT 
a442 : 2709                       beq  L9167          ; BRANCH IF EXPONENT = 0
a444 : d647                       ldb  V47            ; GET BASE 10 EXPONENT
a446 : cb09                       addb #$09           ; ADD 9 FOR 9 SIGNIFICAN
a448 : d099                       subb VD9            ; SUBTRACT LEFT DIGIT CO
a44a : f001df                     subb STRBUF+3       ; ADD ONE TO EXPONENT IF
a44d : 862b             L9167     lda  #'+'           ; PLUS SIGN
a44f : 5d                         tstb                ; TEST EXPONENT
a450 : 2a03                       bpl  L916F          ; BRANCH IF POSITIVE EXP
a452 : 862d                       lda  #'-'           ; MINUS SIGN
a454 : 50                         negb                ; CONVERT EXPONENT TO PO
a455 : a741             L916F     sta  $01,u          ; PUT SIGN OF EXPONENT I
a457 : 8645                       lda  #'E'           ; * PUT AN 'E' (EXPONENT
a459 : a7c1                       sta  ,u++           ; * BUFFER AND SKIP OVER
AS09 Assembler for M6809 [1.42].                                     Page  119
--------------------------------- merge.a09 ----------------------------------

a45b : 862f                       lda  #$2F           ; * WAS lda #'0'-1
                        *CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACC
a45d : 4c               L9177     inca                ; ADD ONE TO TENS DIGIT 
a45e : c00a                       subb #10            ; *SUBTRACT 10 FROM EXPO
a460 : 24fb                       bcc  L9177          ; * DIGIT IF NO CARRY. T
a462 : cb3a                       addb #$3A           ; WAS addb #'9'+1
a464 : edc1                       std  ,u++           ; SAVE EXPONENT IN BUFFE
a466 : 6fc4                       clr  ,u             ; CLEAR FINAL BYTE IN BU
a468 : 7ea33a                     jmp  L9054          ; INSERT ASTERISK PADDIN
                        
                        * INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN
a46b : 8e01e0           L9185     ldx  #STRBUF+4      ; POINT X TO START OF PR
a46e : e684                       ldb  ,x             ; * GET SIGN BYTE OF ITE
a470 : 3404                       pshs b              ; * AND SAVE IT ON THE S
a472 : 8620                       lda  #SPACE         ; DEFAULT PAD WITH BLANK
a474 : d69a                       ldb  VDA            ; * GET STATUS BYTE AND 
a476 : c520                       bitb #$20           ; * ASTERISK LEFT PADDIN
a478 : 3504                       puls b              ; GET SIGN BYTE AGAIN
a47a : 2708                       beq  L919E          ; BRANCH IF NO PADDING
a47c : 862a                       lda  #'*'           ; PAD WITH ASTERISK
a47e : c120                       cmpb #SPACE         ; WAS THE FIRST BYTE A B
a480 : 2602                       bne  L919E          ; NO
a482 : 1f89                       tfr  a,b            ; TRANSFER PAD CHARACTER
a484 : 3404             L919E     pshs b              ; SAVE FIRST CHARACTER O
a486 : a780             L91A0     sta  ,x+            ; STORE PAD CHARACTER IN
a488 : e684                       ldb  ,x             ; GET NEXT CHARACTER IN 
a48a : 2710                       beq  L91B6          ; INSERT A ZERO IF END O
a48c : c145                       cmpb #'E'           ; * CHECK FOR AN 'E' AND
a48e : 270c                       beq  L91B6          ; * PUT A ZERO BEFORE IT
a490 : c130                       cmpb #'0'           ; * REPLACE LEADING ZERO
a492 : 27f2                       beq  L91A0          ; * PAD CHARACTERS
a494 : c12c                       cmpb #','           ; * REPLACE LEADING COMM
a496 : 27ee                       beq  L91A0          ; * WITH PAD CHARACTERS
a498 : c12e                       cmpb #'.'           ; * CHECK FOR DECIMAL PO
a49a : 2604                       bne  L91BA          ; * AND DON'T PUT A ZERO
a49c : 8630             L91B6     lda  #'0'           ; * REPLACE PREVIOUS CHA
a49e : a782                       sta  ,-x            ; * WITH A ZERO
a4a0 : 969a             L91BA     lda  VDA            ; * GET STATUS BYTE, CHE
a4a2 : 8510                       bita #$10           ; * FOR FLOATING $
a4a4 : 2704                       beq  L91C4          ; * BRANCH IF NO FLOATIN
a4a6 : c624                       ldb  #'$'           ; * STORE A $ IN
a4a8 : e782                       stb  ,-x            ; * BUFFER
a4aa : 8404             L91C4     anda #$04           ; CHECK PRE-SIGN FLAG
a4ac : 3504                       puls b              ; GET SIGN CHARACTER
a4ae : 2602                       bne  L91CC          ; RETURN IF POST-SIGN RE
a4b0 : e782                       stb  ,-x            ; STORE FIRST CHARACTER
a4b2 : 39               L91CC     rts
                        *
                        * CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN
                        * THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPO
a4b3 : 3440             L91CD     pshs u              ; SAVE BUFFER POINTER
a4b5 : 4f                         clra                ; INITIAL EXPONENT OFFSE
a4b6 : 9747             L91D0     sta  V47            ; SAVE EXPONENT OFFSET
a4b8 : d64f                       ldb  FP0EXP         ; GET EXPONENT OF FPA0
a4ba : c180                       cmpb #$80           ; * COMPARE TO EXPONENT 
a4bc : 2211                       bhi  L91E9          ; * AND BRANCH IF FPA0 >
                        
                        * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1
a4be : 8e96b6                     ldx  #LBDC0         ; POINT X TO FP NUMBER (
a4c1 : bd93c0                     jsr  LBACA          ; MULTIPLY FPA0 BY 1E+09
a4c4 : 9647                       lda  V47            ; GET EXPONENT OFFSET
a4c6 : 8009                       suba #$09           ; SUBTRACT 9 (BECAUSE WE
AS09 Assembler for M6809 [1.42].                                     Page  120
--------------------------------- merge.a09 ----------------------------------

a4c8 : 20ec                       bra  L91D0          ; CHECK TO SEE IF > 1.0
a4ca : bd9478           L91E4     jsr  LBB82          ; DIVIDE FPA0 BY 10
a4cd : 0c47                       inc  V47            ; INCREMENT EXPONENT OFF
a4cf : 8e96b1           L91E9     ldx  #LBDBB         ; POINT X TO FP NUMBER (
a4d2 : bd9596                     jsr  LBCA0          ; COMPARE FPA0 TO X
a4d5 : 2ef3                       bgt  L91E4          ; BRANCH IF FPA0 > 999,9
a4d7 : 8e96ac           L91F1     ldx  #LBDB6         ; POINT X TO FP NUMBER (
a4da : bd9596                     jsr  LBCA0          ; COMPARE FPA0 TO X
a4dd : 2e07                       bgt  L9200          ; RETURN IF 999,999,999 
a4df : bd9460                     jsr  LBB6A          ; MULTIPLY FPA0 BY 10
a4e2 : 0a47                       dec  V47            ; DECREMENT EXPONENT OFF
a4e4 : 20f1                       bra  L91F1          ; KEEP UNNORMALIZING
a4e6 : 35c0             L9200     puls u,pc           ; RESTORE BUFFER POINTER
                        *
                        * CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT
                        * INTO A DECIMAL ASCII STRING IN THE BUFFER
a4e8 : 3440             L9202     pshs u              ; SAVE BUFFER POINTER
a4ea : bd92aa                     jsr  LB9B4          ; ADD .5 TO FPA0 (ROUND 
a4ed : bd95be                     jsr  LBCC8          ; CONVERT FPA0 TO INTEGE
a4f0 : 3540                       puls u              ; RESTORE BUFFER POINTER
                        *
                        * CONVERT FPA0 INTO A DECIMAL ASCII STRING
a4f2 : 8e97bb                     ldx  #LBEC5         ; POINT X TO UNNORMALIZE
a4f5 : c680                       ldb  #$80           ; INITIALIZE DIGIT COUNT
                        * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 M
                        * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSa, IT 
                        * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF 
                        * IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OC
a4f7 : 8d36             L9211     bsr  L9249          ; CHECK FOR COMMA INSERT
a4f9 : 9653             L9213     lda  FPA0+3         ; * 'ADD' A POWER OF 10 
a4fb : ab03                       adda $03,x          ; * IF THE MANTISSA IS N
a4fd : 9753                       sta  FPA0+3         ; * WILL BE WHAT REALLY 
a4ff : 9652                       lda  FPA0+2         ; *
a501 : a902                       adca $02,x          ; *
a503 : 9752                       sta  FPA0+2         ; *
a505 : 9651                       lda  FPA0+1         ; *
a507 : a901                       adca $01,x          ; *
a509 : 9751                       sta  FPA0+1         ; *
a50b : 9650                       lda  FPA0           ; *
a50d : a984                       adca ,x             ; *
a50f : 9750                       sta  FPA0           ; *
a511 : 5c                         incb                ; ADD ONE TO DIGIT COUNT
a512 : 56                         rorb                ; ROTATE CARRY INTO BIT 
a513 : 59                         rolb                ; * SET OVERFLOW FLAG - 
a514 : 28e3                       bvc  L9213          ; * ADDING MANTISSA OR C
a516 : 2403                       bcc  L9235          ; BRANCH IF SUBTRACTING 
a518 : c00b                       subb #10+1          ; WAS subb #10+1
a51a : 50                         negb                ; * IF ADDING MANTISSA
a51b : cb2f             L9235     addb #$2F           ; WAS addb #'0'-1
a51d : 3004                       leax $04,x          ; MOVE TO NEXT POWER OF 
a51f : 1f98                       tfr  b,a            ; SAVE DIGIT IN ACCA
a521 : 847f                       anda #$7F           ; MASK OFF ADD/SUBTRACT 
a523 : a7c0                       sta  ,u+            ; STORE DIGIT IN BUFFER
a525 : 53                         comb                ; TOGGLE ADD/SUBTRACT FL
a526 : c480                       andb #$80           ; MASK OFF EVERYTHING BU
a528 : 8c97df                     cmpx #LBEE9         ; COMPARE TO END OF UNNO
a52b : 26ca                       bne  L9211          ; BRANCH IF NOT DONE
a52d : 6fc4                       clr  ,u             ; PUT A ZERO AT END OF I
                        
                        * DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA 
a52f : 0a45             L9249     dec  V45            ; DECREMENT DECIMAL POIN
a531 : 2609                       bne  L9256          ; NOT TIME FOR DECIMAL P
AS09 Assembler for M6809 [1.42].                                     Page  121
--------------------------------- merge.a09 ----------------------------------

a533 : df39             L924D     stu  VARPTR         ; SAVE BUFFER POINTER-PO
a535 : 862e                       lda  #'.'           ; * STORE A DECIMAL
a537 : a7c0                       sta  ,u+            ; * POINT IN THE OUTPUT 
a539 : 0f97                       clr  VD7            ; * CLEAR COMMA COUNTER 
                        *                             ; * DECREMENTS BEFORE AN
a53b : 39                         rts
a53c : 0a97             L9256     dec  VD7            ; DECREMENT COMMA COUNTE
a53e : 2608                       bne  L9262          ; RETURN IF NOT TIME FOR
a540 : 8603                       lda  #$03           ; * RESET COMMA COUNTER 
a542 : 9797                       sta  VD7            ; * DIGITS BETWEEN COMMA
a544 : 862c                       lda  #','            ; * PUT A COMMA INTO
a546 : a7c0                       sta  ,u+            ; * THE BUFFER
a548 : 39               L9262     rts
                        
                        * INITIALIZE DECIMAL POINT AND COMMA COUNTERS
a549 : 9647             L9263     lda  V47            ; GET THE BASE 10 EXPONE
a54b : 8b0a                       adda #10            ; * ADD 10 (FPA0 WAS 'NO
a54d : 9745                       sta  V45            ; * OF DECIMAL POINT) - 
a54f : 4c                         inca                ; ADD ONE FOR THE DECIMA
a550 : 8003             L926A     suba #$03           ; * DIVIDE DECIMAL POINT
a552 : 24fc                       bcc  L926A          ; * THE REMAINDER IN ACC
a554 : 8b05                       adda #$05           ; CONVERT REMAINDER INTO
a556 : 9797                       sta  VD7            ; SAVE COMMA COUNTER
a558 : 969a                       lda  VDA            ; GET STATUS BYTE
a55a : 8440                       anda #$40           ; CHECK FOR COMMA FLAG
a55c : 2602                       bne  L927A          ; BRANCH IF COMMA FLAG A
a55e : 9797                       sta  VD7            ; CLEAR COMMA COUNTER - 
a560 : 39               L927A     rts
                        *
                        * INSERT ACCA ZEROES INTO THE BUFFER
a561 : 3402             L927B     pshs a              ; SAVE ZEROES COUNTER
a563 : 8dca                       bsr  L9249          ; CHECK FOR DECIMAL POIN
a565 : 3502                       puls a              ; RESTORE ZEROES COUNTER
a567 : 4a               L9281     deca                ; * DECREMENT ZEROES COU
a568 : 2b0a                       bmi  L928E          ; * RETURN IF < 0
a56a : 3402                       pshs a              ; SAVE ZEROES COUNTER
a56c : 8630                       lda  #'0'            ; * PUT A ZERO INTO
a56e : a7c0                       sta  ,u+            ; * THE BUFFER
a570 : a6e0                       lda  ,s+            ; RESTORE THE ZEROES COU
a572 : 26ed                       bne  L927B          ; BRANCH IF NOT DONE
a574 : 39               L928E     rts
                        
                        
                        * LINE
a575 : 8189             LINE      cmpa #TOK_INPUT     ; 'INPUT' TOKEN
a577 : 1027f95c                   lbeq L89C0          ; GO DO 'LINE INPUT' COM
a57b : 7e8b99                     jmp  LB277          ; 'SYNTAX ERROR' IF NOT 
                        		  
                        
                        * END OF EXTENDED BASIC
                        
                        * DIR COMMAND				; DIR "DRIVE NUMBER"
a57e : bda585           DIR 	  jsr LD24F 		; SCAN DRIVE NUMBER FROM INPUT LINE
                        		  ;jsr LC79D 		; GET FAT FOR THIS DRIVE
                        		  ;jsr LB958 		; PRINT CARRIAGE RETURN TO CONSOLE OU
                        		  ;ldd #$1102 		; * GET TRACK 17 AND
                        		  ;sta DCTRK 		; * READ OP CODE AND
                        		  ;stb DCOPC 		; * SAVE IN DSKCON VARIABLES
                        		  ;ldb #$03 		; START WITH SECTOR 3 (FIRST DIRECTORY
a581 : bda5d8           		  jsr DSK_FDIR		; CALL THE DISK FILE LISTING FUNCTIO
a584 : 39               		  rts
                        
AS09 Assembler for M6809 [1.42].                                     Page  122
--------------------------------- merge.a09 ----------------------------------

                        * GET DRIVE NUMBER FROM BASIC - USE THE DEFAULT DRIVE 
a585 :                  LD24F	  ;ldb				; DEFDRV	GET DEFAULT DRIVE NUMBER		
a585 : 9d82             		  jsr	GETCCH		; GET NEXT INPUT CHAR (TO MAINTAIN BAC
a587 : 5f               		  clrb				; ONLY DRIVE 0 SUPPORTED
                        		  ;beq LD25F			; USE DEFAULT DRIVE NUMBER IF NONE GI
a588 :                  LD256	  ;jsr EVALEXPB		; EVALUATE EXPRESSION
                        		  ;cmpb #$03		; 4 DRIVES MAX
                        		  ;lbhi LA61F		; 'DEVICE NUMBER ERROR' IF > 3
a588 :                  LD25F	  ;stb DCDRV		; STORE IN DSKCON VARIABLE
a588 : 39               		  rts
                        
000d =                  FILELENGTH    equ  13		; FORMAT 8.3 + NULL GIVES 13 BY
                        
                        * KILL COMMAND  ; FROM DISK BASIC UNRAVELLED II
a589 : 3273             KILL	  leas -FILELENGTH,s; ALLOCATE FILENAME STORAGE
a58b : bda5b2           		  jsr GET_FN
a58e : bda6be           		  jsr DSK_FDEL		; CALL THE DISK FILE DELETION FUNCTI
a591 : 326d             		  leas FILELENGTH,s	; FREE FILENAME STACK		  
a593 : 39               		  rts
                        
                        ; KILL	  ldb #FILELENGTH
                        		  ; pshs b			; SAVE FILE LENGTH POSITION
                        ; LC6E9_	  jsr  GETNCH		; GET THE CHARS  
                        		  ; puls b			; RESTORE FILE LENGTH POSITION
                        		  ; cmpa #'"'			; UNTIL THE STRING ENDS WITH "
                        		  ; beq LC6EA_
                        		  ; pshs a			; THE FILENAME STRING ON THE STACK
                        		  ; decb
                        		  ; beq LC6EE_
                        		  ; pshs b		  	; RE-SAVE FILE LENGTH POSITION
                        		  ; bra LC6E9_
                        ; LC6EA_	  clra
                        		  ; pshs a			; FILL FILENAME STRING WITH NULL
                        		  ; decb
                        		  ; bne LC6EA_
                        ; LC6EE_	  jsr DSK_FDEL		; CALL THE DISK FILE DELETION
                        		  ; leas FILELENGTH,s	; FREE FILENAME STACK		  
                        		  ; rts
                        		  
                        * LOAD COMMAND ; FROM DISK BASIC UNRAVELLED II
a594 : 3273             LOAD 	  leas -FILELENGTH,s; ALLOCATE FILENAME STORAGE
a596 : bda5b2           		  jsr GET_FN
a599 : bda6d2           		  jsr DSK_FRD		; CALL THE DISK FILE READING FUNCTION
a59c : 326d             		  leas FILELENGTH,s	; FREE FILENAME STACK		  
a59e : 39               		  rts
                        
                        *LOAD	  cmpa #'M'			; "LOADM" COMMAND
                        *		  lbeq LCFC1		; *BRANCH IF LOADM
                        *		 clra 				; RUN	FLAG = ZERO (DON'T RUN)
                        *LCA4F	 clrb				; CLEAR	MERGE FLAG
                        *LCA50	 sta	DRUNFL	RUN FLAG (0 = DON'T RUN, 2 = RUN)
                        *		 stb	DMRGFL	MERGE FLAG (0 = NO MERGE, $FF = MERGE)
                        *		  bsr	LCA33	GO GET FILENAME, ETC. FROM BASIC
                        *		  jsr	GETCCH	GET CURRENT INPUT CHAR
                        *		  beq	LCA6C	BRANCH IF END OF LINE
                        *		  jsr	SYNCOMMA	SYNTAX CHECK FOR COMMA
a59f : 39               		  rts
                        
                        * SAVE COMMAND
a5a0 : 3273             SAVE 	  leas -FILELENGTH,s; ALLOCATE FILENAME STORAGE
a5a2 : bda5b2           		  jsr  GET_FN
a5a5 : bd828a           		  lbsr LA960		; get the timestamp updated
AS09 Assembler for M6809 [1.42].                                     Page  123
--------------------------------- merge.a09 ----------------------------------

a5a8 : bda6f9           		  jsr  DSK_FWR		; CALL THE DISK FILE WRITING FUNCTIO
a5ab : 326d             		  leas FILELENGTH,s	; FREE FILENAME STACK
a5ad : 3262             		  leas 2,s          ; PURGE RETURN ADDRESS FROM THE 
a5af : 7e85b7           		  jmp  LAC73        ; RETURN TO BASIC'S MAIN INPUT L
                        		  
                        * SAVE COMMAND ; FROM DISK BASIC UNRAVELLED II
                        *SAVE	cmpa	#'M	*
                        ;	lbeq	LCF68	*BRANCH IF SAVEM
                        ;	bsr	LCA33	GO GET FILENAME, ETC. FROM BASIC
                        ;	ldx	ZERO	ZERO OUT X REG
                        ;	stx	DFLTYP	SET FILE TYPE AND ASCII FLAG TO ZERO
                        ;	jsr	GETCCH	GET CURRENT INPUT CHARACTER FROM BASIC
                        ;	beq	LCA12	BRANCH IF END OF LINE
                        ;	jsr	SYNCOMMA	SYNTAX CHECK FOR COMMA
                        ;	ldb	#'A		*ASCII FILE?
                        ;	jsr	>LB26F	*SYNTAX CHECK ON CONTENTS OF ACCB
                        ;	bne	LC9DF	RETURN IF NO MORE CHARACTERS ON LINE
                        ;	COM	DASCFL	SET CRUNCHED/ASCII FLAG TO ASCII
                        ;	bsr	LCA04	OPEN A SEQUENTIAL FILE FOR OUTPUT
                        ;	clra		SET	ZERO FLAG - CAUSE ENTIRE FILE TO BE LISTED
                        ;	jmp	LIST	'LIST' THE FILE TO CONSOLE OUT
                        
                        
a5b2 : 3440             GET_FN	  pshs u
a5b4 : 3364             		  leau 4,s ; +4 BYTES FOR RETURN ADDR + U
a5b6 : c60d             		  ldb #FILELENGTH
a5b8 : 3444             		  pshs u,b			; SAVE FILE LENGTH POSITION
a5ba : 9d7c             LC6E9	  jsr  GETNCH		; GET THE CHARS  
a5bc : 3544             		  puls b,u			; RESTORE FILE LENGTH POSITION
a5be : 8122             		  cmpa #'"'			; UNTIL THE STRING ENDS WITH "
a5c0 : 270b             		  beq LC6EA
a5c2 : a7c0             		  sta ,u+			; THE FILENAME STRING ON THE STACK
a5c4 : 5a               		  decb
a5c5 : 10270004         		  lbeq LC6EA
a5c9 : 3444             		  pshs u,b		  	; RE-SAVE FILE LENGTH POSITION
a5cb : 20ed             		  bra LC6E9
a5cd : 4f               LC6EA	  clra
a5ce : a7c0             		  sta ,u+			; FILL FILENAME STRING WITH NULL
a5d0 : 5a               		  decb
a5d1 : 26fa             		  bne LC6EA
a5d3 : 9d7c             		  jsr  GETNCH		; purge the command
a5d5 : 3540             		  puls u
a5d7 : 39               		  rts
                        		    
                        *************************CALLING FAT32 FUNCTIONS *****
                        * Generated code from C and optimized afterward
                        * Note for BASIC ASM -> C : the U, X and Y registers n
                        ******************************************************
                        
                        * DSK_FDIR()
                        * {
                        * 	fileInfo fileList; //18 bytes
                        * 	
                        * 	while(FILE_List(&fileList) != END_OF_FILE_LIST) {
a5d8 : 3470             DSK_FDIR  pshs 	u,x,y
a5da : 33e4             		  leau 	,s
a5dc : 32e8ee           		  leas 	-18,s			; alloc 18 bytes
a5df : bda753           		  lbsr  initDISK
a5e2 : 102600b2         		  lbne  FDIR_2			; return when failed
a5e6 : 30c8ee           FDIR_3	  leax 	-18,u
a5e9 : 3410             		  pshs 	x
a5eb : bdbd86           		  lbsr	FILE_Lis
AS09 Assembler for M6809 [1.42].                                     Page  124
--------------------------------- merge.a09 ----------------------------------

a5ee : 3262             		  leas 	2,s		
a5f0 : 830009           		  subd 	#$9
a5f3 : 102700a1         		  lbeq 	FDIR_2
                        * 		PUTCHR('\r');
a5f7 : 860d             		  lda	#$d
a5f9 : bd805c           		  lbsr	PUTCHR	
                        * 		if(fileList.FI_Attr == ATTR_VOLUME_ID) {
a5fc : e652             		  ldb	-14,u
a5fe : c108             		  cmpb	#$8
a600 : 2619             		  bne	FDIR_4
                        * 		L85B4("VOLUME NAME IS ");
a602 : 308d0002         		  leax	FDIR_5_,pc
a606 : 2010             		  bra	FDIR_5
a608 :                  FDIR_5_
a608 : 564f4c554d45204e 	fcb	$56, $4f, $4c, $55, $4d, $45, $20, $4e
a610 : 414d452049532000 	fcb	$41, $4d, $45, $20, $49, $53, $20, $0
a618 : bd9b1b           FDIR_5    lbsr	L85B4
                        * 		}
                        * 		L85B4(fileList.FI_Name); PUTCHR(' ');
a61b : 3053             FDIR_4    leax 	-13,u
a61d : bd9b1b           		  jsr 	L85B4			; PRINT STRING TO THE SCREEN
a620 : 8620             		  lda 	#SPACE
a622 : bd805c           		  lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN
                        * 		if((fileList.FI_Attr != ATTR_VOLUME_ID) && (fileLi
a625 : e652             		  ldb	-14,u
a627 : c108             		  cmpb	#$8
a629 : 276a             		  beq	FDIR_6	
a62b : c110             		  cmpb	#$10
a62d : 2766             		  beq	FDIR_6	
                        * 			if(fileList.FI_Size.h > 0xf) { // bigger than 1M 
a62f : ecc8ee           		  ldd	-18,u
a632 : 1083000f         		  cmpd	#$f
a636 : 10230017         		  lbls	FDIR_8
                        * 				PutWhitespace(fileList.FI_Size.h >> 4); PUTCHR('
a63a : 44               		  lsra
a63b : 56               		  rorb
a63c : 44               		  lsra
a63d : 56               		  rorb
a63e : 44               		  lsra
a63f : 56               		  rorb
a640 : 44               		  lsra
a641 : 56               		  rorb
a642 : 3406             		  pshs	d
a644 : bda69c           		  lbsr	PutWS
a647 : 3262             		  leas	2,s
a649 : 864d             		  lda	#'M'
a64b : bd805c           		  lbsr	PUTCHR	
                        * 				}
                        * 				else {
a64e : 203612           		  lbra	FDIR_11
a651 :                  FDIR_8
                        * 				if((fileList.FI_Size.h == 0) && (fileList.FI_Siz
a651 : ecc8ee           		  ldd	-18,u
a654 : 2617             		  bne	FDIR_10
a656 : ec50             		  ldd	-16,u
a658 : 108303e8         		  cmpd	#1000
a65c : 240f             		  bhs 	FDIR_10
                        * 					PutWhitespace(fileList.FI_Size.l);
a65e : 3406             		  pshs	d
a660 : bda69c           		  lbsr	PutWS
a663 : 3262             		  leas	2,s
a665 : 8620             		  lda	#' '
AS09 Assembler for M6809 [1.42].                                     Page  125
--------------------------------- merge.a09 ----------------------------------

a667 : bd805c           		  lbsr	PUTCHR
                        * 				}
                        * 				else {
a66a : 201a12           		  lbra	FDIR_11
a66d :                  FDIR_10
                        * 					i = ((fileList.FI_Size.h & 0xf) << 8) | (fileLi
a66d : ecc8ee           		  ldd	-18,u
a670 : c40f             		  andb	#$f
a672 : 1f98             		  tfr 	b,a
a674 : e650             		  ldb	-16,u	
                        * 					PutWhitespace(i >> 2); PUTCHR('K');					
a676 : 44               		  lsra
a677 : 56               		  rorb
a678 : 44               		  lsra
a679 : 56               		  rorb	
a67a : 3406             		  pshs	d
a67c : bda69c           		  lbsr	PutWS
a67f : 3262             		  leas	2,s
a681 : 864b             		  lda	#'K'
a683 : bd805c           		  lbsr	PUTCHR
                        * 				}
                        * 			}
                        * 			PUTCHR('B');
a686 : 8642             FDIR_11	  lda 	#'B'
a688 : bd805c           		  lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN
a68b : 8620             		  lda 	#' '
a68d : bd805c           		  lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN
a690 : 8664             		  lda  	#'d'
a692 : bd82aa           		  lbsr  LA964			; print the date
                        * 		}
                        * 	}
a695 :                  FDIR_6
                        * }
a695 : 7ea5e6           		  lbra	FDIR_3
a698 :                  FDIR_2
a698 : 32c4             		  leas	,u			; free allocated bytes
a69a : 35f0             		  puls	u,x,y,pc
                        
                        * PutWhitespace(n) unsigned int n; {
                        * 	if (n < 100) PUTCHR(' ');
a69c :                  PutWS
a69c : ec62             		  ldd	2,s
a69e : 10830064         		  cmpd	#100
a6a2 : 2405             		  bhs	PutWS2
a6a4 : 8620             		  lda	#' '
a6a6 : bd805c           		  lbsr	PUTCHR	
                        * 	if (n < 10) PUTCHR(' ');
a6a9 : ec62             PutWS2	  ldd	2,s
a6ab : c10a             		  cmpb	#10
a6ad : 2405             		  bhs	PutWS3
a6af : 8620             		  lda	#' '
a6b1 : bd805c           		  lbsr	PUTCHR	
                        * 	LBDCC(n);  
a6b4 : ec62             PutWS3	  ldd	2,s
a6b6 : 3440             		  pshs	u	
a6b8 : bd96c2           		  lbsr	LBDCC
a6bb : 3540             		  puls	u	
                        * }
a6bd : 39               		  rts
                        
a6be :                  DSK_FDEL 
a6be : 3470             		  pshs u,x,y
AS09 Assembler for M6809 [1.42].                                     Page  126
--------------------------------- merge.a09 ----------------------------------

a6c0 : 33e4             		  leau 	,s
a6c2 : bda753           		  lbsr initDISK
a6c5 : 2609             		  bne  DSK_FDL1				; return when failed
                        		  		  
                        * 	returnStatus = FILE_Delete(ptr);		  
a6c7 : 3048             		  leax 8,u	; +8 BYTES (RETURN ADDR, U, X, Y)
a6c9 : 3410             		  pshs	x
a6cb : bdb4cf           		  lbsr	FILE_Del
a6ce : 3262             		  leas	2,s
a6d0 : 35f0             DSK_FDL1  puls	u,x,y,pc
                        
a6d2 : 3470             DSK_FRD   pshs  u,x,y
a6d4 : 33e4             		  leau 	,s
a6d6 : bda753           		  lbsr  initDISK		  
a6d9 : 10260018         		  lbne  DSK_FRD1			; return when failed
                        		  
                        * 	unsigned char returnStatus; //1 byte
a6dd : 327f             		  leas	-1,s		; alloc 1 byte
                        * 	srcFilePtr = FILE_Open(ptr, READ, &returnStatus);
a6df : 305f             	 	  leax	-1,u
a6e1 : 3410             		  pshs	x
a6e3 : 4f               		  clra
a6e4 : 5f               		  clrb
a6e5 : 3406             		  pshs	d		  
a6e7 : 3048             		  leax  8,u			; +8 BYTES (RETURN ADDR, U, X, Y)
a6e9 : 3410             		  pshs	x
a6eb : bdb07c           		  lbsr	FILE_Ope	; file pointer in ACCD
a6ee : 3266             		  leas	6,s		  	; CCR unchanged	
                        * 	if(srcFilePtr != 0)	{
a6f0 : 2703             		  beq   DSK_FRD1
a6f2 : fd0205           		  std	F_PTR		; let the ConsoleIn pull the file conte
                        * 	}
a6f5 : 32c4             DSK_FRD1  leas	,u			; free allocated bytes
a6f7 : 35f0             		  puls	u,x,y,pc
                        
                        
a6f9 : 3470             DSK_FWR   pshs  u,x,y	  
a6fb : 33e4             		  leau 	,s
a6fd : bda753           		  lbsr  initDISK
a700 : 1026004b         		  lbne  FWR_20				; return when failed
                        		  
                        * 	fileConfig_st *srcFilePtr; //2 bytes
                        * 	unsigned char returnStatus; //1 byte
a704 : 327d             		  leas	-3,s	; alloc 3 bytes
                        * 	srcFilePtr = FILE_Open(ptr, WRITE, &returnStatus);
a706 : 305d             		  leax	-3,u
a708 : 3410             		  pshs	x
a70a : cc0002           		  ldd	#$2
a70d : 3406             		  pshs	d
a70f : 3048             		  leax 8,u	; +8 BYTES (RETURN ADDR, U, X, Y)		  
a711 : 3410             		  pshs	x
a713 : bdb07c           		  lbsr	FILE_Ope
a716 : 3266             		  leas	6,s
a718 : ed5e             		  std	-2,u
                        		  
                        * 	if(srcFilePtr == 0)	{
a71a : ec5e             		  ldd	-2,u
a71c : 2603             		  bne	FWR_19
                        * 		//print_DebugMsg("\nFile Opening Failed!"); HEXBYT
a71e : 202f12           		  lbra	FWR_20
                        * 	}
                        * 	else {		  
AS09 Assembler for M6809 [1.42].                                     Page  127
--------------------------------- merge.a09 ----------------------------------

a721 :                  FWR_19
                        *      send BAS program to the file
a721 : ec5e             		  ldd	-2,u
a723 : fd0205           		  std	F_PTR
a726 : 0c6e             		  inc	DEVNUM
a728 : 3460             		  pshs  u,y			; save U,Y overwritten in LIST routine
a72a : 4f               		  clra				; SET	ZERO FLAG - CAUSE ENTIRE FILE TO BE 
a72b : bd9078           		  jsr	LIST		; Note for C -> BASIC ASM : the U and Y 
a72e : 3560             		  puls  u,y
a730 : 0f6e             		  clr	DEVNUM
a732 : 7f0205           		  clr	F_PTR
a735 : 7f0207           		  clr	F_PTR+2
                        		  
                        * 		FILE_PutCh(srcFilePtr,EOF);
a738 : cc001a           		  ldd	#$1a
a73b : 3406             		  pshs	d
a73d : ec5e             		  ldd	-2,u
a73f : 3406             		  pshs	d
a741 : bdb675           		  lbsr	FILE_Put
a744 : 3264             		  leas	4,s
                        * 		FILE_Close(srcFilePtr);
a746 : ec5e             		  ldd	-2,u
a748 : 3406             		  pshs	d
a74a : bdb4b8           		  lbsr	FILE_Clo
a74d : 3262             		  leas	2,s
                        * 	}
                        * }
a74f :                  FWR_20		  
a74f : 32c4             		  leas	,u			; free allocated bytes
a751 : 35f0             		  puls	u,x,y,pc		  
                        					
                        
                        * initDISK() {
                        * 	unsigned char returnStatus, sdcardType; //2 bytes  
a753 :                  initDISK
a753 : 3470             	pshs	u,x,y
a755 : 33e4             	leau	,s
a757 : 327e             	leas	-2,s	
                        * 	
                        * 	setPins();
a759 : bdab89           	lbsr	setPins
                        * 	
                        * 	returnStatus = SD_Init(&sdcardType);		
a75c : 305e             	leax	-2,u
a75e : 3410             	pshs	x
a760 : bdadc0           	lbsr	SD_Init
a763 : 3262             	leas	2,s
a765 : e75f             	stb	-1,u
                        * 
                        * 	if(returnStatus != INIT_SUCCESSFUL) {
a767 : e65f             	ldb	-1,u
a769 : 1027005a         	lbeq	init_8
                        * 		if(returnStatus == NOT_DETECTED)	print_DebugMsg("S
a76d : c101             	cmpb	#$1
a76f : 2624             	bne		init_9
a771 : 308d0002         	leax	init_10_,pc
a775 : 2017             	bra	init_10
a777 :                  init_10_
a777 : 5344206361726420 	fcb	$53, $44, $20, $63, $61, $72, $64, $20
a77f : 6e6f742064657465 	fcb	$6e, $6f, $74, $20, $64, $65, $74, $65
a787 : 63746564210a00   	fcb	$63, $74, $65, $64, $21, $a, $0
a78e :                  init_10
AS09 Assembler for M6809 [1.42].                                     Page  128
--------------------------------- merge.a09 ----------------------------------

a78e : 3410             	pshs	x
a790 : bdfc5e           	lbsr	print_De
a793 : 3262             	leas	2,s
                        * 		if(returnStatus == INIT_FAILED) print_DebugMsg("Ca
a795 :                  init_9
a795 : e65f             	ldb	-1,u
a797 : c102             	cmpb	#$2
a799 : 265c             	bne		init_15
a79b : 308d0002         	leax	init_12_,pc
a79f : 201d             	bra	init_12
a7a1 :                  init_12_
a7a1 : 4361726420496e69 	fcb	$43, $61, $72, $64, $20, $49, $6e, $69
a7a9 : 7469616c697a6174 	fcb	$74, $69, $61, $6c, $69, $7a, $61, $74
a7b1 : 696f6e206661696c 	fcb	$69, $6f, $6e, $20, $66, $61, $69, $6c
a7b9 : 6564210a00       	fcb	$65, $64, $21, $a, $0
a7be :                  init_12
a7be : 3410             	pshs	x
a7c0 : bdfc5e           	lbsr	print_De
a7c3 : 3262             	leas	2,s
                        * 	}
a7c5 : 2630                 bne		init_15
                        * 	else {		
a7c7 :                  init_8
                        * 		returnStatus = getBootSectorData (); //read boot s
a7c7 : bde000           	lbsr	getBootS
a7ca : e75f             	stb	-1,u
                        * 		if(returnStatus == FAT_INVALID) print_DebugMsg("In
a7cc : c103             	cmpb #$3
a7ce : 2627             	bne		init_15
a7d0 : 308d0002         	leax	init_16_,pc
a7d4 : 201a             	bra	init_16
a7d6 :                  init_16_
a7d6 : 496e76616c696420 	fcb	$49, $6e, $76, $61, $6c, $69, $64, $20
a7de : 4641542066696c65 	fcb	$46, $41, $54, $20, $66, $69, $6c, $65
a7e6 : 2073797374656d21 	fcb	$20, $73, $79, $73, $74, $65, $6d, $21
a7ee : 0a00             	fcb	$a, $0
a7f0 :                  init_16
a7f0 : 3410             	pshs	x
a7f2 : bdfc5e           	lbsr	print_De
a7f5 : 3262             	leas	2,s
                        * 	}    
a7f7 :                  init_15
a7f7 : e65f             	ldb	-1,u
a7f9 : 4f               	clra
                        * }
a7fa : 32c4             	leas	,u			; free allocated bytes
a7fc : 35f0             	puls	y,x,u,pc
                        		  
                        * END OF DISK BASIC
                        
                        * micro-C(ver 0.4.1), 1981-1987 Masataka Ohta, Hiroshi
                        * /***************************************************
                        * /*                                                  
                        * /* file:          stdutils.c		                      
                        * /*                                                  
                        * /* source:        2023, written by Adrian Kundert (a
                        * /*                                                  
                        * /* description:   read and write data from SD CARD (
                        * /*                                                  
                        * /* This library is free software; you can redistribu
                        * /* GNU Lesser General Public License as published by
                        * /* either version 2.1 of the License, or (at your op
AS09 Assembler for M6809 [1.42].                                     Page  129
--------------------------------- merge.a09 ----------------------------------

                        * /*                                                  
                        * /* This library is distributed in the hope that it w
                        * /* without even the implied warranty of MERCHANTABIL
                        * /* See the GNU Lesser General Public License for mor
                        * /*                                                  
                        * /***************************************************
                        * 
                        * #include "stdutils.h"
                        * /***************************************************
                        * /*                                                  
                        * /* file:          stdutils.h		                      
                        * /*                                                  
                        * /* source:        2023, written by Adrian Kundert (a
                        * /*                                                  
                        * /* description:   read and write data from SD CARD (
                        * /*                                                  
                        * /* This library is free software; you can redistribu
                        * /* GNU Lesser General Public License as published by
                        * /* either version 2.1 of the License, or (at your op
                        * /*                                                  
                        * /* This library is distributed in the hope that it w
                        * /* without even the implied warranty of MERCHANTABIL
                        * /* See the GNU Lesser General Public License for mor
                        * /*                                                  
                        * /***************************************************
                        * 
                        * /**----------char 8-bit--------
                        *      char (-128 to 127)
                        *      signed char (-128 to 127)
                        *      unsigned char (0 - 255)
                        * 	-----------------------------*/
                        * 
                        * /**---------int 16-bit----------
                        * 	 int (-32768 to 32767)
                        * 	 signed int (-32768 to 32767)
                        *      unsigned int (0 to 65535)
                        * 	 -----------------------------*/
                        * 
                        * /***************************************************
                        * 
                        * 
                        * /***************************************************
                        *                            Port Direction configurat
                        *  ***************************************************
                        * #define LOW                0x00
                        * #define HIGH               0x01
                        * /***************************************************
                        * 
                        * /***************************************************
                        * ****************************************************
                        *                               Commonly used constant
                        * ****************************************************
                        * #define FALSE              0x00
                        * #define TRUE               0x01
                        * 
                        * /***************************************************
                        * 			32-bit variable and operation wrapper for 16-bit 
                        * ****************************************************
                        * typedef struct _u32_t {
                        * 	unsigned int h;
                        * 	unsigned int l;
                        * }u32_t;
AS09 Assembler for M6809 [1.42].                                     Page  130
--------------------------------- merge.a09 ----------------------------------

                        * 
                        * 
                        * /*
                        * void _u32_and(u32_t *a, u32_t *b, u32_t *out);
                        * void _u32_div2(u32_t *a, unsigned int b, u32_t *quot
                        * void _u32_mul(unsigned int a, u32_t *b, u32_t *prod)
                        * void _u32_sub(u32_t *a, u32_t *b, u32_t *dif);
                        * void _u32_dec(u32_t *a);
                        * void _u32_add(u32_t *a, u32_t *b, u32_t *sum);
                        * void _u32_inc(u32_t *a);
                        * unsigned char _u32_lower(u32_t *a, u32_t *b);
                        * unsigned char _u32_equal(u32_t *a, u32_t *b);
                        * unsigned char _u32_higher(u32_t *a, u32_t *b); 
                        * */
                        * 
                        * /***************************************************
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * /***************************************************
                        * 			32-bit variable and operation wrapper for 16-bit 
                        *  ***************************************************
                        * 
                        * // &
                        * _u32_and(a, b, out) u32_t *a; u32_t *b; u32_t *out; 
                        * 	out->l = a->l & b->l;
a7fe :                  _u32_and
a7fe : 3440             	pshs	u
a800 : 33e4             	leau	,s
a802 : ae46             	ldx	6,u
a804 : ec02             	ldd	2,x
a806 : 3406             	pshs	d
a808 : ae44             	ldx	4,u
a80a : ec02             	ldd	2,x
a80c : a4e0             	anda	,s+
a80e : e4e0             	andb	,s+
a810 : ae48             	ldx	8,u
a812 : ed02             	std	2,x
                        * 	out->h = a->h & b->h;
a814 : ecd806           	ldd	[6,u]
a817 : 3406             	pshs	d
a819 : ecd804           	ldd	[4,u]
a81c : a4e0             	anda	,s+
a81e : e4e0             	andb	,s+
a820 : edd808           	std	[8,u]
                        * }
a823 : 35c0             	puls	u,pc
                        * 
                        * // /
                        * _u32_div2(a,b, quot) u32_t *a; unsigned int b; u32_t
                        * 	quot->h = a->h; quot->l = a->l;
a825 :                  _u32_div
a825 : 3440             	pshs	u
a827 : 33e4             	leau	,s
a829 : ecd804           	ldd	[4,u]
a82c : edd808           	std	[8,u]
a82f : ae44             	ldx	4,u
AS09 Assembler for M6809 [1.42].                                     Page  131
--------------------------------- merge.a09 ----------------------------------

a831 : ec02             	ldd	2,x
a833 : ae48             	ldx	8,u
a835 : ed02             	std	2,x
                        * 	while (b > 1) {
a837 :                  _3
a837 : ec46             	ldd	6,u
a839 : 830001           	subd	#$1
a83c : 1023004f         	lbls	_2
                        * 		quot->l = quot->l >> 1;
a840 : cc0001           	ldd	#$1
a843 : 3406             	pshs	d
a845 : ae48             	ldx	8,u
a847 : ec02             	ldd	2,x
a849 : 3510             	puls	x
a84b : bdee27           	lbsr	_00009
a84e : ae48             	ldx	8,u
a850 : ed02             	std	2,x
                        * 		if (quot->h & 1) quot->l |= 0x8000;
a852 : ecd808           	ldd	[8,u]
a855 : 8400             	anda	#$0
a857 : c401             	andb	#$1
a859 : 830000           	subd	#$0
a85c : 1027000f         	lbeq	_4
a860 : ec48             	ldd	8,u
a862 : c30002           	addd	#$2
a865 : 1f01             	tfr	d,x
a867 : ec84             	ldd	0,x
a869 : 8a80             	ora	#$80
a86b : ca00             	orb	#$0
a86d : ed84             	std	0,x
                        * 		quot->h = quot->h >> 1;
a86f :                  _4
a86f : cc0001           	ldd	#$1
a872 : 3406             	pshs	d
a874 : ecd808           	ldd	[8,u]
a877 : 3510             	puls	x
a879 : bdee27           	lbsr	_00009
a87c : edd808           	std	[8,u]
                        * 		b = b >> 1;
a87f : cc0001           	ldd	#$1
a882 : 3406             	pshs	d
a884 : ec46             	ldd	6,u
a886 : 3510             	puls	x
a888 : bdee27           	lbsr	_00009
a88b : ed46             	std	6,u
                        * 	}
                        * }
a88d : 20a8             	lbra	_3
a88f :                  _2
a88f : 35c0             	puls	u,pc
                        * 
                        * // *
                        * _u32_mul(a, b, prod) unsigned int a; u32_t *b; u32_t
                        * 	unsigned int u16, a0, a1, b0, b1, b2, b3; // any ch
                        * 	{ // brace to ensure proper initialisation before t
a891 :                  _u32_mul
a891 : 3440             	pshs	u
a893 : 33e4             	leau	,s
a895 : 3272             	leas	-14,s
                        * #asm
                        * 	a0 = a & 0xff;
a897 : e645             	ldb	5,u		;lower word
AS09 Assembler for M6809 [1.42].                                     Page  132
--------------------------------- merge.a09 ----------------------------------

a899 : 4f               	clra
a89a : ed5c             	std	-4,u
                        * 	a1 = a >> 8;
a89c : e644             	ldb	4,u
a89e : 4f               	clra
a89f : ed5a             	std	-6,u
                        * 	b0 = b->l & 0xff;
a8a1 : ae46             	ldx	6,u
a8a3 : e603             	ldb	3,x		;lower word
a8a5 : 4f               	clra
a8a6 : ed58             	std	-8,u
                        * 	b1 = b->l >> 8;
a8a8 : ae46             	ldx	6,u
a8aa : e602             	ldb	2,x
a8ac : 4f               	clra
a8ad : ed56             	std	-10,u
                        * 	b2 = b->h & 0xff;
a8af : ae46             	ldx	6,u
a8b1 : e601             	ldb	1,x		;lower word
a8b3 : 4f               	clra
a8b4 : ed54             	std	-12,u
                        * 	b3 = b->h >> 8;
a8b6 : ae46             	ldx	6,u
a8b8 : e684             	ldb	0,x
a8ba : 4f               	clra
a8bb : ed52             	std	-14,u
                        * 	}
                        * 	// byte 0
                        * 	u16 = (a0 * b0);
a8bd : ec5c             	ldd	-4,u
a8bf : 3406             	pshs	d
a8c1 : ec58             	ldd	-8,u
a8c3 : 3510             	puls	x
a8c5 : bdee0d           	lbsr	_00001
a8c8 : ed5e             	std	-2,u
                        * 	prod->l = u16 & 0xff;	
a8ca : ec5e             	ldd	-2,u
a8cc : 8400             	anda	#$0
a8ce : c4ff             	andb	#$ff
a8d0 : ae48             	ldx	8,u
a8d2 : ed02             	std	2,x
                        * 
                        * 	// byte 1
                        * #asm
                        *	u16 = u16 >> 8;
a8d4 : e65e             	ldb	-2,u
a8d6 : 4f               	clra
a8d7 : ed5e             	std	-2,u
                        * 	u16 += (a1 * b0) + (a0 * b1);
a8d9 : ec5c             	ldd	-4,u
a8db : 3406             	pshs	d
a8dd : ec56             	ldd	-10,u
a8df : 3510             	puls	x
a8e1 : bdee0d           	lbsr	_00001
a8e4 : 3406             	pshs	d
a8e6 : ec5a             	ldd	-6,u
a8e8 : 3406             	pshs	d
a8ea : ec58             	ldd	-8,u
a8ec : 3510             	puls	x
a8ee : bdee0d           	lbsr	_00001
a8f1 : e3e1             	addd	,s++
a8f3 : 3406             	pshs	d
AS09 Assembler for M6809 [1.42].                                     Page  133
--------------------------------- merge.a09 ----------------------------------

a8f5 : ec5e             	ldd	-2,u
a8f7 : e3e1             	addd	,s++
a8f9 : ed5e             	std	-2,u
                        * #asm
                        * 	prod->l += u16 << 8;
a8fb : a65f             	lda	-1,u	; lower word
a8fd : 5f               	clrb
a8fe : 3406             	pshs	d
a900 : ec48             	ldd	8,u
a902 : c30002           	addd	#$2
a905 : 1f01             	tfr	d,x
a907 : ec84             	ldd	0,x
a909 : e3e1             	addd	,s++
a90b : ed84             	std	0,x
                        	
                        *	// byte 2
                        *	u16 = u16 >> 8;
a90d : e65e             	ldb	-2,u
a90f : 4f               	clra
a910 : ed5e             	std -2,u
                        * 	u16 += (a1 * b1) + (a0 * b2);
a912 : ec5c             	ldd	-4,u
a914 : 3406             	pshs	d
a916 : ec54             	ldd	-12,u
a918 : 3510             	puls	x
a91a : bdee0d           	lbsr	_00001
a91d : 3406             	pshs	d
a91f : ec5a             	ldd	-6,u
a921 : 3406             	pshs	d
a923 : ec56             	ldd	-10,u
a925 : 3510             	puls	x
a927 : bdee0d           	lbsr	_00001
a92a : e3e1             	addd	,s++
a92c : 3406             	pshs	d
a92e : ec5e             	ldd	-2,u
a930 : e3e1             	addd	,s++
a932 : ed5e             	std	-2,u
                        * 	prod->h = u16 & 0xff;
a934 : ec5e             	ldd	-2,u
a936 : 8400             	anda	#$0
a938 : c4ff             	andb	#$ff
a93a : edd808           	std	[8,u]
                        * 	
                        * 	// byte 3
                        * #asm
                        * 	u16 = u16 >> 8;
a93d : e65e             	ldb	-2,u	;upper word
a93f : 4f               	clra
a940 : ed5e             	std	-2,u
                        * 	u16 += (a1 * b2) + (a0 * b3);
a942 : ec5c             	ldd	-4,u
a944 : 3406             	pshs	d
a946 : ec52             	ldd	-14,u
a948 : 3510             	puls	x
a94a : bdee0d           	lbsr	_00001
a94d : 3406             	pshs	d
a94f : ec5a             	ldd	-6,u
a951 : 3406             	pshs	d
a953 : ec54             	ldd	-12,u
a955 : 3510             	puls	x
a957 : bdee0d           	lbsr	_00001
a95a : e3e1             	addd	,s++
AS09 Assembler for M6809 [1.42].                                     Page  134
--------------------------------- merge.a09 ----------------------------------

a95c : 3406             	pshs	d
a95e : ec5e             	ldd	-2,u
a960 : e3e1             	addd	,s++
a962 : ed5e             	std	-2,u
                        * #asm
                        * 	prod->h += u16 << 8;
a964 : a65f             	lda	-1,u	; lower word
a966 : 5f               	clrb
a967 : 3406             	pshs	d
a969 : ae48             	ldx	8,u
a96b : ec84             	ldd	0,x
a96d : e3e1             	addd	,s++
a96f : ed84             	std	0,x
                        * }
a971 : 32c4             	leas	,u
a973 : 35c0             	puls	u,pc
                        * 
                        * // -
                        * _u32_sub(a, b, dif) u32_t *a; u32_t *b; u32_t *dif; 
                        * 	dif->h = a->h - b->h;
a975 :                  _u32_sub
a975 : 3440             	pshs	u
a977 : 33e4             	leau	,s
a979 : ecd806           	ldd	[6,u]
a97c : 3406             	pshs	d
a97e : ecd804           	ldd	[4,u]
a981 : a3e1             	subd	,s++
a983 : edd808           	std	[8,u]
                        * 	dif->l = a->l - b->l;	
a986 : ae46             	ldx	6,u
a988 : ec02             	ldd	2,x
a98a : 3406             	pshs	d
a98c : ae44             	ldx	4,u
a98e : ec02             	ldd	2,x
a990 : a3e1             	subd	,s++
a992 : ae48             	ldx	8,u
a994 : ed02             	std	2,x
                        * 	if(a->l < b->l) dif->h -= 1;
a996 : ae46             	ldx	6,u
a998 : ec02             	ldd	2,x
a99a : 3406             	pshs	d
a99c : ae44             	ldx	4,u
a99e : ec02             	ldd	2,x
a9a0 : a3e1             	subd	,s++
a9a2 : 10240009         	lbhs	_5
a9a6 : ae48             	ldx	8,u
a9a8 : ec84             	ldd	0,x
a9aa : 830001           	subd	#$1
a9ad : ed84             	std	0,x
                        * }
a9af :                  _5
a9af : 35c0             	puls	u,pc
                        * 
                        * _u32_dec(a) u32_t *a; {
                        * 	a->l--;
a9b1 :                  _u32_dec
a9b1 : 3440             	pshs	u
a9b3 : 33e4             	leau	,s
a9b5 : ec44             	ldd	4,u
a9b7 : c30002           	addd	#$2
a9ba : 1f01             	tfr	d,x
a9bc : ec84             	ldd	,x
AS09 Assembler for M6809 [1.42].                                     Page  135
--------------------------------- merge.a09 ----------------------------------

a9be : c3ffff           	addd	#$ffff
a9c1 : ed84             	std	,x
a9c3 : 83ffff           	subd	#$ffff
                        * 	if (a->l == 0xffff) a->h--;
a9c6 : ae44             	ldx	4,u
a9c8 : ec02             	ldd	2,x
a9ca : 83ffff           	subd	#$ffff
a9cd : 1026000c         	lbne	_6
a9d1 : ae44             	ldx	4,u
a9d3 : ec84             	ldd	,x
a9d5 : c3ffff           	addd	#$ffff
a9d8 : ed84             	std	,x
a9da : 83ffff           	subd	#$ffff
                        * }
a9dd :                  _6
a9dd : 35c0             	puls	u,pc
                        * 
                        * // +
                        * _u32_add(a, b, sum) u32_t *a; u32_t *b; u32_t *sum; 
                        * 	sum->h = a->h + b->h;
a9df :                  _u32_add
a9df : 3440             	pshs	u
a9e1 : 33e4             	leau	,s
a9e3 : ecd806           	ldd	[6,u]
a9e6 : 3406             	pshs	d
a9e8 : ecd804           	ldd	[4,u]
a9eb : e3e1             	addd	,s++
a9ed : edd808           	std	[8,u]
                        * 	sum->l = a->l + b->l;
a9f0 : ae46             	ldx	6,u
a9f2 : ec02             	ldd	2,x
a9f4 : 3406             	pshs	d
a9f6 : ae44             	ldx	4,u
a9f8 : ec02             	ldd	2,x
a9fa : e3e1             	addd	,s++
a9fc : ae48             	ldx	8,u
a9fe : ed02             	std	2,x
                        * 	if ((sum->l < a->l) || (sum->l < b->l)) sum->h++;
aa00 : ae44             	ldx	4,u
aa02 : ec02             	ldd	2,x
aa04 : 3406             	pshs	d
aa06 : ae48             	ldx	8,u
aa08 : ec02             	ldd	2,x
aa0a : a3e1             	subd	,s++
aa0c : 10250010         	lblo	_8
aa10 : ae46             	ldx	6,u
aa12 : ec02             	ldd	2,x
aa14 : 3406             	pshs	d
aa16 : ae48             	ldx	8,u
aa18 : ec02             	ldd	2,x
aa1a : a3e1             	subd	,s++
aa1c : 1024000c         	lbhs	_7
aa20 :                  _8
aa20 : ae48             	ldx	8,u
aa22 : ec84             	ldd	,x
aa24 : c30001           	addd	#$1
aa27 : ed84             	std	,x
aa29 : 830001           	subd	#$1
                        * }
aa2c :                  _7
aa2c : 35c0             	puls	u,pc
                        * 
AS09 Assembler for M6809 [1.42].                                     Page  136
--------------------------------- merge.a09 ----------------------------------

                        * _u32_inc(a) u32_t *a; {
                        * 	a->l++;
aa2e :                  _u32_inc
aa2e : 3440             	pshs	u
aa30 : 33e4             	leau	,s
aa32 : ec44             	ldd	4,u
aa34 : c30002           	addd	#$2
aa37 : 1f01             	tfr	d,x
aa39 : ec84             	ldd	,x
aa3b : c30001           	addd	#$1
aa3e : ed84             	std	,x
aa40 : 830001           	subd	#$1
                        * 	if (a->l == 0) a->h++;
aa43 : ae44             	ldx	4,u
aa45 : ec02             	ldd	2,x
aa47 : 830000           	subd	#$0
aa4a : 1026000c         	lbne	_9
aa4e : ae44             	ldx	4,u
aa50 : ec84             	ldd	,x
aa52 : c30001           	addd	#$1
aa55 : ed84             	std	,x
aa57 : 830001           	subd	#$1
                        * }
aa5a :                  _9
aa5a : 35c0             	puls	u,pc
                        * 
                        * // <
                        * _u32_lower(a,b) u32_t *a; u32_t *b; {
                        * 	if ((a->h < b->h) || ((a->h == b->h) && (a->l < b->
aa5c :                  _u32_low
aa5c : 3440             	pshs	u
aa5e : 33e4             	leau	,s
aa60 : ecd806           	ldd	[6,u]
aa63 : 3406             	pshs	d
aa65 : ecd804           	ldd	[4,u]
aa68 : a3e1             	subd	,s++
aa6a : 1025001e         	lblo	_11
aa6e : ecd806           	ldd	[6,u]
aa71 : 3406             	pshs	d
aa73 : ecd804           	ldd	[4,u]
aa76 : a3e1             	subd	,s++
aa78 : 10260015         	lbne	_10
aa7c : ae46             	ldx	6,u
aa7e : ec02             	ldd	2,x
aa80 : 3406             	pshs	d
aa82 : ae44             	ldx	4,u
aa84 : ec02             	ldd	2,x
aa86 : a3e1             	subd	,s++
aa88 : 10240005         	lbhs	_10
aa8c :                  _11
aa8c : cc0001           	ldd	#$1
                        * 	else return FALSE;
aa8f : 35c0             	puls	u,pc
aa91 :                  _10
aa91 : 4f               	clra
aa92 : 5f               	clrb
                        * }
aa93 : 35c0             	puls	u,pc
                        * 
                        * // ==
                        * _u32_equal(a,b) u32_t *a; u32_t *b; {
                        * 	if ((a->h == b->h) && (a->l == b->l)) return TRUE;
AS09 Assembler for M6809 [1.42].                                     Page  137
--------------------------------- merge.a09 ----------------------------------

aa95 :                  _u32_equ
aa95 : 3440             	pshs	u
aa97 : 33e4             	leau	,s
aa99 : ecd806           	ldd	[6,u]
aa9c : 3406             	pshs	d
aa9e : ecd804           	ldd	[4,u]
aaa1 : a3e1             	subd	,s++
aaa3 : 10260015         	lbne	_12
aaa7 : ae46             	ldx	6,u
aaa9 : ec02             	ldd	2,x
aaab : 3406             	pshs	d
aaad : ae44             	ldx	4,u
aaaf : ec02             	ldd	2,x
aab1 : a3e1             	subd	,s++
aab3 : 10260005         	lbne	_12
aab7 : cc0001           	ldd	#$1
                        * 	else return FALSE;
aaba : 35c0             	puls	u,pc
aabc :                  _12
aabc : 4f               	clra
aabd : 5f               	clrb
                        * }
aabe : 35c0             	puls	u,pc
                        * 
                        * // >
                        * _u32_higher(a,b) u32_t *a; u32_t *b; {
                        * 	if ((a->h > b->h) || ((a->h == b->h) && (a->l > b->
aac0 :                  _u32_hig
aac0 : 3440             	pshs	u
aac2 : 33e4             	leau	,s
aac4 : ecd806           	ldd	[6,u]
aac7 : 3406             	pshs	d
aac9 : ecd804           	ldd	[4,u]
aacc : a3e1             	subd	,s++
aace : 1022001e         	lbhi	_14
aad2 : ecd806           	ldd	[6,u]
aad5 : 3406             	pshs	d
aad7 : ecd804           	ldd	[4,u]
aada : a3e1             	subd	,s++
aadc : 10260015         	lbne	_13
aae0 : ae46             	ldx	6,u
aae2 : ec02             	ldd	2,x
aae4 : 3406             	pshs	d
aae6 : ae44             	ldx	4,u
aae8 : ec02             	ldd	2,x
aaea : a3e1             	subd	,s++
aaec : 10230005         	lbls	_13
aaf0 :                  _14
aaf0 : cc0001           	ldd	#$1
                        * 	else return FALSE;
aaf3 : 35c0             	puls	u,pc
aaf5 :                  _13
aaf5 : 4f               	clra
aaf6 : 5f               	clrb
                        * }
aaf7 : 35c0             	puls	u,pc
                        * 
                        * /***************************************************
                        * 
                        * //unsigned char _strcpy(char *src)
                        * _strlen(src) char *src;
                        * {
AS09 Assembler for M6809 [1.42].                                     Page  138
--------------------------------- merge.a09 ----------------------------------

                        * 	unsigned char i;
                        * 	i=0;
aaf9 :                  _strlen
aaf9 : 3440             	pshs	u
aafb : 33e4             	leau	,s
aafd : 327f             	leas	-1,s
aaff : 4f               	clra
ab00 : 5f               	clrb
ab01 : e75f             	stb	-1,u
                        * 	while((src[i] != 0) && (i <= 0xff)) {
ab03 :                  _16
ab03 : e65f             	ldb	-1,u
ab05 : 4f               	clra
ab06 : ae44             	ldx	4,u
ab08 : e68b             	ldb	d,x
ab0a : 4f               	clra
ab0b : 830000           	subd	#$0
ab0e : 10270013         	lbeq	_15
ab12 : e65f             	ldb	-1,u
ab14 : 4f               	clra
ab15 : 8300ff           	subd	#$ff
ab18 : 10220009         	lbhi	_15
                        * 		i++;		
ab1c : 305f             	leax	-1,u
ab1e : e684             	ldb	,x
ab20 : 6c84             	inc	,x
ab22 : 4f               	clra
                        * 	};
ab23 : 20de             	lbra	_16
ab25 :                  _15
                        * 	return i;
ab25 : e65f             	ldb	-1,u
ab27 : 4f               	clra
                        * }
ab28 : 32c4             	leas	,u
ab2a : 35c0             	puls	u,pc
                        * 
                        * //void _strcpy(char *dest, char *src)
                        * _strcpy(dest, src) char *dest; char *src;
                        * {
                        * 	char b;
                        * 	do {
ab2c :                  _strcpy
ab2c : 3440             	pshs	u
ab2e : 33e4             	leau	,s
ab30 : 327f             	leas	-1,s
ab32 :                  _19
                        * 		b = *src++;
ab32 : ae46             	ldx	6,u
ab34 : e680             	ldb	,x+
ab36 : af46             	stx	6,u
ab38 : 1d               	sex
ab39 : e75f             	stb	-1,u
                        * 		*dest++ = b;
ab3b : e65f             	ldb	-1,u
ab3d : 1d               	sex
ab3e : ae44             	ldx	4,u
ab40 : e780             	stb	,x+
ab42 : af44             	stx	4,u
                        * 	}while(b != 0);
ab44 :                  _18
ab44 : e65f             	ldb	-1,u
AS09 Assembler for M6809 [1.42].                                     Page  139
--------------------------------- merge.a09 ----------------------------------

ab46 : 1d               	sex
ab47 : 830000           	subd	#$0
ab4a : 26e6             	lbne	_19
                        * }
ab4c :                  _17
ab4c : 35c2             	puls	a,u,pc
                        * 
                        * //unsigned char _strcmp(char *str1, char *str2)
                        * _strcmp(str1, str2) char *str1; char *str2;
                        * {
                        * 	while((*str1 != 0) && (*str2 != 0)) {
ab4e :                  _strcmp
ab4e : 3440             	pshs	u
ab50 : 33e4             	leau	,s
ab52 :                  _21
ab52 : e6d804           	ldb	[4,u]
ab55 : 1d               	sex
ab56 : 830000           	subd	#$0
ab59 : 10270028         	lbeq	_20
ab5d : e6d806           	ldb	[6,u]
ab60 : 1d               	sex
ab61 : 830000           	subd	#$0
ab64 : 1027001d         	lbeq	_20
                        * 		if (*str1++ != *str2++) return 1;
ab68 : ae46             	ldx	6,u
ab6a : e680             	ldb	,x+
ab6c : af46             	stx	6,u
ab6e : 1d               	sex
ab6f : 3406             	pshs	d
ab71 : ae44             	ldx	4,u
ab73 : e680             	ldb	,x+
ab75 : af44             	stx	4,u
ab77 : 1d               	sex
ab78 : a3e1             	subd	,s++
ab7a : 10270005         	lbeq	_22
ab7e : cc0001           	ldd	#$1
                        * 	}
ab81 : 35c0             	puls	u,pc
ab83 :                  _22
                        * 	return 0;
ab83 : 20cd             	lbra	_21
ab85 :                  _20
ab85 : 4f               	clra
ab86 : 5f               	clrb
                        * }
ab87 : 35c0             	puls	u,pc
                        * 
                        * 
                        * 
                        * 
                        * /***************************************************
                        * /*                                                  
                        * /* file:          sdcard.c			                       
                        * /*                                                  
                        * /* source:        2023, written by Adrian Kundert (a
                        * /*                                                  
                        * /* description:   read and write data from SD CARD (
                        * /*                                                  
                        * /* This library is free software; you can redistribu
                        * /* GNU Lesser General Public License as published by
                        * /* either version 2.1 of the License, or (at your op
                        * /*                                                  
AS09 Assembler for M6809 [1.42].                                     Page  140
--------------------------------- merge.a09 ----------------------------------

                        * /* This library is distributed in the hope that it w
                        * /* without even the implied warranty of MERCHANTABIL
                        * /* See the GNU Lesser General Public License for mor
                        * /*                                                  
                        * /***************************************************
                        * 
                        * #include "sdcard.h"
                        * /***************************************************
                        * /*                                                  
                        * /* file:          sdcard.h			                       
                        * /*                                                  
                        * /* source:        2023, written by Adrian Kundert (a
                        * /*                                                  
                        * /* description:   read and write data from SD CARD (
                        * /*                                                  
                        * /* This library is free software; you can redistribu
                        * /* GNU Lesser General Public License as published by
                        * /* either version 2.1 of the License, or (at your op
                        * /*                                                  
                        * /* This library is distributed in the hope that it w
                        * /* without even the implied warranty of MERCHANTABIL
                        * /* See the GNU Lesser General Public License for mor
                        * /*                                                  
                        * /***************************************************
                        * 
                        * /***************************************************
                        *                                SD CARD INIT STATUS
                        *  ***************************************************
                        * #define INIT_SUCCESSFUL 0
                        * #define NOT_DETECTED    1
                        * #define INIT_FAILED     2
                        * #define FAT_INVALID     3
                        * #define SIZE_INVALID    4
                        * 
                        * 
                        * #define TYPE_UNKNOWN        0
                        * #define TYPE_STANDARD       1
                        * #define TYPE_HIGH_CAPACITY  2
                        * /***************************************************
                        * 
                        * #define C_MaxPageSize_U16        512
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * //SD commands, many of these are not used here
                        * #define GO_IDLE_STATE            0
                        * #define SEND_OP_COND             1
                        * #define SEND_IF_COND			 8
                        * #define SEND_CSD                 9
                        * #define STOP_TRANSMISSION        12
                        * #define SEND_STATUS              13
                        * #define SET_BLOCK_LEN            16
                        * #define RD_SINGLE_BLOCK        17
                        * #define RD_MULTIPLE_BLOCKS     18
                        * #define WR_SINGLE_BLOCK       24
                        * #define WR_MULTIPLE_BLOCKS    25
AS09 Assembler for M6809 [1.42].                                     Page  141
--------------------------------- merge.a09 ----------------------------------

                        * // #define ERASE_BLOCK_START_ADDR   32
                        * // #define ERASE_BLOCK_END_ADDR     33
                        * // #define ERASE_SELECTED_BLOCKS    38
                        * #define SD_SEND_OP_COND			 41   
                        * #define APP_CMD					 55
                        * #define READ_OCR				 58
                        * #define CRC_ON_OFF               59
                        * 
                        * 
                        * 
                        *  
                        * #define PORTA   0xd800
                        * #define CRA     0xd801
                        * #define PORTB   0xd802
                        * #define CRB     0xd803
                        * 
                        * //--------------------------------------------------
                        * 
                        * #define SD_TIMEOUT 2000
                        * 
                        * /*
                        *   The circuit:
                        *     SD card attached to GPIO as follows:
                        *  ** CS   - PB0 
                        *  ** MOSI - PB1
                        *  ** MISO - PB2
                        *  ** CLK  - PB3
                        * */
                        * 
                        * setPins() {
                        * 	/*	
                        * 	DDR |= 0b00000001; CS_HIGH();	// cs_n
                        * 	DDR |= 0b00000010; MOSI_HIGH();	// mosi
                        * 	DDR &= 0b11111011;				// miso
                        * 	DDR |= 0b00001000; SCK_LOW();	// sck
                        * 	*/
                        *  	PIAinit(PORTB, 0x0b);
ab89 :                  setPins
ab89 : 3440             	pshs	u
ab8b : 33e4             	leau	,s
ab8d : cc000b           	ldd	#$b
ab90 : 3406             	pshs	d
ab92 : ccd802           	ldd	#$d802
ab95 : 3406             	pshs	d
ab97 : bdf24e           	lbsr	PIAinit
ab9a : 3264             	leas	4,s
                        * 	CS_HIGH(); MOSI_HIGH(); SCK_LOW();
ab9c : bdaba7           	lbsr	CS_HIGH
ab9f : bdabb9           	lbsr	MOSI_HIG
aba2 : bdabdd           	lbsr	SCK_LOW
                        * }
aba5 : 35c0             	puls	u,pc
                        * 
                        * #asm
aba7 : f6d802           CS_HIGH		ldb		PORTB
abaa : ca01             			orb		#%00000001
abac : f7d802           			stb		PORTB
abaf : 39               			rts
                        
abb0 : f6d802           CS_LOW		ldb		PORTB
abb3 : c4fe             			andb	#%11111110
abb5 : f7d802           			stb		PORTB
AS09 Assembler for M6809 [1.42].                                     Page  142
--------------------------------- merge.a09 ----------------------------------

abb8 : 39               			rts
                        
abb9 : f6d802           MOSI_HIG	ldb		PORTB
abbc : ca02             			orb		#%00000010
abbe : f7d802           			stb		PORTB
abc1 : 39               			rts
                        
abc2 : f6d802           MOSI_LOW	ldb		PORTB
abc5 : c4fd             			andb	#%11111101
abc7 : f7d802           			stb		PORTB
abca : 39               			rts		
                        
abcb : f6d802           MISO_REA	ldb		PORTB
abce : c404             			andb	#%00000100
abd0 : 54               			lsrb	
abd1 : 54               			lsrb
abd2 : 4f               			clra
abd3 : 39               			rts
                        
abd4 : f6d802           SCK_HIGH	ldb		PORTB
abd7 : ca08             			orb		#%00001000
abd9 : f7d802           			stb		PORTB
abdc : 39               			rts
                        
abdd : f6d802           SCK_LOW		ldb		PORTB
abe0 : c4f7             			andb	#%11110111
abe2 : f7d802           			stb		PORTB
abe5 : 39               			rts
                        * 
                        * 
                        * SPI_Init() {
                        *   unsigned char i;
                        * 
                        *   setPins();
abe6 :                  SPI_Init
abe6 : 3440             	pshs	u
abe8 : 33e4             	leau	,s
abea : 327f             	leas	-1,s
abec : 8d9b             	lbsr	setPins
                        *   
                        *   // 80 clks without CS to init the SPI connection  
                        *   for(i=0; i<80; i++) {
abee : 4f               	clra
abef : 5f               	clrb
abf0 : e75f             	stb	-1,u
abf2 :                  _24
abf2 : e65f             	ldb	-1,u
abf4 : 4f               	clra
abf5 : 830050           	subd	#$50
abf8 : 1024000d         	lbhs	_23
                        *     SCK_HIGH();
abfc : 8dd6             	lbsr	SCK_HIGH
                        *     SCK_LOW();
abfe : 8ddd             	lbsr	SCK_LOW
                        *   }  
                        * }
ac00 :                  _25
ac00 : 305f             	leax	-1,u
ac02 : e684             	ldb	,x
ac04 : 6c84             	inc	,x
ac06 : 1d               	sex
ac07 : 20e9             	lbra	_24
AS09 Assembler for M6809 [1.42].                                     Page  143
--------------------------------- merge.a09 ----------------------------------

ac09 :                  _23
ac09 : 35c2             	puls	a,u,pc
                        * 
                        * //SPI_Write(data) unsigned char data; {}
                        * #asm
ac0b :                  SPI_Write
ac0b :                  SPI_Writ
                        		; 0,s return address
                        		; 2,s not used -> taken as unsigned char i
                        		; 3,s data
ac0b : 8608             		lda	#8			;8 bits countdown
ac0d : a762             		sta	2,s		
ac0f : 8dcc             SPI_W0	lbsr SCK_LOW
ac11 : 6863             		lsl 3,s
ac13 : 10240005         		lbcc SPI_W1
ac17 : 8da0             		lbsr MOSI_HIG
ac19 : 200312           		lbra SPI_W2
ac1c : 8da4             SPI_W1	lbsr MOSI_LOW
ac1e : 8db4             SPI_W2	lbsr SCK_HIGH		
ac20 : 6a62             		dec 2,s
ac22 : 26eb             		lbne SPI_W0
ac24 : 8db7             		lbsr SCK_LOW				
ac26 : 39               		rts
                        * 
                        * SPI_Rsync(mask) unsigned char mask; {
                        *     unsigned char data;			// any changes will impact
                        *     unsigned int retry;
                        * 	data = 0xff;
ac27 :                  SPI_Rsyn
ac27 : 3440             	pshs	u
ac29 : 33e4             	leau	,s
ac2b : 327d             	leas	-3,s
ac2d : cc00ff           	ldd	#$ff
ac30 : e75f             	stb	-1,u
                        *     retry = SD_TIMEOUT;
ac32 : cc07d0           	ldd	#$7d0
ac35 : ed5d             	std	-3,u
                        * 	
                        * 	MOSI_HIGH(); // rest state 
ac37 : 8d80             	lbsr	MOSI_HIG
                        *     do {  // 10 KHz sck loop
ac39 :                  _28
                        *         if(--retry == 0) break; //{print_DebugMsg("s
ac39 : ec5d             	ldd	-3,u
ac3b : c3ffff           	addd	#$ffff
ac3e : ed5d             	std	-3,u
ac40 : 830000           	subd	#$0
ac43 : 10260003         	lbne	_29
ac47 : 202312           	lbra	_26
                        * 		SCK_HIGH();
ac4a :                  _29
ac4a : 8d88             	lbsr	SCK_HIGH
                        * #asm
                        *       data = MISO_READ() | (data<<1);
ac4c : 685f             		lsl		-1,u
ac4e : bdabcb           		lbsr	MISO_REA
ac51 : ea5f             		orb		-1,u
ac53 : e75f             		stb		-1,u
                        * 		SCK_LOW();		
ac55 : 8d86             	lbsr	SCK_LOW
                        *     }while((data|mask) != mask);  // wait on matchin
ac57 :                  _27
AS09 Assembler for M6809 [1.42].                                     Page  144
--------------------------------- merge.a09 ----------------------------------

ac57 : e645             	ldb	5,u
ac59 : 4f               	clra
ac5a : 3406             	pshs	d
ac5c : e645             	ldb	5,u
ac5e : 4f               	clra
ac5f : 3406             	pshs	d
ac61 : e65f             	ldb	-1,u
ac63 : 4f               	clra
ac64 : aae0             	ora	,s+
ac66 : eae0             	orb	,s+
ac68 : a3e1             	subd	,s++
ac6a : 26cd             	lbne	_28
                        *     
                        *     return data;
ac6c :                  _26
ac6c : e65f             	ldb	-1,u
ac6e : 4f               	clra
                        * }
ac6f : 32c4             	leas	,u
ac71 : 35c0             	puls	u,pc
                        * 
                        * SPI_Read() {
                        *     unsigned char i, data;		// any changes will impa
                        * 	
                        * 	data=0;
ac73 :                  SPI_Read
ac73 : 3440             	pshs	u
ac75 : 33e4             	leau	,s
ac77 : 327e             	leas	-2,s
ac79 : 4f               	clra
ac7a : 5f               	clrb
ac7b : e75e             	stb	-2,u
                        *     MOSI_HIGH(); // rest state 
ac7d : bdabb9           	lbsr	MOSI_HIG
                        * #asm
                        *	for(i=8; i>0; i--)  {   // 10 KHz sck loop     
ac80 : c608             	ldb	#8
ac82 : e75f             	stb	-1,u
ac84 :                  SPI_R1	
                        *         SCK_HIGH(); 
ac84 : bdabd4           	lbsr	SCK_HIGH
                        *         data = MISO_READ() | (data<<1);        
ac87 : bdabcb           	lbsr	MISO_REA
ac8a : 685e             	lsl		-2,u
ac8c : ea5e             	orb		-2,u
ac8e : e75e             	stb		-2,u
                        *         SCK_LOW();
ac90 : bdabdd           	lbsr	SCK_LOW
ac93 : 6a5f             	dec		-1,u
ac95 : 26ed             	lbne	SPI_R1
                        *     }	
                        *     return data;
ac97 : e65e             	ldb	-2,u
ac99 : 4f               	clra
                        * }
ac9a : 35d0             	puls	x,u,pc
                        * 
                        * SPI_EnableChipSelect () {
                        *     CS_LOW();
ac9c :                  SPI_Enab
ac9c : 3440             	pshs	u
ac9e : 33e4             	leau	,s
AS09 Assembler for M6809 [1.42].                                     Page  145
--------------------------------- merge.a09 ----------------------------------

aca0 : bdabb0           	lbsr	CS_LOW
                        * }
aca3 : 35c0             	puls	u,pc
                        * 
                        * SPI_DisableChipSelect () {
                        *     CS_HIGH();
aca5 :                  SPI_Disa
aca5 : 3440             	pshs	u
aca7 : 33e4             	leau	,s
aca9 : bdaba7           	lbsr	CS_HIGH
                        * }
acac : 35c0             	puls	u,pc
                        * 
                        * //--------------------------------------------------
                        * unsigned char V_SdHighcapacityFlag_u8;
ffff =                  V_SdHigh	equ	-1
                        * 
                        * 
                        * //**************************************************
                        * //Function	: to send a command to SD card
                        * //Arguments	: unsigned char (8-bit command value)
                        * // 			  & unsigned long (32-bit command argument)
                        * //return	: unsigned char; response byte
                        * //**************************************************
                        * SD_sendCommand(cmd, arg) unsigned char cmd; u32_t *a
                        * {
                        * 	unsigned char response; 		// any changes will impac
                        * 	unsigned int argLo, argHi;  	// any changes will im
                        * 	
                        * 	response = 0xff;	
acae :                  SD_sendC
acae : 3440             	pshs	u
acb0 : 33e4             	leau	,s
acb2 : 327b             	leas	-5,s
acb4 : cc00ff           	ldd	#$ff
acb7 : e75f             	stb	-1,u
                        * 	argHi = arg->h;
acb9 : ecd806           	ldd	[6,u]
acbc : ed5b             	std	-5,u
                        * 	argLo = arg->l;
acbe : ae46             	ldx	6,u
acc0 : ec02             	ldd	2,x
acc2 : ed5d             	std	-3,u
                        * 	
                        * 	if(SPI_Rsync(0xff) == 0xff) //ensure ready, shall r
acc4 : cc00ff           	ldd	#$ff
acc7 : 3406             	pshs	d
acc9 : bdac27           	lbsr	SPI_Rsyn
accc : 3262             	leas	2,s
acce : 8300ff           	subd	#$ff
acd1 : 102600aa         	lbne	_30
                        * 	{
                        * 		   
                        * 	    //SD card accepts byte address while SDHC accep
                        * 	    //so, if it's SD card we need to convert block 
                        * 	    //multiplying it with 512. which is equivalent 
                        * 	    //following 'if' loop does that
                        * 	    
                        * 		if(V_SdHighcapacityFlag_u8 == 0)
acd5 : e63f             	ldb	V_SdHigh+0,y
acd7 : 4f               	clra
acd8 : 830000           	subd	#$0
AS09 Assembler for M6809 [1.42].                                     Page  146
--------------------------------- merge.a09 ----------------------------------

acdb : 1026003f         	lbne	_31
                        * 	    {
                        * 		    if((cmd == RD_SINGLE_BLOCK)      ||
                        * 				(cmd == RD_MULTIPLE_BLOCKS)  ||
                        * 				(cmd == WR_SINGLE_BLOCK)    ||
                        * 				(cmd == WR_MULTIPLE_BLOCKS))
acdf : e645             	ldb	5,u
ace1 : 4f               	clra
ace2 : 830011           	subd	#$11
ace5 : 1027001e         	lbeq	_33
ace9 : e645             	ldb	5,u
aceb : 4f               	clra
acec : 830012           	subd	#$12
acef : 10270014         	lbeq	_33
acf3 : e645             	ldb	5,u
acf5 : 4f               	clra
acf6 : 830018           	subd	#$18
acf9 : 1027000a         	lbeq	_33
acfd : e645             	ldb	5,u
acff : 4f               	clra
ad00 : 830019           	subd	#$19
ad03 : 10260017         	lbne	_32
ad07 :                  _33
                        * 		    {
                        * #asm			
                        *				argHi = (argHi << 9) | (argLo >> 7);
ad07 : 4f               				clra
ad08 : e65e             				ldb	-2,u	; argLo lower word
ad0a : 58               				lslb
ad0b : 49               				rola
ad0c : 3402             				pshs a		; msb argLo lower word
ad0e : a65c             				lda	-4,u	; argHi lower word
ad10 : e65d             				ldb -3,u	; argLo upper word
ad12 : 58               				lslb
ad13 : 49               				rola
ad14 : ebe0             				addb ,s+
ad16 : ed5b             				std	-5,u
                         			    
                        *				argLo = argLo << 9;				
ad18 : a65e             				lda	-2,u	; argLo lower word
ad1a : 48               				lsla
ad1b : 5f               				clrb
ad1c : ed5d             				std	-3,u
                        * 		    }
                        * 	    }
ad1e :                  _32
                        * 		
                        * 		{	// use a brace when starting asm code following 
ad1e :                  _31
                        * #asm
                        *		SPI_Write( cmd | 0x40 );
ad1e : e645             		ldb	5,u
ad20 : 4f               		clra
ad21 : ca40             		orb	#$40
ad23 : 3406             		pshs	d
ad25 : bdac0b           		lbsr	SPI_Writ
ad28 : 3262             		leas	2,s
                        *		SPI_Write( argHi >> 8);
ad2a : e65b             		ldb	-5,u	; argHi upper word
ad2c : 4f               		clra
ad2d : 3406             		pshs	d
ad2f : bdac0b           		lbsr	SPI_Writ
AS09 Assembler for M6809 [1.42].                                     Page  147
--------------------------------- merge.a09 ----------------------------------

ad32 : 3262             		leas	2,s
                        *		SPI_Write( argHi & 0xff );
ad34 : e65c             		ldb	-4,u	; argHi lower word
ad36 : 4f               		clra
ad37 : 3406             		pshs	d
ad39 : bdac0b           		lbsr	SPI_Writ
ad3c : 3262             		leas	2,s		
                        *		SPI_Write( argLo >> 8);
ad3e : e65d             		ldb	-3,u	; argLo upper word
ad40 : 4f               		clra
ad41 : 3406             		pshs	d
ad43 : bdac0b           		lbsr	SPI_Writ
ad46 : 3262             		leas	2,s
                        *		SPI_Write( argLo & 0xff );
ad48 : e65e             		ldb	-2,u	; argLo lower word
ad4a : 4f               		clra
ad4b : 3406             		pshs	d
ad4d : bdac0b           		lbsr	SPI_Writ
ad50 : 3262             		leas	2,s
                        * 		}
                        * 		
                        * 		if ( cmd == SEND_IF_COND )
ad52 : e645             	ldb	5,u
ad54 : 4f               	clra
ad55 : 830008           	subd	#$8
ad58 : 1026000d         	lbne	_34
                        * 			SPI_Write( 0x87 );     
ad5c : cc0087           	ldd	#$87
ad5f : 3406             	pshs	d
ad61 : bdac0b           	lbsr	SPI_Writ
ad64 : 3262             	leas	2,s
                        * 		else {
ad66 : 200b12           	lbra	_35
ad69 :                  _34
                        * 			SPI_Write( 0x95 ); 
ad69 : cc0095           	ldd	#$95
ad6c : 3406             	pshs	d
ad6e : bdac0b           	lbsr	SPI_Writ
ad71 : 3262             	leas	2,s
                        * 		}
                        * 		response = SPI_Rsync(0x7f); //wait response, is 0 
ad73 :                  _35
ad73 : cc007f           	ldd	#$7f
ad76 : 3406             	pshs	d
ad78 : bdac27           	lbsr	SPI_Rsyn
ad7b : 3262             	leas	2,s
ad7d : e75f             	stb	-1,u
                        * 	}
                        * 	
                        * 	if((response == 0x00) && (cmd == READ_OCR))  //chec
ad7f :                  _30
ad7f : e65f             	ldb	-1,u
ad81 : 4f               	clra
ad82 : 830000           	subd	#$0
ad85 : 1026002d         	lbne	_36
ad89 : e645             	ldb	5,u
ad8b : 4f               	clra
ad8c : 83003a           	subd	#$3a
ad8f : 10260023         	lbne	_36
                        * 	{
                        * 		if((SPI_Read() & 0x40) != 0) //first byte of the O
ad93 : bdac73           	lbsr	SPI_Read
AS09 Assembler for M6809 [1.42].                                     Page  148
--------------------------------- merge.a09 ----------------------------------

ad96 : 8400             	anda	#$0
ad98 : c440             	andb	#$40
ad9a : 830000           	subd	#$0
ad9d : 10270008         	lbeq	_37
                        * 		{
                        * 			V_SdHighcapacityFlag_u8 = 1;  //we need it to ver
ada1 : cc0001           	ldd	#$1
ada4 : e73f             	stb	V_SdHigh+0,y
                        * 			//print_DebugMsg("set SdHighcapacityFlag\n");
                        * 		}
                        * 		else
ada6 : 200512           	lbra	_38
ada9 :                  _37
                        * 		{
                        * 			V_SdHighcapacityFlag_u8 = 0;
ada9 : 4f               	clra
adaa : 5f               	clrb
adab : e73f             	stb	V_SdHigh+0,y
                        * 		}
                        * 
                        * 		SPI_Read(); //remaining 3 bytes of the OCR registe
adad :                  _38
adad : bdac73           	lbsr	SPI_Read
                        * 		SPI_Read(); //one can use these bytes to check pow
adb0 : bdac73           	lbsr	SPI_Read
                        * 		SPI_Read();
adb3 : bdac73           	lbsr	SPI_Read
                        * 	}
                        * 	
                        *     SPI_Read(); //extra 8 CLK
adb6 :                  _36
adb6 : bdac73           	lbsr	SPI_Read
                        * 	return response;
adb9 : e65f             	ldb	-1,u
adbb : 4f               	clra
                        * }
adbc : 32c4             	leas	,u
adbe : 35c0             	puls	u,pc
                        * 
                        * /***************************************************
                        *                           uint8_t SD_Init(uint8_t *c
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                  uint8_t *: Pointer to stire Card Ty
                        *                            SDCARD_TYPE_UNKNOWN
                        *                            SDCARD_TYPE_STANDARD
                        *                            SDCARD_TYPE_HIGH_CAPACITY
                        * 
                        *  * Return value  :
                        *                   uint8_t : Returns the SD card init
                        *                   SDCARD_INIT_SUCCESSFUL
                        *                   SDCARD_NOT_DETECTED
                        *                   SDCARD_INIT_FAILED
                        *                   SDCARD_FAT_INVALID
                        * 
                        *  * description :
                        *                  This function is used to initialize
                        *                  It returns the initialization statu
                        *  ***************************************************
                        * SD_Init(cardType) unsigned char *cardType; {
                        * 	unsigned char response, sd_version;
                        * 	unsigned int retry;
AS09 Assembler for M6809 [1.42].                                     Page  149
--------------------------------- merge.a09 ----------------------------------

                        * 	u32_t tmp;
                        * 	
                        * 	{ // brace to ensure proper initialisation before t
adc0 :                  SD_Init
adc0 : 3440             	pshs	u
adc2 : 33e4             	leau	,s
adc4 : 3278             	leas	-8,s
                        * #asm	
adc6 : 108e7fb9         	ldy  #GV_StackBeginAddr	; restore C global variables 
                        * 	}
                        * 	
                        * 	SPI_Init();
adca : bdabe6           	lbsr	SPI_Init
                        * 	V_SdHighcapacityFlag_u8 = 0;
adcd : 4f               	clra
adce : 5f               	clrb
adcf : e73f             	stb	V_SdHigh+0,y
                        * 
                        * 	SPI_EnableChipSelect ();    
add1 : bdac9c           	lbsr	SPI_Enab
                        * 	retry=SD_TIMEOUT;
add4 : cc07d0           	ldd	#$7d0
add7 : ed5c             	std	-4,u
                        * 	tmp.h = tmp.l = 0x0000;
add9 : 4f               	clra
adda : 5f               	clrb
addb : ed5a             	std	-6,u
addd : ed58             	std	-8,u
                        * 	do {
addf :                  _41
                        *         response = SD_sendCommand(GO_IDLE_STATE, &tm
addf : 3058             	leax	-8,u
ade1 : 3410             	pshs	x
ade3 : 4f               	clra
ade4 : 5f               	clrb
ade5 : 3406             	pshs	d
ade7 : bdacae           	lbsr	SD_sendC
adea : 3264             	leas	4,s
adec : e75f             	stb	-1,u
                        *         if(--retry == 0) {return NOT_DETECTED;}   //
adee : ec5c             	ldd	-4,u
adf0 : c3ffff           	addd	#$ffff
adf3 : ed5c             	std	-4,u
adf5 : 830000           	subd	#$0
adf8 : 10260007         	lbne	_42
adfc : cc0001           	ldd	#$1
adff : 32c4             	leas	,u
ae01 : 35c0             	puls	u,pc
                        *     }while(response != 1);
ae03 :                  _42
ae03 :                  _40
ae03 : e65f             	ldb	-1,u
ae05 : 4f               	clra
ae06 : 830001           	subd	#$1
ae09 : 26d4             	lbne	_41
                        * 	//print_DebugMsg("cmd00 OK\n");
                        *  	
                        * 	retry = SD_TIMEOUT;
ae0b :                  _39
ae0b : cc07d0           	ldd	#$7d0
ae0e : ed5c             	std	-4,u
                        * 	*cardType = TYPE_STANDARD;
AS09 Assembler for M6809 [1.42].                                     Page  150
--------------------------------- merge.a09 ----------------------------------

ae10 : cc0001           	ldd	#$1
ae13 : e7d804           	stb	[4,u]
                        * 	sd_version = 2; //default set to SD compliance with
ae16 : cc0002           	ldd	#$2
ae19 : e75e             	stb	-2,u
                        * 	//this may change after checking the next command
                        * 	tmp.h = 0x0000; tmp.l = 0x01AA;
ae1b : 4f               	clra
ae1c : 5f               	clrb
ae1d : ed58             	std	-8,u
ae1f : cc01aa           	ldd	#$1aa
ae22 : ed5a             	std	-6,u
                        * 	do {        
ae24 :                  _45
                        *         response = SD_sendCommand(SEND_IF_COND, &tmp
ae24 : 3058             	leax	-8,u
ae26 : 3410             	pshs	x
ae28 : cc0008           	ldd	#$8
ae2b : 3406             	pshs	d
ae2d : bdacae           	lbsr	SD_sendC
ae30 : 3264             	leas	4,s
ae32 : e75f             	stb	-1,u
                        *         SPI_Read(); SPI_Read(); SPI_Read(); SPI_Read
ae34 : bdac73           	lbsr	SPI_Read
ae37 : bdac73           	lbsr	SPI_Read
ae3a : bdac73           	lbsr	SPI_Read
ae3d : bdac73           	lbsr	SPI_Read
                        * 		if(--retry == 0) {
ae40 : ec5c             	ldd	-4,u
ae42 : c3ffff           	addd	#$ffff
ae45 : ed5c             	std	-4,u
ae47 : 830000           	subd	#$0
ae4a : 10260008         	lbne	_46
                        * 			sd_version = 1;			
ae4e : cc0001           	ldd	#$1
ae51 : e75e             	stb	-2,u
                        * 			break;
ae53 : 200912           	lbra	_43
                        * 		}
                        *     }while(response != 1);    
ae56 :                  _46
ae56 :                  _44
ae56 : e65f             	ldb	-1,u
ae58 : 4f               	clra
ae59 : 830001           	subd	#$1
ae5c : 26c6             	lbne	_45
                        *     //print_DebugMsg("cmd08 done\n");
                        * 	 
                        * 	retry = SD_TIMEOUT;
ae5e :                  _43
ae5e : cc07d0           	ldd	#$7d0
ae61 : ed5c             	std	-4,u
                        * 	do {
ae63 :                  _49
                        *         tmp.h = tmp.l = 0x0000;
ae63 : 4f               	clra
ae64 : 5f               	clrb
ae65 : ed5a             	std	-6,u
ae67 : ed58             	std	-8,u
                        * 		SD_sendCommand(APP_CMD, &tmp);
ae69 : 3058             	leax	-8,u
ae6b : 3410             	pshs	x
AS09 Assembler for M6809 [1.42].                                     Page  151
--------------------------------- merge.a09 ----------------------------------

ae6d : cc0037           	ldd	#$37
ae70 : 3406             	pshs	d
ae72 : bdacae           	lbsr	SD_sendC
ae75 : 3264             	leas	4,s
                        * 		tmp.h = 0x4000; tmp.l = 0x0000;
ae77 : cc4000           	ldd	#$4000
ae7a : ed58             	std	-8,u
ae7c : 4f               	clra
ae7d : 5f               	clrb
ae7e : ed5a             	std	-6,u
                        *         response = SD_sendCommand(SD_SEND_OP_COND, &
ae80 : 3058             	leax	-8,u
ae82 : 3410             	pshs	x
ae84 : cc0029           	ldd	#$29
ae87 : 3406             	pshs	d
ae89 : bdacae           	lbsr	SD_sendC
ae8c : 3264             	leas	4,s
ae8e : e75f             	stb	-1,u
                        *         if(--retry == 0) {return INIT_FAILED;}  //ti
ae90 : ec5c             	ldd	-4,u
ae92 : c3ffff           	addd	#$ffff
ae95 : ed5c             	std	-4,u
ae97 : 830000           	subd	#$0
ae9a : 10260007         	lbne	_50
ae9e : cc0002           	ldd	#$2
aea1 : 32c4             	leas	,u
aea3 : 35c0             	puls	u,pc
                        *     }while(response != 0);
aea5 :                  _50
aea5 :                  _48
aea5 : e65f             	ldb	-1,u
aea7 : 4f               	clra
aea8 : 830000           	subd	#$0
aeab : 26b6             	lbne	_49
                        *     //print_DebugMsg("cmd55,cmd41 OK\n");
                        *     //print_DebugMsg("Wiring is correct and a card i
                        * 	
                        * 	if (sd_version == 2) {
aead :                  _47
aead : e65e             	ldb	-2,u
aeaf : 4f               	clra
aeb0 : 830002           	subd	#$2
aeb3 : 10260052         	lbne	_51
                        * 		retry = SD_TIMEOUT;
aeb7 : cc07d0           	ldd	#$7d0
aeba : ed5c             	std	-4,u
                        * 		tmp.h = tmp.l = 0x0000;		
aebc : 4f               	clra
aebd : 5f               	clrb
aebe : ed5a             	std	-6,u
aec0 : ed58             	std	-8,u
                        * 		do {			
aec2 :                  _54
                        * 			response = SD_sendCommand(READ_OCR, &tmp);			
aec2 : 3058             	leax	-8,u
aec4 : 3410             	pshs	x
aec6 : cc003a           	ldd	#$3a
aec9 : 3406             	pshs	d
aecb : bdacae           	lbsr	SD_sendC
aece : 3264             	leas	4,s
aed0 : e75f             	stb	-1,u
                        * 			if(--retry == 0) {
AS09 Assembler for M6809 [1.42].                                     Page  152
--------------------------------- merge.a09 ----------------------------------

aed2 : ec5c             	ldd	-4,u
aed4 : c3ffff           	addd	#$ffff
aed7 : ed5c             	std	-4,u
aed9 : 830000           	subd	#$0
aedc : 10260008         	lbne	_55
                        * 				*cardType = TYPE_UNKNOWN;
aee0 : 4f               	clra
aee1 : 5f               	clrb
aee2 : e7d804           	stb	[4,u]
                        * 				break;  //time out
aee5 : 200912           	lbra	_52
                        * 			}
                        * 		}while(response != 0);
aee8 :                  _55
aee8 :                  _53
aee8 : e65f             	ldb	-1,u
aeea : 4f               	clra
aeeb : 830000           	subd	#$0
aeee : 26d2             	lbne	_54
                        * 		//print_DebugMsg("cmd58 sent\n");
                        * 		
                        * 		if((cardType != TYPE_UNKNOWN) && (V_SdHighcapacity
aef0 :                  _52
aef0 : ec44             	ldd	4,u
aef2 : 830000           	subd	#$0
aef5 : 10270010         	lbeq	_56
aef9 : e63f             	ldb	V_SdHigh+0,y
aefb : 4f               	clra
aefc : 830001           	subd	#$1
aeff : 10260006         	lbne	_56
                        * 			*cardType = TYPE_HIGH_CAPACITY;
af03 : cc0002           	ldd	#$2
af06 : e7d804           	stb	[4,u]
                        * 		}
                        * 	}
af09 :                  _56
                        * 	SPI_DisableChipSelect ();
af09 :                  _51
af09 : bdaca5           	lbsr	SPI_Disa
                        * 
                        *     //print_DebugMsg("SD init completed\n");
                        * 	return INIT_SUCCESSFUL;  
af0c : 4f               	clra
af0d : 5f               	clrb
                        * }
af0e : 32c4             	leas	,u
af10 : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function	: to read a single block from SD card
                        * //Arguments	: none
                        * //return	: unsigned char; will be 0 if no error,
                        * // 			  otherwise the response byte is returned
                        * //**************************************************
                        * SD_readSingleBlock(buf, startBlock) char *buf; u32_t
                        * {
                        * 	unsigned char response;
                        * 	unsigned int i;
                        * 	
                        * 	SPI_EnableChipSelect ();
af12 :                  SD_readS
af12 : 3440             	pshs	u
AS09 Assembler for M6809 [1.42].                                     Page  153
--------------------------------- merge.a09 ----------------------------------

af14 : 33e4             	leau	,s
af16 : 327d             	leas	-3,s
af18 : bdac9c           	lbsr	SPI_Enab
                        *     i=SD_TIMEOUT;
af1b : cc07d0           	ldd	#$7d0
af1e : ed5d             	std	-3,u
                        * 	do {
af20 :                  _59
                        * 		response = SD_sendCommand(RD_SINGLE_BLOCK, startBl
af20 : ec46             	ldd	6,u
af22 : 3406             	pshs	d
af24 : cc0011           	ldd	#$11
af27 : 3406             	pshs	d
af29 : bdacae           	lbsr	SD_sendC
af2c : 3264             	leas	4,s
af2e : e75f             	stb	-1,u
                        * 		if(--i == 0) {
af30 : ec5d             	ldd	-3,u
af32 : c3ffff           	addd	#$ffff
af35 : ed5d             	std	-3,u
af37 : 830000           	subd	#$0
af3a : 10260007         	lbne	_60
                        * 		    //print_DebugMsg("\nread cmd failed!\n");
                        * 		    return response; //check for SD status: 0x00 -
af3e : e65f             	ldb	-1,u
af40 : 4f               	clra
                        * 	    }		
af41 : 32c4             	leas	,u
af43 : 35c0             	puls	u,pc
                        * 	}while(response != 0x00);
af45 :                  _60
af45 :                  _58
af45 : e65f             	ldb	-1,u
af47 : 4f               	clra
af48 : 830000           	subd	#$0
af4b : 26d3             	lbne	_59
                        *     
                        * 	if(SPI_Rsync(0xfe) != 0xfe) //wait data token 0xfe 
af4d :                  _57
af4d : cc00fe           	ldd	#$fe
af50 : 3406             	pshs	d
af52 : bdac27           	lbsr	SPI_Rsyn
af55 : 3262             	leas	2,s
af57 : 8300fe           	subd	#$fe
af5a : 1027000a         	lbeq	_61
                        * 	{									
                        *   		SPI_DisableChipSelect();        
af5e : bdaca5           	lbsr	SPI_Disa
                        *   		//print_DebugMsg("read token failed!\n");
                        * 		return 1;
af61 : cc0001           	ldd	#$1
                        * 	}
af64 : 32c4             	leas	,u
af66 : 35c0             	puls	u,pc
                        * 	
                        * 	for (i = 0; i < C_MaxPageSize_U16; i ++ ) {
af68 :                  _61
af68 : 4f               	clra
af69 : 5f               	clrb
af6a : ed5d             	std	-3,u
af6c :                  _63
af6c : ec5d             	ldd	-3,u
AS09 Assembler for M6809 [1.42].                                     Page  154
--------------------------------- merge.a09 ----------------------------------

af6e : 830200           	subd	#$200
af71 : 1024001b         	lbhs	_62
                        *   		buf[i] = SPI_Read ();
af75 : bdac73           	lbsr	SPI_Read
af78 : 3406             	pshs	d
af7a : ec5d             	ldd	-3,u
af7c : ae44             	ldx	4,u
af7e : 308b             	leax	d,x
af80 : 3506             	puls	d
af82 : e784             	stb	0,x
                        * 	}
                        *       
                        *     SPI_Read (); 	SPI_Read (); // CRC
af84 :                  _64
af84 : ec5d             	ldd	-3,u
af86 : c30001           	addd	#$1
af89 : ed5d             	std	-3,u
af8b : 830001           	subd	#$1
af8e : 20dc             	lbra	_63
af90 :                  _62
af90 : bdac73           	lbsr	SPI_Read
af93 : bdac73           	lbsr	SPI_Read
                        * 	SPI_DisableChipSelect();    
af96 : bdaca5           	lbsr	SPI_Disa
                        *     
                        * 	return response;
af99 : e65f             	ldb	-1,u
af9b : 4f               	clra
                        * }
af9c : 32c4             	leas	,u
af9e : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function	: to write to a single block of SD card
                        * //Arguments	: none
                        * //return	: unsigned char; will be 0 if no error,
                        * // 			  otherwise the response byte will be sent
                        * //**************************************************
                        * SD_writeSingleBlock(buf, startBlock) char *buf; u32_
                        * {
                        * 	unsigned char response;
                        * 	unsigned int i;
                        * 			
                        * 	SPI_EnableChipSelect ();
afa0 :                  SD_write
afa0 : 3440             	pshs	u
afa2 : 33e4             	leau	,s
afa4 : 327d             	leas	-3,s
afa6 : bdac9c           	lbsr	SPI_Enab
                        * 	i=SD_TIMEOUT;
afa9 : cc07d0           	ldd	#$7d0
afac : ed5d             	std	-3,u
                        * 	do {		
afae :                  _67
                        * 		response = SD_sendCommand(WR_SINGLE_BLOCK, startBl
afae : ec46             	ldd	6,u
afb0 : 3406             	pshs	d
afb2 : cc0018           	ldd	#$18
afb5 : 3406             	pshs	d
afb7 : bdacae           	lbsr	SD_sendC
afba : 3264             	leas	4,s
afbc : e75f             	stb	-1,u
AS09 Assembler for M6809 [1.42].                                     Page  155
--------------------------------- merge.a09 ----------------------------------

                        * 	    if(--i == 0) {
afbe : ec5d             	ldd	-3,u
afc0 : c3ffff           	addd	#$ffff
afc3 : ed5d             	std	-3,u
afc5 : 830000           	subd	#$0
afc8 : 10260007         	lbne	_68
                        * 		  	//print_DebugMsg("\nwrite cmd failed!\n");
                        * 			return response; //check for SD status: 0x00 - OK
afcc : e65f             	ldb	-1,u
afce : 4f               	clra
                        * 		}
afcf : 32c4             	leas	,u
afd1 : 35c0             	puls	u,pc
                        *     }while(response != 0x00);
afd3 :                  _68
afd3 :                  _66
afd3 : e65f             	ldb	-1,u
afd5 : 4f               	clra
afd6 : 830000           	subd	#$0
afd9 : 26d3             	lbne	_67
                        * 		
                        * 	SPI_Write (0xff);   //8 clks before the packet
afdb :                  _65
afdb : cc00ff           	ldd	#$ff
afde : 3406             	pshs	d
afe0 : bdac0b           	lbsr	SPI_Writ
afe3 : 3262             	leas	2,s
                        * 	SPI_Write (0xfe);   //data token 0xfe to start tran
afe5 : cc00fe           	ldd	#$fe
afe8 : 3406             	pshs	d
afea : bdac0b           	lbsr	SPI_Writ
afed : 3262             	leas	2,s
                        *     for (i=0; i<C_MaxPageSize_U16; i++) {	//send 512
afef : 4f               	clra
aff0 : 5f               	clrb
aff1 : ed5d             	std	-3,u
aff3 :                  _70
aff3 : ec5d             	ldd	-3,u
aff5 : 830200           	subd	#$200
aff8 : 1024001a         	lbhs	_69
                        *   		SPI_Write(buf[i]);
affc : ec5d             	ldd	-3,u
affe : ae44             	ldx	4,u
b000 : e68b             	ldb	d,x
b002 : 1d               	sex
b003 : 3406             	pshs	d
b005 : bdac0b           	lbsr	SPI_Writ
b008 : 3262             	leas	2,s
                        * 	}
                        * 	SPI_Write (0xff);	SPI_Write (0xff);  //transmit dum
b00a :                  _71
b00a : ec5d             	ldd	-3,u
b00c : c30001           	addd	#$1
b00f : ed5d             	std	-3,u
b011 : 830001           	subd	#$1
b014 : 20dd             	lbra	_70
b016 :                  _69
b016 : cc00ff           	ldd	#$ff
b019 : 3406             	pshs	d
b01b : bdac0b           	lbsr	SPI_Writ
b01e : 3262             	leas	2,s
b020 : cc00ff           	ldd	#$ff
AS09 Assembler for M6809 [1.42].                                     Page  156
--------------------------------- merge.a09 ----------------------------------

b023 : 3406             	pshs	d
b025 : bdac0b           	lbsr	SPI_Writ
b028 : 3262             	leas	2,s
                        *     
                        * 	response = SPI_Read ();    
b02a : bdac73           	lbsr	SPI_Read
b02d : e75f             	stb	-1,u
                        * 	if( ( response & 0x1f) != 0x05 )  		//r1 = 0bXXX0AA
b02f : e65f             	ldb	-1,u
b031 : 4f               	clra
b032 : 8400             	anda	#$0
b034 : c41f             	andb	#$1f
b036 : 830005           	subd	#$5
b039 : 1027000a         	lbeq	_72
                        * 	{										//AAA='101'-data rejected due to CRC err
                        *   		SPI_DisableChipSelect();          		//AAA='110'-
b03d : bdaca5           	lbsr	SPI_Disa
                        *         //print_DebugMsg("\ndata response "); HEXBYT
                        *   		//print_DebugMsg(", write failed!\n");
                        * 		return response;
b040 : e65f             	ldb	-1,u
b042 : 4f               	clra
                        * 	}
b043 : 32c4             	leas	,u
b045 : 35c0             	puls	u,pc
                        * 
                        * 	i = SD_TIMEOUT;
b047 :                  _72
b047 : cc07d0           	ldd	#$7d0
b04a : ed5d             	std	-3,u
                        * 	response = 0;
b04c : 4f               	clra
b04d : 5f               	clrb
b04e : e75f             	stb	-1,u
                        * 	while ( !SPI_Read ()) { 				//wait till writing com
b050 :                  _74
b050 : bdac73           	lbsr	SPI_Read
b053 : 830000           	subd	#$0
b056 : 10260018         	lbne	_73
                        *         if(--i == 0) {
b05a : ec5d             	ldd	-3,u
b05c : c3ffff           	addd	#$ffff
b05f : ed5d             	std	-3,u
b061 : 830000           	subd	#$0
b064 : 10260008         	lbne	_75
                        * 			response = -1;
b068 : ccffff           	ldd	#$ffff
b06b : e75f             	stb	-1,u
                        * 			//print_DebugMsg("\nwrite failed!\n");
                        * 			break;			
b06d : 200312           	lbra	_73
                        * 		}
                        *     }	
b070 :                  _75
                        * 		
                        * 	SPI_DisableChipSelect();
b070 : 20de             	lbra	_74
b072 :                  _73
b072 : bdaca5           	lbsr	SPI_Disa
                        *     return response;
b075 : e65f             	ldb	-1,u
b077 : 4f               	clra
AS09 Assembler for M6809 [1.42].                                     Page  157
--------------------------------- merge.a09 ----------------------------------

                        * }
b078 : 32c4             	leas	,u
b07a : 35c0             	puls	u,pc
                        * /***************************************************
                        * /*                                                  
                        * /* file:          fat32.c			                        
                        * /*                                                  
                        * /* source:        2023-2025, written by Adrian Kunde
                        * /*                                                  
                        * /* description:   read and write data from SD CARD (
                        * /*                                                  
                        * /* This library is free software; you can redistribu
                        * /* GNU Lesser General Public License as published by
                        * /* either version 2.1 of the License, or (at your op
                        * /*                                                  
                        * /* This library is distributed in the hope that it w
                        * /* without even the implied warranty of MERCHANTABIL
                        * /* See the GNU Lesser General Public License for mor
                        * /*                                                  
                        * /***************************************************
                        * 
                        * #include "fat32.h"
                        * /***************************************************
                        * /*                                                  
                        * /* file:          fat32.h			                        
                        * /*                                                  
                        * /* source:        2023, written by Adrian Kundert (a
                        * /*                                                  
                        * /* description:   read and write data from SD CARD (
                        * /*                                                  
                        * /* This library is free software; you can redistribu
                        * /* GNU Lesser General Public License as published by
                        * /* either version 2.1 of the License, or (at your op
                        * /*                                                  
                        * /* This library is distributed in the hope that it w
                        * /* without even the implied warranty of MERCHANTABIL
                        * /* See the GNU Lesser General Public License for mor
                        * /*                                                  
                        * /***************************************************
                        * 
                        * #define C_8_3_FileNameSize    11	//Root Directory En
                        * 
                        * //Structure to access Master Boot Record for getting
                        * typedef struct {
                        *     unsigned char	nothing[446];		//ignore, placed he
                        *     unsigned char	partitionData[64];	//partition rec
                        *     unsigned char	signature[2];		//0xaa55
                        * } LE_MBRinfo_Structure;
                        * 
                        * 
                        * 
                        * //Structure to access boot sector data (Little Endia
                        * typedef struct {
                        *     unsigned char jumpBoot[3];			//00, default: 0x00
                        *     unsigned char OEMName[8];			//03,
                        *     unsigned char bytesPerSector[2];	//11, default: 
                        *     unsigned char secPrCluster; 		//13, "sectorPerCl
                        *     unsigned char rsvSectorCount[2];	//14, "reserved
                        *     unsigned char nbofFATs;				//16, "numberofFATs"
                        *     unsigned char rootEntryCount[2];	//17,
                        *     unsigned char tSec_F16[2];			//19, "totalSectors
                        *     unsigned char mediaType;			//21,
AS09 Assembler for M6809 [1.42].                                     Page  158
--------------------------------- merge.a09 ----------------------------------

                        *     unsigned char FATsz_F16[2];			//22, "FATsize_F16
                        *     unsigned char sectorsPerTrack[2];	//24,
                        *     unsigned char nbofHeads[2];			//26, "numberofHea
                        *     unsigned char hiddenSectors[4];		//28, 
                        *     unsigned char tSec_F32[4];			//32, "totalSectors
                        *     unsigned char FATsz_F32[4];			//36, "unsigned ch
                        *     unsigned char extFlags[2];
                        *     unsigned char FSversion[2]; //0x0000 (defines ve
                        *     unsigned char rootCluster[4]; //first cluster of
                        *     unsigned char FSinfo[2]; //sector number of FSin
                        *     unsigned char BackupBootSector[2];
                        *     unsigned char rsved[12];//    unsigned char rese
                        *     unsigned char driveNumber;
                        *     unsigned char rsved1;//    unsigned char reserve
                        *     unsigned char bootSignature;
                        *     unsigned char volumeID[4];
                        *     unsigned char volumeLabel[11]; //"NO NAME "
                        *     unsigned char fileSystemType[8]; //"FAT32"
                        *     unsigned char bootData[420];
                        *     unsigned char bootEndSignature[2]; //0xaa55
                        * }LE_BS_Structure;
                        * 
                        * 
                        * //Structure to access FSinfo sector data (Little End
                        * typedef struct {
                        *     unsigned char leadSignature[4]; //0x41615252
                        *     unsigned char rsved3[480];  //    unsigned char 
                        *     unsigned char structureSignature[4]; //0x6141727
                        *     unsigned char freeClusterCount[4]; //initial: 0x
                        *     unsigned char nextFreeCluster[4]; //initial: 0xf
                        *     unsigned char rsved4[12];  //    unsigned char r
                        *     unsigned char trailSignature[4]; //0xaa550000
                        * }LE_FSinfo_Structure;
                        * 
                        * 
                        * /**************** Each directory is of 32bytes.*****
                        * Bytes   Content
                        * 0-10    File name (8 bytes) with extension (3 bytes)
                        * 11      Attribute - a bitvector. Bit 0: read only. B
                        * Bit 2: system file. Bit 3: volume label. Bit 4: subd
                        * Bit 5: archive. Bits 6-7: unused.
                        * 12-21   Reserved (see below)
                        * 22-23   Time (5/6/5 bits, for hour/minutes/doublesec
                        * 24-25   Date (7/4/5 bits, for year-since-1980/month/
                        * 26-27   Starting cluster (0 for an empty file)
                        * 28-31   Filesize in bytes
                        * ****************************************************
                        * //Structure to access Directory Entry in the FAT (Li
                        * typedef struct{
                        *     unsigned char name[C_8_3_FileNameSize];
                        *     unsigned char attrib; //file attributes
                        *     unsigned char NTreserved; //always 0
                        *     unsigned char timeTenth; //tenths of seconds, se
                        *     unsigned char createTime[2]; //time file was cre
                        *     unsigned char createDate[2]; //date file was cre
                        *     unsigned char lastAccessDate[2];
                        *     unsigned char fClsterHI[2]; //higher word of the
                        *     unsigned char writeTime[2]; //time of last write
                        *     unsigned char writeDate[2]; //date of last write
                        *     unsigned char fClsterLO[2]; //lower word of the 
                        *     unsigned char fSize[4]; //size of file in bytes	
                        * }LE_dir_Structure;
AS09 Assembler for M6809 [1.42].                                     Page  159
--------------------------------- merge.a09 ----------------------------------

                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * 
                        * //Attribute definitions for file/directory
                        * #define ATTR_READ_ONLY     0x01
                        * #define ATTR_HIDDEN        0x02
                        * #define ATTR_SYSTEM        0x04
                        * #define ATTR_VOLUME_ID     0x08
                        * #define ATTR_DIRECTORY     0x10
                        * #define ATTR_ARCHIVE       0x20
                        * #define ATTR_LONG_NAME     0x0f
                        * 
                        * 
                        * #define END_OF_CLUSTERS    0x0fffffff
                        * #define DIR_ENTRY_SIZE     0x32
                        * #define EMPTY              0x00
                        * #define DELETED            0xe5
                        * #define GET     0
                        * #define SET     1
                        * 
                        * #define READ	0
                        * #define VERIFY  1
                        * #define WRITE   2
                        * #define APPEND  3
                        * 
                        * #define ADD		0
                        * #define REMOVE	1
                        * 
                        * #define TOTAL_FREE   1
                        * #define NEXT_FREE    2
                        * 
                        * #define GET_LIST     0
                        * #define GET_FILE     1
                        * #define DELETE		 2
                        * 
                        * #define EOF     26
                        * 
                        * #define FOPEN_SUCCESSFUL                   0 //FAT32
                        * #define FDELETED_OR_NOT_FOUND              1 //FAT32
                        * #define FALREADY_EXISTS                    2 //FAT32
                        * #define VALID_FILE_NAME                    3
                        * #define INVALID_FILE_NAME                  4
                        * #define NO_FREE_CLUSTERS_FOUND             5
                        * #define FILE_OPENED_CANNOT_BE_DELETED      6
                        * #define TO_MANY_FILES_OPENED               7
                        * #define MORE_FILES_To_READ                 8
                        * #define END_OF_FILE_LIST                   9
                        * 
                        * #define CONTINUE_LOOP                   0x55
                        * 
                        * #define C_MaxFileNameSize     13 //(C_8_3_FileNameSi
                        * 
                        * 
                        * typedef struct
                        * {
                        *     u32_t firstSector;
                        *     u32_t cluster;
                        *     u32_t prevCluster;
AS09 Assembler for M6809 [1.42].                                     Page  160
--------------------------------- merge.a09 ----------------------------------

                        *     u32_t appFSector;
                        *     unsigned int appFLocation;
                        *     u32_t fileSize;
                        *     u32_t byteCounter;
                        *     u32_t blockNumber_u32;
                        *     u32_t appendStartCluster;
                        *     unsigned int sectorIndex;
                        *     unsigned int bufferIndex_u16;
                        *     //unsigned int fClstrHigh;
                        *     //unsigned int fClstrLow;
                        *     unsigned char LE_fileBuffer[C_MaxPageSize_U16];
                        *     unsigned char fileOperation_u8;
                        *     unsigned char fileOpenedFlag;
                        *     unsigned char fileCreatedFlag;
                        *     unsigned char appendFileFlag;
                        *     unsigned char sectorEndFlag;
                        *     unsigned char endOfFileDetected;
                        *     char fName[C_MaxFileNameSize];
                        * }fileConfig_st;
                        * 
                        * typedef struct{
                        * 	u32_t FI_Size;	unsigned char FI_Attr;	char FI_Name[
                        * }fileInfo;
                        * 
                        * 
                        * 
                        * 
                        * 
                        * /***************************************************
                        *                            Global Variables
                        *  ***************************************************
                        * u32_t fDataSector, rCluster, totalClusters;   			// 
fffb =                  fDataSec	equ	-5
fff7 =                  rCluster	equ	-9
fff3 =                  totalClu	equ	-13
                        * unsigned int  bPerSector, secPerCluster, rsvSecCnt; 
fff1 =                  bPerSect	equ	-15
ffef =                  secPerCl	equ	-17
ffed =                  rsvSecCn	equ	-19
                        * u32_t unusedSectors;
ffe9 =                  unusedSe	equ	-23
                        * unsigned char fClstCnU; 								// "freeClusterCount
ffe8 =                  fClstCnU	equ	-24
                        * unsigned char FL_initialized;
ffe7 =                  FL_initi	equ	-25
                        * 	
                        * fileConfig_st fatMapTb; 								// "fatMappingTable"
fdae =                  fatMapTb	equ	-594
                        * 
                        * u32_t clusterNumber, sectorNumber, frstSectorIndex;
fdaa =                  clusterN	equ	-598
fda6 =                  sectorNu	equ	-602
fda2 =                  frstSect	equ	-606
                        * unsigned int list_i;
fda0 =                  list_i	equ	-608
                        * 
                        * /***************************************************
                        *                  fileConfig_st* FILE_Open(char* file
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                   char *: Name of the file to be ope
                        *                   unsigned char: READ, WRITE, APPEND
AS09 Assembler for M6809 [1.42].                                     Page  161
--------------------------------- merge.a09 ----------------------------------

                        *                   char *: pointer to update the file
                        * 
                        *  * Return value  :
                        *                   fileConfig_st *: Pointer to file s
                        *                                  : NULL, if file is 
                        * 
                        *  * description :
                        *                  This functions opens the file with 
                        *                  If the file is successfully opened,
                        *                  In case the file is not opened it r
                        *  ***************************************************
                        * //fileConfig_st* FILE_Open(char* filename,unsigned c
                        * FILE_Open(filename, fOperation, fOpenSts) char* file
                        * {
                        *     fileConfig_st *filePtr;
                        *     u32_t nextCluster, clusterCount, tmp1, tmp2;
                        *     
                        * 	_setGVpt(); // call when GV are utilized
b07c :                  FILE_Ope
b07c : 3440             	pshs	u
b07e : 33e4             	leau	,s
b080 : 32e8ee           	leas	-18,s
b083 : bde2ef           	lbsr	_setGVpt
                        * 
                        * 	filePtr = 0;
b086 : 4f               	clra
b087 : 5f               	clrb
b088 : ed5e             	std	-2,u
                        * 	
                        *     // ensure the filename length
                        * 	if(_strlen(filename) >= C_MaxFileNameSize) {
b08a : ec44             	ldd	4,u
b08c : 3406             	pshs	d
b08e : bdaaf9           	lbsr	_strlen
b091 : 3262             	leas	2,s
b093 : 83000d           	subd	#$d
b096 : 102d000c         	lblt	_76
                        * 		*fOpenSts = INVALID_FILE_NAME;
b09a : cc0004           	ldd	#$4
b09d : e7d808           	stb	[8,u]
                        * 		return 0; /* Set the pointer to NULL indication wh
b0a0 : 4f               	clra
b0a1 : 5f               	clrb
                        * 	}
b0a2 : 32c4             	leas	,u
b0a4 : 35c0             	puls	u,pc
                        * 	
                        *     if(fatMapTb.fileOpenedFlag == FALSE)
b0a6 :                  _76
b0a6 : e6a8d5           	ldb	fatMapTb+551,y
b0a9 : 4f               	clra
b0aa : 830000           	subd	#$0
b0ad : 10260401         	lbne	_77
                        *     {
                        *         filePtr = &fatMapTb;
b0b1 : 30a9fdae         	leax	fatMapTb+0,y
b0b5 : 1f10             	tfr	x,d
b0b7 : ed5e             	std	-2,u
                        *         _strcpy(filePtr->fName,filename);
b0b9 : ec44             	ldd	4,u
b0bb : 3406             	pshs	d
b0bd : ec5e             	ldd	-2,u
AS09 Assembler for M6809 [1.42].                                     Page  162
--------------------------------- merge.a09 ----------------------------------

b0bf : c3022c           	addd	#$22c
b0c2 : 3406             	pshs	d
b0c4 : bdab2c           	lbsr	_strcpy
b0c7 : 3264             	leas	4,s
                        * 		filePtr->fileOperation_u8 = fOperation;
b0c9 : e647             	ldb	7,u
b0cb : 4f               	clra
b0cc : ae5e             	ldx	-2,u
b0ce : e7890226         	stb	550,x
                        *         filePtr->firstSector.h = filePtr->firstSecto
b0d2 : 4f               	clra
b0d3 : 5f               	clrb
b0d4 : ae5e             	ldx	-2,u
b0d6 : ed02             	std	2,x
b0d8 : edd8fe           	std	[-2,u]
                        *         filePtr->cluster.h = filePtr->cluster.l =0x0
b0db : ec5e             	ldd	-2,u
b0dd : c30004           	addd	#$4
b0e0 : c30002           	addd	#$2
b0e3 : 1f01             	tfr	d,x
b0e5 : 4f               	clra
b0e6 : 5f               	clrb
b0e7 : ed84             	std	0,x
b0e9 : ae5e             	ldx	-2,u
b0eb : ed04             	std	4,x
                        *         filePtr->blockNumber_u32.h = filePtr->blockN
b0ed : ec5e             	ldd	-2,u
b0ef : c3001a           	addd	#$1a
b0f2 : c30002           	addd	#$2
b0f5 : 1f01             	tfr	d,x
b0f7 : 4f               	clra
b0f8 : 5f               	clrb
b0f9 : ed84             	std	0,x
b0fb : ae5e             	ldx	-2,u
b0fd : ed881a           	std	26,x
                        *         filePtr->appFSector.h = filePtr->appFSector.
b100 : ec5e             	ldd	-2,u
b102 : c3000c           	addd	#$c
b105 : c30002           	addd	#$2
b108 : 1f01             	tfr	d,x
b10a : 4f               	clra
b10b : 5f               	clrb
b10c : ed84             	std	0,x
b10e : ae5e             	ldx	-2,u
b110 : ed0c             	std	12,x
                        *         filePtr->appFLocation= 0x00;
b112 : 4f               	clra
b113 : 5f               	clrb
b114 : ae5e             	ldx	-2,u
b116 : ed8810           	std	16,x
                        *         filePtr->fileSize.h = filePtr->fileSize.l = 
b119 : ec5e             	ldd	-2,u
b11b : c30012           	addd	#$12
b11e : c30002           	addd	#$2
b121 : 1f01             	tfr	d,x
b123 : 4f               	clra
b124 : 5f               	clrb
b125 : ed84             	std	0,x
b127 : ae5e             	ldx	-2,u
b129 : ed8812           	std	18,x
                        *         filePtr->byteCounter.h = filePtr->byteCounte
b12c : ec5e             	ldd	-2,u
AS09 Assembler for M6809 [1.42].                                     Page  163
--------------------------------- merge.a09 ----------------------------------

b12e : c30016           	addd	#$16
b131 : c30002           	addd	#$2
b134 : 1f01             	tfr	d,x
b136 : 4f               	clra
b137 : 5f               	clrb
b138 : ed84             	std	0,x
b13a : ae5e             	ldx	-2,u
b13c : ed8816           	std	22,x
                        *         filePtr->appendStartCluster.h = filePtr->app
b13f : ec5e             	ldd	-2,u
b141 : c3001e           	addd	#$1e
b144 : c30002           	addd	#$2
b147 : 1f01             	tfr	d,x
b149 : 4f               	clra
b14a : 5f               	clrb
b14b : ed84             	std	0,x
b14d : ae5e             	ldx	-2,u
b14f : ed881e           	std	30,x
                        *         filePtr->sectorIndex= 0x00;
b152 : 4f               	clra
b153 : 5f               	clrb
b154 : ae5e             	ldx	-2,u
b156 : ed8822           	std	34,x
                        *         filePtr->bufferIndex_u16= 0x00;
b159 : 4f               	clra
b15a : 5f               	clrb
b15b : ae5e             	ldx	-2,u
b15d : ed8824           	std	36,x
                        * 		filePtr->appendFileFlag = 0;
b160 : 4f               	clra
b161 : 5f               	clrb
b162 : ae5e             	ldx	-2,u
b164 : e7890229         	stb	553,x
                        *         filePtr->fileCreatedFlag = 0x00;
b168 : 4f               	clra
b169 : 5f               	clrb
b16a : ae5e             	ldx	-2,u
b16c : e7890228         	stb	552,x
                        *         filePtr->endOfFileDetected = 0x00;
b170 : 4f               	clra
b171 : 5f               	clrb
b172 : ae5e             	ldx	-2,u
b174 : e789022b         	stb	555,x
                        * 
                        *         if(fOperation == READ)
b178 : e647             	ldb	7,u
b17a : 4f               	clra
b17b : 830000           	subd	#$0
b17e : 10260024         	lbne	_78
                        *         {
                        *             *fOpenSts = openFile( READ, filePtr);
b182 : ec5e             	ldd	-2,u
b184 : 3406             	pshs	d
b186 : 4f               	clra
b187 : 5f               	clrb
b188 : 3406             	pshs	d
b18a : bde80b           	lbsr	openFile
b18d : 3264             	leas	4,s
b18f : e7d808           	stb	[8,u]
                        *             if(*fOpenSts != FOPEN_SUCCESSFUL) return
b192 : e6d808           	ldb	[8,u]
b195 : 4f               	clra
AS09 Assembler for M6809 [1.42].                                     Page  164
--------------------------------- merge.a09 ----------------------------------

b196 : 830000           	subd	#$0
b199 : 10270006         	lbeq	_79
b19d : 4f               	clra
b19e : 5f               	clrb
                        *         }
b19f : 32c4             	leas	,u
b1a1 : 35c0             	puls	u,pc
b1a3 :                  _79
                        *         else if((fOperation == WRITE) || (fOperation
b1a3 : 7eb4a3           	lbra	_80
b1a6 :                  _78
b1a6 : e647             	ldb	7,u
b1a8 : 4f               	clra
b1a9 : 830002           	subd	#$2
b1ac : 1027000a         	lbeq	_82
b1b0 : e647             	ldb	7,u
b1b2 : 4f               	clra
b1b3 : 830003           	subd	#$3
b1b6 : 102602e9         	lbne	_81
b1ba :                  _82
                        *         {
                        *             *fOpenSts = openFile (VERIFY, filePtr);
b1ba : ec5e             	ldd	-2,u
b1bc : 3406             	pshs	d
b1be : cc0001           	ldd	#$1
b1c1 : 3406             	pshs	d
b1c3 : bde80b           	lbsr	openFile
b1c6 : 3264             	leas	4,s
b1c8 : e7d808           	stb	[8,u]
                        * 
                        *             if(*fOpenSts == FOPEN_SUCCESSFUL)
b1cb : e6d808           	ldb	[8,u]
b1ce : 4f               	clra
b1cf : 830000           	subd	#$0
b1d2 : 10260179         	lbne	_83
                        *             {
                        * 				filePtr->appendFileFlag = 1;
b1d6 : cc0001           	ldd	#$1
b1d9 : ae5e             	ldx	-2,u
b1db : e7890229         	stb	553,x
                        *                 filePtr->cluster.h = filePtr->append
b1df : ae5e             	ldx	-2,u
b1e1 : ec881e           	ldd	30,x
b1e4 : ae5e             	ldx	-2,u
b1e6 : ed04             	std	4,x
b1e8 : ec5e             	ldd	-2,u
b1ea : c3001e           	addd	#$1e
b1ed : 3406             	pshs	d
b1ef : cc0002           	ldd	#$2
b1f2 : 3510             	puls	x
b1f4 : ec8b             	ldd	d,x
b1f6 : 3406             	pshs	d
b1f8 : ec5e             	ldd	-2,u
b1fa : c30004           	addd	#$4
b1fd : c30002           	addd	#$2
b200 : 1f01             	tfr	d,x
b202 : 3506             	puls	d
b204 : ed84             	std	0,x
                        * 				clusterCount.h = clusterCount.l = 0;
b206 : 4f               	clra
b207 : 5f               	clrb
b208 : ed58             	std	-8,u
AS09 Assembler for M6809 [1.42].                                     Page  165
--------------------------------- merge.a09 ----------------------------------

b20a : ed56             	std	-10,u
                        *                 while(1)
b20c :                  _85
                        *                 {
                        *                     //nextCluster = getSetNextCluste
                        * 					tmp1.h = tmp1.l = 0;
b20c : 4f               	clra
b20d : 5f               	clrb
b20e : ed54             	std	-12,u
b210 : ed52             	std	-14,u
                        * 					getSetNC(filePtr->LE_fileBuffer, &filePtr->clus
b212 : 305a             	leax	-6,u
b214 : 3410             	pshs	x
b216 : 3052             	leax	-14,u
b218 : 3410             	pshs	x
b21a : 4f               	clra
b21b : 5f               	clrb
b21c : 3406             	pshs	d
b21e : ec5e             	ldd	-2,u
b220 : c30004           	addd	#$4
b223 : 3406             	pshs	d
b225 : ec5e             	ldd	-2,u
b227 : c30026           	addd	#$26
b22a : 3406             	pshs	d
b22c : bde33b           	lbsr	getSetNC
b22f : 326a             	leas	10,s
                        * 					
                        *                     //if(nextCluster == END_OF_CLUST
                        * 					tmp1.h = 0x0fff; tmp1.l = 0xffff; // = END_OF_C
b231 : cc0fff           	ldd	#$fff
b234 : ed52             	std	-14,u
b236 : ccffff           	ldd	#$ffff
b239 : ed54             	std	-12,u
                        * 					if(_u32_equal(&nextCluster, &tmp1) != 0) break;
b23b : 3052             	leax	-14,u
b23d : 3410             	pshs	x
b23f : 305a             	leax	-6,u
b241 : 3410             	pshs	x
b243 : bdaa95           	lbsr	_u32_equ
b246 : 3264             	leas	4,s
b248 : 830000           	subd	#$0
b24b : 10270003         	lbeq	_86
b24f : 202012           	lbra	_84
                        *                     filePtr->cluster.h = nextCluster
b252 :                  _86
b252 : ec5a             	ldd	-6,u
b254 : ae5e             	ldx	-2,u
b256 : ed04             	std	4,x
b258 : ec5e             	ldd	-2,u
b25a : c30004           	addd	#$4
b25d : c30002           	addd	#$2
b260 : 1f01             	tfr	d,x
b262 : ec5c             	ldd	-4,u
b264 : ed84             	std	0,x
                        *                     _u32_inc(&clusterCount);
b266 : 3056             	leax	-10,u
b268 : 3410             	pshs	x
b26a : bdaa2e           	lbsr	_u32_inc
b26d : 3262             	leas	2,s
                        *                 }
                        * 
                        *                 //filePtr->sectorIndex = (filePtr->f
AS09 Assembler for M6809 [1.42].                                     Page  166
--------------------------------- merge.a09 ----------------------------------

                        * 				_u32_mul(secPerCluster, &clusterCount, &tmp1);
b26f : 209b             	lbra	_85
b271 :                  _84
b271 : 3052             	leax	-14,u
b273 : 3410             	pshs	x
b275 : 3056             	leax	-10,u
b277 : 3410             	pshs	x
b279 : eca8ef           	ldd	secPerCl+0,y
b27c : 3406             	pshs	d
b27e : bda891           	lbsr	_u32_mul
b281 : 3266             	leas	6,s
                        * 				_u32_mul(bPerSector, &tmp1, &tmp2);
b283 : 30c8ee           	leax	-18,u
b286 : 3410             	pshs	x
b288 : 3052             	leax	-14,u
b28a : 3410             	pshs	x
b28c : ec31             	ldd	bPerSect+0,y
b28e : 3406             	pshs	d
b290 : bda891           	lbsr	_u32_mul
b293 : 3266             	leas	6,s
                        * 				_u32_sub(&filePtr->fileSize, &tmp2, &tmp1);
b295 : 3052             	leax	-14,u
b297 : 3410             	pshs	x
b299 : 30c8ee           	leax	-18,u
b29c : 3410             	pshs	x
b29e : ec5e             	ldd	-2,u
b2a0 : c30012           	addd	#$12
b2a3 : 3406             	pshs	d
b2a5 : bda975           	lbsr	_u32_sub
b2a8 : 3266             	leas	6,s
                        * 				_u32_div2(&tmp1, bPerSector, &tmp2);
b2aa : 30c8ee           	leax	-18,u
b2ad : 3410             	pshs	x
b2af : ec31             	ldd	bPerSect+0,y
b2b1 : 3406             	pshs	d
b2b3 : 3052             	leax	-14,u
b2b5 : 3410             	pshs	x
b2b7 : bda825           	lbsr	_u32_div
b2ba : 3266             	leas	6,s
                        * 				filePtr->sectorIndex = tmp2.l;
b2bc : ec50             	ldd	-16,u
b2be : ae5e             	ldx	-2,u
b2c0 : ed8822           	std	34,x
                        * 					
                        *                 getFirstSector (&filePtr->cluster, &
b2c3 : ec5e             	ldd	-2,u
b2c5 : c3001a           	addd	#$1a
b2c8 : 3406             	pshs	d
b2ca : ec5e             	ldd	-2,u
b2cc : c30004           	addd	#$4
b2cf : 3406             	pshs	d
b2d1 : bde2f4           	lbsr	getFirst
b2d4 : 3264             	leas	4,s
                        * 				tmp1.h = filePtr->blockNumber_u32.h; tmp1.l = fi
b2d6 : ae5e             	ldx	-2,u
b2d8 : ec881a           	ldd	26,x
b2db : ed52             	std	-14,u
b2dd : ec5e             	ldd	-2,u
b2df : c3001a           	addd	#$1a
b2e2 : 3406             	pshs	d
b2e4 : cc0002           	ldd	#$2
b2e7 : 3510             	puls	x
AS09 Assembler for M6809 [1.42].                                     Page  167
--------------------------------- merge.a09 ----------------------------------

b2e9 : ec8b             	ldd	d,x
b2eb : ed54             	std	-12,u
                        * 				tmp2.h = 0; tmp2.l = filePtr->sectorIndex;
b2ed : 4f               	clra
b2ee : 5f               	clrb
b2ef : edc8ee           	std	-18,u
b2f2 : ae5e             	ldx	-2,u
b2f4 : ec8822           	ldd	34,x
b2f7 : ed50             	std	-16,u
                        * 				_u32_add(&tmp1, &tmp2, &filePtr->blockNumber_u32
b2f9 : ec5e             	ldd	-2,u
b2fb : c3001a           	addd	#$1a
b2fe : 3406             	pshs	d
b300 : 30c8ee           	leax	-18,u
b303 : 3410             	pshs	x
b305 : 3052             	leax	-14,u
b307 : 3410             	pshs	x
b309 : bda9df           	lbsr	_u32_add
b30c : 3266             	leas	6,s
                        *                 if(SD_readSingleBlock(filePtr->LE_fi
b30e : ec5e             	ldd	-2,u
b310 : c3001a           	addd	#$1a
b313 : 3406             	pshs	d
b315 : ec5e             	ldd	-2,u
b317 : c30026           	addd	#$26
b31a : 3406             	pshs	d
b31c : bdaf12           	lbsr	SD_readS
b31f : 3264             	leas	4,s
b321 : 830000           	subd	#$0
b324 : 10270006         	lbeq	_87
b328 : 4f               	clra
b329 : 5f               	clrb
                        *                 filePtr->bufferIndex_u16 = filePtr->
b32a : 32c4             	leas	,u
b32c : 35c0             	puls	u,pc
b32e :                  _87
b32e : ec31             	ldd	bPerSect+0,y
b330 : 830001           	subd	#$1
b333 : 3406             	pshs	d
b335 : ec5e             	ldd	-2,u
b337 : c30012           	addd	#$12
b33a : 3406             	pshs	d
b33c : cc0002           	ldd	#$2
b33f : 3510             	puls	x
b341 : ec8b             	ldd	d,x
b343 : a4e0             	anda	,s+
b345 : e4e0             	andb	,s+
b347 : ae5e             	ldx	-2,u
b349 : ed8824           	std	36,x
                        *             }
                        *             else if(*fOpenSts == FDELETED_OR_NOT_FOU
b34c : 7eb4a3           	lbra	_88
b34f :                  _83
b34f : e6d808           	ldb	[8,u]
b352 : 4f               	clra
b353 : 830001           	subd	#$1
b356 : 10260145         	lbne	_89
                        *             {
                        *                 *fOpenSts = FOPEN_SUCCESSFUL;
b35a : 4f               	clra
b35b : 5f               	clrb
b35c : e7d808           	stb	[8,u]
AS09 Assembler for M6809 [1.42].                                     Page  168
--------------------------------- merge.a09 ----------------------------------

                        * 
                        *                 getSetFreeCluster(filePtr->LE_fileBu
b35f : ec5e             	ldd	-2,u
b361 : c30004           	addd	#$4
b364 : 3406             	pshs	d
b366 : 4f               	clra
b367 : 5f               	clrb
b368 : 3406             	pshs	d
b36a : 4f               	clra
b36b : 5f               	clrb
b36c : 3406             	pshs	d
b36e : cc0002           	ldd	#$2
b371 : 3406             	pshs	d
b373 : ec5e             	ldd	-2,u
b375 : c30026           	addd	#$26
b378 : 3406             	pshs	d
b37a : bde442           	lbsr	getSetFr
b37d : 326a             	leas	10,s
                        * 				if((filePtr->cluster.h == 0xffff) && (filePtr->c
b37f : ae5e             	ldx	-2,u
b381 : ec04             	ldd	4,x
b383 : 83ffff           	subd	#$ffff
b386 : 1026001b         	lbne	_90
b38a : ec5e             	ldd	-2,u
b38c : c30004           	addd	#$4
b38f : 3406             	pshs	d
b391 : cc0002           	ldd	#$2
b394 : 3510             	puls	x
b396 : ec8b             	ldd	d,x
b398 : 83ffff           	subd	#$ffff
b39b : 10260006         	lbne	_90
b39f : 4f               	clra
b3a0 : 5f               	clrb
                        * 				if(_u32_higher(&filePtr->cluster, &totalClusters
b3a1 : 32c4             	leas	,u
b3a3 : 35c0             	puls	u,pc
b3a5 :                  _90
b3a5 : 3033             	leax	totalClu+0,y
b3a7 : 3410             	pshs	x
b3a9 : ec5e             	ldd	-2,u
b3ab : c30004           	addd	#$4
b3ae : 3406             	pshs	d
b3b0 : bdaac0           	lbsr	_u32_hig
b3b3 : 3264             	leas	4,s
b3b5 : 830000           	subd	#$0
b3b8 : 10270014         	lbeq	_91
                        *                 {
                        *                     filePtr->cluster.h = rCluster.h;
b3bc : ec37             	ldd	rCluster+0,y
b3be : ae5e             	ldx	-2,u
b3c0 : ed04             	std	4,x
b3c2 : ec5e             	ldd	-2,u
b3c4 : c30004           	addd	#$4
b3c7 : c30002           	addd	#$2
b3ca : 1f01             	tfr	d,x
b3cc : ec39             	ldd	rCluster+2,y
b3ce : ed84             	std	0,x
                        * 	            }
                        *                 searchNextFreeCluster(filePtr->LE_fi
b3d0 :                  _91
b3d0 : ec5e             	ldd	-2,u
b3d2 : c30004           	addd	#$4
AS09 Assembler for M6809 [1.42].                                     Page  169
--------------------------------- merge.a09 ----------------------------------

b3d5 : 3406             	pshs	d
b3d7 : ec5e             	ldd	-2,u
b3d9 : c30004           	addd	#$4
b3dc : 3406             	pshs	d
b3de : ec5e             	ldd	-2,u
b3e0 : c30026           	addd	#$26
b3e3 : 3406             	pshs	d
b3e5 : bde55f           	lbsr	searchNe
b3e8 : 3266             	leas	6,s
                        *                 if((filePtr->cluster.h == 0) && (fil
b3ea : ae5e             	ldx	-2,u
b3ec : ec04             	ldd	4,x
b3ee : 830000           	subd	#$0
b3f1 : 10260021         	lbne	_92
b3f5 : ec5e             	ldd	-2,u
b3f7 : c30004           	addd	#$4
b3fa : 3406             	pshs	d
b3fc : cc0002           	ldd	#$2
b3ff : 3510             	puls	x
b401 : ec8b             	ldd	d,x
b403 : 830000           	subd	#$0
b406 : 1026000c         	lbne	_92
                        *                 {
                        *                     *fOpenSts = NO_FREE_CLUSTERS_FOU
b40a : cc0005           	ldd	#$5
b40d : e7d808           	stb	[8,u]
                        *                     return 0; /* Set the pointer to 
b410 : 4f               	clra
b411 : 5f               	clrb
                        *                 } 
b412 : 32c4             	leas	,u
b414 : 35c0             	puls	u,pc
                        * 
                        *                 tmp1.h = 0x0fff; tmp1.l = 0xffff; //
b416 :                  _92
b416 : cc0fff           	ldd	#$fff
b419 : ed52             	std	-14,u
b41b : ccffff           	ldd	#$ffff
b41e : ed54             	std	-12,u
                        * 				getSetNC(filePtr->LE_fileBuffer, &filePtr->clust
b420 : 30c8ee           	leax	-18,u
b423 : 3410             	pshs	x
b425 : 3052             	leax	-14,u
b427 : 3410             	pshs	x
b429 : cc0001           	ldd	#$1
b42c : 3406             	pshs	d
b42e : ec5e             	ldd	-2,u
b430 : c30004           	addd	#$4
b433 : 3406             	pshs	d
b435 : ec5e             	ldd	-2,u
b437 : c30026           	addd	#$26
b43a : 3406             	pshs	d
b43c : bde33b           	lbsr	getSetNC
b43f : 326a             	leas	10,s
                        * 				
                        *                 filePtr->appendStartCluster.h = file
b441 : ae5e             	ldx	-2,u
b443 : ec04             	ldd	4,x
b445 : ae5e             	ldx	-2,u
b447 : ed881e           	std	30,x
                        *                 filePtr->appendStartCluster.l = file
b44a : ec5e             	ldd	-2,u
AS09 Assembler for M6809 [1.42].                                     Page  170
--------------------------------- merge.a09 ----------------------------------

b44c : c30004           	addd	#$4
b44f : 3406             	pshs	d
b451 : cc0002           	ldd	#$2
b454 : 3510             	puls	x
b456 : ec8b             	ldd	d,x
b458 : 3406             	pshs	d
b45a : ec5e             	ldd	-2,u
b45c : c3001e           	addd	#$1e
b45f : c30002           	addd	#$2
b462 : 1f01             	tfr	d,x
b464 : 3506             	puls	d
b466 : ed84             	std	0,x
                        *                 filePtr->fileSize.h = filePtr->fileS
b468 : ec5e             	ldd	-2,u
b46a : c30012           	addd	#$12
b46d : c30002           	addd	#$2
b470 : 1f01             	tfr	d,x
b472 : 4f               	clra
b473 : 5f               	clrb
b474 : ed84             	std	0,x
b476 : ae5e             	ldx	-2,u
b478 : ed8812           	std	18,x
                        * 
                        *                 getFirstSector (&filePtr->cluster, &
b47b : ec5e             	ldd	-2,u
b47d : c3001a           	addd	#$1a
b480 : 3406             	pshs	d
b482 : ec5e             	ldd	-2,u
b484 : c30004           	addd	#$4
b487 : 3406             	pshs	d
b489 : bde2f4           	lbsr	getFirst
b48c : 3264             	leas	4,s
                        *                 filePtr->bufferIndex_u16=0;
b48e : 4f               	clra
b48f : 5f               	clrb
b490 : ae5e             	ldx	-2,u
b492 : ed8824           	std	36,x
                        *                 filePtr->sectorIndex=0;					
b495 : 4f               	clra
b496 : 5f               	clrb
b497 : ae5e             	ldx	-2,u
b499 : ed8822           	std	34,x
                        *             }
                        *             else
b49c : 200512           	lbra	_93
b49f :                  _89
                        *             {
                        *                 filePtr = 0;
b49f : 4f               	clra
b4a0 : 5f               	clrb
b4a1 : ed5e             	std	-2,u
                        *             }
                        *         }
b4a3 :                  _93
b4a3 :                  _88
                        * 
                        *         if(filePtr != 0)
b4a3 :                  _81
b4a3 :                  _80
b4a3 : ec5e             	ldd	-2,u
b4a5 : 830000           	subd	#$0
b4a8 : 10270006         	lbeq	_94
AS09 Assembler for M6809 [1.42].                                     Page  171
--------------------------------- merge.a09 ----------------------------------

                        *         {
                        *             fatMapTb.fileOpenedFlag = TRUE;
b4ac : cc0001           	ldd	#$1
b4af : e7a8d5           	stb	fatMapTb+551,y
                        *         }
                        *     }
b4b2 :                  _94
                        * 
                        *     return filePtr;
b4b2 :                  _77
b4b2 : ec5e             	ldd	-2,u
                        * }
b4b4 : 32c4             	leas	,u
b4b6 : 35c0             	puls	u,pc
                        * 
                        * 
                        * 
                        * 
                        * /***************************************************
                        *                          void FILE_Close(fileConfig_
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                   fileConfig_st *: structure pointer
                        * 
                        *  * Return value  :
                        *                   none
                        * 
                        *  * description :
                        *                  This functions closes the file and 
                        *                  Once the file is closed, no more fi
                        *  ***************************************************
                        * //void FILE_Close(fileConfig_st *ptr)
                        * FILE_Close(ptr) fileConfig_st *ptr;
                        * {
                        * 	if(ptr != 0) {
b4b8 :                  FILE_Clo
b4b8 : 3440             	pshs	u
b4ba : 33e4             	leau	,s
b4bc : ec44             	ldd	4,u
b4be : 830000           	subd	#$0
b4c1 : 10270008         	lbeq	_95
                        *         ptr->fileOpenedFlag = FALSE; /* Clear the fi
b4c5 : 4f               	clra
b4c6 : 5f               	clrb
b4c7 : ae44             	ldx	4,u
b4c9 : e7890227         	stb	551,x
                        * 	}
                        * }
b4cd :                  _95
b4cd : 35c0             	puls	u,pc
                        * 
                        * 
                        * 
                        * 
                        * /***************************************************
                        *                          unsigned char FILE_Delete(c
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                   char *: Name of the file to be del
                        * 
                        *  * Return value  :
                        *                   unsigned char:
AS09 Assembler for M6809 [1.42].                                     Page  172
--------------------------------- merge.a09 ----------------------------------

                        *                   INVALID_FILE_NAME--> In case file 
                        *                   FILE_OPENED_CANNOT_BE_DELETED--> F
                        *                   FILE_DELETED_OR_NOT_FOUND --> File
                        * 
                        *  * description :
                        *                  This functions deletes the file fro
                        *  ***************************************************
                        * //unsigned char FILE_Delete(char *fileName)
                        * FILE_Delete(fileName) char *fileName;
                        * {
                        *     unsigned char returnStatus;
                        *     char localfileName[C_MaxFileNameSize];
                        * 
                        * 	_setGVpt(); // call when GV are utilized
b4cf :                  FILE_Del
b4cf : 3440             	pshs	u
b4d1 : 33e4             	leau	,s
b4d3 : 3272             	leas	-14,s
b4d5 : bde2ef           	lbsr	_setGVpt
                        * 
                        * 	// ensure the filename length
                        * 	if(_strlen(fileName) >= C_MaxFileNameSize) {
b4d8 : ec44             	ldd	4,u
b4da : 3406             	pshs	d
b4dc : bdaaf9           	lbsr	_strlen
b4df : 3262             	leas	2,s
b4e1 : 83000d           	subd	#$d
b4e4 : 102d0008         	lblt	_96
                        * 		returnStatus = INVALID_FILE_NAME;		
b4e8 : cc0004           	ldd	#$4
b4eb : e75f             	stb	-1,u
                        * 	}
                        * 	else {
b4ed : 201912           	lbra	_97
b4f0 :                  _96
                        * 		_strcpy(localfileName, fileName);
b4f0 : ec44             	ldd	4,u
b4f2 : 3406             	pshs	d
b4f4 : 3052             	leax	-14,u
b4f6 : 3410             	pshs	x
b4f8 : bdab2c           	lbsr	_strcpy
b4fb : 3264             	leas	4,s
                        * 		returnStatus = convertFileName (localfileName);
b4fd : 3052             	leax	-14,u
b4ff : 3410             	pshs	x
b501 : bde69f           	lbsr	convertF
b504 : 3262             	leas	2,s
b506 : e75f             	stb	-1,u
                        * 	}
                        * 
                        *     if(returnStatus == VALID_FILE_NAME)
b508 :                  _97
b508 : e65f             	ldb	-1,u
b50a : 4f               	clra
b50b : 830003           	subd	#$3
b50e : 1026003e         	lbne	_98
                        *     {
                        *         returnStatus = 0; // default
b512 : 4f               	clra
b513 : 5f               	clrb
b514 : e75f             	stb	-1,u
                        * 		if(fatMapTb.fileOpenedFlag == TRUE)
AS09 Assembler for M6809 [1.42].                                     Page  173
--------------------------------- merge.a09 ----------------------------------

b516 : e6a8d5           	ldb	fatMapTb+551,y
b519 : 4f               	clra
b51a : 830001           	subd	#$1
b51d : 1026001a         	lbne	_99
                        *         {
                        *             /* Check the file to be deleted is alrea
                        *             if(_strcmp(localfileName,fatMapTb.fName)
b521 : 30a8da           	leax	fatMapTb+556,y
b524 : 3410             	pshs	x
b526 : 3052             	leax	-14,u
b528 : 3410             	pshs	x
b52a : bdab4e           	lbsr	_strcmp
b52d : 3264             	leas	4,s
b52f : 830000           	subd	#$0
b532 : 10260005         	lbne	_100
b536 : cc0006           	ldd	#$6
b539 : e75f             	stb	-1,u
                        *         }
b53b :                  _100
                        * 
                        *         if(returnStatus == 0) returnStatus = deleteF
b53b :                  _99
b53b : e65f             	ldb	-1,u
b53d : 4f               	clra
b53e : 830000           	subd	#$0
b541 : 1026000b         	lbne	_101
b545 : 3052             	leax	-14,u
b547 : 3410             	pshs	x
b549 : bdeb51           	lbsr	deleteFi
b54c : 3262             	leas	2,s
b54e : e75f             	stb	-1,u
                        *     }
b550 :                  _101
                        * 
                        *     return returnStatus;
b550 :                  _98
b550 : e65f             	ldb	-1,u
b552 : 4f               	clra
                        * }
b553 : 32c4             	leas	,u
b555 : 35c0             	puls	u,pc
                        * 
                        * /***************************************************
                        *                          char FILE_GetCh(fileConfig_
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                   fileConfig_st *: structure pointer
                        * 
                        *  * Return value  :
                        *                    char : Byte of data read from fil
                        * 
                        * 
                        *  * description :
                        *                  This functions reads a byte of data
                        *                  It checks whether the requested fil
                        *                  Once the End of File is reached it 
                        *  ***************************************************
                        * //char FILE_GetCh(fileConfig_st *filePtr)
                        * FILE_GetCh(filePtr) fileConfig_st *filePtr;
                        * {
                        *     char ch;
                        * 	u32_t tmp1, tmp2;
AS09 Assembler for M6809 [1.42].                                     Page  174
--------------------------------- merge.a09 ----------------------------------

                        * 
                        * 	_setGVpt(); // call when GV are utilized
b557 :                  FILE_Get
b557 : 3440             	pshs	u
b559 : 33e4             	leau	,s
b55b : 3277             	leas	-9,s
b55d : bde2ef           	lbsr	_setGVpt
                        * 
                        *     if( ((_u32_higher(&filePtr->fileSize, &filePtr->
b560 : ec44             	ldd	4,u
b562 : c30016           	addd	#$16
b565 : 3406             	pshs	d
b567 : ec44             	ldd	4,u
b569 : c30012           	addd	#$12
b56c : 3406             	pshs	d
b56e : bdaac0           	lbsr	_u32_hig
b571 : 3264             	leas	4,s
b573 : 830000           	subd	#$0
b576 : 102700ef         	lbeq	_102
b57a : ae44             	ldx	4,u
b57c : e6890227         	ldb	551,x
b580 : 4f               	clra
b581 : 830001           	subd	#$1
b584 : 102600e1         	lbne	_102
                        *     {
                        *         if(filePtr->bufferIndex_u16 == 0)
b588 : ae44             	ldx	4,u
b58a : ec8824           	ldd	36,x
b58d : 830000           	subd	#$0
b590 : 10260048         	lbne	_103
                        *         {
                        *             if((filePtr->sectorIndex == 0))
b594 : ae44             	ldx	4,u
b596 : ec8822           	ldd	34,x
b599 : 830000           	subd	#$0
b59c : 10260010         	lbne	_104
                        *             {
                        *                 getFirstSector(&filePtr->cluster, &f
b5a0 : ec44             	ldd	4,u
b5a2 : 3406             	pshs	d
b5a4 : ec44             	ldd	4,u
b5a6 : c30004           	addd	#$4
b5a9 : 3406             	pshs	d
b5ab : bde2f4           	lbsr	getFirst
b5ae : 3264             	leas	4,s
                        *             }            
                        * 			tmp1.h = 0; tmp1.l = filePtr->sectorIndex;
b5b0 :                  _104
b5b0 : 4f               	clra
b5b1 : 5f               	clrb
b5b2 : ed5b             	std	-5,u
b5b4 : ae44             	ldx	4,u
b5b6 : ec8822           	ldd	34,x
b5b9 : ed5d             	std	-3,u
                        * 			_u32_add(&filePtr->firstSector, &tmp1, &tmp2);
b5bb : 3057             	leax	-9,u
b5bd : 3410             	pshs	x
b5bf : 305b             	leax	-5,u
b5c1 : 3410             	pshs	x
b5c3 : ec44             	ldd	4,u
b5c5 : 3406             	pshs	d
b5c7 : bda9df           	lbsr	_u32_add
AS09 Assembler for M6809 [1.42].                                     Page  175
--------------------------------- merge.a09 ----------------------------------

b5ca : 3266             	leas	6,s
                        * 			SD_readSingleBlock(filePtr->LE_fileBuffer, &tmp2)
b5cc : 3057             	leax	-9,u
b5ce : 3410             	pshs	x
b5d0 : ec44             	ldd	4,u
b5d2 : c30026           	addd	#$26
b5d5 : 3406             	pshs	d
b5d7 : bdaf12           	lbsr	SD_readS
b5da : 3264             	leas	4,s
                        *         }
                        * 
                        *         ch = filePtr->LE_fileBuffer[filePtr->bufferI
b5dc :                  _103
b5dc : ec44             	ldd	4,u
b5de : c30026           	addd	#$26
b5e1 : 3406             	pshs	d
b5e3 : ec44             	ldd	4,u
b5e5 : c30024           	addd	#$24
b5e8 : 1f01             	tfr	d,x
b5ea : ec84             	ldd	,x
b5ec : c30001           	addd	#$1
b5ef : ed84             	std	,x
b5f1 : 830001           	subd	#$1
b5f4 : 3510             	puls	x
b5f6 : e68b             	ldb	d,x
b5f8 : 1d               	sex
b5f9 : e75f             	stb	-1,u
                        *         _u32_inc(&filePtr->byteCounter);
b5fb : ec44             	ldd	4,u
b5fd : c30016           	addd	#$16
b600 : 3406             	pshs	d
b602 : bdaa2e           	lbsr	_u32_inc
b605 : 3262             	leas	2,s
                        * 
                        *         if(filePtr->bufferIndex_u16 == C_MaxPageSize
b607 : ae44             	ldx	4,u
b609 : ec8824           	ldd	36,x
b60c : 830200           	subd	#$200
b60f : 10260053         	lbne	_105
                        *         {
                        *             filePtr->sectorIndex++;
b613 : ec44             	ldd	4,u
b615 : c30022           	addd	#$22
b618 : 1f01             	tfr	d,x
b61a : ec84             	ldd	,x
b61c : c30001           	addd	#$1
b61f : ed84             	std	,x
b621 : 830001           	subd	#$1
                        *             filePtr->bufferIndex_u16 = 0;
b624 : 4f               	clra
b625 : 5f               	clrb
b626 : ae44             	ldx	4,u
b628 : ed8824           	std	36,x
                        *             if(filePtr->sectorIndex == secPerCluster
b62b : ae44             	ldx	4,u
b62d : ec8822           	ldd	34,x
b630 : a3a8ef           	subd	secPerCl+0,y
b633 : 1026002f         	lbne	_106
                        *             {
                        *                 filePtr->sectorIndex = 0;
b637 : 4f               	clra
b638 : 5f               	clrb
AS09 Assembler for M6809 [1.42].                                     Page  176
--------------------------------- merge.a09 ----------------------------------

b639 : ae44             	ldx	4,u
b63b : ed8822           	std	34,x
                        *                 tmp1.h = tmp1.l = 0;
b63e : 4f               	clra
b63f : 5f               	clrb
b640 : ed5d             	std	-3,u
b642 : ed5b             	std	-5,u
                        * 				getSetNC (filePtr->LE_fileBuffer, &filePtr->clus
b644 : ec44             	ldd	4,u
b646 : c30004           	addd	#$4
b649 : 3406             	pshs	d
b64b : 305b             	leax	-5,u
b64d : 3410             	pshs	x
b64f : 4f               	clra
b650 : 5f               	clrb
b651 : 3406             	pshs	d
b653 : ec44             	ldd	4,u
b655 : c30004           	addd	#$4
b658 : 3406             	pshs	d
b65a : ec44             	ldd	4,u
b65c : c30026           	addd	#$26
b65f : 3406             	pshs	d
b661 : bde33b           	lbsr	getSetNC
b664 : 326a             	leas	10,s
                        *             }
                        *         }
b666 :                  _106
                        *     }
b666 :                  _105
                        *     else
b666 : 200612           	lbra	_107
b669 :                  _102
                        *     {
                        *         ch = EOF;
b669 : cc001a           	ldd	#$1a
b66c : e75f             	stb	-1,u
                        *     }
                        * 
                        *     return ch;
b66e :                  _107
b66e : e65f             	ldb	-1,u
b670 : 1d               	sex
                        * }
b671 : 32c4             	leas	,u
b673 : 35c0             	puls	u,pc
                        * 
                        * /***************************************************
                        *                          void FILE_PutCh (fileConfig
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                   fileConfig_st *: structure pointer
                        *                   char           : Byte of data to b
                        * 
                        *  * Return value  :
                        *                   0 when successfully
                        * 
                        * 
                        *  * description :
                        *                  This functions writes a byte of dat
                        *                  It checks whether the requested fil
                        * 
                        *            Note: CTRL+Z(26) needs to be passed to ma
AS09 Assembler for M6809 [1.42].                                     Page  177
--------------------------------- merge.a09 ----------------------------------

                        *  ***************************************************
                        * //void FILE_PutCh (fileConfig_st *filePtr, char data
                        * FILE_PutCh(filePtr, data) fileConfig_st *filePtr; ch
                        * {
                        *     unsigned char k;
                        *     LE_dir_Structure *dir;
                        *     u32_t tmp1, tmp2;
                        * 
                        * 	_setGVpt(); // call when GV are utilized
b675 :                  FILE_Put
b675 : 3440             	pshs	u
b677 : 33e4             	leau	,s
b679 : 3275             	leas	-11,s
b67b : bde2ef           	lbsr	_setGVpt
                        * 	
                        *     if(filePtr->fileOpenedFlag == TRUE)
b67e : ae44             	ldx	4,u
b680 : e6890227         	ldb	551,x
b684 : 4f               	clra
b685 : 830001           	subd	#$1
b688 : 102606f3         	lbne	_108
                        *     {
                        *         if((filePtr->endOfFileDetected == 0) && (dat
b68c : ae44             	ldx	4,u
b68e : e689022b         	ldb	555,x
b692 : 1d               	sex
b693 : 830000           	subd	#$0
b696 : 10260231         	lbne	_109
b69a : e647             	ldb	7,u
b69c : 1d               	sex
b69d : 83001a           	subd	#$1a
b6a0 : 10270227         	lbeq	_109
                        *         {
                        *             if(filePtr->sectorEndFlag == 1) //specia
b6a4 : ae44             	ldx	4,u
b6a6 : e689022a         	ldb	554,x
b6aa : 4f               	clra
b6ab : 830001           	subd	#$1
b6ae : 10260035         	lbne	_110
                        *             {
                        *                 filePtr->LE_fileBuffer[filePtr->buff
b6b2 : ec44             	ldd	4,u
b6b4 : c30024           	addd	#$24
b6b7 : 1f01             	tfr	d,x
b6b9 : ec84             	ldd	,x
b6bb : c30001           	addd	#$1
b6be : ed84             	std	,x
b6c0 : 830001           	subd	#$1
b6c3 : 3406             	pshs	d
b6c5 : ec44             	ldd	4,u
b6c7 : c30026           	addd	#$26
b6ca : e3e1             	addd	,s++
b6cc : 1f01             	tfr	d,x
b6ce : cc000a           	ldd	#$a
b6d1 : e784             	stb	0,x
                        *                 _u32_inc(&filePtr->fileSize);
b6d3 : ec44             	ldd	4,u
b6d5 : c30012           	addd	#$12
b6d8 : 3406             	pshs	d
b6da : bdaa2e           	lbsr	_u32_inc
b6dd : 3262             	leas	2,s
                        *                 filePtr->sectorEndFlag = 0;
AS09 Assembler for M6809 [1.42].                                     Page  178
--------------------------------- merge.a09 ----------------------------------

b6df : 4f               	clra
b6e0 : 5f               	clrb
b6e1 : ae44             	ldx	4,u
b6e3 : e789022a         	stb	554,x
                        *             }
                        * 
                        *             if(data == 0x08)    //'Back Space' key p
b6e7 :                  _110
b6e7 : e647             	ldb	7,u
b6e9 : 1d               	sex
b6ea : 830008           	subd	#$8
b6ed : 1026002c         	lbne	_111
                        *             {
                        *                 if(filePtr->bufferIndex_u16 != 0)
b6f1 : ae44             	ldx	4,u
b6f3 : ec8824           	ldd	36,x
b6f6 : 830000           	subd	#$0
b6f9 : 1027001d         	lbeq	_112
                        *                 {
                        *                     filePtr->bufferIndex_u16--;
b6fd : ec44             	ldd	4,u
b6ff : c30024           	addd	#$24
b702 : 1f01             	tfr	d,x
b704 : ec84             	ldd	,x
b706 : c3ffff           	addd	#$ffff
b709 : ed84             	std	,x
b70b : 83ffff           	subd	#$ffff
                        *                     _u32_dec(&filePtr->fileSize);
b70e : ec44             	ldd	4,u
b710 : c30012           	addd	#$12
b713 : 3406             	pshs	d
b715 : bda9b1           	lbsr	_u32_dec
b718 : 3262             	leas	2,s
                        *                 }
                        *             }
b71a :                  _112
                        *             else
b71a : 202e12           	lbra	_113
b71d :                  _111
                        *             {
                        *                 filePtr->LE_fileBuffer[filePtr->buff
b71d : ec44             	ldd	4,u
b71f : c30024           	addd	#$24
b722 : 1f01             	tfr	d,x
b724 : ec84             	ldd	,x
b726 : c30001           	addd	#$1
b729 : ed84             	std	,x
b72b : 830001           	subd	#$1
b72e : 3406             	pshs	d
b730 : ec44             	ldd	4,u
b732 : c30026           	addd	#$26
b735 : e3e1             	addd	,s++
b737 : 1f01             	tfr	d,x
b739 : e647             	ldb	7,u
b73b : 4f               	clra
b73c : e784             	stb	0,x
                        *                 _u32_inc(&filePtr->fileSize);
b73e : ec44             	ldd	4,u
b740 : c30012           	addd	#$12
b743 : 3406             	pshs	d
b745 : bdaa2e           	lbsr	_u32_inc
b748 : 3262             	leas	2,s
AS09 Assembler for M6809 [1.42].                                     Page  179
--------------------------------- merge.a09 ----------------------------------

                        *             }
                        * 
                        * 
                        *             if(data == '\r')  //'Carriage Return (CR
b74a :                  _113
b74a : e647             	ldb	7,u
b74c : 1d               	sex
b74d : 83000d           	subd	#$d
b750 : 10260045         	lbne	_114
                        *             {
                        *                 if(filePtr->bufferIndex_u16 == C_Max
b754 : ae44             	ldx	4,u
b756 : ec8824           	ldd	36,x
b759 : 830200           	subd	#$200
b75c : 1026000c         	lbne	_115
                        *                     filePtr->sectorEndFlag = 1;  //f
b760 : cc0001           	ldd	#$1
b763 : ae44             	ldx	4,u
b765 : e789022a         	stb	554,x
                        *                 else
b769 : 202e12           	lbra	_116
b76c :                  _115
                        *                 {
                        *                     filePtr->LE_fileBuffer[filePtr->
b76c : ec44             	ldd	4,u
b76e : c30024           	addd	#$24
b771 : 1f01             	tfr	d,x
b773 : ec84             	ldd	,x
b775 : c30001           	addd	#$1
b778 : ed84             	std	,x
b77a : 830001           	subd	#$1
b77d : 3406             	pshs	d
b77f : ec44             	ldd	4,u
b781 : c30026           	addd	#$26
b784 : e3e1             	addd	,s++
b786 : 1f01             	tfr	d,x
b788 : cc000a           	ldd	#$a
b78b : e784             	stb	0,x
                        *                     _u32_inc(&filePtr->fileSize);
b78d : ec44             	ldd	4,u
b78f : c30012           	addd	#$12
b792 : 3406             	pshs	d
b794 : bdaa2e           	lbsr	_u32_inc
b797 : 3262             	leas	2,s
                        *                 }
                        *             }
b799 :                  _116
                        * 
                        *             if(filePtr->bufferIndex_u16 >= C_MaxPage
b799 :                  _114
b799 : ae44             	ldx	4,u
b79b : ec8824           	ldd	36,x
b79e : 830200           	subd	#$200
b7a1 : 10250123         	lblo	_117
                        *             {               //infinite loop in case 
                        *                 filePtr->bufferIndex_u16=0;         
b7a5 : 4f               	clra
b7a6 : 5f               	clrb
b7a7 : ae44             	ldx	4,u
b7a9 : ed8824           	std	36,x
                        * 				if (SD_writeSingleBlock(filePtr->LE_fileBuffer, 
b7ac : ec44             	ldd	4,u
AS09 Assembler for M6809 [1.42].                                     Page  180
--------------------------------- merge.a09 ----------------------------------

b7ae : c3001a           	addd	#$1a
b7b1 : 3406             	pshs	d
b7b3 : ec44             	ldd	4,u
b7b5 : c30026           	addd	#$26
b7b8 : 3406             	pshs	d
b7ba : bdafa0           	lbsr	SD_write
b7bd : 3264             	leas	4,s
b7bf : 830000           	subd	#$0
b7c2 : 10270007         	lbeq	_118
b7c6 : ccffff           	ldd	#$ffff
                        *                 filePtr->sectorIndex++;
b7c9 : 32c4             	leas	,u
b7cb : 35c0             	puls	u,pc
b7cd :                  _118
b7cd : ec44             	ldd	4,u
b7cf : c30022           	addd	#$22
b7d2 : 1f01             	tfr	d,x
b7d4 : ec84             	ldd	,x
b7d6 : c30001           	addd	#$1
b7d9 : ed84             	std	,x
b7db : 830001           	subd	#$1
                        *                 if(filePtr->sectorIndex == secPerClu
b7de : ae44             	ldx	4,u
b7e0 : ec8822           	ldd	34,x
b7e3 : a3a8ef           	subd	secPerCl+0,y
b7e6 : 102600d2         	lbne	_119
                        *                 {
                        *                     filePtr->sectorIndex = 0;
b7ea : 4f               	clra
b7eb : 5f               	clrb
b7ec : ae44             	ldx	4,u
b7ee : ed8822           	std	34,x
                        *                     filePtr->prevCluster.h = filePtr
b7f1 : ae44             	ldx	4,u
b7f3 : ec04             	ldd	4,x
b7f5 : ae44             	ldx	4,u
b7f7 : ed08             	std	8,x
b7f9 : ec44             	ldd	4,u
b7fb : c30004           	addd	#$4
b7fe : 3406             	pshs	d
b800 : cc0002           	ldd	#$2
b803 : 3510             	puls	x
b805 : ec8b             	ldd	d,x
b807 : 3406             	pshs	d
b809 : ec44             	ldd	4,u
b80b : c30008           	addd	#$8
b80e : c30002           	addd	#$2
b811 : 1f01             	tfr	d,x
b813 : 3506             	puls	d
b815 : ed84             	std	0,x
                        * 
                        *                     searchNextFreeCluster(filePtr->L
b817 : ec44             	ldd	4,u
b819 : c30004           	addd	#$4
b81c : 3406             	pshs	d
b81e : ec44             	ldd	4,u
b820 : c30008           	addd	#$8
b823 : 3406             	pshs	d
b825 : ec44             	ldd	4,u
b827 : c30026           	addd	#$26
b82a : 3406             	pshs	d
b82c : bde55f           	lbsr	searchNe
AS09 Assembler for M6809 [1.42].                                     Page  181
--------------------------------- merge.a09 ----------------------------------

b82f : 3266             	leas	6,s
                        * 
                        *                     tmp1.h = tmp1.l = 0;
b831 : 4f               	clra
b832 : 5f               	clrb
b833 : ed5b             	std	-5,u
b835 : ed59             	std	-7,u
                        *                     if(_u32_equal(&filePtr->cluster,
b837 : 3059             	leax	-7,u
b839 : 3410             	pshs	x
b83b : ec44             	ldd	4,u
b83d : c30004           	addd	#$4
b840 : 3406             	pshs	d
b842 : bdaa95           	lbsr	_u32_equ
b845 : 3264             	leas	4,s
b847 : 830000           	subd	#$0
b84a : 10270007         	lbeq	_120
b84e : ccffff           	ldd	#$ffff
                        * 
                        *                     getSetNC(filePtr->LE_fileBuffer,
b851 : 32c4             	leas	,u
b853 : 35c0             	puls	u,pc
b855 :                  _120
b855 : 3059             	leax	-7,u
b857 : 3410             	pshs	x
b859 : ec44             	ldd	4,u
b85b : c30004           	addd	#$4
b85e : 3406             	pshs	d
b860 : cc0001           	ldd	#$1
b863 : 3406             	pshs	d
b865 : ec44             	ldd	4,u
b867 : c30008           	addd	#$8
b86a : 3406             	pshs	d
b86c : ec44             	ldd	4,u
b86e : c30026           	addd	#$26
b871 : 3406             	pshs	d
b873 : bde33b           	lbsr	getSetNC
b876 : 326a             	leas	10,s
                        * 					tmp1.h = 0x0fff; tmp1.l = 0xffff; // = END_OF_C
b878 : cc0fff           	ldd	#$fff
b87b : ed59             	std	-7,u
b87d : ccffff           	ldd	#$ffff
b880 : ed5b             	std	-5,u
                        *                     getSetNC(filePtr->LE_fileBuffer,
b882 : 3055             	leax	-11,u
b884 : 3410             	pshs	x
b886 : 3059             	leax	-7,u
b888 : 3410             	pshs	x
b88a : cc0001           	ldd	#$1
b88d : 3406             	pshs	d
b88f : ec44             	ldd	4,u
b891 : c30004           	addd	#$4
b894 : 3406             	pshs	d
b896 : ec44             	ldd	4,u
b898 : c30026           	addd	#$26
b89b : 3406             	pshs	d
b89d : bde33b           	lbsr	getSetNC
b8a0 : 326a             	leas	10,s
                        * 
                        *                     getFirstSector (&filePtr->cluste
b8a2 : ec44             	ldd	4,u
b8a4 : c3001a           	addd	#$1a
AS09 Assembler for M6809 [1.42].                                     Page  182
--------------------------------- merge.a09 ----------------------------------

b8a7 : 3406             	pshs	d
b8a9 : ec44             	ldd	4,u
b8ab : c30004           	addd	#$4
b8ae : 3406             	pshs	d
b8b0 : bde2f4           	lbsr	getFirst
b8b3 : 3264             	leas	4,s
                        *                     filePtr->bufferIndex_u16=0;
b8b5 : 4f               	clra
b8b6 : 5f               	clrb
b8b7 : ae44             	ldx	4,u
b8b9 : ed8824           	std	36,x
                        *                 }
                        *                 _u32_inc(&filePtr->blockNumber_u32);
b8bc :                  _119
b8bc : ec44             	ldd	4,u
b8be : c3001a           	addd	#$1a
b8c1 : 3406             	pshs	d
b8c3 : bdaa2e           	lbsr	_u32_inc
b8c6 : 3262             	leas	2,s
                        *             }
                        *         }
b8c8 :                  _117
                        *         else if(filePtr->endOfFileDetected == 0)
b8c8 : 7ebd7c           	lbra	_121
b8cb :                  _109
b8cb : ae44             	ldx	4,u
b8cd : e689022b         	ldb	555,x
b8d1 : 4f               	clra
b8d2 : 830000           	subd	#$0
b8d5 : 102604a3         	lbne	_122
                        *         {
                        *             filePtr->endOfFileDetected = 1;
b8d9 : cc0001           	ldd	#$1
b8dc : ae44             	ldx	4,u
b8de : e789022b         	stb	555,x
                        *             for(;filePtr->bufferIndex_u16<C_MaxPageS
b8e2 :                  _124
b8e2 : ae44             	ldx	4,u
b8e4 : ec8824           	ldd	36,x
b8e7 : 830200           	subd	#$200
b8ea : 10240027         	lbhs	_123
                        *                 filePtr->LE_fileBuffer[filePtr->buff
b8ee : ae44             	ldx	4,u
b8f0 : ec8824           	ldd	36,x
b8f3 : 3406             	pshs	d
b8f5 : ec44             	ldd	4,u
b8f7 : c30026           	addd	#$26
b8fa : e3e1             	addd	,s++
b8fc : 1f01             	tfr	d,x
b8fe : 4f               	clra
b8ff : 5f               	clrb
b900 : e784             	stb	0,x
                        * 
                        * 			if (SD_writeSingleBlock(filePtr->LE_fileBuffer, &
b902 :                  _125
b902 : ec44             	ldd	4,u
b904 : c30024           	addd	#$24
b907 : 1f01             	tfr	d,x
b909 : ec84             	ldd	,x
b90b : c30001           	addd	#$1
b90e : ed84             	std	,x
b910 : 830001           	subd	#$1
AS09 Assembler for M6809 [1.42].                                     Page  183
--------------------------------- merge.a09 ----------------------------------

b913 : 20cd             	lbra	_124
b915 :                  _123
b915 : ec44             	ldd	4,u
b917 : c3001a           	addd	#$1a
b91a : 3406             	pshs	d
b91c : ec44             	ldd	4,u
b91e : c30026           	addd	#$26
b921 : 3406             	pshs	d
b923 : bdafa0           	lbsr	SD_write
b926 : 3264             	leas	4,s
b928 : 830000           	subd	#$0
b92b : 10270007         	lbeq	_126
b92f : ccffff           	ldd	#$ffff
                        *             
                        * 			getSetFreeCluster(filePtr->LE_fileBuffer,NEXT_FRE
b932 : 32c4             	leas	,u
b934 : 35c0             	puls	u,pc
b936 :                  _126
b936 : 3059             	leax	-7,u
b938 : 3410             	pshs	x
b93a : ec44             	ldd	4,u
b93c : c30004           	addd	#$4
b93f : 3406             	pshs	d
b941 : cc0001           	ldd	#$1
b944 : 3406             	pshs	d
b946 : cc0002           	ldd	#$2
b949 : 3406             	pshs	d
b94b : ec44             	ldd	4,u
b94d : c30026           	addd	#$26
b950 : 3406             	pshs	d
b952 : bde442           	lbsr	getSetFr
b955 : 326a             	leas	10,s
                        * 
                        *             if(filePtr->appendFileFlag == 1)  //exec
b957 : ae44             	ldx	4,u
b959 : e6890229         	ldb	553,x
b95d : 4f               	clra
b95e : 830001           	subd	#$1
b961 : 102600d7         	lbne	_127
                        *             {
                        *                 if (SD_readSingleBlock(filePtr->LE_f
b965 : ec44             	ldd	4,u
b967 : c3000c           	addd	#$c
b96a : 3406             	pshs	d
b96c : ec44             	ldd	4,u
b96e : c30026           	addd	#$26
b971 : 3406             	pshs	d
b973 : bdaf12           	lbsr	SD_readS
b976 : 3264             	leas	4,s
b978 : 830000           	subd	#$0
b97b : 10270007         	lbeq	_128
b97f : ccffff           	ldd	#$ffff
                        * 				
                        *                 dir = &filePtr->LE_fileBuffer[filePt
b982 : 32c4             	leas	,u
b984 : 35c0             	puls	u,pc
b986 :                  _128
b986 : ae44             	ldx	4,u
b988 : ec8810           	ldd	16,x
b98b : 3406             	pshs	d
b98d : ec44             	ldd	4,u
b98f : c30026           	addd	#$26
AS09 Assembler for M6809 [1.42].                                     Page  184
--------------------------------- merge.a09 ----------------------------------

b992 : e3e1             	addd	,s++
b994 : ed5d             	std	-3,u
                        * 				set_Word(getTimeF32(), dir->writeTime);        /
b996 : ec5d             	ldd	-3,u
b998 : c30016           	addd	#$16
b99b : 3406             	pshs	d
b99d : bde2df           	lbsr	getTimeF
b9a0 : 3406             	pshs	d
b9a2 : bde2be           	lbsr	set_Word
b9a5 : 3264             	leas	4,s
                        * 				set_Word(getDateF32(), dir->lastAccessDate);   /
b9a7 : ec5d             	ldd	-3,u
b9a9 : c30012           	addd	#$12
b9ac : 3406             	pshs	d
b9ae : bde2db           	lbsr	getDateF
b9b1 : 3406             	pshs	d
b9b3 : bde2be           	lbsr	set_Word
b9b6 : 3264             	leas	4,s
                        * 	            set_Word(getDateF32(), dir->writeDate);
b9b8 : ec5d             	ldd	-3,u
b9ba : c30018           	addd	#$18
b9bd : 3406             	pshs	d
b9bf : bde2db           	lbsr	getDateF
b9c2 : 3406             	pshs	d
b9c4 : bde2be           	lbsr	set_Word
b9c7 : 3264             	leas	4,s
                        *                 get_QByte(dir->fSize, &tmp1);
b9c9 : 3059             	leax	-7,u
b9cb : 3410             	pshs	x
b9cd : ec5d             	ldd	-3,u
b9cf : c3001c           	addd	#$1c
b9d2 : 3406             	pshs	d
b9d4 : bde2c6           	lbsr	get_QByt
b9d7 : 3264             	leas	4,s
                        * 				_u32_sub(&filePtr->fileSize, &tmp1, &tmp2);
b9d9 : 3055             	leax	-11,u
b9db : 3410             	pshs	x
b9dd : 3059             	leax	-7,u
b9df : 3410             	pshs	x
b9e1 : ec44             	ldd	4,u
b9e3 : c30012           	addd	#$12
b9e6 : 3406             	pshs	d
b9e8 : bda975           	lbsr	_u32_sub
b9eb : 3266             	leas	6,s
                        * 				set_QByte(&filePtr->fileSize, dir->fSize);
b9ed : ec5d             	ldd	-3,u
b9ef : c3001c           	addd	#$1c
b9f2 : 3406             	pshs	d
b9f4 : ec44             	ldd	4,u
b9f6 : c30012           	addd	#$12
b9f9 : 3406             	pshs	d
b9fb : bde2c6           	lbsr	set_QByt
b9fe : 3264             	leas	4,s
                        *                 if (SD_writeSingleBlock(filePtr->LE_
ba00 : ec44             	ldd	4,u
ba02 : c3000c           	addd	#$c
ba05 : 3406             	pshs	d
ba07 : ec44             	ldd	4,u
ba09 : c30026           	addd	#$26
ba0c : 3406             	pshs	d
ba0e : bdafa0           	lbsr	SD_write
ba11 : 3264             	leas	4,s
AS09 Assembler for M6809 [1.42].                                     Page  185
--------------------------------- merge.a09 ----------------------------------

ba13 : 830000           	subd	#$0
ba16 : 10270007         	lbeq	_129
ba1a : ccffff           	ldd	#$ffff
                        *                 freeMemoryUpdate (filePtr->LE_fileBu
ba1d : 32c4             	leas	,u
ba1f : 35c0             	puls	u,pc
ba21 :                  _129
ba21 : 3055             	leax	-11,u
ba23 : 3410             	pshs	x
ba25 : cc0001           	ldd	#$1
ba28 : 3406             	pshs	d
ba2a : ec44             	ldd	4,u
ba2c : c30026           	addd	#$26
ba2f : 3406             	pshs	d
ba31 : bdea64           	lbsr	freeMemo
ba34 : 3266             	leas	6,s
                        *                 return 0;
ba36 : 4f               	clra
ba37 : 5f               	clrb
                        *             }
ba38 : 32c4             	leas	,u
ba3a : 35c0             	puls	u,pc
                        * 
                        *             //executes following portion when new fi
                        * 			filePtr->prevCluster.h = rCluster.h; filePtr->pre
ba3c :                  _127
ba3c : ec37             	ldd	rCluster+0,y
ba3e : ae44             	ldx	4,u
ba40 : ed08             	std	8,x
ba42 : ec44             	ldd	4,u
ba44 : c30008           	addd	#$8
ba47 : c30002           	addd	#$2
ba4a : 1f01             	tfr	d,x
ba4c : ec39             	ldd	rCluster+2,y
ba4e : ed84             	std	0,x
                        * 
                        *             while(1)
ba50 :                  _131
                        *             {
                        *                 getFirstSector(&filePtr->prevCluster
ba50 : ec44             	ldd	4,u
ba52 : 3406             	pshs	d
ba54 : ec44             	ldd	4,u
ba56 : c30008           	addd	#$8
ba59 : 3406             	pshs	d
ba5b : bde2f4           	lbsr	getFirst
ba5e : 3264             	leas	4,s
                        * 
                        *                 for(filePtr->sectorIndex = 0; filePt
ba60 : 4f               	clra
ba61 : 5f               	clrb
ba62 : ae44             	ldx	4,u
ba64 : ed8822           	std	34,x
ba67 :                  _133
ba67 : ae44             	ldx	4,u
ba69 : ec8822           	ldd	34,x
ba6c : a3a8ef           	subd	secPerCl+0,y
ba6f : 102401eb         	lbhs	_132
                        *                 {
                        *                     tmp1.h = 0; tmp1.l = filePtr->se
ba73 : 4f               	clra
ba74 : 5f               	clrb
AS09 Assembler for M6809 [1.42].                                     Page  186
--------------------------------- merge.a09 ----------------------------------

ba75 : ed59             	std	-7,u
ba77 : ae44             	ldx	4,u
ba79 : ec8822           	ldd	34,x
ba7c : ed5b             	std	-5,u
                        *                     _u32_add(&filePtr->firstSector, 
ba7e : 3055             	leax	-11,u
ba80 : 3410             	pshs	x
ba82 : 3059             	leax	-7,u
ba84 : 3410             	pshs	x
ba86 : ec44             	ldd	4,u
ba88 : 3406             	pshs	d
ba8a : bda9df           	lbsr	_u32_add
ba8d : 3266             	leas	6,s
                        * 					if (SD_readSingleBlock(filePtr->LE_fileBuffer, 
ba8f : 3055             	leax	-11,u
ba91 : 3410             	pshs	x
ba93 : ec44             	ldd	4,u
ba95 : c30026           	addd	#$26
ba98 : 3406             	pshs	d
ba9a : bdaf12           	lbsr	SD_readS
ba9d : 3264             	leas	4,s
ba9f : 830000           	subd	#$0
baa2 : 10270007         	lbeq	_135
baa6 : ccffff           	ldd	#$ffff
                        * 					
                        *                     for(filePtr->bufferIndex_u16=0; 
baa9 : 32c4             	leas	,u
baab : 35c0             	puls	u,pc
baad :                  _135
baad : 4f               	clra
baae : 5f               	clrb
baaf : ae44             	ldx	4,u
bab1 : ed8824           	std	36,x
bab4 :                  _137
bab4 : ae44             	ldx	4,u
bab6 : ec8824           	ldd	36,x
bab9 : a331             	subd	bPerSect+0,y
babb : 1024018b         	lbhs	_136
                        *                     {
                        *                         dir = &filePtr->LE_fileBuffe
babf : ae44             	ldx	4,u
bac1 : ec8824           	ldd	36,x
bac4 : 3406             	pshs	d
bac6 : ec44             	ldd	4,u
bac8 : c30026           	addd	#$26
bacb : e3e1             	addd	,s++
bacd : ed5d             	std	-3,u
                        * 						if(filePtr->fileCreatedFlag != 0)   //to mark 
bacf : ae44             	ldx	4,u
bad1 : e6890228         	ldb	552,x
bad5 : 4f               	clra
bad6 : 830000           	subd	#$0
bad9 : 1027000c         	lbeq	_139
                        *                         {                     //indi
                        *                             dir->name[0] = 0x00;
badd : 4f               	clra
bade : 5f               	clrb
badf : ae5d             	ldx	-3,u
bae1 : e784             	stb	0,x
                        *                             return 0;
bae3 : 4f               	clra
bae4 : 5f               	clrb
AS09 Assembler for M6809 [1.42].                                     Page  187
--------------------------------- merge.a09 ----------------------------------

                        *                         }
bae5 : 32c4             	leas	,u
bae7 : 35c0             	puls	u,pc
                        * 
                        *                         if((dir->name[0] == EMPTY) |
bae9 :                  _139
bae9 : ae5d             	ldx	-3,u
baeb : e684             	ldb	0,x
baed : 4f               	clra
baee : 830000           	subd	#$0
baf1 : 1027000c         	lbeq	_141
baf5 : ae5d             	ldx	-3,u
baf7 : e684             	ldb	0,x
baf9 : 4f               	clra
bafa : 8300e5           	subd	#$e5
bafd : 10260138         	lbne	_140
bb01 :                  _141
                        *                         {                           
                        * 							// Root Directory Entry Format (SFN)					
                        * 							for(k=0; k<C_8_3_FileNameSize; k++) {        
bb01 : 4f               	clra
bb02 : 5f               	clrb
bb03 : e75f             	stb	-1,u
bb05 :                  _143
bb05 : e65f             	ldb	-1,u
bb07 : 4f               	clra
bb08 : 83000b           	subd	#$b
bb0b : 10240025         	lbhs	_142
                        * 								dir->name[k] = filePtr->fName[k];
bb0f : ec44             	ldd	4,u
bb11 : c3022c           	addd	#$22c
bb14 : 3406             	pshs	d
bb16 : e65f             	ldb	-1,u
bb18 : 4f               	clra
bb19 : 3510             	puls	x
bb1b : e68b             	ldb	d,x
bb1d : 4f               	clra
bb1e : 3406             	pshs	d
bb20 : e65f             	ldb	-1,u
bb22 : 4f               	clra
bb23 : ae5d             	ldx	-3,u
bb25 : 308b             	leax	d,x
bb27 : 3506             	puls	d
bb29 : e784             	stb	0,x
                        * 							}
                        *                             dir->attrib = ATTR_ARCHI
bb2b :                  _144
bb2b : 305f             	leax	-1,u
bb2d : e684             	ldb	,x
bb2f : 6c84             	inc	,x
bb31 : 4f               	clra
bb32 : 20d1             	lbra	_143
bb34 :                  _142
bb34 : cc0020           	ldd	#$20
bb37 : ae5d             	ldx	-3,u
bb39 : e70b             	stb	11,x
                        *                             dir->NTreserved = 0;    
bb3b : 4f               	clra
bb3c : 5f               	clrb
bb3d : ae5d             	ldx	-3,u
bb3f : e70c             	stb	12,x
                        * 							dir->timeTenth = 0;         					//always set
AS09 Assembler for M6809 [1.42].                                     Page  188
--------------------------------- merge.a09 ----------------------------------

bb41 : 4f               	clra
bb42 : 5f               	clrb
bb43 : ae5d             	ldx	-3,u
bb45 : e70d             	stb	13,x
                        *                             set_Word(getTimeF32(), d
bb47 : ec5d             	ldd	-3,u
bb49 : c3000e           	addd	#$e
bb4c : 3406             	pshs	d
bb4e : bde2df           	lbsr	getTimeF
bb51 : 3406             	pshs	d
bb53 : bde2be           	lbsr	set_Word
bb56 : 3264             	leas	4,s
                        * 	                        set_Word(getTimeF32(), dir-
bb58 : ec5d             	ldd	-3,u
bb5a : c30016           	addd	#$16
bb5d : 3406             	pshs	d
bb5f : bde2df           	lbsr	getTimeF
bb62 : 3406             	pshs	d
bb64 : bde2be           	lbsr	set_Word
bb67 : 3264             	leas	4,s
                        * 							set_Word(getDateF32(), dir->createDate); 	   
bb69 : ec5d             	ldd	-3,u
bb6b : c30010           	addd	#$10
bb6e : 3406             	pshs	d
bb70 : bde2db           	lbsr	getDateF
bb73 : 3406             	pshs	d
bb75 : bde2be           	lbsr	set_Word
bb78 : 3264             	leas	4,s
                        * 	                        set_Word(getDateF32(), dir-
bb7a : ec5d             	ldd	-3,u
bb7c : c30012           	addd	#$12
bb7f : 3406             	pshs	d
bb81 : bde2db           	lbsr	getDateF
bb84 : 3406             	pshs	d
bb86 : bde2be           	lbsr	set_Word
bb89 : 3264             	leas	4,s
                        * 	                        set_Word(getDateF32(), dir-
bb8b : ec5d             	ldd	-3,u
bb8d : c30018           	addd	#$18
bb90 : 3406             	pshs	d
bb92 : bde2db           	lbsr	getDateF
bb95 : 3406             	pshs	d
bb97 : bde2be           	lbsr	set_Word
bb9a : 3264             	leas	4,s
                        * 	                        set_Word(filePtr->appendSta
bb9c : ec5d             	ldd	-3,u
bb9e : c30014           	addd	#$14
bba1 : 3406             	pshs	d
bba3 : ae44             	ldx	4,u
bba5 : ec881e           	ldd	30,x
bba8 : 3406             	pshs	d
bbaa : bde2be           	lbsr	set_Word
bbad : 3264             	leas	4,s
                        * 	                        set_Word(filePtr->appendSta
bbaf : ec5d             	ldd	-3,u
bbb1 : c3001a           	addd	#$1a
bbb4 : 3406             	pshs	d
bbb6 : ec44             	ldd	4,u
bbb8 : c3001e           	addd	#$1e
bbbb : 3406             	pshs	d
bbbd : cc0002           	ldd	#$2
bbc0 : 3510             	puls	x
AS09 Assembler for M6809 [1.42].                                     Page  189
--------------------------------- merge.a09 ----------------------------------

bbc2 : ec8b             	ldd	d,x
bbc4 : 3406             	pshs	d
bbc6 : bde2be           	lbsr	set_Word
bbc9 : 3264             	leas	4,s
                        * 	                        set_QByte(&filePtr->fileSiz
bbcb : ec5d             	ldd	-3,u
bbcd : c3001c           	addd	#$1c
bbd0 : 3406             	pshs	d
bbd2 : ec44             	ldd	4,u
bbd4 : c30012           	addd	#$12
bbd7 : 3406             	pshs	d
bbd9 : bde2c6           	lbsr	set_QByt
bbdc : 3264             	leas	4,s
                        * 							
                        * 							tmp1.h = 0; tmp1.l = filePtr->sectorIndex;
bbde : 4f               	clra
bbdf : 5f               	clrb
bbe0 : ed59             	std	-7,u
bbe2 : ae44             	ldx	4,u
bbe4 : ec8822           	ldd	34,x
bbe7 : ed5b             	std	-5,u
                        * 							_u32_add(&filePtr->firstSector, &tmp1, &tmp2)
bbe9 : 3055             	leax	-11,u
bbeb : 3410             	pshs	x
bbed : 3059             	leax	-7,u
bbef : 3410             	pshs	x
bbf1 : ec44             	ldd	4,u
bbf3 : 3406             	pshs	d
bbf5 : bda9df           	lbsr	_u32_add
bbf8 : 3266             	leas	6,s
                        * 							if (SD_writeSingleBlock(filePtr->LE_fileBuffe
bbfa : 3055             	leax	-11,u
bbfc : 3410             	pshs	x
bbfe : ec44             	ldd	4,u
bc00 : c30026           	addd	#$26
bc03 : 3406             	pshs	d
bc05 : bdafa0           	lbsr	SD_write
bc08 : 3264             	leas	4,s
bc0a : 830000           	subd	#$0
bc0d : 10270007         	lbeq	_145
bc11 : ccffff           	ldd	#$ffff
                        *                             filePtr->fileCreatedFlag
bc14 : 32c4             	leas	,u
bc16 : 35c0             	puls	u,pc
bc18 :                  _145
bc18 : cc0001           	ldd	#$1
bc1b : ae44             	ldx	4,u
bc1d : e7890228         	stb	552,x
                        *                             freeMemoryUpdate (filePt
bc21 : ec44             	ldd	4,u
bc23 : c30012           	addd	#$12
bc26 : 3406             	pshs	d
bc28 : cc0001           	ldd	#$1
bc2b : 3406             	pshs	d
bc2d : ec44             	ldd	4,u
bc2f : c30026           	addd	#$26
bc32 : 3406             	pshs	d
bc34 : bdea64           	lbsr	freeMemo
bc37 : 3266             	leas	6,s
                        *                         }
                        *                     }
bc39 :                  _140
AS09 Assembler for M6809 [1.42].                                     Page  190
--------------------------------- merge.a09 ----------------------------------

                        *                 }
bc39 :                  _138
bc39 : ec44             	ldd	4,u
bc3b : c30024           	addd	#$24
bc3e : 1f01             	tfr	d,x
bc40 : ec84             	ldd	0,x
bc42 : c30020           	addd	#$20
bc45 : ed84             	std	0,x
bc47 : 7ebab4           	lbra	_137
bc4a :                  _136
                        * 				tmp1.h = tmp1.l = 0;
bc4a :                  _134
bc4a : ec44             	ldd	4,u
bc4c : c30022           	addd	#$22
bc4f : 1f01             	tfr	d,x
bc51 : ec84             	ldd	,x
bc53 : c30001           	addd	#$1
bc56 : ed84             	std	,x
bc58 : 830001           	subd	#$1
bc5b : 7eba67           	lbra	_133
bc5e :                  _132
bc5e : 4f               	clra
bc5f : 5f               	clrb
bc60 : ed5b             	std	-5,u
bc62 : ed59             	std	-7,u
                        *                 getSetNC (filePtr->LE_fileBuffer, &f
bc64 : ec44             	ldd	4,u
bc66 : c30004           	addd	#$4
bc69 : 3406             	pshs	d
bc6b : 3059             	leax	-7,u
bc6d : 3410             	pshs	x
bc6f : 4f               	clra
bc70 : 5f               	clrb
bc71 : 3406             	pshs	d
bc73 : ec44             	ldd	4,u
bc75 : c30008           	addd	#$8
bc78 : 3406             	pshs	d
bc7a : ec44             	ldd	4,u
bc7c : c30026           	addd	#$26
bc7f : 3406             	pshs	d
bc81 : bde33b           	lbsr	getSetNC
bc84 : 326a             	leas	10,s
                        * 
                        *                 tmp1.h = 0x0fff; tmp1.l = 0xfff6;
bc86 : cc0fff           	ldd	#$fff
bc89 : ed59             	std	-7,u
bc8b : ccfff6           	ldd	#$fff6
bc8e : ed5b             	std	-5,u
                        * 				if(_u32_higher(&filePtr->cluster, &tmp1) != 0)
bc90 : 3059             	leax	-7,u
bc92 : 3410             	pshs	x
bc94 : ec44             	ldd	4,u
bc96 : c30004           	addd	#$4
bc99 : 3406             	pshs	d
bc9b : bdaac0           	lbsr	_u32_hig
bc9e : 3264             	leas	4,s
bca0 : 830000           	subd	#$0
bca3 : 10270088         	lbeq	_146
                        *                 {
                        *                     tmp1.h = 0x0fff; tmp1.l = 0xffff
bca7 : cc0fff           	ldd	#$fff
bcaa : ed59             	std	-7,u
AS09 Assembler for M6809 [1.42].                                     Page  191
--------------------------------- merge.a09 ----------------------------------

bcac : ccffff           	ldd	#$ffff
bcaf : ed5b             	std	-5,u
                        * 					if(_u32_equal(&filePtr->cluster, &tmp1) != 0)  
bcb1 : 3059             	leax	-7,u
bcb3 : 3410             	pshs	x
bcb5 : ec44             	ldd	4,u
bcb7 : c30004           	addd	#$4
bcba : 3406             	pshs	d
bcbc : bdaa95           	lbsr	_u32_equ
bcbf : 3264             	leas	4,s
bcc1 : 830000           	subd	#$0
bcc4 : 10270060         	lbeq	_147
                        *                     {
                        *                         searchNextFreeCluster(filePt
bcc8 : ec44             	ldd	4,u
bcca : c30004           	addd	#$4
bccd : 3406             	pshs	d
bccf : ec44             	ldd	4,u
bcd1 : c30008           	addd	#$8
bcd4 : 3406             	pshs	d
bcd6 : ec44             	ldd	4,u
bcd8 : c30026           	addd	#$26
bcdb : 3406             	pshs	d
bcdd : bde55f           	lbsr	searchNe
bce0 : 3266             	leas	6,s
                        *                         getSetNC(filePtr->LE_fileBuf
bce2 : 3055             	leax	-11,u
bce4 : 3410             	pshs	x
bce6 : ec44             	ldd	4,u
bce8 : c30004           	addd	#$4
bceb : 3406             	pshs	d
bced : cc0001           	ldd	#$1
bcf0 : 3406             	pshs	d
bcf2 : ec44             	ldd	4,u
bcf4 : c30008           	addd	#$8
bcf7 : 3406             	pshs	d
bcf9 : ec44             	ldd	4,u
bcfb : c30026           	addd	#$26
bcfe : 3406             	pshs	d
bd00 : bde33b           	lbsr	getSetNC
bd03 : 326a             	leas	10,s
                        * 						getSetNC(filePtr->LE_fileBuffer, &filePtr->clu
bd05 : 3055             	leax	-11,u
bd07 : 3410             	pshs	x
bd09 : 3059             	leax	-7,u
bd0b : 3410             	pshs	x
bd0d : cc0001           	ldd	#$1
bd10 : 3406             	pshs	d
bd12 : ec44             	ldd	4,u
bd14 : c30004           	addd	#$4
bd17 : 3406             	pshs	d
bd19 : ec44             	ldd	4,u
bd1b : c30026           	addd	#$26
bd1e : 3406             	pshs	d
bd20 : bde33b           	lbsr	getSetNC
bd23 : 326a             	leas	10,s
                        *                     }
                        *                     else
bd25 : 200812           	lbra	_148
bd28 :                  _147
                        *                     {
                        *                         return -1;
AS09 Assembler for M6809 [1.42].                                     Page  192
--------------------------------- merge.a09 ----------------------------------

bd28 : ccffff           	ldd	#$ffff
                        *                     }
bd2b : 32c4             	leas	,u
bd2d : 35c0             	puls	u,pc
                        *                 }
bd2f :                  _148
                        *                 tmp1.h = tmp1.l = 0;
bd2f :                  _146
bd2f : 4f               	clra
bd30 : 5f               	clrb
bd31 : ed5b             	std	-5,u
bd33 : ed59             	std	-7,u
                        *                 if(_u32_equal(&filePtr->cluster, &tm
bd35 : 3059             	leax	-7,u
bd37 : 3410             	pshs	x
bd39 : ec44             	ldd	4,u
bd3b : c30004           	addd	#$4
bd3e : 3406             	pshs	d
bd40 : bdaa95           	lbsr	_u32_equ
bd43 : 3264             	leas	4,s
bd45 : 830000           	subd	#$0
bd48 : 10270007         	lbeq	_149
bd4c : ccffff           	ldd	#$ffff
                        * 
                        *                 filePtr->prevCluster.h = filePtr->cl
bd4f : 32c4             	leas	,u
bd51 : 35c0             	puls	u,pc
bd53 :                  _149
bd53 : ae44             	ldx	4,u
bd55 : ec04             	ldd	4,x
bd57 : ae44             	ldx	4,u
bd59 : ed08             	std	8,x
bd5b : ec44             	ldd	4,u
bd5d : c30004           	addd	#$4
bd60 : 3406             	pshs	d
bd62 : cc0002           	ldd	#$2
bd65 : 3510             	puls	x
bd67 : ec8b             	ldd	d,x
bd69 : 3406             	pshs	d
bd6b : ec44             	ldd	4,u
bd6d : c30008           	addd	#$8
bd70 : c30002           	addd	#$2
bd73 : 1f01             	tfr	d,x
bd75 : 3506             	puls	d
bd77 : ed84             	std	0,x
                        *             }
                        *         }
bd79 : 7eba50           	lbra	_131
bd7c :                  _130
                        *     }
bd7c :                  _122
bd7c :                  _121
                        *     else
bd7c : 200112           	lbra	_150
bd7f :                  _108
                        *     {
                        *         /* FIle not opened, do not handle the file o
                        *     }
                        * 
                        *     return -1;
bd7f :                  _150
bd7f : ccffff           	ldd	#$ffff
AS09 Assembler for M6809 [1.42].                                     Page  193
--------------------------------- merge.a09 ----------------------------------

                        * }
bd82 : 32c4             	leas	,u
bd84 : 35c0             	puls	u,pc
                        * 
                        * /***************************************************
                        *                          unsigned char FILE_List (fi
                        *  ***************************************************
                        *  * I/P Arguments :
                        *                   fileInfo *: structure pointer to s
                        * 
                        *  * Return value  :
                        *                   unsigned char : MORE_FILES_To_READ
                        *                             END_OF_FILE_LIST(9)  -->
                        * 
                        * 
                        *  * description :
                        *                  This functions traverses through th
                        *                  It updates the file name and its si
                        *                  It returns MORE_FILES_To_READ(8), i
                        *                  In case there are no files to be li
                        *  ***************************************************
                        * //unsigned char FILE_List (fileInfo *fileList)
                        * FILE_List(fileList) fileInfo *fileList;
                        * {
                        *     LE_dir_Structure *dir;
                        *     unsigned char j;
                        *     unsigned char fNameIndex;
                        * 	u32_t tmp;
                        * 
                        * 	_setGVpt(); // call when GV are utilized
bd86 :                  FILE_Lis
bd86 : 3440             	pshs	u
bd88 : 33e4             	leau	,s
bd8a : 3278             	leas	-8,s
bd8c : bde2ef           	lbsr	_setGVpt
                        * 
                        * 	if(FL_initialized == 0)
bd8f : e6a8e7           	ldb	FL_initi+0,y
bd92 : 4f               	clra
bd93 : 830000           	subd	#$0
bd96 : 10260059         	lbne	_151
                        *     {
                        *         clusterNumber.h = rCluster.h; clusterNumber.
bd9a : ec37             	ldd	rCluster+0,y
bd9c : eda9fdaa         	std	clusterN+0,y
bda0 : ec39             	ldd	rCluster+2,y
bda2 : eda9fdac         	std	clusterN+2,y
                        *         sectorNumber.h = 0; sectorNumber.l = 0;
bda6 : 4f               	clra
bda7 : 5f               	clrb
bda8 : eda9fda6         	std	sectorNu+0,y
bdac : 4f               	clra
bdad : 5f               	clrb
bdae : eda9fda8         	std	sectorNu+2,y
                        *         list_i = 0;
bdb2 : 4f               	clra
bdb3 : 5f               	clrb
bdb4 : eda9fda0         	std	list_i+0,y
                        * 		getFirstSector(&clusterNumber, &frstSectorIndex);
bdb8 : 30a9fda2         	leax	frstSect+0,y
bdbc : 3410             	pshs	x
bdbe : 30a9fdaa         	leax	clusterN+0,y
AS09 Assembler for M6809 [1.42].                                     Page  194
--------------------------------- merge.a09 ----------------------------------

bdc2 : 3410             	pshs	x
bdc4 : bde2f4           	lbsr	getFirst
bdc7 : 3264             	leas	4,s
                        * 		_u32_add(&frstSectorIndex, &sectorNumber, &tmp);
bdc9 : 3058             	leax	-8,u
bdcb : 3410             	pshs	x
bdcd : 30a9fda6         	leax	sectorNu+0,y
bdd1 : 3410             	pshs	x
bdd3 : 30a9fda2         	leax	frstSect+0,y
bdd7 : 3410             	pshs	x
bdd9 : bda9df           	lbsr	_u32_add
bddc : 3266             	leas	6,s
                        * 		SD_readSingleBlock(fatMapTb.LE_fileBuffer, &tmp); 
bdde : 3058             	leax	-8,u
bde0 : 3410             	pshs	x
bde2 : 30a9fdd4         	leax	fatMapTb+38,y
bde6 : 3410             	pshs	x
bde8 : bdaf12           	lbsr	SD_readS
bdeb : 3264             	leas	4,s
                        * 		FL_initialized = 1;		
bded : cc0001           	ldd	#$1
bdf0 : e7a8e7           	stb	FL_initi+0,y
                        *     }
                        * 
                        *     fNameIndex = 0;
bdf3 :                  _151
bdf3 : 4f               	clra
bdf4 : 5f               	clrb
bdf5 : e75c             	stb	-4,u
                        *     do
bdf7 :                  _154
                        *     {
                        *         dir = &fatMapTb.LE_fileBuffer[list_i];  //ca
bdf7 : 30a9fdd4         	leax	fatMapTb+38,y
bdfb : 1f10             	tfr	x,d
bdfd : e3a9fda0         	addd	list_i+0,y
be01 : ed5e             	std	-2,u
                        * 		
                        * 		if(dir->name[0] == EMPTY) //indicates end of the f
be03 : ae5e             	ldx	-2,u
be05 : e684             	ldb	0,x
be07 : 4f               	clra
be08 : 830000           	subd	#$0
be0b : 1026000c         	lbne	_155
                        *         {
                        *             FL_initialized = 0;
be0f : 4f               	clra
be10 : 5f               	clrb
be11 : e7a8e7           	stb	FL_initi+0,y
                        *             return (END_OF_FILE_LIST);
be14 : cc0009           	ldd	#$9
                        *         }
be17 : 32c4             	leas	,u
be19 : 35c0             	puls	u,pc
                        *         if((dir->name[0] != DELETED) && (dir->attrib
be1b :                  _155
be1b : ae5e             	ldx	-2,u
be1d : e684             	ldb	0,x
be1f : 4f               	clra
be20 : 8300e5           	subd	#$e5
be23 : 102700bd         	lbeq	_156
be27 : ae5e             	ldx	-2,u
AS09 Assembler for M6809 [1.42].                                     Page  195
--------------------------------- merge.a09 ----------------------------------

be29 : e60b             	ldb	11,x
be2b : 4f               	clra
be2c : 83000f           	subd	#$f
be2f : 102700b1         	lbeq	_156
                        *         {
                        *             for(j=0; j<11; j++)
be33 : 4f               	clra
be34 : 5f               	clrb
be35 : e75d             	stb	-3,u
be37 :                  _158
be37 : e65d             	ldb	-3,u
be39 : 4f               	clra
be3a : 83000b           	subd	#$b
be3d : 10240052         	lbhs	_157
                        *             {
                        *                 if(dir->name[j] == '\n') fileList->F
be41 : e65d             	ldb	-3,u
be43 : 4f               	clra
be44 : ae5e             	ldx	-2,u
be46 : e68b             	ldb	d,x
be48 : 4f               	clra
be49 : 83000a           	subd	#$a
be4c : 1026001a         	lbne	_160
be50 : 305c             	leax	-4,u
be52 : e684             	ldb	,x
be54 : 6c84             	inc	,x
be56 : 1d               	sex
be57 : 3406             	pshs	d
be59 : ec44             	ldd	4,u
be5b : c30005           	addd	#$5
be5e : e3e1             	addd	,s++
be60 : 1f01             	tfr	d,x
be62 : cc000d           	ldd	#$d
be65 : e784             	stb	0,x
                        * 				else {
be67 : 202112           	lbra	_161
be6a :                  _160
                        * 					fileList->FI_Name[fNameIndex++] = dir->name[j];
be6a : e65d             	ldb	-3,u
be6c : 1d               	sex
be6d : ae5e             	ldx	-2,u
be6f : e68b             	ldb	d,x
be71 : 1d               	sex
be72 : 3406             	pshs	d
be74 : 305c             	leax	-4,u
be76 : e684             	ldb	,x
be78 : 6c84             	inc	,x
be7a : 1d               	sex
be7b : 3406             	pshs	d
be7d : ec44             	ldd	4,u
be7f : c30005           	addd	#$5
be82 : e3e1             	addd	,s++
be84 : 1f01             	tfr	d,x
be86 : 3506             	puls	d
be88 : e784             	stb	0,x
                        * 				}
                        *             }		
be8a :                  _161
                        *             fileList->FI_Name[fNameIndex] = 0;
be8a :                  _159
be8a : 305d             	leax	-3,u
be8c : e684             	ldb	,x
AS09 Assembler for M6809 [1.42].                                     Page  196
--------------------------------- merge.a09 ----------------------------------

be8e : 6c84             	inc	,x
be90 : 1d               	sex
be91 : 20a4             	lbra	_158
be93 :                  _157
be93 : e65c             	ldb	-4,u
be95 : 1d               	sex
be96 : 3406             	pshs	d
be98 : ec44             	ldd	4,u
be9a : c30005           	addd	#$5
be9d : e3e1             	addd	,s++
be9f : 1f01             	tfr	d,x
bea1 : 4f               	clra
bea2 : 5f               	clrb
bea3 : e784             	stb	0,x
                        * 			
                        * 			fileList->FI_Attr = dir->attrib;
bea5 : ae5e             	ldx	-2,u
bea7 : e60b             	ldb	11,x
bea9 : 4f               	clra
beaa : ae44             	ldx	4,u
beac : e704             	stb	4,x
                        * 			get_QByte(dir->fSize, &fileList->FI_Size);
beae : ec44             	ldd	4,u
beb0 : 3406             	pshs	d
beb2 : ec5e             	ldd	-2,u
beb4 : c3001c           	addd	#$1c
beb7 : 3406             	pshs	d
beb9 : bde2c6           	lbsr	get_QByt
bebc : 3264             	leas	4,s
                        * 			setTimeF(get_Word(dir->writeTime));			
bebe : ec5e             	ldd	-2,u
bec0 : c30016           	addd	#$16
bec3 : 3406             	pshs	d
bec5 : bde2b8           	lbsr	get_Word
bec8 : 3262             	leas	2,s
beca : 3406             	pshs	d
becc : bde2e9           	lbsr	setTimeF
becf : 3262             	leas	2,s
                        * 			setDateF(get_Word(dir->writeDate));
bed1 : ec5e             	ldd	-2,u
bed3 : c30018           	addd	#$18
bed6 : 3406             	pshs	d
bed8 : bde2b8           	lbsr	get_Word
bedb : 3262             	leas	2,s
bedd : 3406             	pshs	d
bedf : bde2e3           	lbsr	setDateF
bee2 : 3262             	leas	2,s
                        *         }
                        * 
                        *         list_i = list_i+32;
bee4 :                  _156
bee4 : eca9fda0         	ldd	list_i+0,y
bee8 : c30020           	addd	#$20
beeb : eda9fda0         	std	list_i+0,y
                        * 
                        *         if(list_i >= bPerSector)
beef : eca9fda0         	ldd	list_i+0,y
bef3 : a331             	subd	bPerSect+0,y
bef5 : 102500ea         	lblo	_162
                        *         {
                        *             list_i = 0;
bef9 : 4f               	clra
AS09 Assembler for M6809 [1.42].                                     Page  197
--------------------------------- merge.a09 ----------------------------------

befa : 5f               	clrb
befb : eda9fda0         	std	list_i+0,y
                        *             _u32_inc(&sectorNumber);
beff : 30a9fda6         	leax	sectorNu+0,y
bf03 : 3410             	pshs	x
bf05 : bdaa2e           	lbsr	_u32_inc
bf08 : 3262             	leas	2,s
                        * 
                        *             tmp.h = 0x00; tmp.l = secPerCluster;
bf0a : 4f               	clra
bf0b : 5f               	clrb
bf0c : ed58             	std	-8,u
bf0e : eca8ef           	ldd	secPerCl+0,y
bf11 : ed5a             	std	-6,u
                        *             if(_u32_equal(&sectorNumber, &tmp) != 0)
bf13 : 3058             	leax	-8,u
bf15 : 3410             	pshs	x
bf17 : 30a9fda6         	leax	sectorNu+0,y
bf1b : 3410             	pshs	x
bf1d : bdaa95           	lbsr	_u32_equ
bf20 : 3264             	leas	4,s
bf22 : 830000           	subd	#$0
bf25 : 10270096         	lbeq	_163
                        *             {
                        *                 sectorNumber.h = sectorNumber.l = 0;
bf29 : 4f               	clra
bf2a : 5f               	clrb
bf2b : eda9fda8         	std	sectorNu+2,y
bf2f : eda9fda6         	std	sectorNu+0,y
                        *                 tmp.h = tmp.l = 0;
bf33 : 4f               	clra
bf34 : 5f               	clrb
bf35 : ed5a             	std	-6,u
bf37 : ed58             	std	-8,u
                        *                 getSetNC (fatMapTb.LE_fileBuffer, &c
bf39 : 30a9fdaa         	leax	clusterN+0,y
bf3d : 3410             	pshs	x
bf3f : 3058             	leax	-8,u
bf41 : 3410             	pshs	x
bf43 : 4f               	clra
bf44 : 5f               	clrb
bf45 : 3406             	pshs	d
bf47 : 30a9fdaa         	leax	clusterN+0,y
bf4b : 3410             	pshs	x
bf4d : 30a9fdd4         	leax	fatMapTb+38,y
bf51 : 3410             	pshs	x
bf53 : bde33b           	lbsr	getSetNC
bf56 : 326a             	leas	10,s
                        * 
                        *                 tmp.h = 0x0fff; tmp.l = 0xfff6;     
bf58 : cc0fff           	ldd	#$fff
bf5b : ed58             	std	-8,u
bf5d : ccfff6           	ldd	#$fff6
bf60 : ed5a             	std	-6,u
                        * 				if(_u32_higher(&clusterNumber, &tmp) != 0)
bf62 : 3058             	leax	-8,u
bf64 : 3410             	pshs	x
bf66 : 30a9fdaa         	leax	clusterN+0,y
bf6a : 3410             	pshs	x
bf6c : bdaac0           	lbsr	_u32_hig
bf6f : 3264             	leas	4,s
bf71 : 830000           	subd	#$0
AS09 Assembler for M6809 [1.42].                                     Page  198
--------------------------------- merge.a09 ----------------------------------

bf74 : 1027000c         	lbeq	_164
                        *                 {
                        *                     FL_initialized = 0;
bf78 : 4f               	clra
bf79 : 5f               	clrb
bf7a : e7a8e7           	stb	FL_initi+0,y
                        *                     return END_OF_FILE_LIST;
bf7d : cc0009           	ldd	#$9
                        *                 }
bf80 : 32c4             	leas	,u
bf82 : 35c0             	puls	u,pc
                        * 
                        *                 tmp.h = 0x00; tmp.l = 0x00;
bf84 :                  _164
bf84 : 4f               	clra
bf85 : 5f               	clrb
bf86 : ed58             	std	-8,u
bf88 : 4f               	clra
bf89 : 5f               	clrb
bf8a : ed5a             	std	-6,u
                        *                 if(_u32_equal(&clusterNumber, &tmp) 
bf8c : 3058             	leax	-8,u
bf8e : 3410             	pshs	x
bf90 : 30a9fdaa         	leax	clusterN+0,y
bf94 : 3410             	pshs	x
bf96 : bdaa95           	lbsr	_u32_equ
bf99 : 3264             	leas	4,s
bf9b : 830000           	subd	#$0
bf9e : 1027000c         	lbeq	_165
                        *                 {
                        *                     FL_initialized = 0;
bfa2 : 4f               	clra
bfa3 : 5f               	clrb
bfa4 : e7a8e7           	stb	FL_initi+0,y
                        *                     return END_OF_FILE_LIST;
bfa7 : cc0009           	ldd	#$9
                        *                 }
bfaa : 32c4             	leas	,u
bfac : 35c0             	puls	u,pc
                        * 
                        *                 getFirstSector(&clusterNumber, &frst
bfae :                  _165
bfae : 30a9fda2         	leax	frstSect+0,y
bfb2 : 3410             	pshs	x
bfb4 : 30a9fdaa         	leax	clusterN+0,y
bfb8 : 3410             	pshs	x
bfba : bde2f4           	lbsr	getFirst
bfbd : 3264             	leas	4,s
                        *             }
                        * 	        _u32_add(&frstSectorIndex, &sectorNumber, &
bfbf :                  _163
bfbf : 3058             	leax	-8,u
bfc1 : 3410             	pshs	x
bfc3 : 30a9fda6         	leax	sectorNu+0,y
bfc7 : 3410             	pshs	x
bfc9 : 30a9fda2         	leax	frstSect+0,y
bfcd : 3410             	pshs	x
bfcf : bda9df           	lbsr	_u32_add
bfd2 : 3266             	leas	6,s
                        *             SD_readSingleBlock(fatMapTb.LE_fileBuffe
bfd4 : 3058             	leax	-8,u
bfd6 : 3410             	pshs	x
AS09 Assembler for M6809 [1.42].                                     Page  199
--------------------------------- merge.a09 ----------------------------------

bfd8 : 30a9fdd4         	leax	fatMapTb+38,y
bfdc : 3410             	pshs	x
bfde : bdaf12           	lbsr	SD_readS
bfe1 : 3264             	leas	4,s
                        *         }
                        *     }while(fNameIndex == 0);
bfe3 :                  _162
bfe3 :                  _153
bfe3 : e65c             	ldb	-4,u
bfe5 : 4f               	clra
bfe6 : 830000           	subd	#$0
bfe9 : 1027fe0a         	lbeq	_154
                        * 
                        *     return MORE_FILES_To_READ;
bfed :                  _152
bfed : cc0008           	ldd	#$8
                        * }
bff0 : 32c4             	leas	,u
bff2 : 35c0             	puls	u,pc
                        * 
                        * // split the ROMs
                        * #asm
bff4 : 7ee000               jmp $e000
e000 =                  	org $e000    
                        * 
                        * //unsigned char getBootSectorData (void)
                        * getBootSectorData()
                        * {
                        * 	LE_BS_Structure *bpb; //mapping the buffer onto the
                        * 	LE_MBRinfo_Structure *mbr;
                        *     u32_t FATsize_t;
                        * 	u32_t dataSectors;
                        * 	u32_t tmp1, tmp2;
                        * 	unsigned char i, n;
                        * 	unsigned int tmp16;
                        * 
                        * 	FL_initialized = 0;	
e000 :                  getBootS
e000 : 3440             	pshs	u
e002 : 33e4             	leau	,s
e004 : 32e8e8           	leas	-24,s
e007 : 4f               	clra
e008 : 5f               	clrb
e009 : e7a8e7           	stb	FL_initi+0,y
                        * 	unusedSectors.h = unusedSectors.l = 0;   //init at 
e00c : 4f               	clra
e00d : 5f               	clrb
e00e : eda8eb           	std	unusedSe+2,y
e011 : eda8e9           	std	unusedSe+0,y
                        *     fatMapTb.fileOpenedFlag = FALSE;
e014 : 4f               	clra
e015 : 5f               	clrb
e016 : e7a8d5           	stb	fatMapTb+551,y
                        * 	
                        *     if(SD_readSingleBlock(fatMapTb.LE_fileBuffer, &u
e019 : 30a8e9           	leax	unusedSe+0,y
e01c : 3410             	pshs	x
e01e : 30a9fdd4         	leax	fatMapTb+38,y
e022 : 3410             	pshs	x
e024 : bdaf12           	lbsr	SD_readS
e027 : 3264             	leas	4,s
e029 : 830000           	subd	#$0
AS09 Assembler for M6809 [1.42].                                     Page  200
--------------------------------- merge.a09 ----------------------------------

e02c : 10270007         	lbeq	_166
e030 : cc0003           	ldd	#$3
                        * 	
                        * 	bpb = fatMapTb.LE_fileBuffer;   //cast removed
e033 : 32c4             	leas	,u
e035 : 35c0             	puls	u,pc
e037 :                  _166
e037 : 30a9fdd4         	leax	fatMapTb+38,y
e03b : 1f10             	tfr	x,d
e03d : ed5e             	std	-2,u
                        * 	
                        *     if((bpb->jumpBoot[0]!=0xE9) && (bpb->jumpBoot[0]
e03f : ae5e             	ldx	-2,u
e041 : e684             	ldb	0,x
e043 : 4f               	clra
e044 : 8300e9           	subd	#$e9
e047 : 10270082         	lbeq	_167
e04b : ae5e             	ldx	-2,u
e04d : e684             	ldb	0,x
e04f : 4f               	clra
e050 : 8300eb           	subd	#$eb
e053 : 10270076         	lbeq	_167
                        *     {
                        *         mbr = fatMapTb.LE_fileBuffer;       //if it 
e057 : 30a9fdd4         	leax	fatMapTb+38,y
e05b : 1f10             	tfr	x,d
e05d : ed5c             	std	-4,u
                        * 		
                        * 		if(get_Word(mbr->signature) != 0xaa55)
e05f : ec5c             	ldd	-4,u
e061 : c301fe           	addd	#$1fe
e064 : 3406             	pshs	d
e066 : bde2b8           	lbsr	get_Word
e069 : 3262             	leas	2,s
e06b : 83aa55           	subd	#$aa55
e06e : 10270007         	lbeq	_168
                        *         {
                        *             return FAT_INVALID;       //if it is not
e072 : cc0003           	ldd	#$3
                        *         }
e075 : 32c4             	leas	,u
e077 : 35c0             	puls	u,pc
                        *         
                        *         //partition = (struct partitionInfo_Structur
                        *         get_QByte(fatMapTb.LE_fileBuffer+454, &unuse
e079 :                  _168
e079 : 30a8e9           	leax	unusedSe+0,y
e07c : 3410             	pshs	x
e07e : 30a89a           	leax	fatMapTb+492,y
e081 : 3410             	pshs	x
e083 : bde2c6           	lbsr	get_QByt
e086 : 3264             	leas	4,s
                        * 		
                        *         if(SD_readSingleBlock(fatMapTb.LE_fileBuffer
e088 : 30a8e9           	leax	unusedSe+0,y
e08b : 3410             	pshs	x
e08d : 30a9fdd4         	leax	fatMapTb+38,y
e091 : 3410             	pshs	x
e093 : bdaf12           	lbsr	SD_readS
e096 : 3264             	leas	4,s
e098 : 830000           	subd	#$0
e09b : 10270007         	lbeq	_169
AS09 Assembler for M6809 [1.42].                                     Page  201
--------------------------------- merge.a09 ----------------------------------

e09f : cc0002           	ldd	#$2
                        *         bpb = fatMapTb.LE_fileBuffer;  //cast remove
e0a2 : 32c4             	leas	,u
e0a4 : 35c0             	puls	u,pc
e0a6 :                  _169
e0a6 : 30a9fdd4         	leax	fatMapTb+38,y
e0aa : 1f10             	tfr	x,d
e0ac : ed5e             	std	-2,u
                        *         if((bpb->jumpBoot[0]!=0xE9) && (bpb->jumpBoo
e0ae : ae5e             	ldx	-2,u
e0b0 : e684             	ldb	0,x
e0b2 : 4f               	clra
e0b3 : 8300e9           	subd	#$e9
e0b6 : 10270013         	lbeq	_170
e0ba : ae5e             	ldx	-2,u
e0bc : e684             	ldb	0,x
e0be : 4f               	clra
e0bf : 8300eb           	subd	#$eb
e0c2 : 10270007         	lbeq	_170
                        *         {
                        *             return FAT_INVALID;
e0c6 : cc0003           	ldd	#$3
                        *         }
e0c9 : 32c4             	leas	,u
e0cb : 35c0             	puls	u,pc
                        *     }
e0cd :                  _170
                        * 
                        *     bPerSector = get_Word(bpb->bytesPerSector);
e0cd :                  _167
e0cd : ec5e             	ldd	-2,u
e0cf : c3000b           	addd	#$b
e0d2 : 3406             	pshs	d
e0d4 : bde2b8           	lbsr	get_Word
e0d7 : 3262             	leas	2,s
e0d9 : ed31             	std	bPerSect+0,y
                        * 	i=0;
e0db : 4f               	clra
e0dc : 5f               	clrb
e0dd : e7c8eb           	stb	-21,u
                        * 	tmp16 = bPerSector;
e0e0 : ec31             	ldd	bPerSect+0,y
e0e2 : edc8e8           	std	-24,u
                        * 	for (n=0; n<16; n++) {
e0e5 : 4f               	clra
e0e6 : 5f               	clrb
e0e7 : e7c8ea           	stb	-22,u
e0ea :                  _172
e0ea : e6c8ea           	ldb	-22,u
e0ed : 4f               	clra
e0ee : 830010           	subd	#$10
e0f1 : 10240030         	lbhs	_171
                        * 		if (tmp16 & 1) i++;
e0f5 : ecc8e8           	ldd	-24,u
e0f8 : 8400             	anda	#$0
e0fa : c401             	andb	#$1
e0fc : 830000           	subd	#$0
e0ff : 10270008         	lbeq	_174
e103 : 30c8eb           	leax	-21,u
e106 : e684             	ldb	,x
e108 : 6c84             	inc	,x
e10a : 4f               	clra
AS09 Assembler for M6809 [1.42].                                     Page  202
--------------------------------- merge.a09 ----------------------------------

                        * 		tmp16 = tmp16 >> 1;
e10b :                  _174
e10b : cc0001           	ldd	#$1
e10e : 3406             	pshs	d
e110 : ecc8e8           	ldd	-24,u
e113 : 3510             	puls	x
e115 : bdee27           	lbsr	_00009
e118 : edc8e8           	std	-24,u
                        * 	}
                        * 	if (i != 1) return SIZE_INVALID; //allow just 2^n b
e11b :                  _173
e11b : 30c8ea           	leax	-22,u
e11e : e684             	ldb	,x
e120 : 6c84             	inc	,x
e122 : 4f               	clra
e123 : 20c5             	lbra	_172
e125 :                  _171
e125 : e6c8eb           	ldb	-21,u
e128 : 4f               	clra
e129 : 830001           	subd	#$1
e12c : 10270007         	lbeq	_175
e130 : cc0004           	ldd	#$4
                        * 	
                        *     secPerCluster = bpb->secPrCluster;
e133 : 32c4             	leas	,u
e135 : 35c0             	puls	u,pc
e137 :                  _175
e137 : ae5e             	ldx	-2,u
e139 : e60d             	ldb	13,x
e13b : 4f               	clra
e13c : eda8ef           	std	secPerCl+0,y
                        * 	i=0;
e13f : 4f               	clra
e140 : 5f               	clrb
e141 : e7c8eb           	stb	-21,u
                        * 	tmp16 = secPerCluster;
e144 : eca8ef           	ldd	secPerCl+0,y
e147 : edc8e8           	std	-24,u
                        * 
                        * 	for (n=0; n<16; n++) {
e14a : 4f               	clra
e14b : 5f               	clrb
e14c : e7c8ea           	stb	-22,u
e14f :                  _177
e14f : e6c8ea           	ldb	-22,u
e152 : 4f               	clra
e153 : 830010           	subd	#$10
e156 : 10240030         	lbhs	_176
                        * 		if (tmp16 & 1) i++;
e15a : ecc8e8           	ldd	-24,u
e15d : 8400             	anda	#$0
e15f : c401             	andb	#$1
e161 : 830000           	subd	#$0
e164 : 10270008         	lbeq	_179
e168 : 30c8eb           	leax	-21,u
e16b : e684             	ldb	,x
e16d : 6c84             	inc	,x
e16f : 4f               	clra
                        * 		tmp16 = tmp16 >> 1;
e170 :                  _179
e170 : cc0001           	ldd	#$1
e173 : 3406             	pshs	d
AS09 Assembler for M6809 [1.42].                                     Page  203
--------------------------------- merge.a09 ----------------------------------

e175 : ecc8e8           	ldd	-24,u
e178 : 3510             	puls	x
e17a : bdee27           	lbsr	_00009
e17d : edc8e8           	std	-24,u
                        * 	}
                        * 	if (i != 1) return SIZE_INVALID; //allow just 2^n b
e180 :                  _178
e180 : 30c8ea           	leax	-22,u
e183 : e684             	ldb	,x
e185 : 6c84             	inc	,x
e187 : 4f               	clra
e188 : 20c5             	lbra	_177
e18a :                  _176
e18a : e6c8eb           	ldb	-21,u
e18d : 4f               	clra
e18e : 830001           	subd	#$1
e191 : 10270007         	lbeq	_180
e195 : cc0004           	ldd	#$4
                        * 
                        *     rsvSecCnt = get_Word(bpb->rsvSectorCount);
e198 : 32c4             	leas	,u
e19a : 35c0             	puls	u,pc
e19c :                  _180
e19c : ec5e             	ldd	-2,u
e19e : c3000e           	addd	#$e
e1a1 : 3406             	pshs	d
e1a3 : bde2b8           	lbsr	get_Word
e1a6 : 3262             	leas	2,s
e1a8 : eda8ed           	std	rsvSecCn+0,y
                        *     get_QByte(bpb->rootCluster, &rCluster);
e1ab : 3037             	leax	rCluster+0,y
e1ad : 3410             	pshs	x
e1af : ec5e             	ldd	-2,u
e1b1 : c3002c           	addd	#$2c
e1b4 : 3406             	pshs	d
e1b6 : bde2c6           	lbsr	get_QByt
e1b9 : 3264             	leas	4,s
                        *     
                        * 	//firstDataSector = bpb->hiddenSectors + reservedSe
                        * 	get_QByte(bpb->FATsz_F32, &tmp1);
e1bb : 3050             	leax	-16,u
e1bd : 3410             	pshs	x
e1bf : ec5e             	ldd	-2,u
e1c1 : c30024           	addd	#$24
e1c4 : 3406             	pshs	d
e1c6 : bde2c6           	lbsr	get_QByt
e1c9 : 3264             	leas	4,s
                        * 	_u32_mul(bpb->nbofFATs, &tmp1, &FATsize_t);
e1cb : 3058             	leax	-8,u
e1cd : 3410             	pshs	x
e1cf : 3050             	leax	-16,u
e1d1 : 3410             	pshs	x
e1d3 : ae5e             	ldx	-2,u
e1d5 : e68810           	ldb	16,x
e1d8 : 1d               	sex
e1d9 : 3406             	pshs	d
e1db : bda891           	lbsr	_u32_mul
e1de : 3266             	leas	6,s
                        * 	get_QByte(bpb->hiddenSectors, &fDataSector);    
e1e0 : 303b             	leax	fDataSec+0,y
e1e2 : 3410             	pshs	x
e1e4 : ec5e             	ldd	-2,u
AS09 Assembler for M6809 [1.42].                                     Page  204
--------------------------------- merge.a09 ----------------------------------

e1e6 : c3001c           	addd	#$1c
e1e9 : 3406             	pshs	d
e1eb : bde2c6           	lbsr	get_QByt
e1ee : 3264             	leas	4,s
                        * 	tmp1.h = 0; tmp1.l = rsvSecCnt; 
e1f0 : 4f               	clra
e1f1 : 5f               	clrb
e1f2 : ed50             	std	-16,u
e1f4 : eca8ed           	ldd	rsvSecCn+0,y
e1f7 : ed52             	std	-14,u
                        * 	_u32_add(&fDataSector, &tmp1, &tmp2);
e1f9 : 30c8ec           	leax	-20,u
e1fc : 3410             	pshs	x
e1fe : 3050             	leax	-16,u
e200 : 3410             	pshs	x
e202 : 303b             	leax	fDataSec+0,y
e204 : 3410             	pshs	x
e206 : bda9df           	lbsr	_u32_add
e209 : 3266             	leas	6,s
                        * 	_u32_add(&tmp2, &FATsize_t, &fDataSector);
e20b : 303b             	leax	fDataSec+0,y
e20d : 3410             	pshs	x
e20f : 3058             	leax	-8,u
e211 : 3410             	pshs	x
e213 : 30c8ec           	leax	-20,u
e216 : 3410             	pshs	x
e218 : bda9df           	lbsr	_u32_add
e21b : 3266             	leas	6,s
                        *     	
                        *     //dataSectors = bpb->totalSectors_F32 - reserved
                        *     get_QByte(bpb->tSec_F32, &dataSectors);
e21d : 3054             	leax	-12,u
e21f : 3410             	pshs	x
e221 : ec5e             	ldd	-2,u
e223 : c30020           	addd	#$20
e226 : 3406             	pshs	d
e228 : bde2c6           	lbsr	get_QByt
e22b : 3264             	leas	4,s
                        * 	tmp1.h = 0; tmp1.l = rsvSecCnt;
e22d : 4f               	clra
e22e : 5f               	clrb
e22f : ed50             	std	-16,u
e231 : eca8ed           	ldd	rsvSecCn+0,y
e234 : ed52             	std	-14,u
                        * 	_u32_sub(&dataSectors, &tmp1, &tmp2);
e236 : 30c8ec           	leax	-20,u
e239 : 3410             	pshs	x
e23b : 3050             	leax	-16,u
e23d : 3410             	pshs	x
e23f : 3054             	leax	-12,u
e241 : 3410             	pshs	x
e243 : bda975           	lbsr	_u32_sub
e246 : 3266             	leas	6,s
                        * 	_u32_sub(&tmp2, &FATsize_t, &dataSectors);
e248 : 3054             	leax	-12,u
e24a : 3410             	pshs	x
e24c : 3058             	leax	-8,u
e24e : 3410             	pshs	x
e250 : 30c8ec           	leax	-20,u
e253 : 3410             	pshs	x
e255 : bda975           	lbsr	_u32_sub
e258 : 3266             	leas	6,s
AS09 Assembler for M6809 [1.42].                                     Page  205
--------------------------------- merge.a09 ----------------------------------

                        *    
                        * 	//totalClusters = dataSectors / sectorPerCluster;
                        * 	_u32_div2(&dataSectors, secPerCluster, &totalCluste
e25a : 3033             	leax	totalClu+0,y
e25c : 3410             	pshs	x
e25e : eca8ef           	ldd	secPerCl+0,y
e261 : 3406             	pshs	d
e263 : 3054             	leax	-12,u
e265 : 3410             	pshs	x
e267 : bda825           	lbsr	_u32_div
e26a : 3266             	leas	6,s
                        *    	
                        * 	//if((getSetFreeCluster (GlobalBuffer,TOTAL_FREE, G
                        * 	tmp1.h = tmp1.l = 0;
e26c : 4f               	clra
e26d : 5f               	clrb
e26e : ed52             	std	-14,u
e270 : ed50             	std	-16,u
                        * 	getSetFreeCluster(fatMapTb.LE_fileBuffer,TOTAL_FREE
e272 : 30c8ec           	leax	-20,u
e275 : 3410             	pshs	x
e277 : 3050             	leax	-16,u
e279 : 3410             	pshs	x
e27b : 4f               	clra
e27c : 5f               	clrb
e27d : 3406             	pshs	d
e27f : cc0001           	ldd	#$1
e282 : 3406             	pshs	d
e284 : 30a9fdd4         	leax	fatMapTb+38,y
e288 : 3410             	pshs	x
e28a : bde442           	lbsr	getSetFr
e28d : 326a             	leas	10,s
                        * 	if(_u32_higher(&tmp2, &totalClusters) != 0)
e28f : 3033             	leax	totalClu+0,y
e291 : 3410             	pshs	x
e293 : 30c8ec           	leax	-20,u
e296 : 3410             	pshs	x
e298 : bdaac0           	lbsr	_u32_hig
e29b : 3264             	leas	4,s
e29d : 830000           	subd	#$0
e2a0 : 10270008         	lbeq	_181
                        *         fClstCnU = 0;
e2a4 : 4f               	clra
e2a5 : 5f               	clrb
e2a6 : e7a8e8           	stb	fClstCnU+0,y
                        *     else
e2a9 : 200712           	lbra	_182
e2ac :                  _181
                        *         fClstCnU = 1;
e2ac : cc0001           	ldd	#$1
e2af : e7a8e8           	stb	fClstCnU+0,y
                        * 
                        *     return INIT_SUCCESSFUL;
e2b2 :                  _182
e2b2 : 4f               	clra
e2b3 : 5f               	clrb
                        * }
e2b4 : 32c4             	leas	,u
e2b6 : 35c0             	puls	u,pc
                        * 
                        * /***************************************************
                        *                                      Local Functions
AS09 Assembler for M6809 [1.42].                                     Page  206
--------------------------------- merge.a09 ----------------------------------

                        * ****************************************************
                        * //unsigned int get_Word(unsigned char *ptr)
                        * //get_Word(ptr) unsigned char *ptr;
                        * //{
                        * 	// Conversion from the FAT allocated in Little-endi
                        * #asm
e2b8 :                  get_Word
                        *	unsigned int retval;
                        *	retval = *ptr++; //cast removed
                        * 	retval += (*ptr) << 8; //cast removed
                        *	return retval;
e2b8 : ecf802           	ldd	[2,s]
e2bb : 1e89             	exg	a,b
e2bd : 39               	rts
                        * //}
                        * 
                        * //void set_Word(unsigned int data, unsigned char *pt
                        * //set_Word(data, ptr) unsigned int data; unsigned ch
                        * //{
                        * 	// Conversion to the FAT allocated in Little-endian
                        * #asm
e2be :                  set_Word
                        * 	*ptr++ = data & 0xff;
                        * 	*ptr = data >> 8;
e2be : ec62             	ldd	2,s	
e2c0 : 1e89             	exg	a,b
e2c2 : edf804           	std	[4,s]
e2c5 : 39               	rts
                        * //}
                        * 
                        * //void get_QByte(unsigned char *ptr, u32_t *sData)
                        * //get_QByte(ptr, sData) unsigned char *ptr; u32_t *s
                        * //{
                        * 	// Conversion from the FAT allocated in Little-endi
                        * //	sData->l = get_Word(ptr);
                        * //	ptr += 2; 
                        * //	sData->h = get_Word(ptr);
                        * #asm
e2c6 :                  get_QByt	
e2c6 : 3420             	pshs y
e2c8 : 10ae64           	ldy	4,s	;src
e2cb : ae66             	ldx	6,s ;dst
e2cd : eca4             	ldd 0,y
e2cf : a703             	sta	3,x
e2d1 : e702             	stb	2,x
e2d3 : ec22             	ldd 2,y
e2d5 : a701             	sta	1,x
e2d7 : e784             	stb	0,x
e2d9 : 35a0             	puls y,pc
                        * //}
                        * 
                        * //void set_QByte(u32_t *sData, unsigned char *ptr)
                        * /*set_QByte(sData, ptr) u32_t *sData; unsigned char 
                        * {
                        * 	// Conversion to the FAT allocated in Little-endian
                        * 	set_Word(sData->l, ptr);
                        * 	ptr += 2;
                        * 	set_Word(sData->h, ptr);
                        * }*/
                        * #asm
e2c6 =                  set_QByt 	equ 	get_QByt	; same bytes swapping
                        * 
AS09 Assembler for M6809 [1.42].                                     Page  207
--------------------------------- merge.a09 ----------------------------------

                        * // unsigned int getDateF32()
                        * //{	
                        * #asm
e2db :                  getDateF
                        *	return APLdate;
e2db : fc7fe0           	ldd  APLdate	
e2de : 39               	rts
                        * //}
                        * 
                        * // unsigned int getTimeF32()
                        * //{	
                        * #asm
e2df :                  getTimeF
                        *	return APLdate;
e2df : fc7fe2           	ldd  APLtime	
e2e2 : 39               	rts
                        * //}
                        * 
                        * // setDateF32(unsigned int d)
                        * //{	
                        * #asm
e2e3 :                  setDateF
                        *	APLdate = d;
e2e3 : ec62             	ldd	 2,s
e2e5 : fd7fe0           	std  APLdate	
e2e8 : 39               	rts
                        * //}
                        * 
                        * // setTimeF32(unsigned int t)
                        * //{	
                        * #asm
e2e9 :                  setTimeF
                        *	APLtime = t;
e2e9 : ec62             	ldd	 2,s
e2eb : fd7fe2           	std  APLtime	
e2ee : 39               	rts
                        * //}
                        * 
                        * /***************************************************
                        * #asm
e2ef :                  _setGVpt
e2ef : 108e7fb9         	ldy  #GV_StackBeginAddr	; set C global variables stac
e2f3 : 39               	rts
                        * 
                        * 
                        * //**************************************************
                        * //Function: to calculate first sector address of any
                        * //Arguments: cluster number for which first sector i
                        * //return: first sector address
                        * //**************************************************
                        * //void getFirstSector(u32_t *clusterNumber, u32_t *r
                        * getFirstSector(clusterNumber, rValue) u32_t *cluster
                        * {
                        *     u32_t tmp1, tmp2;
                        * 		
                        * 	//*rValue = ((clusterNumber - 2) * secPerCluster) +
                        * 	tmp1.h = 0; tmp1.l = 2;
e2f4 :                  getFirst
e2f4 : 3440             	pshs	u
e2f6 : 33e4             	leau	,s
e2f8 : 3278             	leas	-8,s
e2fa : 4f               	clra
AS09 Assembler for M6809 [1.42].                                     Page  208
--------------------------------- merge.a09 ----------------------------------

e2fb : 5f               	clrb
e2fc : ed5c             	std	-4,u
e2fe : cc0002           	ldd	#$2
e301 : ed5e             	std	-2,u
                        * 	_u32_sub(clusterNumber, &tmp1, &tmp2);
e303 : 3058             	leax	-8,u
e305 : 3410             	pshs	x
e307 : 305c             	leax	-4,u
e309 : 3410             	pshs	x
e30b : ec44             	ldd	4,u
e30d : 3406             	pshs	d
e30f : bda975           	lbsr	_u32_sub
e312 : 3266             	leas	6,s
                        * 	_u32_mul(secPerCluster, &tmp2, &tmp1);
e314 : 305c             	leax	-4,u
e316 : 3410             	pshs	x
e318 : 3058             	leax	-8,u
e31a : 3410             	pshs	x
e31c : eca8ef           	ldd	secPerCl+0,y
e31f : 3406             	pshs	d
e321 : bda891           	lbsr	_u32_mul
e324 : 3266             	leas	6,s
                        * 	_u32_add(&tmp1, &fDataSector, rValue);	
e326 : ec46             	ldd	6,u
e328 : 3406             	pshs	d
e32a : 303b             	leax	fDataSec+0,y
e32c : 3410             	pshs	x
e32e : 305c             	leax	-4,u
e330 : 3410             	pshs	x
e332 : bda9df           	lbsr	_u32_add
e335 : 3266             	leas	6,s
                        * }
e337 : 32c4             	leas	,u
e339 : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function: get cluster entry value from FAT to find
                        * //or set new cluster entry in FAT
                        * //Arguments: 1. current cluster number, 2. get_set (
                        * //if next cluster is to be set 3. next cluster numbe
                        * //return: next cluster number, if if argument#2 = GE
                        * //**************************************************
                        * //uint32_t getSetNextCluster(char *inputBuffer,uint3
                        * getSetNC(inputBuffer, clusterNumber, get_set, cluste
                        * {
                        *     unsigned int EntryOffset; // "FATEntryOffset"
                        *     //uint32_t *FATEntryValue;
                        *     u32_t EntrySector; // "FATEntrySector"
                        *     unsigned char retry;
                        * 	u32_t tmp1, tmp2;
                        * 	
                        *     //get sector number of the cluster entry in the 
                        *     //FATEntrySector = unusedSectors + reservedSecto
                        * 	_u32_mul(4, clusterNumber, &tmp1);	
e33b :                  getSetNC
e33b : 3440             	pshs	u
e33d : 33e4             	leau	,s
e33f : 3271             	leas	-15,s
e341 : 3055             	leax	-11,u
e343 : 3410             	pshs	x
e345 : ec46             	ldd	6,u
e347 : 3406             	pshs	d
AS09 Assembler for M6809 [1.42].                                     Page  209
--------------------------------- merge.a09 ----------------------------------

e349 : cc0004           	ldd	#$4
e34c : 3406             	pshs	d
e34e : bda891           	lbsr	_u32_mul
e351 : 3266             	leas	6,s
                        * 	_u32_div2(&tmp1, bPerSector, &tmp2);
e353 : 3051             	leax	-15,u
e355 : 3410             	pshs	x
e357 : ec31             	ldd	bPerSect+0,y
e359 : 3406             	pshs	d
e35b : 3055             	leax	-11,u
e35d : 3410             	pshs	x
e35f : bda825           	lbsr	_u32_div
e362 : 3266             	leas	6,s
                        * 	EntrySector.h = 0; EntrySector.l = rsvSecCnt;
e364 : 4f               	clra
e365 : 5f               	clrb
e366 : ed5a             	std	-6,u
e368 : eca8ed           	ldd	rsvSecCn+0,y
e36b : ed5c             	std	-4,u
                        * 	_u32_add(&tmp2, &EntrySector, &tmp1);
e36d : 3055             	leax	-11,u
e36f : 3410             	pshs	x
e371 : 305a             	leax	-6,u
e373 : 3410             	pshs	x
e375 : 3051             	leax	-15,u
e377 : 3410             	pshs	x
e379 : bda9df           	lbsr	_u32_add
e37c : 3266             	leas	6,s
                        * 	_u32_add(&tmp1, &unusedSectors, &EntrySector);
e37e : 305a             	leax	-6,u
e380 : 3410             	pshs	x
e382 : 30a8e9           	leax	unusedSe+0,y
e385 : 3410             	pshs	x
e387 : 3055             	leax	-11,u
e389 : 3410             	pshs	x
e38b : bda9df           	lbsr	_u32_add
e38e : 3266             	leas	6,s
                        * 	
                        *     //get the offset address in that sector number
                        * 	//FATEntryOffset = (uint16_t) ((clusterNumber * 4) 
                        *     EntryOffset = (clusterNumber->l * 4) & (bPerSect
e390 : ec31             	ldd	bPerSect+0,y
e392 : 830001           	subd	#$1
e395 : 3406             	pshs	d
e397 : ae46             	ldx	6,u
e399 : ec02             	ldd	2,x
e39b : 58               	aslb
e39c : 49               	rola
e39d : 58               	aslb
e39e : 49               	rola
e39f : a4e0             	anda	,s+
e3a1 : e4e0             	andb	,s+
e3a3 : ed5e             	std	-2,u
                        * 
                        *     //read the sector into a buffer
                        *     retry = 0;
e3a5 : 4f               	clra
e3a6 : 5f               	clrb
e3a7 : e759             	stb	-7,u
                        *     while(retry <10)
e3a9 :                  _184
                        *     {
AS09 Assembler for M6809 [1.42].                                     Page  210
--------------------------------- merge.a09 ----------------------------------

e3a9 : e659             	ldb	-7,u
e3ab : 4f               	clra
e3ac : 83000a           	subd	#$a
e3af : 1024002e         	lbhs	_183
                        *         if(!SD_readSingleBlock(inputBuffer, &EntrySe
e3b3 : 305a             	leax	-6,u
e3b5 : 3410             	pshs	x
e3b7 : ec44             	ldd	4,u
e3b9 : 3406             	pshs	d
e3bb : bdaf12           	lbsr	SD_readS
e3be : 3264             	leas	4,s
e3c0 : 830000           	subd	#$0
e3c3 : 10270004         	lbeq	_186
e3c7 : 4f               	clra
e3c8 : 5f               	clrb
e3c9 : 2003             	bra	*+5
e3cb :                  _186
e3cb : cc0001           	ldd	#$1
e3ce : 830000           	subd	#$0
e3d1 : 10270003         	lbeq	_185
                        *             break;
e3d5 : 200a12           	lbra	_183
                        *         retry++;
e3d8 :                  _185
e3d8 : 3059             	leax	-7,u
e3da : e684             	ldb	,x
e3dc : 6c84             	inc	,x
e3de : 4f               	clra
                        *     }
                        * 
                        *     //get the cluster address from the buffer
                        *     //FATEntryValue = (uint32_t *) &inputBuffer[FATE
                        *     
                        * 	if(get_set == GET) {		
e3df : 20c8             	lbra	_184
e3e1 :                  _183
e3e1 : e649             	ldb	9,u
e3e3 : 4f               	clra
e3e4 : 830000           	subd	#$0
e3e7 : 1026002e         	lbne	_187
                        * 		//return ((*FATEntryValue) & 0x0fffffff);
                        * 		get_QByte(&inputBuffer[EntryOffset], &tmp1);
e3eb : 3055             	leax	-11,u
e3ed : 3410             	pshs	x
e3ef : ec5e             	ldd	-2,u
e3f1 : e344             	addd	4,u
e3f3 : 3406             	pshs	d
e3f5 : bde2c6           	lbsr	get_QByt
e3f8 : 3264             	leas	4,s
                        * 		tmp2.h = 0x0fff; tmp2.l = 0xffff;
e3fa : cc0fff           	ldd	#$fff
e3fd : ed51             	std	-15,u
e3ff : ccffff           	ldd	#$ffff
e402 : ed53             	std	-13,u
                        * 		_u32_and(&tmp1, &tmp2, rValue);
e404 : ec4c             	ldd	12,u
e406 : 3406             	pshs	d
e408 : 3051             	leax	-15,u
e40a : 3410             	pshs	x
e40c : 3055             	leax	-11,u
e40e : 3410             	pshs	x
e410 : bda7fe           	lbsr	_u32_and
AS09 Assembler for M6809 [1.42].                                     Page  211
--------------------------------- merge.a09 ----------------------------------

e413 : 3266             	leas	6,s
                        * 		return;
                        * 	}
e415 : 32c4             	leas	,u
e417 : 35c0             	puls	u,pc
                        * 
                        *     //*FATEntryValue = clusterEntry;   //for setting
                        * 	set_QByte(clusterEntry, &inputBuffer[EntryOffset]);
e419 :                  _187
e419 : ec5e             	ldd	-2,u
e41b : e344             	addd	4,u
e41d : 3406             	pshs	d
e41f : ec4a             	ldd	10,u
e421 : 3406             	pshs	d
e423 : bde2c6           	lbsr	set_QByt
e426 : 3264             	leas	4,s
                        *     SD_writeSingleBlock(inputBuffer, &EntrySector); 
e428 : 305a             	leax	-6,u
e42a : 3410             	pshs	x
e42c : ec44             	ldd	4,u
e42e : 3406             	pshs	d
e430 : bdafa0           	lbsr	SD_write
e433 : 3264             	leas	4,s
                        * 
                        *     rValue->h = rValue->l = 0;	
e435 : 4f               	clra
e436 : 5f               	clrb
e437 : ae4c             	ldx	12,u
e439 : ed02             	std	2,x
e43b : edd80c           	std	[12,u]
                        * }
e43e : 32c4             	leas	,u
e440 : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function: to get or set next free cluster or total
                        * //Arguments: 1.flag:TOTAL_FREE or NEXT_FREE, 
                        * //			 2.flag: GET or SET 
                        * //			 3.new FS entry, when argument2 is SET; or 0, w
                        * //return: next free cluster, if arg1 is NEXT_FREE & 
                        * //        total number of free clusters, if arg1 is 
                        * //		  0xffffffff, if any error or if arg2 is SET
                        * //**************************************************
                        * //uint32_t getSetFreeCluster(char *inputBuffer, uint
                        * getSetFreeCluster(inputBuffer, totOrNext, get_set, F
                        * {
                        * 	LE_FSinfo_Structure *FS;
                        * 	u32_t _unusedSectors, tmp;
                        * 	
                        * 	FS = inputBuffer; //cast ok, but removed
e442 :                  getSetFr
e442 : 3440             	pshs	u
e444 : 33e4             	leau	,s
e446 : 3276             	leas	-10,s
e448 : ec44             	ldd	4,u
e44a : ed5e             	std	-2,u
                        *     
                        * 	//SD_readSingleBlock(inputBuffer,unusedSectors + 1)
                        * 	_unusedSectors.h = unusedSectors.h; _unusedSectors.
e44c : eca8e9           	ldd	unusedSe+0,y
e44f : ed5a             	std	-6,u
e451 : eca8eb           	ldd	unusedSe+2,y
AS09 Assembler for M6809 [1.42].                                     Page  212
--------------------------------- merge.a09 ----------------------------------

e454 : ed5c             	std	-4,u
                        * 	_u32_inc(&_unusedSectors);
e456 : 305a             	leax	-6,u
e458 : 3410             	pshs	x
e45a : bdaa2e           	lbsr	_u32_inc
e45d : 3262             	leas	2,s
                        * 	SD_readSingleBlock(inputBuffer, &_unusedSectors);  
e45f : 305a             	leax	-6,u
e461 : 3410             	pshs	x
e463 : ec44             	ldd	4,u
e465 : 3406             	pshs	d
e467 : bdaf12           	lbsr	SD_readS
e46a : 3264             	leas	4,s
                        * 
                        * 	//if((FS->leadSignature != 0x41615252) || (FS->stru
                        *     rValue->h = rValue->l = 0xffff; //return default
e46c : ccffff           	ldd	#$ffff
e46f : ae4c             	ldx	12,u
e471 : ed02             	std	2,x
e473 : edd80c           	std	[12,u]
                        * 	get_QByte(FS->leadSignature, &tmp);	//print_DebugMs
e476 : 3056             	leax	-10,u
e478 : 3410             	pshs	x
e47a : ec5e             	ldd	-2,u
e47c : 3406             	pshs	d
e47e : bde2c6           	lbsr	get_QByt
e481 : 3264             	leas	4,s
                        * 	if((tmp.h != 0x4161) || (tmp.l != 0x5252)) return;
e483 : ec56             	ldd	-10,u
e485 : 834161           	subd	#$4161
e488 : 10260009         	lbne	_189
e48c : ec58             	ldd	-8,u
e48e : 835252           	subd	#$5252
e491 : 10270004         	lbeq	_188
e495 :                  _189
                        * 	get_QByte(FS->structureSignature, &tmp); //print_De
e495 : 32c4             	leas	,u
e497 : 35c0             	puls	u,pc
e499 :                  _188
e499 : 3056             	leax	-10,u
e49b : 3410             	pshs	x
e49d : ec5e             	ldd	-2,u
e49f : c301e4           	addd	#$1e4
e4a2 : 3406             	pshs	d
e4a4 : bde2c6           	lbsr	get_QByt
e4a7 : 3264             	leas	4,s
                        * 	if((tmp.h != 0x6141) || (tmp.l != 0x7272)) return;
e4a9 : ec56             	ldd	-10,u
e4ab : 836141           	subd	#$6141
e4ae : 10260009         	lbne	_191
e4b2 : ec58             	ldd	-8,u
e4b4 : 837272           	subd	#$7272
e4b7 : 10270004         	lbeq	_190
e4bb :                  _191
                        * 	get_QByte(FS->trailSignature, &tmp); //print_DebugM
e4bb : 32c4             	leas	,u
e4bd : 35c0             	puls	u,pc
e4bf :                  _190
e4bf : 3056             	leax	-10,u
e4c1 : 3410             	pshs	x
e4c3 : ec5e             	ldd	-2,u
e4c5 : c301fc           	addd	#$1fc
AS09 Assembler for M6809 [1.42].                                     Page  213
--------------------------------- merge.a09 ----------------------------------

e4c8 : 3406             	pshs	d
e4ca : bde2c6           	lbsr	get_QByt
e4cd : 3264             	leas	4,s
                        * 	if((tmp.h != 0xaa55) || (tmp.l != 0x0000)) return;
e4cf : ec56             	ldd	-10,u
e4d1 : 83aa55           	subd	#$aa55
e4d4 : 10260009         	lbne	_193
e4d8 : ec58             	ldd	-8,u
e4da : 830000           	subd	#$0
e4dd : 10270004         	lbeq	_192
e4e1 :                  _193
                        * 	
                        *     if(get_set == GET)
e4e1 : 32c4             	leas	,u
e4e3 : 35c0             	puls	u,pc
e4e5 :                  _192
e4e5 : e649             	ldb	9,u
e4e7 : 4f               	clra
e4e8 : 830000           	subd	#$0
e4eb : 10260032         	lbne	_194
                        *     {
                        *         if(totOrNext == TOTAL_FREE) {			
e4ef : e647             	ldb	7,u
e4f1 : 4f               	clra
e4f2 : 830001           	subd	#$1
e4f5 : 10260014         	lbne	_195
                        * 			//return(FS->freeClusterCount);
                        * 			get_QByte(FS->freeClusterCount, rValue);
e4f9 : ec4c             	ldd	12,u
e4fb : 3406             	pshs	d
e4fd : ec5e             	ldd	-2,u
e4ff : c301e8           	addd	#$1e8
e502 : 3406             	pshs	d
e504 : bde2c6           	lbsr	get_QByt
e507 : 3264             	leas	4,s
                        * 			return;
                        * 		}
e509 : 32c4             	leas	,u
e50b : 35c0             	puls	u,pc
                        *         else { // when totOrNext = NEXT_FREE		
e50d :                  _195
                        * 			//return(FS->nextFreeCluster);
                        * 			get_QByte(FS->nextFreeCluster, rValue);
e50d : ec4c             	ldd	12,u
e50f : 3406             	pshs	d
e511 : ec5e             	ldd	-2,u
e513 : c301ec           	addd	#$1ec
e516 : 3406             	pshs	d
e518 : bde2c6           	lbsr	get_QByt
e51b : 3264             	leas	4,s
                        * 			return;
                        * 		}
e51d : 32c4             	leas	,u
e51f : 35c0             	puls	u,pc
                        *     }
                        *     else
e521 :                  _194
                        *     {
                        *         if(totOrNext == TOTAL_FREE) {            
e521 : e647             	ldb	7,u
e523 : 4f               	clra
e524 : 830001           	subd	#$1
AS09 Assembler for M6809 [1.42].                                     Page  214
--------------------------------- merge.a09 ----------------------------------

e527 : 10260013         	lbne	_196
                        * 			//FS->freeClusterCount = FSEntry;			
                        * 			set_QByte(FSEntry, FS->freeClusterCount);
e52b : ec5e             	ldd	-2,u
e52d : c301e8           	addd	#$1e8
e530 : 3406             	pshs	d
e532 : ec4a             	ldd	10,u
e534 : 3406             	pshs	d
e536 : bde2c6           	lbsr	set_QByt
e539 : 3264             	leas	4,s
                        * 		}
                        *         else { // when totOrNext = NEXT_FREE
e53b : 201112           	lbra	_197
e53e :                  _196
                        *             //FS->nextFreeCluster = FSEntry;
                        * 			set_QByte(FSEntry, FS->nextFreeCluster);
e53e : ec5e             	ldd	-2,u
e540 : c301ec           	addd	#$1ec
e543 : 3406             	pshs	d
e545 : ec4a             	ldd	10,u
e547 : 3406             	pshs	d
e549 : bde2c6           	lbsr	set_QByt
e54c : 3264             	leas	4,s
                        * 		}
                        *         //SD_writeSingleBlock(inputBuffer,unusedSect
                        * 		SD_writeSingleBlock(inputBuffer, &_unusedSectors);
e54e :                  _197
e54e : 305a             	leax	-6,u
e550 : 3410             	pshs	x
e552 : ec44             	ldd	4,u
e554 : 3406             	pshs	d
e556 : bdafa0           	lbsr	SD_write
e559 : 3264             	leas	4,s
                        *     }
                        * }
e55b : 32c4             	leas	,u
e55d : 35c0             	puls	u,pc
                        * 
                        * 
                        * 
                        * 
                        * //**************************************************
                        * //Function: to search for the next free cluster in t
                        * //          starting from a specified cluster
                        * //Arguments: Starting cluster
                        * //return: the next free cluster
                        * //**************************************************
                        * //uint32_t searchNextFreeCluster (char *inputBuffer,
                        * searchNextFreeCluster(inputBuffer, startCluster, rVa
                        * {
                        *     u32_t cluster, sector;
                        *     unsigned char i;
                        * 	u32_t tmp1, tmp2;
                        * 
                        *     //startCluster -=  (startCluster & 127);   //to 
                        * 	//for(cluster =startCluster; cluster < totalCluster
                        * 	cluster.h = startCluster->h; cluster.l = startClust
e55f :                  searchNe
e55f : 3440             	pshs	u
e561 : 33e4             	leau	,s
e563 : 32e8ef           	leas	-17,s
e566 : ecd806           	ldd	[6,u]
AS09 Assembler for M6809 [1.42].                                     Page  215
--------------------------------- merge.a09 ----------------------------------

e569 : ed5c             	std	-4,u
e56b : ae46             	ldx	6,u
e56d : ec02             	ldd	2,x
e56f : 84ff             	anda	#$ff
e571 : c480             	andb	#$80
e573 : ed5e             	std	-2,u
                        * 	while(_u32_higher(&totalClusters, &cluster)) {
e575 :                  _199
e575 : 305c             	leax	-4,u
e577 : 3410             	pshs	x
e579 : 3033             	leax	totalClu+0,y
e57b : 3410             	pshs	x
e57d : bdaac0           	lbsr	_u32_hig
e580 : 3264             	leas	4,s
e582 : 830000           	subd	#$0
e585 : 10270109         	lbeq	_198
                        *         //sector = unusedSectors + reservedSectorCou
                        * 		_u32_mul(4, &cluster, &tmp2);		
e589 : 30c8ef           	leax	-17,u
e58c : 3410             	pshs	x
e58e : 305c             	leax	-4,u
e590 : 3410             	pshs	x
e592 : cc0004           	ldd	#$4
e595 : 3406             	pshs	d
e597 : bda891           	lbsr	_u32_mul
e59a : 3266             	leas	6,s
                        * 		_u32_div2(&tmp2, bPerSector, &tmp1);
e59c : 3053             	leax	-13,u
e59e : 3410             	pshs	x
e5a0 : ec31             	ldd	bPerSect+0,y
e5a2 : 3406             	pshs	d
e5a4 : 30c8ef           	leax	-17,u
e5a7 : 3410             	pshs	x
e5a9 : bda825           	lbsr	_u32_div
e5ac : 3266             	leas	6,s
                        * 		sector.h = 0; sector.l = rsvSecCnt;
e5ae : 4f               	clra
e5af : 5f               	clrb
e5b0 : ed58             	std	-8,u
e5b2 : eca8ed           	ldd	rsvSecCn+0,y
e5b5 : ed5a             	std	-6,u
                        * 		_u32_add(&tmp1, &sector, &tmp2);
e5b7 : 30c8ef           	leax	-17,u
e5ba : 3410             	pshs	x
e5bc : 3058             	leax	-8,u
e5be : 3410             	pshs	x
e5c0 : 3053             	leax	-13,u
e5c2 : 3410             	pshs	x
e5c4 : bda9df           	lbsr	_u32_add
e5c7 : 3266             	leas	6,s
                        * 		_u32_add(&tmp2, &unusedSectors, &sector);
e5c9 : 3058             	leax	-8,u
e5cb : 3410             	pshs	x
e5cd : 30a8e9           	leax	unusedSe+0,y
e5d0 : 3410             	pshs	x
e5d2 : 30c8ef           	leax	-17,u
e5d5 : 3410             	pshs	x
e5d7 : bda9df           	lbsr	_u32_add
e5da : 3266             	leas	6,s
                        * 		
                        *         SD_readSingleBlock(inputBuffer, &sector);  /
e5dc : 3058             	leax	-8,u
AS09 Assembler for M6809 [1.42].                                     Page  216
--------------------------------- merge.a09 ----------------------------------

e5de : 3410             	pshs	x
e5e0 : ec44             	ldd	4,u
e5e2 : 3406             	pshs	d
e5e4 : bdaf12           	lbsr	SD_readS
e5e7 : 3264             	leas	4,s
                        *         for(i=0; i<128; i++)
e5e9 : 4f               	clra
e5ea : 5f               	clrb
e5eb : e757             	stb	-9,u
e5ed :                  _201
e5ed : e657             	ldb	-9,u
e5ef : 4f               	clra
e5f0 : 830080           	subd	#$80
e5f3 : 10240074         	lbhs	_200
                        *         {
                        *             // if(((uint32_t *) &inputBuffer[i*4]) &
                        * 			get_QByte((unsigned char*)&inputBuffer[i*4], &tmp
e5f7 : 3053             	leax	-13,u
e5f9 : 3410             	pshs	x
e5fb : e657             	ldb	-9,u
e5fd : 1d               	sex
e5fe : 58               	aslb
e5ff : 49               	rola
e600 : 58               	aslb
e601 : 49               	rola
e602 : e344             	addd	4,u
e604 : 3406             	pshs	d
e606 : bde2c6           	lbsr	get_QByt
e609 : 3264             	leas	4,s
                        * 			tmp2.h = 0x0fff; tmp2.l = 0xffff;
e60b : cc0fff           	ldd	#$fff
e60e : edc8ef           	std	-17,u
e611 : ccffff           	ldd	#$ffff
e614 : ed51             	std	-15,u
                        * 			_u32_and(&tmp1, &tmp2, &tmp1);
e616 : 3053             	leax	-13,u
e618 : 3410             	pshs	x
e61a : 30c8ef           	leax	-17,u
e61d : 3410             	pshs	x
e61f : 3053             	leax	-13,u
e621 : 3410             	pshs	x
e623 : bda7fe           	lbsr	_u32_and
e626 : 3266             	leas	6,s
                        * 			tmp2.h = tmp2.l = 0;
e628 : 4f               	clra
e629 : 5f               	clrb
e62a : ed51             	std	-15,u
e62c : edc8ef           	std	-17,u
                        * 			if(_u32_equal(&tmp1, &tmp2)) {
e62f : 30c8ef           	leax	-17,u
e632 : 3410             	pshs	x
e634 : 3053             	leax	-13,u
e636 : 3410             	pshs	x
e638 : bdaa95           	lbsr	_u32_equ
e63b : 3264             	leas	4,s
e63d : 830000           	subd	#$0
e640 : 1027001e         	lbeq	_203
                        *                 tmp1.h = 0; tmp1.l = i;
e644 : 4f               	clra
e645 : 5f               	clrb
e646 : ed53             	std	-13,u
e648 : e657             	ldb	-9,u
AS09 Assembler for M6809 [1.42].                                     Page  217
--------------------------------- merge.a09 ----------------------------------

e64a : 4f               	clra
e64b : ed55             	std	-11,u
                        * 				_u32_add(&cluster, &tmp1, rValue);				
e64d : ec48             	ldd	8,u
e64f : 3406             	pshs	d
e651 : 3053             	leax	-13,u
e653 : 3410             	pshs	x
e655 : 305c             	leax	-4,u
e657 : 3410             	pshs	x
e659 : bda9df           	lbsr	_u32_add
e65c : 3266             	leas	6,s
                        * 				return;
                        *             }
e65e : 32c4             	leas	,u
e660 : 35c0             	puls	u,pc
                        *         }
e662 :                  _203
                        * 		tmp1.h = 0; tmp1.l = 128;
e662 :                  _202
e662 : 3057             	leax	-9,u
e664 : e684             	ldb	,x
e666 : 6c84             	inc	,x
e668 : 1d               	sex
e669 : 2082             	lbra	_201
e66b :                  _200
e66b : 4f               	clra
e66c : 5f               	clrb
e66d : ed53             	std	-13,u
e66f : cc0080           	ldd	#$80
e672 : ed55             	std	-11,u
                        * 		_u32_add(&cluster, &tmp1, &tmp2);
e674 : 30c8ef           	leax	-17,u
e677 : 3410             	pshs	x
e679 : 3053             	leax	-13,u
e67b : 3410             	pshs	x
e67d : 305c             	leax	-4,u
e67f : 3410             	pshs	x
e681 : bda9df           	lbsr	_u32_add
e684 : 3266             	leas	6,s
                        * 		cluster.h = tmp2.h; cluster.l = tmp2.l;
e686 : ecc8ef           	ldd	-17,u
e689 : ed5c             	std	-4,u
e68b : ec51             	ldd	-15,u
e68d : ed5e             	std	-2,u
                        *     }
                        * 	rValue->h = rValue->l = 0; //return value
e68f : 7ee575           	lbra	_199
e692 :                  _198
e692 : 4f               	clra
e693 : 5f               	clrb
e694 : ae48             	ldx	8,u
e696 : ed02             	std	2,x
e698 : edd808           	std	[8,u]
                        * }
e69b : 32c4             	leas	,u
e69d : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function: to convert normal short file name into F
                        * //Arguments: pointer to the file name
                        * //return: 0, if successful else 1.
                        * //**************************************************
AS09 Assembler for M6809 [1.42].                                     Page  218
--------------------------------- merge.a09 ----------------------------------

                        * //unsigned char convertFileName (char *inputFileName
                        * convertFileName(inputFileName) char *inputFileName;
                        * {
                        *     unsigned char fileNameFAT[C_8_3_FileNameSize];
                        *     unsigned char j, k;
                        * 
                        *     for(j=0; j<C_MaxFileNameSize-1; j++)
e69f :                  convertF
e69f : 3440             	pshs	u
e6a1 : 33e4             	leau	,s
e6a3 : 3273             	leas	-13,s
e6a5 : 4f               	clra
e6a6 : 5f               	clrb
e6a7 : e754             	stb	-12,u
e6a9 :                  _205
e6a9 : e654             	ldb	-12,u
e6ab : 4f               	clra
e6ac : 83000c           	subd	#$c
e6af : 1024001b         	lbhs	_204
                        *         if(inputFileName[j] == '.') break;
e6b3 : e654             	ldb	-12,u
e6b5 : 1d               	sex
e6b6 : ae44             	ldx	4,u
e6b8 : e68b             	ldb	d,x
e6ba : 1d               	sex
e6bb : 83002e           	subd	#$2e
e6be : 10260003         	lbne	_207
e6c2 : 200a12           	lbra	_204
                        * 
                        *     if(j>8) {
e6c5 :                  _207
e6c5 :                  _206
e6c5 : 3054             	leax	-12,u
e6c7 : e684             	ldb	,x
e6c9 : 6c84             	inc	,x
e6cb : 1d               	sex
e6cc : 20db             	lbra	_205
e6ce :                  _204
e6ce : e654             	ldb	-12,u
e6d0 : 4f               	clra
e6d1 : 830008           	subd	#$8
e6d4 : 10230007         	lbls	_208
                        *         return INVALID_FILE_NAME;
e6d8 : cc0004           	ldd	#$4
                        *     }
e6db : 32c4             	leas	,u
e6dd : 35c0             	puls	u,pc
                        * 
                        *     for(k=0; k<j; k++) //setting file name
e6df :                  _208
e6df : 4f               	clra
e6e0 : 5f               	clrb
e6e1 : e753             	stb	-13,u
e6e3 :                  _210
e6e3 : e654             	ldb	-12,u
e6e5 : 4f               	clra
e6e6 : 3406             	pshs	d
e6e8 : e653             	ldb	-13,u
e6ea : 4f               	clra
e6eb : a3e1             	subd	,s++
e6ed : 1024001e         	lbhs	_209
                        *         fileNameFAT[k] = inputFileName[k];
AS09 Assembler for M6809 [1.42].                                     Page  219
--------------------------------- merge.a09 ----------------------------------

e6f1 : e653             	ldb	-13,u
e6f3 : 4f               	clra
e6f4 : ae44             	ldx	4,u
e6f6 : e68b             	ldb	d,x
e6f8 : 4f               	clra
e6f9 : 3406             	pshs	d
e6fb : e653             	ldb	-13,u
e6fd : 4f               	clra
e6fe : 3055             	leax	-11,u
e700 : 308b             	leax	d,x
e702 : 3506             	puls	d
e704 : e784             	stb	0,x
                        * 
                        *     for(k=j; k<=7; k++) //filling file name trail wi
e706 :                  _211
e706 : 3053             	leax	-13,u
e708 : e684             	ldb	,x
e70a : 6c84             	inc	,x
e70c : 4f               	clra
e70d : 20d4             	lbra	_210
e70f :                  _209
e70f : e654             	ldb	-12,u
e711 : 4f               	clra
e712 : e753             	stb	-13,u
e714 :                  _213
e714 : e653             	ldb	-13,u
e716 : 4f               	clra
e717 : 830007           	subd	#$7
e71a : 10220015         	lbhi	_212
                        *         fileNameFAT[k] = ' ';
e71e : e653             	ldb	-13,u
e720 : 4f               	clra
e721 : 3055             	leax	-11,u
e723 : 308b             	leax	d,x
e725 : cc0020           	ldd	#$20
e728 : e784             	stb	0,x
                        * 
                        *     j++;
e72a :                  _214
e72a : 3053             	leax	-13,u
e72c : e684             	ldb	,x
e72e : 6c84             	inc	,x
e730 : 4f               	clra
e731 : 20e1             	lbra	_213
e733 :                  _212
e733 : 3054             	leax	-12,u
e735 : e684             	ldb	,x
e737 : 6c84             	inc	,x
e739 : 4f               	clra
                        *     for(k=8; k<C_8_3_FileNameSize; k++) //setting fi
e73a : cc0008           	ldd	#$8
e73d : e753             	stb	-13,u
e73f :                  _216
e73f : e653             	ldb	-13,u
e741 : 4f               	clra
e742 : 83000b           	subd	#$b
e745 : 10240050         	lbhs	_215
                        *     {
                        *         if(inputFileName[j] != 0)
e749 : e654             	ldb	-12,u
e74b : 1d               	sex
e74c : ae44             	ldx	4,u
AS09 Assembler for M6809 [1.42].                                     Page  220
--------------------------------- merge.a09 ----------------------------------

e74e : e68b             	ldb	d,x
e750 : 1d               	sex
e751 : 830000           	subd	#$0
e754 : 1027001c         	lbeq	_218
                        *             fileNameFAT[k] = inputFileName[j++];
e758 : 3054             	leax	-12,u
e75a : e684             	ldb	,x
e75c : 6c84             	inc	,x
e75e : 4f               	clra
e75f : ae44             	ldx	4,u
e761 : e68b             	ldb	d,x
e763 : 4f               	clra
e764 : 3406             	pshs	d
e766 : e653             	ldb	-13,u
e768 : 4f               	clra
e769 : 3055             	leax	-11,u
e76b : 308b             	leax	d,x
e76d : 3506             	puls	d
e76f : e784             	stb	0,x
                        *         else //filling extension trail with blanks
e771 : 201d12           	lbra	_219
e774 :                  _218
                        *             while(k<C_8_3_FileNameSize)
e774 :                  _221
                        *                 fileNameFAT[k++] = ' ';
e774 : e653             	ldb	-13,u
e776 : 4f               	clra
e777 : 83000b           	subd	#$b
e77a : 10240012         	lbhs	_220
e77e : 3053             	leax	-13,u
e780 : e684             	ldb	,x
e782 : 6c84             	inc	,x
e784 : 4f               	clra
e785 : 3055             	leax	-11,u
e787 : 308b             	leax	d,x
e789 : cc0020           	ldd	#$20
e78c : e784             	stb	0,x
                        *     }
e78e : 20e4             	lbra	_221
e790 :                  _220
e790 :                  _219
                        * 
                        *     for(j=0; j<C_8_3_FileNameSize; j++) //converting
e790 :                  _217
e790 : 3053             	leax	-13,u
e792 : e684             	ldb	,x
e794 : 6c84             	inc	,x
e796 : 4f               	clra
e797 : 20a6             	lbra	_216
e799 :                  _215
e799 : 4f               	clra
e79a : 5f               	clrb
e79b : e754             	stb	-12,u
e79d :                  _223
e79d : e654             	ldb	-12,u
e79f : 4f               	clra
e7a0 : 83000b           	subd	#$b
e7a3 : 10240057         	lbhs	_222
                        *     {
                        *         if((fileNameFAT[j] >= 'a') && (fileNameFAT[j
e7a7 : e654             	ldb	-12,u
e7a9 : 4f               	clra
AS09 Assembler for M6809 [1.42].                                     Page  221
--------------------------------- merge.a09 ----------------------------------

e7aa : 3055             	leax	-11,u
e7ac : e68b             	ldb	d,x
e7ae : 4f               	clra
e7af : 830061           	subd	#$61
e7b2 : 1025002a         	lblo	_225
e7b6 : e654             	ldb	-12,u
e7b8 : 4f               	clra
e7b9 : 3055             	leax	-11,u
e7bb : e68b             	ldb	d,x
e7bd : 4f               	clra
e7be : 83007a           	subd	#$7a
e7c1 : 1022001b         	lbhi	_225
                        *         {
                        *             inputFileName[j] = fileNameFAT[j] - 0x20
e7c5 : e654             	ldb	-12,u
e7c7 : 1d               	sex
e7c8 : 3055             	leax	-11,u
e7ca : e68b             	ldb	d,x
e7cc : 1d               	sex
e7cd : 830020           	subd	#$20
e7d0 : 3406             	pshs	d
e7d2 : e654             	ldb	-12,u
e7d4 : 1d               	sex
e7d5 : ae44             	ldx	4,u
e7d7 : 308b             	leax	d,x
e7d9 : 3506             	puls	d
e7db : e784             	stb	0,x
                        *         }
                        *         else
e7dd : 201612           	lbra	_226
e7e0 :                  _225
                        *         {
                        *             inputFileName[j] = fileNameFAT[j];
e7e0 : e654             	ldb	-12,u
e7e2 : 1d               	sex
e7e3 : 3055             	leax	-11,u
e7e5 : e68b             	ldb	d,x
e7e7 : 1d               	sex
e7e8 : 3406             	pshs	d
e7ea : e654             	ldb	-12,u
e7ec : 1d               	sex
e7ed : ae44             	ldx	4,u
e7ef : 308b             	leax	d,x
e7f1 : 3506             	puls	d
e7f3 : e784             	stb	0,x
                        *         }
                        *     }
e7f5 :                  _226
                        * 	inputFileName[C_8_3_FileNameSize] = 0;
e7f5 :                  _224
e7f5 : 3054             	leax	-12,u
e7f7 : e684             	ldb	,x
e7f9 : 6c84             	inc	,x
e7fb : 1d               	sex
e7fc : 209f             	lbra	_223
e7fe :                  _222
e7fe : 4f               	clra
e7ff : 5f               	clrb
e800 : ae44             	ldx	4,u
e802 : e70b             	stb	11,x
                        * 
                        *     return VALID_FILE_NAME;
AS09 Assembler for M6809 [1.42].                                     Page  222
--------------------------------- merge.a09 ----------------------------------

e804 : cc0003           	ldd	#$3
                        * }
e807 : 32c4             	leas	,u
e809 : 35c0             	puls	u,pc
                        * 
                        * 
                        * //**************************************************
                        * //Function: to create a file in FAT32 format in the 
                        * //			file name does not exist; if the file already e
                        * //Arguments: pointer to the file name
                        * //return: status
                        * //**************************************************
                        * //unsigned char openFile (unsigned char fileOperatio
                        * openFile(fileOperation, filePtr) unsigned char fileO
                        * {
                        *     unsigned char returnStatus;
                        *     u32_t cluster_, sector, firstSector;
                        *     LE_dir_Structure *dir;
                        *     u32_t tmp1, tmp2; 
                        * 	unsigned int i;
                        *     unsigned char j;
                        * 	cluster_.h = rCluster.h; cluster_.l = rCluster.l;
e80b :                  openFile
e80b : 3440             	pshs	u
e80d : 33e4             	leau	,s
e80f : 32e8e6           	leas	-26,s
e812 : ec37             	ldd	rCluster+0,y
e814 : ed5b             	std	-5,u
e816 : ec39             	ldd	rCluster+2,y
e818 : ed5d             	std	-3,u
                        * 	
                        *     returnStatus = convertFileName(filePtr->fName); 
e81a : ec46             	ldd	6,u
e81c : c3022c           	addd	#$22c
e81f : 3406             	pshs	d
e821 : bde69f           	lbsr	convertF
e824 : 3262             	leas	2,s
e826 : e75f             	stb	-1,u
                        * 
                        *     if(returnStatus == VALID_FILE_NAME)
e828 : e65f             	ldb	-1,u
e82a : 4f               	clra
e82b : 830003           	subd	#$3
e82e : 1026022b         	lbne	_227
                        *     {
                        *        returnStatus = CONTINUE_LOOP;
e832 : cc0055           	ldd	#$55
e835 : e75f             	stb	-1,u
                        * 
                        *         do
e837 :                  _230
                        *         {
                        *             getFirstSector(&cluster_, &firstSector);
e837 : 3053             	leax	-13,u
e839 : 3410             	pshs	x
e83b : 305b             	leax	-5,u
e83d : 3410             	pshs	x
e83f : bde2f4           	lbsr	getFirst
e842 : 3264             	leas	4,s
                        * 			
                        * 			sector.h = 0;
e844 : 4f               	clra
AS09 Assembler for M6809 [1.42].                                     Page  223
--------------------------------- merge.a09 ----------------------------------

e845 : 5f               	clrb
e846 : ed57             	std	-9,u
                        * 			for(sector.l = 0; ((sector.l < secPerCluster) && 
e848 : 4f               	clra
e849 : 5f               	clrb
e84a : ed59             	std	-7,u
e84c :                  _232
e84c : ec59             	ldd	-7,u
e84e : a3a8ef           	subd	secPerCl+0,y
e851 : 10240140         	lbhs	_231
e855 : e65f             	ldb	-1,u
e857 : 4f               	clra
e858 : 830055           	subd	#$55
e85b : 10260136         	lbne	_231
                        *             {                
                        *                 _u32_add(&firstSector, &sector, &tmp
e85f : 30c8ed           	leax	-19,u
e862 : 3410             	pshs	x
e864 : 3057             	leax	-9,u
e866 : 3410             	pshs	x
e868 : 3053             	leax	-13,u
e86a : 3410             	pshs	x
e86c : bda9df           	lbsr	_u32_add
e86f : 3266             	leas	6,s
                        * 				SD_readSingleBlock(filePtr->LE_fileBuffer, &tmp1
e871 : 30c8ed           	leax	-19,u
e874 : 3410             	pshs	x
e876 : ec46             	ldd	6,u
e878 : c30026           	addd	#$26
e87b : 3406             	pshs	d
e87d : bdaf12           	lbsr	SD_readS
e880 : 3264             	leas	4,s
                        * 
                        *                 for(i=0; ((i<bPerSector) && (returnS
e882 : 4f               	clra
e883 : 5f               	clrb
e884 : edc8e7           	std	-25,u
e887 :                  _235
e887 : ecc8e7           	ldd	-25,u
e88a : a331             	subd	bPerSect+0,y
e88c : 102400f8         	lbhs	_234
e890 : e65f             	ldb	-1,u
e892 : 4f               	clra
e893 : 830055           	subd	#$55
e896 : 102600ee         	lbne	_234
                        *                 {
                        * 					dir = &filePtr->LE_fileBuffer[i];  //cast ok, b
e89a : ec46             	ldd	6,u
e89c : c30026           	addd	#$26
e89f : e3c8e7           	addd	-25,u
e8a2 : ed51             	std	-15,u
                        * 
                        *                     if(dir->name[0] == EMPTY) //indi
e8a4 : ae51             	ldx	-15,u
e8a6 : e684             	ldb	0,x
e8a8 : 4f               	clra
e8a9 : 830000           	subd	#$0
e8ac : 10260008         	lbne	_237
                        *                     {
                        *                         returnStatus = FDELETED_OR_N
e8b0 : cc0001           	ldd	#$1
e8b3 : e75f             	stb	-1,u
AS09 Assembler for M6809 [1.42].                                     Page  224
--------------------------------- merge.a09 ----------------------------------

                        *                         break;
e8b5 : 7ee988           	lbra	_234
                        *                     }
                        *                     if((dir->name[0] != DELETED) && 
e8b8 :                  _237
e8b8 : ae51             	ldx	-15,u
e8ba : e684             	ldb	0,x
e8bc : 4f               	clra
e8bd : 8300e5           	subd	#$e5
e8c0 : 102700b8         	lbeq	_238
e8c4 : ae51             	ldx	-15,u
e8c6 : e60b             	ldb	11,x
e8c8 : 4f               	clra
e8c9 : 83000f           	subd	#$f
e8cc : 102700ac         	lbeq	_238
                        *                     {
                        *                         for(j=0; j<C_8_3_FileNameSiz
e8d0 : 4f               	clra
e8d1 : 5f               	clrb
e8d2 : e7c8e6           	stb	-26,u
e8d5 :                  _240
e8d5 : e6c8e6           	ldb	-26,u
e8d8 : 4f               	clra
e8d9 : 83000b           	subd	#$b
e8dc : 1024002e         	lbhs	_239
                        *                         {
                        *                             if(dir->name[j] != fileP
e8e0 : ec46             	ldd	6,u
e8e2 : c3022c           	addd	#$22c
e8e5 : 3406             	pshs	d
e8e7 : e6c8e6           	ldb	-26,u
e8ea : 1d               	sex
e8eb : 3510             	puls	x
e8ed : e68b             	ldb	d,x
e8ef : 1d               	sex
e8f0 : 3406             	pshs	d
e8f2 : e6c8e6           	ldb	-26,u
e8f5 : 1d               	sex
e8f6 : ae51             	ldx	-15,u
e8f8 : e68b             	ldb	d,x
e8fa : 1d               	sex
e8fb : a3e1             	subd	,s++
e8fd : 10270003         	lbeq	_242
                        *                                 break;
e901 : 200b12           	lbra	_239
                        *                         }
e904 :                  _242
                        *                         if(j == C_8_3_FileNameSize)
e904 :                  _241
e904 : 30c8e6           	leax	-26,u
e907 : e684             	ldb	,x
e909 : 6c84             	inc	,x
e90b : 1d               	sex
e90c : 20c7             	lbra	_240
e90e :                  _239
e90e : e6c8e6           	ldb	-26,u
e911 : 4f               	clra
e912 : 83000b           	subd	#$b
e915 : 10260063         	lbne	_243
                        *                         {
                        *                             _u32_add(&firstSector, &
e919 : ec46             	ldd	6,u
AS09 Assembler for M6809 [1.42].                                     Page  225
--------------------------------- merge.a09 ----------------------------------

e91b : c3000c           	addd	#$c
e91e : 3406             	pshs	d
e920 : 3057             	leax	-9,u
e922 : 3410             	pshs	x
e924 : 3053             	leax	-13,u
e926 : 3410             	pshs	x
e928 : bda9df           	lbsr	_u32_add
e92b : 3266             	leas	6,s
                        *                             filePtr->appFLocation = 
e92d : ecc8e7           	ldd	-25,u
e930 : ae46             	ldx	6,u
e932 : ed8810           	std	16,x
                        *                             filePtr->appendStartClus
e935 : ec51             	ldd	-15,u
e937 : c30014           	addd	#$14
e93a : 3406             	pshs	d
e93c : bde2b8           	lbsr	get_Word
e93f : 3262             	leas	2,s
e941 : ae46             	ldx	6,u
e943 : ed881e           	std	30,x
                        * 							filePtr->appendStartCluster.l = get_Word(dir-
e946 : ec51             	ldd	-15,u
e948 : c3001a           	addd	#$1a
e94b : 3406             	pshs	d
e94d : bde2b8           	lbsr	get_Word
e950 : 3262             	leas	2,s
e952 : 3406             	pshs	d
e954 : ec46             	ldd	6,u
e956 : c3001e           	addd	#$1e
e959 : c30002           	addd	#$2
e95c : 1f01             	tfr	d,x
e95e : 3506             	puls	d
e960 : ed84             	std	0,x
                        *                             get_QByte(dir->fSize, &f
e962 : ec46             	ldd	6,u
e964 : c30012           	addd	#$12
e967 : 3406             	pshs	d
e969 : ec51             	ldd	-15,u
e96b : c3001c           	addd	#$1c
e96e : 3406             	pshs	d
e970 : bde2c6           	lbsr	get_QByt
e973 : 3264             	leas	4,s
                        *                             returnStatus = FOPEN_SUC
e975 : 4f               	clra
e976 : 5f               	clrb
e977 : e75f             	stb	-1,u
                        *                             break;
e979 : 200d12           	lbra	_234
                        *                         }
                        *                     }
e97c :                  _243
                        *                 }
e97c :                  _238
                        *             }
e97c :                  _236
e97c : ecc8e7           	ldd	-25,u
e97f : c30020           	addd	#$20
e982 : edc8e7           	std	-25,u
e985 : 7ee887           	lbra	_235
e988 :                  _234
                        * 
                        *             if(returnStatus == CONTINUE_LOOP)
AS09 Assembler for M6809 [1.42].                                     Page  226
--------------------------------- merge.a09 ----------------------------------

e988 :                  _233
e988 : ec59             	ldd	-7,u
e98a : c30001           	addd	#$1
e98d : ed59             	std	-7,u
e98f : 830001           	subd	#$1
e992 : 7ee84c           	lbra	_232
e995 :                  _231
e995 : e65f             	ldb	-1,u
e997 : 4f               	clra
e998 : 830055           	subd	#$55
e99b : 10260061         	lbne	_244
                        *             {
                        *                 getSetNC (filePtr->LE_fileBuffer, &c
e99f : 305b             	leax	-5,u
e9a1 : 3410             	pshs	x
e9a3 : 4f               	clra
e9a4 : 5f               	clrb
e9a5 : 3406             	pshs	d
e9a7 : 4f               	clra
e9a8 : 5f               	clrb
e9a9 : 3406             	pshs	d
e9ab : 305b             	leax	-5,u
e9ad : 3410             	pshs	x
e9af : ec46             	ldd	6,u
e9b1 : c30026           	addd	#$26
e9b4 : 3406             	pshs	d
e9b6 : bde33b           	lbsr	getSetNC
e9b9 : 326a             	leas	10,s
                        * 
                        *                 tmp1.h = 0x0fff; tmp1.l = 0xfff6;
e9bb : cc0fff           	ldd	#$fff
e9be : edc8ed           	std	-19,u
e9c1 : ccfff6           	ldd	#$fff6
e9c4 : edc8ef           	std	-17,u
                        * 				tmp2.h = 0x00; tmp2.l = 0x00;
e9c7 : 4f               	clra
e9c8 : 5f               	clrb
e9c9 : edc8e9           	std	-23,u
e9cc : 4f               	clra
e9cd : 5f               	clrb
e9ce : edc8eb           	std	-21,u
                        *                 if((_u32_higher(&cluster_, &tmp1) !=
e9d1 : 30c8ed           	leax	-19,u
e9d4 : 3410             	pshs	x
e9d6 : 305b             	leax	-5,u
e9d8 : 3410             	pshs	x
e9da : bdaac0           	lbsr	_u32_hig
e9dd : 3264             	leas	4,s
e9df : 830000           	subd	#$0
e9e2 : 10260015         	lbne	_246
e9e6 : 30c8e9           	leax	-23,u
e9e9 : 3410             	pshs	x
e9eb : 305b             	leax	-5,u
e9ed : 3410             	pshs	x
e9ef : bdaa95           	lbsr	_u32_equ
e9f2 : 3264             	leas	4,s
e9f4 : 830000           	subd	#$0
e9f7 : 10270005         	lbeq	_245
e9fb :                  _246
                        * 				{
                        *                     returnStatus = NO_FREE_CLUSTERS_
e9fb : cc0005           	ldd	#$5
AS09 Assembler for M6809 [1.42].                                     Page  227
--------------------------------- merge.a09 ----------------------------------

e9fe : e75f             	stb	-1,u
                        *                 }
                        *             }
ea00 :                  _245
                        *         }while(returnStatus == CONTINUE_LOOP);
ea00 :                  _244
ea00 :                  _229
ea00 : e65f             	ldb	-1,u
ea02 : 4f               	clra
ea03 : 830055           	subd	#$55
ea06 : 1027fe2d         	lbeq	_230
                        * 
                        * 
                        *         if((returnStatus == FOPEN_SUCCESSFUL) && (fi
ea0a :                  _228
ea0a : e65f             	ldb	-1,u
ea0c : 4f               	clra
ea0d : 830000           	subd	#$0
ea10 : 10260049         	lbne	_247
ea14 : e645             	ldb	5,u
ea16 : 4f               	clra
ea17 : 830000           	subd	#$0
ea1a : 1026003f         	lbne	_247
                        *         {
                        *             filePtr->cluster.h = get_Word(dir->fClst
ea1e : ec51             	ldd	-15,u
ea20 : c30014           	addd	#$14
ea23 : 3406             	pshs	d
ea25 : bde2b8           	lbsr	get_Word
ea28 : 3262             	leas	2,s
ea2a : ae46             	ldx	6,u
ea2c : ed04             	std	4,x
ea2e : ec51             	ldd	-15,u
ea30 : c3001a           	addd	#$1a
ea33 : 3406             	pshs	d
ea35 : bde2b8           	lbsr	get_Word
ea38 : 3262             	leas	2,s
ea3a : 3406             	pshs	d
ea3c : ec46             	ldd	6,u
ea3e : c30004           	addd	#$4
ea41 : c30002           	addd	#$2
ea44 : 1f01             	tfr	d,x
ea46 : 3506             	puls	d
ea48 : ed84             	std	0,x
                        *             get_QByte(dir->fSize, &filePtr->fileSize
ea4a : ec46             	ldd	6,u
ea4c : c30012           	addd	#$12
ea4f : 3406             	pshs	d
ea51 : ec51             	ldd	-15,u
ea53 : c3001c           	addd	#$1c
ea56 : 3406             	pshs	d
ea58 : bde2c6           	lbsr	get_QByt
ea5b : 3264             	leas	4,s
                        *         }
                        *     }
ea5d :                  _247
                        *  
                        *     return returnStatus;
ea5d :                  _227
ea5d : e65f             	ldb	-1,u
ea5f : 4f               	clra
                        * }
AS09 Assembler for M6809 [1.42].                                     Page  228
--------------------------------- merge.a09 ----------------------------------

ea60 : 32c4             	leas	,u
ea62 : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function: update the free memory count in the FSin
                        * //			Whenever a file is deleted or created, this fun
                        * //			to ADD or REMOVE clusters occupied by the file
                        * //Arguments: #1.flag ADD or REMOVE #2.file size in B
                        * //return: none
                        * //**************************************************
                        * //void freeMemoryUpdate (char *inputBuffer, unsigned
                        * freeMemoryUpdate(inputBuffer, flag, size) char *inpu
                        * {
                        *     u32_t freeClusters;
                        * 	u32_t tmp;
                        *     
                        * 	//convert file size into number of clusters occupie
                        *     tmp.h = size->h; tmp.l = size->l;
ea64 :                  freeMemo
ea64 : 3440             	pshs	u
ea66 : 33e4             	leau	,s
ea68 : 3278             	leas	-8,s
ea6a : ecd808           	ldd	[8,u]
ea6d : ed58             	std	-8,u
ea6f : ae48             	ldx	8,u
ea71 : ec02             	ldd	2,x
ea73 : ed5a             	std	-6,u
                        * 	_u32_div2(&tmp, C_MaxPageSize_U16, size);
ea75 : ec48             	ldd	8,u
ea77 : 3406             	pshs	d
ea79 : cc0200           	ldd	#$200
ea7c : 3406             	pshs	d
ea7e : 3058             	leax	-8,u
ea80 : 3410             	pshs	x
ea82 : bda825           	lbsr	_u32_div
ea85 : 3266             	leas	6,s
                        * 	if((tmp.l & 511) != 0) _u32_inc(size);
ea87 : ec5a             	ldd	-6,u
ea89 : 8401             	anda	#$1
ea8b : c4ff             	andb	#$ff
ea8d : 830000           	subd	#$0
ea90 : 10270009         	lbeq	_248
ea94 : ec48             	ldd	8,u
ea96 : 3406             	pshs	d
ea98 : bdaa2e           	lbsr	_u32_inc
ea9b : 3262             	leas	2,s
                        *     
                        * 	tmp.h = size->h; tmp.l = size->l;
ea9d :                  _248
ea9d : ecd808           	ldd	[8,u]
eaa0 : ed58             	std	-8,u
eaa2 : ae48             	ldx	8,u
eaa4 : ec02             	ldd	2,x
eaa6 : ed5a             	std	-6,u
                        * 	_u32_div2(&tmp, 8, size);
eaa8 : ec48             	ldd	8,u
eaaa : 3406             	pshs	d
eaac : cc0008           	ldd	#$8
eaaf : 3406             	pshs	d
eab1 : 3058             	leax	-8,u
eab3 : 3410             	pshs	x
eab5 : bda825           	lbsr	_u32_div
AS09 Assembler for M6809 [1.42].                                     Page  229
--------------------------------- merge.a09 ----------------------------------

eab8 : 3266             	leas	6,s
                        * 	if((tmp.l & 7) != 0) _u32_inc(size);
eaba : ec5a             	ldd	-6,u
eabc : 8400             	anda	#$0
eabe : c407             	andb	#$7
eac0 : 830000           	subd	#$0
eac3 : 10270009         	lbeq	_249
eac7 : ec48             	ldd	8,u
eac9 : 3406             	pshs	d
eacb : bdaa2e           	lbsr	_u32_inc
eace : 3262             	leas	2,s
                        * 
                        *     if(fClstCnU != 0)
ead0 :                  _249
ead0 : e6a8e8           	ldb	fClstCnU+0,y
ead3 : 4f               	clra
ead4 : 830000           	subd	#$0
ead7 : 10270072         	lbeq	_250
                        *     {
                        *         tmp.h = tmp.l = 0;
eadb : 4f               	clra
eadc : 5f               	clrb
eadd : ed5a             	std	-6,u
eadf : ed58             	std	-8,u
                        * 		getSetFreeCluster (inputBuffer,TOTAL_FREE, GET, &t
eae1 : 305c             	leax	-4,u
eae3 : 3410             	pshs	x
eae5 : 3058             	leax	-8,u
eae7 : 3410             	pshs	x
eae9 : 4f               	clra
eaea : 5f               	clrb
eaeb : 3406             	pshs	d
eaed : cc0001           	ldd	#$1
eaf0 : 3406             	pshs	d
eaf2 : ec44             	ldd	4,u
eaf4 : 3406             	pshs	d
eaf6 : bde442           	lbsr	getSetFr
eaf9 : 326a             	leas	10,s
                        *         tmp.h = freeClusters.h; tmp.l = freeClusters
eafb : ec5c             	ldd	-4,u
eafd : ed58             	std	-8,u
eaff : ec5e             	ldd	-2,u
eb01 : ed5a             	std	-6,u
                        * 		if(flag == ADD) {            
eb03 : e647             	ldb	7,u
eb05 : 4f               	clra
eb06 : 830000           	subd	#$0
eb09 : 10260014         	lbne	_251
                        * 			_u32_add(&tmp, size, &freeClusters);			
eb0d : 305c             	leax	-4,u
eb0f : 3410             	pshs	x
eb11 : ec48             	ldd	8,u
eb13 : 3406             	pshs	d
eb15 : 3058             	leax	-8,u
eb17 : 3410             	pshs	x
eb19 : bda9df           	lbsr	_u32_add
eb1c : 3266             	leas	6,s
                        * 		}
                        *         else {  //when flag = REMOVE
eb1e : 201212           	lbra	_252
eb21 :                  _251
                        *             _u32_sub(&tmp, size, &freeClusters);    
AS09 Assembler for M6809 [1.42].                                     Page  230
--------------------------------- merge.a09 ----------------------------------

eb21 : 305c             	leax	-4,u
eb23 : 3410             	pshs	x
eb25 : ec48             	ldd	8,u
eb27 : 3406             	pshs	d
eb29 : 3058             	leax	-8,u
eb2b : 3410             	pshs	x
eb2d : bda975           	lbsr	_u32_sub
eb30 : 3266             	leas	6,s
                        * 		}
                        *         getSetFreeCluster(inputBuffer,TOTAL_FREE, SE
eb32 :                  _252
eb32 : 3058             	leax	-8,u
eb34 : 3410             	pshs	x
eb36 : 305c             	leax	-4,u
eb38 : 3410             	pshs	x
eb3a : cc0001           	ldd	#$1
eb3d : 3406             	pshs	d
eb3f : cc0001           	ldd	#$1
eb42 : 3406             	pshs	d
eb44 : ec44             	ldd	4,u
eb46 : 3406             	pshs	d
eb48 : bde442           	lbsr	getSetFr
eb4b : 326a             	leas	10,s
                        *     }
                        * }
eb4d :                  _250
eb4d : 32c4             	leas	,u
eb4f : 35c0             	puls	u,pc
                        * 
                        * //**************************************************
                        * //Function: file deletion FAT32 format 
                        * //Arguments: pointer to the file name
                        * //return: 0 when successfully
                        * //**************************************************
                        * //unsigned char deleteFile (char *fileName)
                        * deleteFile(fileName) char *fileName;
                        * {
                        *     u32_t sector, cluster_, firstCluster, nextCluste
                        * 	u32_t tmp1, tmp2;
                        *     LE_dir_Structure *dir;
                        *     unsigned int i, j;
                        * 
                        *     cluster_.h = rCluster.h; cluster_.l = rCluster.l
eb51 :                  deleteFi
eb51 : 3440             	pshs	u
eb53 : 33e4             	leau	,s
eb55 : 32e8de           	leas	-34,s
eb58 : ec37             	ldd	rCluster+0,y
eb5a : ed58             	std	-8,u
eb5c : ec39             	ldd	rCluster+2,y
eb5e : ed5a             	std	-6,u
                        * 
                        *     while(1)
eb60 :                  _254
                        *     {
                        *         getFirstSector(&cluster_, &firstSector);
eb60 : 30c8ec           	leax	-20,u
eb63 : 3410             	pshs	x
eb65 : 3058             	leax	-8,u
eb67 : 3410             	pshs	x
eb69 : bde2f4           	lbsr	getFirst
eb6c : 3264             	leas	4,s
AS09 Assembler for M6809 [1.42].                                     Page  231
--------------------------------- merge.a09 ----------------------------------

                        * 		sector.h = 0;
eb6e : 4f               	clra
eb6f : 5f               	clrb
eb70 : ed5c             	std	-4,u
                        *         for(sector.l = 0; sector.l < secPerCluster; 
eb72 : 4f               	clra
eb73 : 5f               	clrb
eb74 : ed5e             	std	-2,u
eb76 :                  _256
eb76 : ec5e             	ldd	-2,u
eb78 : a3a8ef           	subd	secPerCl+0,y
eb7b : 1024021c         	lbhs	_255
                        * 		{
                        *             _u32_add(&firstSector, &sector, &tmp1);
eb7f : 30c8e8           	leax	-24,u
eb82 : 3410             	pshs	x
eb84 : 305c             	leax	-4,u
eb86 : 3410             	pshs	x
eb88 : 30c8ec           	leax	-20,u
eb8b : 3410             	pshs	x
eb8d : bda9df           	lbsr	_u32_add
eb90 : 3266             	leas	6,s
                        * 			if(SD_readSingleBlock(fatMapTb.LE_fileBuffer, &tm
eb92 : 30c8e8           	leax	-24,u
eb95 : 3410             	pshs	x
eb97 : 30a9fdd4         	leax	fatMapTb+38,y
eb9b : 3410             	pshs	x
eb9d : bdaf12           	lbsr	SD_readS
eba0 : 3264             	leas	4,s
eba2 : 830000           	subd	#$0
eba5 : 10270007         	lbeq	_258
eba9 : ccffff           	ldd	#$ffff
                        *             for(i=0; i<bPerSector; i+=32)
ebac : 32c4             	leas	,u
ebae : 35c0             	puls	u,pc
ebb0 :                  _258
ebb0 : 4f               	clra
ebb1 : 5f               	clrb
ebb2 : edc8e0           	std	-32,u
ebb5 :                  _260
ebb5 : ecc8e0           	ldd	-32,u
ebb8 : a331             	subd	bPerSect+0,y
ebba : 102401d0         	lbhs	_259
                        *             {
                        *                 dir = &fatMapTb.LE_fileBuffer[i];  /
ebbe : 30a9fdd4         	leax	fatMapTb+38,y
ebc2 : 1f10             	tfr	x,d
ebc4 : e3c8e0           	addd	-32,u
ebc7 : edc8e2           	std	-30,u
                        * 
                        *                 if(dir->name[0] == EMPTY) //indicate
ebca : aec8e2           	ldx	-30,u
ebcd : e684             	ldb	0,x
ebcf : 4f               	clra
ebd0 : 830000           	subd	#$0
ebd3 : 10260007         	lbne	_262
                        *                 {
                        *                     return FDELETED_OR_NOT_FOUND;
ebd7 : cc0001           	ldd	#$1
                        *                 }
ebda : 32c4             	leas	,u
ebdc : 35c0             	puls	u,pc
AS09 Assembler for M6809 [1.42].                                     Page  232
--------------------------------- merge.a09 ----------------------------------

                        *                 if((dir->name[0] != DELETED) && (dir
ebde :                  _262
ebde : aec8e2           	ldx	-30,u
ebe1 : e684             	ldb	0,x
ebe3 : 4f               	clra
ebe4 : 8300e5           	subd	#$e5
ebe7 : 10270197         	lbeq	_263
ebeb : aec8e2           	ldx	-30,u
ebee : e60b             	ldb	11,x
ebf0 : 4f               	clra
ebf1 : 83000f           	subd	#$f
ebf4 : 1027018a         	lbeq	_263
                        *                 {
                        *                     for(j=0; j<11; j++)
ebf8 : 4f               	clra
ebf9 : 5f               	clrb
ebfa : edc8de           	std	-34,u
ebfd :                  _265
ebfd : ecc8de           	ldd	-34,u
ec00 : 83000b           	subd	#$b
ec03 : 1024002a         	lbhs	_264
                        *                         if(dir->name[j] != fileName[
ec07 : ecc8de           	ldd	-34,u
ec0a : ae44             	ldx	4,u
ec0c : e68b             	ldb	d,x
ec0e : 1d               	sex
ec0f : 3406             	pshs	d
ec11 : ecc8de           	ldd	-34,u
ec14 : aec8e2           	ldx	-30,u
ec17 : e68b             	ldb	d,x
ec19 : 1d               	sex
ec1a : a3e1             	subd	,s++
ec1c : 10270003         	lbeq	_267
ec20 : 200f12           	lbra	_264
                        *                     if(j == 11)
ec23 :                  _267
ec23 :                  _266
ec23 : ecc8de           	ldd	-34,u
ec26 : c30001           	addd	#$1
ec29 : edc8de           	std	-34,u
ec2c : 830001           	subd	#$1
ec2f : 20cc             	lbra	_265
ec31 :                  _264
ec31 : ecc8de           	ldd	-34,u
ec34 : 83000b           	subd	#$b
ec37 : 10260147         	lbne	_268
                        *                     {
                        *                         firstCluster.h = get_Word(di
ec3b : ecc8e2           	ldd	-30,u
ec3e : c30014           	addd	#$14
ec41 : 3406             	pshs	d
ec43 : bde2b8           	lbsr	get_Word
ec46 : 3262             	leas	2,s
ec48 : ed54             	std	-12,u
ec4a : ecc8e2           	ldd	-30,u
ec4d : c3001a           	addd	#$1a
ec50 : 3406             	pshs	d
ec52 : bde2b8           	lbsr	get_Word
ec55 : 3262             	leas	2,s
ec57 : ed56             	std	-10,u
                        * 
                        *                         //mark file as 'deleted' in 
AS09 Assembler for M6809 [1.42].                                     Page  233
--------------------------------- merge.a09 ----------------------------------

                        *                         dir->name[0] = DELETED;
ec59 : cc00e5           	ldd	#$e5
ec5c : aec8e2           	ldx	-30,u
ec5f : e784             	stb	0,x
                        *                         _u32_add(&firstSector, &sect
ec61 : 30c8e8           	leax	-24,u
ec64 : 3410             	pshs	x
ec66 : 305c             	leax	-4,u
ec68 : 3410             	pshs	x
ec6a : 30c8ec           	leax	-20,u
ec6d : 3410             	pshs	x
ec6f : bda9df           	lbsr	_u32_add
ec72 : 3266             	leas	6,s
                        * 						if(SD_writeSingleBlock(fatMapTb.LE_fileBuffer,
ec74 : 30c8e8           	leax	-24,u
ec77 : 3410             	pshs	x
ec79 : 30a9fdd4         	leax	fatMapTb+38,y
ec7d : 3410             	pshs	x
ec7f : bdafa0           	lbsr	SD_write
ec82 : 3264             	leas	4,s
ec84 : 830000           	subd	#$0
ec87 : 10270007         	lbeq	_269
ec8b : ccffff           	ldd	#$ffff
                        * 
                        *                         get_QByte(dir->fSize, &tmp1)
ec8e : 32c4             	leas	,u
ec90 : 35c0             	puls	u,pc
ec92 :                  _269
ec92 : 30c8e8           	leax	-24,u
ec95 : 3410             	pshs	x
ec97 : ecc8e2           	ldd	-30,u
ec9a : c3001c           	addd	#$1c
ec9d : 3406             	pshs	d
ec9f : bde2c6           	lbsr	get_QByt
eca2 : 3264             	leas	4,s
                        * 						freeMemoryUpdate (fatMapTb.LE_fileBuffer,ADD, 
eca4 : 30c8e8           	leax	-24,u
eca7 : 3410             	pshs	x
eca9 : 4f               	clra
ecaa : 5f               	clrb
ecab : 3406             	pshs	d
ecad : 30a9fdd4         	leax	fatMapTb+38,y
ecb1 : 3410             	pshs	x
ecb3 : bdea64           	lbsr	freeMemo
ecb6 : 3266             	leas	6,s
                        * 
                        *                         //update next free cluster e
                        *                         tmp1.h = tmp1.l = 0;
ecb8 : 4f               	clra
ecb9 : 5f               	clrb
ecba : edc8ea           	std	-22,u
ecbd : edc8e8           	std	-24,u
                        * 						getSetFreeCluster (fatMapTb.LE_fileBuffer,NEXT
ecc0 : 3058             	leax	-8,u
ecc2 : 3410             	pshs	x
ecc4 : 30c8e8           	leax	-24,u
ecc7 : 3410             	pshs	x
ecc9 : 4f               	clra
ecca : 5f               	clrb
eccb : 3406             	pshs	d
eccd : cc0002           	ldd	#$2
ecd0 : 3406             	pshs	d
AS09 Assembler for M6809 [1.42].                                     Page  234
--------------------------------- merge.a09 ----------------------------------

ecd2 : 30a9fdd4         	leax	fatMapTb+38,y
ecd6 : 3410             	pshs	x
ecd8 : bde442           	lbsr	getSetFr
ecdb : 326a             	leas	10,s
                        *                         //if(firstCluster < cluster)
                        *                         if(_u32_higher(&cluster_, &f
ecdd : 3054             	leax	-12,u
ecdf : 3410             	pshs	x
ece1 : 3058             	leax	-8,u
ece3 : 3410             	pshs	x
ece5 : bdaac0           	lbsr	_u32_hig
ece8 : 3264             	leas	4,s
ecea : 830000           	subd	#$0
eced : 1027001e         	lbeq	_270
                        * 						    getSetFreeCluster (fatMapTb.LE_fileBuffer,
ecf1 : 30c8e8           	leax	-24,u
ecf4 : 3410             	pshs	x
ecf6 : 3054             	leax	-12,u
ecf8 : 3410             	pshs	x
ecfa : cc0001           	ldd	#$1
ecfd : 3406             	pshs	d
ecff : cc0002           	ldd	#$2
ed02 : 3406             	pshs	d
ed04 : 30a9fdd4         	leax	fatMapTb+38,y
ed08 : 3410             	pshs	x
ed0a : bde442           	lbsr	getSetFr
ed0d : 326a             	leas	10,s
                        * 
                        *                         //mark all the clusters allo
                        *                         while(1)
ed0f :                  _270
ed0f :                  _272
                        *                         {
                        *                             tmp1.h = tmp1.l = 0;
ed0f : 4f               	clra
ed10 : 5f               	clrb
ed11 : edc8ea           	std	-22,u
ed14 : edc8e8           	std	-24,u
                        * 							getSetNC(fatMapTb.LE_fileBuffer, &firstCluste
ed17 : 3050             	leax	-16,u
ed19 : 3410             	pshs	x
ed1b : 30c8e8           	leax	-24,u
ed1e : 3410             	pshs	x
ed20 : 4f               	clra
ed21 : 5f               	clrb
ed22 : 3406             	pshs	d
ed24 : 3054             	leax	-12,u
ed26 : 3410             	pshs	x
ed28 : 30a9fdd4         	leax	fatMapTb+38,y
ed2c : 3410             	pshs	x
ed2e : bde33b           	lbsr	getSetNC
ed31 : 326a             	leas	10,s
                        *                             getSetNC(fatMapTb.LE_fil
ed33 : 30c8e8           	leax	-24,u
ed36 : 3410             	pshs	x
ed38 : 30c8e8           	leax	-24,u
ed3b : 3410             	pshs	x
ed3d : cc0001           	ldd	#$1
ed40 : 3406             	pshs	d
ed42 : 3054             	leax	-12,u
ed44 : 3410             	pshs	x
ed46 : 30a9fdd4         	leax	fatMapTb+38,y
AS09 Assembler for M6809 [1.42].                                     Page  235
--------------------------------- merge.a09 ----------------------------------

ed4a : 3410             	pshs	x
ed4c : bde33b           	lbsr	getSetNC
ed4f : 326a             	leas	10,s
                        *                             tmp1.h = 0x0fff; tmp1.l 
ed51 : cc0fff           	ldd	#$fff
ed54 : edc8e8           	std	-24,u
ed57 : ccfff6           	ldd	#$fff6
ed5a : edc8ea           	std	-22,u
                        * 							//if(nextCluster > 0x0ffffff6)
                        * 							if(_u32_higher(&nextCluster, &tmp1) != 0) ret
ed5d : 30c8e8           	leax	-24,u
ed60 : 3410             	pshs	x
ed62 : 3050             	leax	-16,u
ed64 : 3410             	pshs	x
ed66 : bdaac0           	lbsr	_u32_hig
ed69 : 3264             	leas	4,s
ed6b : 830000           	subd	#$0
ed6e : 10270006         	lbeq	_273
ed72 : 4f               	clra
ed73 : 5f               	clrb
                        *                             firstCluster.h = nextClu
ed74 : 32c4             	leas	,u
ed76 : 35c0             	puls	u,pc
ed78 :                  _273
ed78 : ec50             	ldd	-16,u
ed7a : ed54             	std	-12,u
ed7c : ec52             	ldd	-14,u
ed7e : ed56             	std	-10,u
                        *                         }
                        *                     }
ed80 : 208d             	lbra	_272
ed82 :                  _271
                        *                 }
ed82 :                  _268
                        *             }
ed82 :                  _263
                        *         }
ed82 :                  _261
ed82 : ecc8e0           	ldd	-32,u
ed85 : c30020           	addd	#$20
ed88 : edc8e0           	std	-32,u
ed8b : 7eebb5           	lbra	_260
ed8e :                  _259
                        * 
                        *         tmp1.h = tmp1.l = 0;
ed8e :                  _257
ed8e : ec5e             	ldd	-2,u
ed90 : c30001           	addd	#$1
ed93 : ed5e             	std	-2,u
ed95 : 830001           	subd	#$1
ed98 : 7eeb76           	lbra	_256
ed9b :                  _255
ed9b : 4f               	clra
ed9c : 5f               	clrb
ed9d : edc8ea           	std	-22,u
eda0 : edc8e8           	std	-24,u
                        * 		getSetNC(fatMapTb.LE_fileBuffer, &cluster_, GET, &
eda3 : 3058             	leax	-8,u
eda5 : 3410             	pshs	x
eda7 : 30c8e8           	leax	-24,u
edaa : 3410             	pshs	x
edac : 4f               	clra
AS09 Assembler for M6809 [1.42].                                     Page  236
--------------------------------- merge.a09 ----------------------------------

edad : 5f               	clrb
edae : 3406             	pshs	d
edb0 : 3058             	leax	-8,u
edb2 : 3410             	pshs	x
edb4 : 30a9fdd4         	leax	fatMapTb+38,y
edb8 : 3410             	pshs	x
edba : bde33b           	lbsr	getSetNC
edbd : 326a             	leas	10,s
                        * 
                        *         tmp1.h = 0x0fff; tmp1.l = 0xfff6;
edbf : cc0fff           	ldd	#$fff
edc2 : edc8e8           	std	-24,u
edc5 : ccfff6           	ldd	#$fff6
edc8 : edc8ea           	std	-22,u
                        *         tmp2.h = 0x00; tmp2.l = 0x00;
edcb : 4f               	clra
edcc : 5f               	clrb
edcd : edc8e4           	std	-28,u
edd0 : 4f               	clra
edd1 : 5f               	clrb
edd2 : edc8e6           	std	-26,u
                        *         if((_u32_higher(&cluster_, &tmp1)) || (_u32_
edd5 : 30c8e8           	leax	-24,u
edd8 : 3410             	pshs	x
edda : 3058             	leax	-8,u
eddc : 3410             	pshs	x
edde : bdaac0           	lbsr	_u32_hig
ede1 : 3264             	leas	4,s
ede3 : 830000           	subd	#$0
ede6 : 10260015         	lbne	_275
edea : 30c8e4           	leax	-28,u
eded : 3410             	pshs	x
edef : 3058             	leax	-8,u
edf1 : 3410             	pshs	x
edf3 : bdaa95           	lbsr	_u32_equ
edf6 : 3264             	leas	4,s
edf8 : 830000           	subd	#$0
edfb : 10270007         	lbeq	_274
edff :                  _275
                        *         {
                        *             return FDELETED_OR_NOT_FOUND;
edff : cc0001           	ldd	#$1
                        *         }
ee02 : 32c4             	leas	,u
ee04 : 35c0             	puls	u,pc
                        *     }
ee06 :                  _274
                        * }
ee06 : 7eeb60           	lbra	_254
ee09 :                  _253
ee09 : 32c4             	leas	,u
ee0b : 35c0             	puls	u,pc
                        * 
                        * /***************************************************
0260 =                  _GLOBALS	equ	608
                        
                        *
                        * micro-c driver under flex
                        *
                        *	12-dec-81	m.ohta,h.tezuka
                        *
                        
AS09 Assembler for M6809 [1.42].                                     Page  237
--------------------------------- merge.a09 ----------------------------------

ee0d : 3436             _00001	pshs	d,x,y		;multiply	
ee0f : a6e4             		lda	,s
ee11 : e663             		ldb	3,s
ee13 : 3d               		mul
ee14 : e764             		stb	4,s		
ee16 : ec61             		ldd	1,s
ee18 : 3d               		mul
ee19 : e765             		stb	5,s		
ee1b : a661             		lda	1,s
ee1d : e663             		ldb	3,s
ee1f : 3d               		mul
ee20 : ab64             		adda	4,s
ee22 : ab65             		adda	5,s		
ee24 : 3266             		leas	6,s
ee26 : 39               		rts
                        
                        ; _00002	clr	,-s				; signed divide	
                        		; cmpx	#0
                        		; bpl	_02000		
                        		; com	,s		
                        		; exg	d,x
                        		; lbsr	_00020
                        		; exg	d,x
                        ; _02000	tsta
                        		; bpl	_02001		
                        		; com	,s		
                        		; lbsr	_00020	
                        ; _02001	lbsr	_00010
                        		; tfr	x,d
                        		; tst	,s+
                        		; bpl	_02002		
                        		; lbsr	_00020	
                        ; _02002	rts
                        
                        ; _00003	lbsr	_00010		; unsigned divide
                        		; tfr	x,d
                        		; rts
                        
                        ; _00004	clr	,-s				; signed modulous	
                        		; cmpx	#0
                        		; bpl	_04000		
                        		; exg	d,x
                        		; bsr	_00020
                        		; exg	d,x
                        ; _04000	tsta
                        		; bpl	_04001		
                        		; com	,s
                        		; bsr	_00020	
                        ; _04001	bsr	_00010	
                        		; tst	,s+
                        		; bpl	_04002		
                        		; bsr	_00020	
                        ; _04002	rts
                        
                        ; _00005	bsr	_00010		; unsigned modulous
                        		; rts
                        
                        ; _00006	cmpx	#0		; signed left shift
                        		; bmi	_06001 
                        ; _06000	beq	_06009
                        		; lslb
                        		; rola
AS09 Assembler for M6809 [1.42].                                     Page  238
--------------------------------- merge.a09 ----------------------------------

                        		; leax	-1,x
                        		; bra	_06000	
                        ; _06001	beq	_06009
                        		; asra
                        		; rorb
                        		; leax	1,x
                        		; bra	_06001	
                        ; _06009	rts
                        
                        ; _00007	cmpx	#0		; unsigned left shift
                        		; bmi	_07001	
                        ; _07000	beq	_07009
                        		; lslb
                        		; rola
                        		; leax	-1,x
                        		; bra	_07000	
                        ; _07001	beq	_07009
                        		; lsra
                        		; rorb
                        		; leax	1,x
                        		; bra	_07001	
                        ; _07009	rts
                        
                        ; _00008	cmpx	#0		; signed right shift
                        		; bmi	_08001	
                        ; _08000	beq	_08009
                        		; asra
                        		; rorb
                        		; leax	-1,x
                        		; bra	_08000
                        	
                        ; _08001	beq	_08009
                        		; lslb
                        		; rola
                        		; leax	1,x
                        		; bra	_08001	
                        ; _08009	rts
                        
ee27 : 8c0000           _00009	cmpx	#0		; unsigned right shift
ee2a : 2b08             		bmi	_09001	
ee2c : 270e             _09000	beq	_09009
ee2e : 44               		lsra
ee2f : 56               		rorb
ee30 : 301f             		leax	-1,x
ee32 : 20f8             		bra	_09000	
ee34 : 2706             _09001	beq	_09009
ee36 : 58               		lslb
ee37 : 49               		rola
ee38 : 3001             		leax	1,x
ee3a : 20f8             		bra	_09001	
ee3c : 39               _09009	rts
                        
ee3d : 40               _00020	nega			;negate d reg
ee3e : 50               		negb
ee3f : 8200             		sbca	#0
ee41 : 39               		rts
                        
                        ; _00010	pshs	d,x		;divide subroutine	
                        		; clra
                        		; clrb	
                        		; ldx	#17
                        	
AS09 Assembler for M6809 [1.42].                                     Page  239
--------------------------------- merge.a09 ----------------------------------

                        ; _00011	subd	2,s
                        		; bcc	_00012	
                        		; addd	2,s
                        	
                        ; _00012	rol	1,s
                        		; rol	,s
                        		; rolb
                        		; rola	
                        		; leax	-1,x
                        		; bne	_00011	
                        		; rora
                        		; rorb	
                        		; com	1,s
                        		; com	,s
                        		; puls	x	
                        		; leas	2,s
                        		; rts
                        
                        
                        ; coding convention:
                        ; normal function paramters are passed by the stack: a
                        ; the returned value is in D
                        ; the registers D and X can modified in the called fun
                        ;
                        ; special function lead by an 's' (e.g. sFUNCTION) is 
                        ;
                        ;{ ----------------------------------- Program Start -
                        					code
                        					
0010 =                  MONITOR_PROCESS_ID	equ		$10
0020 =                  BASIC_PROCESS_ID	equ		$20
                        
                        
                        ; configuration DEBUG_MON_PORT linked to USB_COM_PORT
00ef =                  ENABLE_MON_INT		equ		%11101111			; enable irq for moni
c800 =                  DEBUG_MON_PORT		equ		USB_COM_WR			; link the debugMonP
c000 =                  sMON_PORT_RD		equ		USB_COM_RD			; use the defined moni
ee42 : f7c800           sMON_PORT_WR		stb		USB_COM_WR			; use the defined moni
ee45 : 39               					rts
                        						
ee46 : 0d76657273696f.. VERSION         	db      CR,"version 2.2.0.2",CR		; ve
ee57 : 323031342d3230.. BOOT_SCR         	db      "2014-2025, Retro 6809 SBC",
ee71 : 68747470733a2f.. 					db		"https://github.com/akund/retro-6809-SBC",CR,
                        
35d7 =                  CheckSum16_ROM0		equ		$35d7
ee9b : f1f5             CheckSum16_ROM1		dw		CSum16_ROM1			; BASIC ROM1 CheckS
                        
ee9d : 1a50             RESET           	orcc	#%01010000			; disable all inter
                        															
                        					; init (clear 16-bit) the re-mapping int vector t
ee9f : 8e7ff2           					ldx		#IntVectSWI3
eea2 : 4f               					clra
eea3 : 5f               					clrb
eea4 : ed81             					std		,x++	;sw3
eea6 : ed81             					std		,x++	;sw2
eea8 : ed81             					std		,x++	;firq
eeaa : ed81             					std		,x++	;irq
eeac : ed81             					std		,x++	;sw1
eeae : ed81             					std		,x++	;nmi
eeb0 : ed81             					std		,x++	;start
                        					
eeb2 : 10ce7d59         					lds		#LV_StackBeginAddr	; NMI is now enabled
AS09 Assembler for M6809 [1.42].                                     Page  240
--------------------------------- merge.a09 ----------------------------------

                        					
eeb6 : 8eee46           					ldx		#VERSION			; version at boot up
eeb9 : bdfaf1           					lbsr	sPUTSTR
                        					
eebc : 8ee000           					ldx		#ROM0_ORG										
eebf : 3410             					pshs	x					; push as 1st arg
eec1 : 30892000         					leax	$2000,x				; calculate end addr+2 (8k size)
eec5 : 3410             					pshs	x					; push as 2nd arg
eec7 : 4f               					clra
eec8 : 5f               					clrb
eec9 : b3fff0           					subd	ROM_Integrity		; ROM0 initial CheckSum16 is 
eecc : 3406             					pshs	d					; push as 3rd arg (initial value)
eece : bdfc39           					lbsr	getCheckSum16		; ret value in d
eed1 : 3266             					leas	6,s					; free the 3 pushes					
eed3 : 8efff0           					ldx		#ROM_Integrity
eed6 : bdfc02           					lbsr	sROMcheck			; check the ROM integrity							
                        					
                        					;--------- init peripherals and others ----------
                        					; port A and B initialized with SD Card (requires
eed9 : bdfaf9           					lbsr	SELECTBANK0
                        					
                        					;---------- initialize monitor resources --------
eedc : bdf4c2           					lbsr	sMONITORSTART
                        					
                        					;---------- initialize DISK EXT BASIC resources -
eedf : fc8000           					ldd		ROM1_ORG			; check if BASIC ROM available
eee2 : 10b3ee9b         					cmpd	CheckSum16_ROM1
eee6 : 2626             					bne		main
eee8 : 8e8000           					ldx		#ROM1_ORG										
eeeb : 3410             					pshs	x					; push as 1st arg
eeed : 30894000         					leax	$4000,x				; calculate end addr+2 (16k size)
eef1 : 3410             					pshs	x					; push as 2nd arg
eef3 : 4f               					clra
eef4 : 5f               					clrb
eef5 : b38000           					subd	ROM1_ORG			; ROM1 initial CheckSum16 is excl
eef8 : 3406             					pshs	d					; push as 3rd arg (initial value)
eefa : bdfc39           					lbsr	getCheckSum16		; ret value in d
eefd : 3266             					leas	6,s					; free the 3 pushes
eeff : 8e8000           					ldx		#ROM1_ORG
ef02 : bdfc02           					lbsr	sROMcheck			; check the ROM integrity
ef05 : 5d               					tstb
ef06 : 2606             					bne		main				; start BASIC only when ROM1 validat
ef08 : bdef81           					lbsr	APL_init
ef0b : bdab89           					lbsr    setPins				; PIA initialization
                        
                        ;-------------------------------- main program -------
ef0e : 327f             main				leas	-1,s				; last APL status @ 2,u
ef10 : 327e             					leas	-2,s				; heart beat countdown @ 0,u
ef12 : 33e4             					leau	0,s					
                        
ef14 : bdf52c           loop				lbsr	sMonProcessCmd		; monitor process call
                        					
ef17 : bdefff           					lbsr	BASICprocess		; BASIC process call
                        					
ef1a : 8130             					cmpa	#APL_RESET			; reset supervision
ef1c : 260c             					bne		_loop1
ef1e : a142             					cmpa	2,u
ef20 : 2708             					beq		_loop1
ef22 : a742             					sta		2,u
ef24 : 8eef3d           					ldx		#APL_RESET_STR
ef27 : bdfaf1           					lbsr	sPUTSTR
                        					
AS09 Assembler for M6809 [1.42].                                     Page  241
--------------------------------- merge.a09 ----------------------------------

                        					;--------- heart beat ~1 sec period -------------
ef2a : ecc4             _loop1				ldd		0,u					; get heart beat countdown
ef2c : 830001           					subd    #1
ef2f : 2608             					bne     _loop2
ef31 : c62e             					ldb		#'.'
ef33 : f7c800           					stb		DEBUG_MON_PORT 		; write the dot as life che
                        				
ef36 : cc1fff           					ldd		#$1fff
ef39 : edc4             _loop2				std		0,u					; save heart beat countdown				
ef3b : 20d7             					bra		loop
ef3d : 0d41504c207265.. APL_RESET_STR      	db      CR,"APL reset",CR,0
                        
                        ;-----------------------------------------------------
                        ; APL interface routines
                        ;-----------------------------------------------------
                        					code
                        					
                        ; APL status definitions
0030 =                  APL_RESET 			equ		'0'
0031 =                  APL_READY			equ		'1'
0032 =                  APL_BUSY			equ		'2'
0039 =                  APL_UNDEFINED		equ		'9'
                        
                        					
                        ; interface to APL API for calls from BASIC
ef49 : 7ef0de           APLgetChar			lbra	getKeyboard					
                        
ef4c : b7c800           APLsendChar			sta		DEBUG_MON_PORT 		; forward to debug
ef4f : 1f89             					tfr  	a,b			  		; char in B
ef51 : 3406             					pshs 	d			  		; charater as parameter (16-bit)
ef53 : bdf103           					lbsr  	sendCharToScreen          
ef56 : 3586             					puls 	d,pc
                        					
ef58 : 7ef123           APLcurBlinking		lbra	cursorBlinking
ef5b : 7ef127           APLcurOff			lbra	cursorOff
                        
ef5e : 3406             APLclearscreen		pshs 	d
ef60 : bdf146           					lbsr	sendClearScreen
ef63 : 3586             					puls 	d,pc
                        
ef65 : 3404             APLsound			pshs b						; save duration value (lower 8-
ef67 : 5f               					clrb
ef68 : 3404             					pshs b						; save duration value (higer 8-bit)		
ef6a : 3402             					pshs a						; save tone value (lower 8-bit)					
ef6c : 3404             					pshs b						; save tone value (higer 8-bit)					
ef6e : bdf1a7           					lbsr	setTone
ef71 : 3264             					leas 4,s					; free parameters
ef73 : 39               					rts
                        
ef74 : 3402             APLsetXY			pshs a						; save ver value (lower 8-bit)
ef76 : 4f               					clra
ef77 : 3402             					pshs a						; save ver value (higer 8-bit)					
ef79 : 3406             					pshs d						; save hor value (16-bit)
ef7b : bdf163           					lbsr 	setpointXY			; character location (hor in 0
ef7e : 3264             					leas 4,s					; free parameters
ef80 : 39               					rts
                        
                        ;-----------------------------------------------------
                        ; APL initialization
                        ; param: 	none
                        ; return:	none
                        ;-----------------------------------------------------
AS09 Assembler for M6809 [1.42].                                     Page  242
--------------------------------- merge.a09 ----------------------------------

ef81 : 3410             APL_init			pshs	x					; save register(s)
                        
ef83 : 7f7ff0           					clr		BasicCallBack		; unused the next callback ad
ef86 : 7f7ff1           					clr		BasicCallBack+1
                        
                        					; init APL output stream interpretation
ef89 : 8639             					lda		#APL_UNDEFINED
ef8b : b77fdf           					sta		APLstatus
ef8e : 7f7fe4           					clr		KeyboardRbHead
ef91 : 7f7fe5           					clr		KeyboardRbTail
                        				
ef94 : bdf281           					lbsr	UART_Init			; initialize the communication w
                        
ef97 : 8effff           					ldx		#$ffff				; timeout count
ef9a : 301f             _APL_init0			leax	-1,x
ef9c : 2742             					beq		_APL_init4
ef9e : bdf01f           					lbsr	APL_OutputStream	; process the APL output st
efa1 : c131             					cmpb	#APL_READY				
efa3 : 26f5             					bne		_APL_init0			; wait until ready
                        					
efa5 : 8eefe3           					ldx		#STR_BASIC
efa8 : bdfaf1           					lbsr	sPUTSTR	
efab : c620             					ldb		#BASIC_PROCESS_ID
efad : 3406             					pshs	d
efaf : bdfca2           					lbsr	HEXBYTE2MONPORT
efb2 : c60d             					ldb		#CR
efb4 : 3406             					pshs	d
efb6 : bdfcc2           					lbsr	BYTE2MONPORT
efb9 : bdfcc2           					lbsr	BYTE2MONPORT
efbc : 3264             					leas	4,s					; clear the 2 pshs
                        										
efbe : 5f               					clrb
efbf : bdf146           					lbsr	sendClearScreen
                        					
efc2 : 8eee57           					ldx		#BOOT_SCR					
efc5 : e680             _APL_init1			ldb		,x+
efc7 : 2711             					beq		_APL_init3 			; string ends with NULL
efc9 : 4f               					clra
efca : 3406             					pshs	d
efcc : bdf103           					lbsr	sendCharToScreen
efcf : 3262             					leas	2,s
efd1 : bdf01f           _APL_init2			lbsr	APL_OutputStream	; process the APL o
efd4 : c131             					cmpb	#APL_READY				
efd6 : 26f9             					bne		_APL_init2			; wait until ready					
efd8 : 20eb             					bra		_APL_init1					
efda : cc8002           _APL_init3			ldd		#BASIC_ORG			; init first time BASIC
efdd : fd7ff0           					std		BasicCallBack
efe0 : 3510             _APL_init4			puls	x					; restore the register(s)
efe2 : 39               					rts
efe3 : 0d737461727469.. STR_BASIC      		db      CR,"starting BASIC process ID
                        
                        ;-----------------------------------------------------
                        ; basic process
                        ; param: 	none
                        ; return:	APLstatus -> B
                        ;-----------------------------------------------------
efff : 8d1e             BASICprocess		bsr		APL_OutputStream	; process the APL 
f001 : c131             					cmpb	#APL_READY				
f003 : 2619             					bne		_BASICprocess2		; skip BASIC when APL not re
                        					
f005 : 3447             					pshs	d,u,cc				; save the registers					
f007 : be7ff0           					ldx  	BasicCallBack
AS09 Assembler for M6809 [1.42].                                     Page  243
--------------------------------- merge.a09 ----------------------------------

f00a : 2710             					beq		_BASICprocess1		; skip the process execution
f00c : 10ff7fee         					sts		MonSavReg_S
f010 : ccf018           					ldd  	#_BASICprocess0
f013 : fd7ff0           					std  	BasicCallBack
f016 : 6e84             					jmp		0,x
f018 : 10fe7fee         _BASICprocess0		lds		MonSavReg_S
f01c : 3547             _BASICprocess1		puls	d,u,cc				; restore the registers
f01e : 39               _BASICprocess2		rts
                        					
                        ;-----------------------------------------------------
                        ; APL output stream process
                        ; param: 	none
                        ; return:	APLstatus -> B
                        ;-----------------------------------------------------
f01f : 3410             APL_OutputStream	pshs	x					; save register(s)
f021 : 8e0001           					ldx		#1					; sAPLgetOutput param: 1 iteration on
f024 : bdf0b6           					lbsr	sAPLgetOutput		; get first protocol byte				
f027 : 4d               					tsta
f028 : 10270084         					lbeq	_APL_OutputStream5										
f02c : c155             					cmpb	#'U'				; Upload msg
f02e : 1026007e         					lbne	_APL_OutputStream5
                        				
f032 : 8effff           					ldx		#$ffff				; sAPLgetOutput param: max iterati
f035 : bdf0b6           					lbsr	sAPLgetOutput		; get second protocol byte
f038 : 4d               					tsta
f039 : 2775             					beq		_APL_OutputStream5
f03b : c161             					cmpb	#'a'				; st'A'tus msg type
f03d : 2617             					bne		_APL_OutputStream2
f03f : 8d75             					bsr		sAPLgetOutput		; get status value
f041 : 4d               					tsta
f042 : 276c             					beq		_APL_OutputStream5
f044 : 3404             					pshs	b					; save status value
f046 : 8d6e             					bsr		sAPLgetOutput		; CR
f048 : 4d               					tsta	
f049 : 2763             					beq		_APL_OS_1
f04b : c10d             					cmpb	#CR
f04d : 265f             					bne		_APL_OS_1
f04f : 3504             					puls	b					; restore status value
f051 : f77fdf           					stb		APLstatus
f054 : 205a             					bra		_APL_OutputStream5
                        					
f056 : c16b             _APL_OutputStream2	cmpb	#'k'				; 'K'eyboard msg type
f058 : 261b             					bne		_APL_OutputStream3
                        					
f05a : 8d5a             					bsr		sAPLgetOutput		; get msg length
f05c : 4d               					tsta
f05d : 2751             					beq		_APL_OutputStream5
f05f : 8d55             					bsr		sAPLgetOutput		; get char value
f061 : 4d               					tsta
f062 : 274c             					beq		_APL_OutputStream5
f064 : 3404             					pshs	b					; save value
f066 : 8d4e             					bsr		sAPLgetOutput		; get CR
f068 : 4d               					tsta
f069 : 2743             					beq		_APL_OS_1
f06b : c10d             					cmpb	#CR
f06d : 263f             					bne		_APL_OS_1
f06f : 3504             					puls	b
f071 : 8d4e             					bsr		sAPL_KeyboardData
f073 : 203b             					bra		_APL_OutputStream5
                        					
f075 : c16d             _APL_OutputStream3	cmpb	#'m'				; DateTime sta'M'p msg
f077 : 2637             					bne		_APL_OutputStream5
AS09 Assembler for M6809 [1.42].                                     Page  244
--------------------------------- merge.a09 ----------------------------------

                        				
f079 : 327c             					leas	-4,s				; free storage for values
f07b : 8d39             					bsr		sAPLgetOutput		; get char value (dateMSB)
f07d : 4d               					tsta
f07e : 272c             					beq		_APL_OS_4
f080 : e7e4             					stb		0,s					; save value
f082 : 8d32             					bsr		sAPLgetOutput		; get char value (dateLSB)
f084 : 4d               					tsta
f085 : 2725             					beq		_APL_OS_4
f087 : e761             					stb		1,s					; save value
f089 : 8d2b             					bsr		sAPLgetOutput		; get char value (timeMSB)
f08b : 4d               					tsta
f08c : 271e             					beq		_APL_OS_4
f08e : e762             					stb		2,s					; save value
f090 : 8d24             					bsr		sAPLgetOutput		; get char value (timeLSB)
f092 : 4d               					tsta
f093 : 2717             					beq		_APL_OS_4
f095 : e763             					stb		3,s					; save value
                        					
f097 : 8d1d             					bsr		sAPLgetOutput		; get CR
f099 : 4d               					tsta
f09a : 2710             					beq		_APL_OS_4
f09c : c10d             					cmpb	#CR
f09e : 260c             					bne		_APL_OS_4					
f0a0 : 3506             					puls	d
f0a2 : fd7fe0           					std		APLdate
f0a5 : 3506             					puls	d
f0a7 : fd7fe2           					std		APLtime
f0aa : 2004             					bra		_APL_OutputStream5
                        					
f0ac : 3263             _APL_OS_4	 		leas	3,s					; free unrestored value
f0ae : 3261             _APL_OS_1	 		leas	1,s					; free unrestored value
f0b0 : 4f               _APL_OutputStream5	clra
f0b1 : f67fdf           					ldb		APLstatus			; return the APL status					
f0b4 : 3590             					puls	x,pc				; restore the register(s) and return
                        					
                        ;-----------------------------------------------------
                        ; Get APL output stream with timeout
                        ; param: 	X -> timeout iterations
                        ; return:	char in -> B and A when != 0
                        ;-----------------------------------------------------
f0b6 :                  sAPLgetOutput ;{					
f0b6 : bdf2a0           _sAPLgetOutput1		lbsr	UartRead
f0b9 : 4d               					tsta
f0ba : 2604             					bne		_sAPLgetOutput2
f0bc : 301f             					leax	-1,x				; dec iteration counter
f0be : 26f6             					bne		_sAPLgetOutput1
f0c0 : 39               _sAPLgetOutput2		rts
                        ;}
                        ;-----------------------------------------------------
                        ; Store APL keyboard data in the keyboard RB
                        ; param: 	key value in -> B
                        ; return:	none
                        ;-----------------------------------------------------
f0c1 : 3410             sAPL_KeyboardData	pshs	x					; save register(s)
f0c3 : 8e7fe6           					ldx     #KeyboardRbuffer	; get buffer base addr		
f0c6 : b67fe4           					lda		KeyboardRbHead		; head index value
f0c9 : 3086             					leax	a,x					; set X to the head pointer
f0cb : 4c               					inca				
f0cc : 8108             					cmpa	#KeyboardRbSize
f0ce : 2501             					blo		_APL_KeyboardData1
f0d0 : 4f               					clra
AS09 Assembler for M6809 [1.42].                                     Page  245
--------------------------------- merge.a09 ----------------------------------

f0d1 : b17fe5           _APL_KeyboardData1  cmpa	KeyboardRbTail
f0d4 : 2705             					beq		_APL_KeyboardData2
f0d6 : b77fe4           					sta     KeyboardRbHead
f0d9 : e784             					stb		,x					; store data to keyboard RB head poin
f0db : 3510             _APL_KeyboardData2	puls	x					; restore the register(s
f0dd : 39               					rts					
                        
                        ;-----------------------------------------------------
                        ; Get keyboard char from ringbuffer (C call compatible
                        ; param: 	none
                        ; return:	key value as char (or zero when no key was p
                        ;-----------------------------------------------------
f0de :                  getKeyboard ;{
f0de : bdf0fb           getKeybo			lbsr	isKeyboardData
f0e1 : 5d               					tstb
f0e2 : 2716             					beq		_getKeyboard2		; fifo empty when tail = head
f0e4 : 3410             					pshs	x
f0e6 : 8e7fe6           					ldx		#KeyboardRbuffer
f0e9 : b67fe5           					lda		KeyboardRbTail					
f0ec : e686             					ldb		a,x
f0ee : 3510             					puls	x
f0f0 : 4c               					inca						; inc tail index
f0f1 : 8108             					cmpa	#KeyboardRbSize
f0f3 : 2501             					blo		_getKeyboard1
f0f5 : 4f               					clra						; wrap RbTail
f0f6 : b77fe5           _getKeyboard1		sta		KeyboardRbTail		; save updated tai
f0f9 : 4f               					clra
f0fa : 39               _getKeyboard2		rts
                        
                        ;-----------------------------------------------------
                        ; isKeyboardData in the ringbuffer? (C call compatible
                        ; param: 	none
                        ; return:	when no data, 0 -> D (unsigned int)
                        ;-----------------------------------------------------
f0fb :                  isKeyboardData ;{
f0fb : f67fe4           isKeyboa			ldb		KeyboardRbHead
f0fe : f07fe5           					subb	KeyboardRbTail
f101 : 4f               					clra
f102 : 39               					rts
                        ;}
                        
                        ;-----------------------------------------------------
                        ; Send a char to the screen [Text mode] (C call compat
                        ; param: 	2,s -> unused
                        ;			3,s -> char to send
                        ; return:	none
                        ;-----------------------------------------------------
f103 :                  sendCharToScreen ;{
f103 : bdf2b7           					lbsr	waitSendDone
f106 : bdf2bf           					lbsr	waitCTS
f109 : c644             					ldb		#'D'				; sending
f10b : f7d000           					stb		UART
f10e : c666             					ldb		#'f'				; cmd
f110 : f7d000           					stb		UART
f113 : c631             					ldb		#'1'				; len
f115 : f7d000           					stb		UART
f118 : e663             					ldb		3,s
f11a : f7d000           					stb 	UART  				; char
f11d : c60d             					ldb		#CR					; end
f11f : f7d000           					stb		UART				
f122 : 39               					rts
                        ;}
AS09 Assembler for M6809 [1.42].                                     Page  246
--------------------------------- merge.a09 ----------------------------------

                        
                        ;-----------------------------------------------------
                        ; Set the screen cursor propriety [Text mode], (C call
                        ; param: 	none
                        ; return:	none
                        ;-----------------------------------------------------
f123 : 8662             cursorBlinking		lda		#'b'				; param 'b' for blinking
f125 : 2002             					bra		_sCursor1
f127 : 8630             cursorOff   		lda		#'0'				; param '0' for Off
f129 : 3402             _sCursor1			pshs	a
f12b : bdf2b7           					lbsr	waitSendDone
f12e : bdf2bf           					lbsr	waitCTS
f131 : 3502             					puls	a
f133 : c644             					ldb		#'D'				; sending
f135 : f7d000           					stb		UART
f138 : c663             					ldb		#'c'				; cmd
f13a : f7d000           					stb		UART
f13d : b7d000           					sta 	UART  				; param
f140 : c60d             					ldb		#CR					; end
f142 : f7d000           					stb		UART				
f145 : 39               					rts
                        	
                        ;-----------------------------------------------------
                        ; Send the clear screen command (C call compatible)
                        ; param: 	2,s -> unused
                        ;			3,s -> color
                        ; return:	none
                        ;-----------------------------------------------------
f146 :                  sendClearScreen ;{
f146 : bdf2b7           					lbsr	waitSendDone
f149 : bdf2bf           					lbsr	waitCTS
f14c : c644             					ldb		#'D'				; sending
f14e : f7d000           					stb		UART
f151 : c66c             					ldb		#'l'				; cmd
f153 : f7d000           					stb		UART
f156 : e663             					ldb		3,s
f158 : cb30             					addb	#'0'
f15a : f7d000           					stb		UART				; color
f15d : c60d             					ldb		#CR					; end
f15f : f7d000           					stb		UART				
f162 : 39               					rts	
                        ;}		
                        			
                        ;-----------------------------------------------------
                        ; Send the setpointXY command (C call compatible)
                        ; param: 	2,s -> unused
                        ;			3,s -> x
                        ;			4,s -> unused
                        ;			5,s -> y
                        ; return:	none
                        ;-----------------------------------------------------
f163 :                  setpointXY ;{
f163 : bdf2b7           setpoint			lbsr	waitSendDone
f166 : bdf2bf           					lbsr	waitCTS
f169 : c644             					ldb		#'D'				; sending
f16b : f7d000           					stb		UART
f16e : c670             					ldb		#'p'				; cmd
f170 : f7d000           					stb		UART
f173 : e663             					ldb		3,s
f175 : cb30             					addb	#'0'
f177 : f7d000           					stb		UART				; x
f17a : e665             					ldb		5,s
AS09 Assembler for M6809 [1.42].                                     Page  247
--------------------------------- merge.a09 ----------------------------------

f17c : cb30             					addb	#'0'
f17e : f7d000           					stb		UART				; y
f181 : c60d             					ldb		#CR					; end
f183 : f7d000           					stb		UART				
f186 : 39               					rts	
                        ;}	
                        
                        ;-----------------------------------------------------
                        ; Set tile index [Graph mode] (C call compatible)
                        ; param: 	2,s -> unused
                        ;			3,s -> tile index
                        ; return:	none
                        ;-----------------------------------------------------
f187 :                  setTile ;{
f187 : bdf2b7           					lbsr	waitSendDone
f18a : bdf2bf           					lbsr	waitCTS
f18d : c644             					ldb		#'D'				; sending
f18f : f7d000           					stb		UART
f192 : c674             					ldb		#'t'				; cmd
f194 : f7d000           					stb		UART
f197 : c631             					ldb		#'1'				; len
f199 : f7d000           					stb		UART
f19c : e663             					ldb		3,s
f19e : f7d000           					stb 	UART  				; index
f1a1 : c60d             					ldb		#CR					; end
f1a3 : f7d000           					stb		UART				
f1a6 : 39               					rts
                        ;}
                        
                        ;-----------------------------------------------------
                        ; Send the tone command (C call compatible)
                        ; param: 	2,s -> unused
                        ;			3,s -> tone (8-bit)
                        ;			4,s -> unused
                        ;			5,s -> duration (8-bit)
                        ; return:	none
                        ;-----------------------------------------------------
f1a7 :                  setTone ;{
f1a7 : bdf2b7           					lbsr	waitSendDone
f1aa : bdf2bf           					lbsr	waitCTS
f1ad : c644             					ldb		#'D'				; sending
f1af : f7d000           					stb		UART
f1b2 : c66f             					ldb		#'o'				; cmd
f1b4 : f7d000           					stb		UART
f1b7 : e663             					ldb		3,s
f1b9 : f7d000           					stb		UART				; tone
f1bc : e665             					ldb		5,s
f1be : f7d000           					stb		UART				; duration
f1c1 : c60d             					ldb		#CR					; end
f1c3 : f7d000           					stb		UART				
f1c6 : 39               					rts	
                        ;}	
                        
                        ;-----------------------------------------------------
                        ; Set sound index (C call compatible)
                        ; param: 	2,s -> unused
                        ;			3,s -> index
                        ; return:	none
                        ;-----------------------------------------------------
f1c7 :                  setSound ;{
f1c7 : bdf2b7           					lbsr	waitSendDone
f1ca : bdf2bf           					lbsr	waitCTS
AS09 Assembler for M6809 [1.42].                                     Page  248
--------------------------------- merge.a09 ----------------------------------

f1cd : c644             					ldb		#'D'				; sending
f1cf : f7d000           					stb		UART
f1d2 : c673             					ldb		#'s'				; cmd
f1d4 : f7d000           					stb		UART
f1d7 : e663             					ldb		3,s
f1d9 : cb30             					addb	#'0'				; container index
f1db : f7d000           					stb		UART					
f1de : c60d             					ldb		#CR					; end
f1e0 : f7d000           					stb		UART				
f1e3 : 39               					rts
                        ;}		
                        
                        ;-----------------------------------------------------
                        ; Send container data [Graph mode] (C call compatible)
                        ; param: 	2,s -> unused
                        ;			3,s -> index
                        ;			4-5,s -> pointer (16-bit) to max 32 bytes array "R
                        ; return:	none
                        ;-----------------------------------------------------
f1e4 :                  sendContainerData ;{
f1e4 : bdf2b7           sendCont			lbsr	waitSendDone
f1e7 : bdf2bf           					lbsr	waitCTS
f1ea : 3410             					pshs	x					; save used pointers (+2 bytes on stac
f1ec : c644             					ldb		#'D'				; sending
f1ee : f7d000           					stb		UART
f1f1 : c664             					ldb		#'d'				; cmd
f1f3 : f7d000           					stb		UART
f1f6 : c650             					ldb		#32+'0'				; len 32 bytes
f1f8 : f7d000           					stb		UART
f1fb : e665             					ldb		5,s					; 3,s +2 bytes, container index
f1fd : f7d000           					stb		UART
f200 : ae66             					ldx		6,s					; 4,s +2 bytes
f202 : c620             					ldb		#32
f204 : a680             _sendCtnData1		lda		,x+
f206 : b7d000           					sta 	UART  				; data 1 to 32
f209 : bdf2b7           					lbsr	waitSendDone		; check again when more than 1
f20c : bdf2bf           					lbsr	waitCTS
f20f : 5a               					decb
f210 : 26f2             					bne		_sendCtnData1					
f212 : c60d             					ldb		#CR					; end
f214 : f7d000           					stb		UART				
f217 : 3590             					puls	x,pc				; restore the register(s) and return
                        
                        ;-----------------------------------------------------
                        ; Set DateTime (C call compatible). This cmd triggers 
                        ; param: 	2,s -> SS or DD
                        ;			3,s -> MM or MM
                        ;			4,s -> HH or YY
                        ;			5,s -> 't' or 'd'
                        ; return:	none
                        ;-----------------------------------------------------
f219 :                  setDateTime ;{
f219 : bdf2b7           					lbsr	waitSendDone
f21c : bdf2bf           					lbsr	waitCTS
f21f : c644             					ldb		#'D'				; sending
f221 : f7d000           					stb		UART
f224 : e665             					ldb		5,s
f226 : c164             					cmpb	#'d'
f228 : 2704             					beq		setDT_01
f22a : c669             					ldb		#'i'				; cmd t'I'me
f22c : 2002             					bra		setDT_02
f22e : c661             setDT_01			ldb		#'a'				; cmd d'A'te
AS09 Assembler for M6809 [1.42].                                     Page  249
--------------------------------- merge.a09 ----------------------------------

f230 : f7d000           setDT_02			stb		UART				; end execution same as set da
f233 : e664             					ldb		4,s
f235 : cb30             					addb	#'0'
f237 : f7d000           					stb		UART
f23a : e663             					ldb		3,s
f23c : cb30             					addb	#'0'
f23e : f7d000           					stb		UART
f241 : e662             					ldb		2,s
f243 : cb30             					addb	#'0'
f245 : f7d000           					stb		UART
f248 : c60d             					ldb		#CR					; end
f24a : f7d000           					stb		UART
f24d : 39               					rts
                        ;}
                        	
                        ;-----------------------------------------------------
                        ; delay in ms (C call compatible)
                        ; param: 	2-3,s -> delay value (16-bit)
                        ; return:	none
                        ;-----------------------------------------------------
                        ; msDelay ;{
                        					; ldd		#282		; 3 cycles
                        ; _msDelay0			subd	#1			; 4 cycles
                        					; bne		_msDelay0	; 3 cycles
                        					; ldd		2,s			; 5 cycles
                        					; subd	#1			; 4 cycles
                        					; std		2,s			; 5 cycles
                        					; cmpd	#0			; 5 cycles
                        					; bne		msDelay		; 3 cycles
                        					; rts
                        										; 3 + (4+3 cycles * 282) + 5+4+5+5+3 = 2000 
                        
                        ;}	;--------------------------------------------------
                        				code
                        				
                        * 
                        * PIAinit(pPort, DDR) unsigned char *pPort; unsigned c
                        *     *(pPort+1)	= 0x30; // Cx2 used as output, select
f24e :                  PIAinit
f24e : ae62             	ldx	2,s
f250 : c630             	ldb	#$30
f252 : e701             	stb	1,x
                        *     *pPort      = DDR;  // DDRx configured as: 1 for
f254 : e665             	ldb	5,s
f256 : e784             	stb	,x
                        * 
                        *     *(pPort+1)	= 0x34; // Cx2 used as output, select
f258 : c634             	ldb	#$34	
f25a : e701             	stb	1,x
                        *     *pPort		= 0x00; // IOs bits cleared	
f25c : 5f               	clrb
f25d : e784             	stb	,x
                        * }
f25f : 39               	rts
                        * 
                        
                        * 
                        * PIA_Out(pPort, value) unsigned char *pPort; unsigned
                        *     *pPort	= value;
f260 :                  PIA_Out
f260 : e665             	ldb	5,s
f262 : e7f802           	stb	[2,s]
AS09 Assembler for M6809 [1.42].                                     Page  250
--------------------------------- merge.a09 ----------------------------------

                        * }
f265 : 39               	rts
                        * 
                        * PIA_In(pPort) unsigned char *pPort; {
                        *     return *pPort;
f266 :                  PIA_In
f266 : e6f802           	ldb	[2,s]	
f269 : 4f               	clra
                        * }
f26a : 39               	rts
                        * 
                        * PIA_SetCx2(pPort) unsigned char *pPort; {
                        *     *(pPort+1)	= *(pPort+1) | 0b00001000; // set bit
f26b :                  PIA_SetC
f26b : ae62             	ldx	2,s
f26d : e601             	ldb	1,x
f26f : ca08             	orb	#$8
f271 : ae62             	ldx	2,s
f273 : e701             	stb	1,x
                        * }
f275 : 39               	rts
                        * 
                        * PIA_ClrCx2(pPort) unsigned char *pPort; {
                        *     *(pPort+1)	= *(pPort+1) & 0b11110111;// clear bi
f276 :                  PIA_ClrC
f276 : ae62             	ldx	2,s
f278 : e601             	ldb	1,x
f27a : c4f7             	andb #$f7
f27c : ae62             	ldx	2,s
f27e : e701             	stb	1,x
                        * }
f280 : 39               	rts
                        * ;---------------------------------------------------
                        				code
                        				
                        ;----------------------------------------------------;
                        ; UART Init
                        ; param: 	none
                        ; return:	none
                        ;----------------------------------------------------;
f281 :                  UART_Init	;{
f281 : 8680             				lda		#$80			; DLAB=1
f283 : b7d003           				sta		UART+3
                        				
                        										; 12MHz ->  78:baudrate 9600,               
                        										; 16MHz -> 104:baudrate 9600, 26:baudrate 38
                        										; 24MHz -> 156:baudrate 9600, 39:baudrate 38
f286 : 8611             				lda		#17
f288 : b7d000           				sta		UART
f28b : 8600             				lda		#$00	  	
f28d : b7d001           				sta		UART+1
                        				
f290 : 8601             				lda		#$01	  		; Fifo enable
f292 : b7d002           				sta		UART+2
                        				
f295 : 8603             				lda		#$03			; DLAB=0, config 8N1 
f297 : b7d003           				sta		UART+3
                        				
f29a : 8601             				lda		#$01			; enable rx interrrupt
f29c : b7d001           				sta		UART+1
f29f : 39               				rts
                        ;}
AS09 Assembler for M6809 [1.42].                                     Page  251
--------------------------------- merge.a09 ----------------------------------

                        
                        ;----------------------------------------------------;
                        ; UART Read
                        ; param: 	none
                        ; return:	read byte -> B when when A != 0
                        ;----------------------------------------------------;
f2a0 :                  UartRead ;{
f2a0 : b6d005           				lda		UART+5 			; check if a byte is available
f2a3 : 8401             				anda	#1				; a contains not NULL when a byte avail
f2a5 : 2703             				beq		_UartRead1
f2a7 : f6d000           				ldb 	UART   			; read first byte
f2aa : 39               _UartRead1		rts
                        ;}
                        
                        ;----------------------------------------------------;
                        ; wait until a char available or 256 polling cycles ti
                        ; param: 	none
                        ; return:	none
                        ;----------------------------------------------------;
f2ab :                  waitdata ;{		
f2ab : 5f               				clrb
f2ac : 5a               _waitdata1		decb
f2ad : 2707             				beq		_waitdata2 		; exit
f2af : b6d005           				lda		UART+5 			; check if a byte is available
f2b2 : 8401             				anda	#1
f2b4 : 27f6             				beq		_waitdata1		
f2b6 : 39               _waitdata2		rts
                        ;}
                        
                        ;----------------------------------------------------;
                        ; wait until the remaining char is sent (fifo empty)
                        ; param: 	none
                        ; return:	none
                        ;----------------------------------------------------;
f2b7 :                  waitSendDone ;{
f2b7 : b6d005           				lda		UART+5 			; check if uart TX ready (waiting f
f2ba : 8420             				anda	#$20
f2bc : 27f9             				beq		waitSendDone		
f2be : 39               				rts
                        ;}
                        
                        ;----------------------------------------------------;
                        ; wait CTS
                        ; param: 	none
                        ; return:	none
                        ;----------------------------------------------------;
f2bf :                  waitCTS ;{
f2bf : b6d006           				lda		UART+6 			; read the moden status register
f2c2 : 8410             				anda	#$10
f2c4 : 27f9             				beq		waitCTS
f2c6 : 39               				rts
                        ;}
                        ;{ ---------------------------------------------------
                        					code
                        					
f2c7 : 302e392e302e3000 MON_VERSION     	db		"0.9.0.0",0			; version [major, m
                        					
                        ;---------------------------------------------------
                        ; write commands menu with version in terminal
                        ;---------------------------------------------------
f2cf : 0d737461727469.. STR_MONITOR      	db      CR,"starting monitor process
f2ed : 0d4d6f6e69746f.. STR_VERSION			db		CR,"Monitor for 6809 Computer v",0
AS09 Assembler for M6809 [1.42].                                     Page  252
--------------------------------- merge.a09 ----------------------------------

f30a : 0d636f6d6d616e.. STR_COMMAND			db		CR,"command menu",CR
f318 : 72205b66697273.. 					db		"r [first addr] (optional [n repeat]) reads t
f351 : 77205b61646472.. 					db		"w [addr] [data], optional [n repeat] writes 
f38e : 65205b7372635d.. 					db		"e [src] [dst] [length] (optional [protection
f3d4 : 6c206f72206c20.. 					db		"l or l [offset] loads a SRec data",CR
f3f6 : 67205b61646472.. 					db		"g [addr] executes at the address",CR
f417 : 73205b70726f63.. 					db		"s [process ID] stops the process",CR
f438 : 62205b61646472.. 					db		"b [addr] sets debugging mode a breakpoint at
f471 : 71207175697473.. 					db		"q quits debugging mode",CR
f488 : 42205b42415349.. 					db		"B [BASIC line entry]",CR
f49d : 4c206c6f616473.. 					db		"L loads a BASIC program",CR
f4b5 : 68207468697320.. 					db		"h this menu",CR,0
                        
f4c2 : cc0000           sMONITORSTART		ldd		#BrkPtOff			; init break point var
f4c5 : fd7fb9           					std		BrkPtAddr										
f4c8 : bdf4f7           					lbsr	sRbInit				; monitor init ring buffer
f4cb : 1cef             					andcc	#ENABLE_MON_INT		; enable monitor interrupt
                        					
f4cd : 8ef2cf           					ldx		#STR_MONITOR		; monitor start-up message
f4d0 : bdfaf1           					lbsr	sPUTSTR				;	
f4d3 : c610             					ldb		#MONITOR_PROCESS_ID
f4d5 : 3406             					pshs	d
f4d7 : bdfca2           					lbsr	HEXBYTE2MONPORT
f4da : c60d             					ldb		#CR
f4dc : 3406             					pshs	d
f4de : bdfcc2           					lbsr	BYTE2MONPORT
f4e1 : 3264             					leas	4,s					; clear 2 pushes
f4e3 : 39               					rts
                        												; print help menu at startup
f4e4 : 8ef2ed           sMONITORMENU		ldx		#STR_VERSION
f4e7 : bdfaf1           					lbsr	sPUTSTR
f4ea : 8ef2c7           					ldx		#MON_VERSION
f4ed : bdfaf1           					lbsr	sPUTSTR
f4f0 : 8ef30a           					ldx		#STR_COMMAND
f4f3 : bdfaf1           					lbsr	sPUTSTR
f4f6 : 39               					rts
                        
                        	;{ --------------------------------------------------
f4f7 :                  sRbInit	
                        		;---------------------------------------------------
                        		; asm call init ring buffer
                        		;---------------------------------------------------
                        		;{
f4f7 : 7f7fbc           					clr		RbHead
f4fa : 7f7fbd           					clr		RbTail
f4fd : 7f7fde           					clr		RbDectCR
f500 : 39               					rts
                        		;}
                        
f501 :                  sRbReadCmd 
                        		;---------------------------------------------------
                        		; asm call read a byte from ringbuffer (a 'CR' must 
                        		; param:	none
                        		; return:	cmd value -> A. when invalid, NULL -> B
                        		;---------------------------------------------------
                        		;{
f501 : 5f               					clrb						; no char by default
f502 : b67fde           					lda		RbDectCR
f505 : 2724             					beq		_sRbRead3			; still no CR in the cmd buffer
                        		
f507 : f67fbd           sRbRead				ldb		RbTail
f50a : f17fbc           					cmpb	RbHead
AS09 Assembler for M6809 [1.42].                                     Page  253
--------------------------------- merge.a09 ----------------------------------

f50d : 2716             					beq		_sRbRead11			; fifo empty when tail = head
f50f : 3410             					pshs	x
f511 : 8e7fbe           					ldx		#Rbuffer
f514 : a685             					lda		b,x
f516 : 3510             					puls	x
f518 : 5c               					incb						; inc tail index
f519 : c120             					cmpb	#RbSize
f51b : 2501             					blo		_sRbRead1
f51d : 5f               					clrb						; wrap RbTail
f51e : f77fbd           _sRbRead1			stb		RbTail				; save updated tail index o
f521 : c601             					ldb		#1					; not null when valid
f523 : 2004             					bra		_sRbRead2
f525 : 7f7fde           _sRbRead11			clr		RbDectCR			; no more CR possible
f528 : 5f               					clrb						; no char
f529 : 1cef             _sRbRead2			andcc	#ENABLE_MON_INT		; re-enable int in 
f52b : 39               _sRbRead3			rts
                        
                        	;}
                        
f52c :                  sMonProcessCmd
                        		;---------------------------------------------------
                        		; asm call extract and execute the cmd
                        		;---------------------------------------------------
                        		;{
f52c : 8dd3             					bsr		sRbReadCmd
f52e : 5d               					tstb						; RB empty ?
f52f : 273e             					beq		_sMonProcessCmd					
f531 : 8168             					cmpa	#'h'
f533 : 273b             					beq		sCMDhelp 			; help command
f535 : 8172             					cmpa	#'r'
f537 : 2746             					beq		sCMDrd  			; read command
f539 : 8177             					cmpa	#'w'
f53b : 102700b6         					lbeq	sCMDwr  			; write command
f53f : 8165             					cmpa	#'e'
f541 : 1027019b         					lbeq	sCMDew 				; eeprom write command
f545 : 816c             					cmpa	#'l'
f547 : 1027028d         					lbeq	sCMDld  			; load SRec command
f54b : 8167             					cmpa	#'g'
f54d : 10270367         					lbeq	sCMDgo  			; Go command
f551 : 8173             					cmpa	#'s'
f553 : 102703a1         					lbeq	sCMDStp  			; Stop process command
f557 : 8162             					cmpa	#'b'
f559 : 102703fe         					lbeq	sCMDbp  			; breakpoint command
f55d : 8171             					cmpa	#'q'
f55f : 1027047c         					lbeq	sCMDqbp  			; stop debugging command
f563 : 8142             					cmpa	#'B'
f565 : 10270505         					lbeq	sCMDbas  			; BASIC line entry command
f569 : 814c             					cmpa	#'L'
f56b : 102704bc         					lbeq	sCMDldbas			; load BASIC program command
f56f : 39               _sMonProcessCmd		rts  						; cmd no existing
                        
                        			;--------------------------------------------------
f570 : 8d8f             sCMDhelp 			bsr		sRbReadCmd
f572 : 5d               					tstb
f573 : 2709             					beq		_sCMDhelp				
f575 : 810d             					cmpa	#CR
f577 : 1026052b         					lbne	sCMDinvalid  		; not CR, invalid CMD
f57b : bdf4e4           					lbsr	sMONITORMENU
f57e : 39               _sCMDhelp			rts							; exit
                        			
                        			;--------------------------------------------------
f57f :                  sCMDrd
AS09 Assembler for M6809 [1.42].                                     Page  254
--------------------------------- merge.a09 ----------------------------------

0000 =                  RdAddr				equ		0					; uint RdAddr index
0002 =                  RdRepeat			equ		2					; uint Count index
f57f : 3440             					pshs	u
f581 : 327e             					leas	-2,s				; allocate 16-bit
f583 : 327e             					leas	-2,s				; allocate 16-bit
f585 : 33e4             					leau	,s					; use the U as pointer
f587 : 4f               					clra
f588 : 5f               					clrb
f589 : ed42             					std		RdRepeat,u 			; set to 0 by default
                        				
                        					;------- extract the ' ' only -------------------
f58b : bdfaad           					lbsr	sCMDextr
f58e : c120             					cmpb	#' '
f590 : 2615             					bne		_sCMDrdinvalid	
                        				
                        					;------- extract 'raddr' --------------------
f592 : bdfaad           					lbsr	sCMDextr
f595 : 5d               					tstb
f596 : 270f             					beq		_sCMDrdinvalid
f598 : afc4             					stx		RdAddr,u 			; save read param 1
f59a : c10d             					cmpb	#CR					; check if a repeat param follows
f59c : 2714             					beq		_sCMDexe_rd0
                        				
                        					;------- extract the optional 'repeat' ----------
f59e : bdfaad           					lbsr	sCMDextr
f5a1 : af42             					stx		RdRepeat,u 			; save read param 2
f5a3 : c10d             					cmpb	#CR
f5a5 : 270b             					beq		_sCMDexe_rd0
f5a7 : bdfaa6           _sCMDrdinvalid		lbsr	sCMDinvalid
f5aa : 2042             					bra		_sCMDrddone
                        				
f5ac : 0d7265616400     STR_CMD_rd			db		CR,"read",0
f5b2 : 8ef5ac           _sCMDexe_rd0		ldx		#STR_CMD_rd
f5b5 : bdfaf1           					lbsr	sPUTSTR
                        				
f5b8 : c60d             _sCMDexe_rd1   		ldb		#CR
f5ba : bdee42           					lbsr	sMON_PORT_WR		; CR when begin with addr
f5bd : ecc4             					ldd		RdAddr,u
f5bf : 3406             					pshs	d
f5c1 : bdfc6d           					lbsr	HEXWORD2MONPORT
f5c4 : 3262             					leas	2,s
f5c6 : c620             _sCMDexe_rd2		ldb		#' '
f5c8 : bdee42           					lbsr	sMON_PORT_WR
f5cb : e6d4             					ldb		[RdAddr,u]
f5cd : 3406             					pshs	d
f5cf : bdfca2           					lbsr	HEXBYTE2MONPORT
f5d2 : 3262             					leas	2,s
f5d4 : ec42             					ldd		RdRepeat,u
f5d6 : 10830000         					cmpd	#0
f5da : 2712             					beq		_sCMDrddone
f5dc : 830001           					subd	#1
f5df : ed42             					std		RdRepeat,u
f5e1 : ecc4             					ldd		RdAddr,u
f5e3 : c30001           					addd	#1
f5e6 : edc4             					std		RdAddr,u
f5e8 : c41f             					andb	#$1f
f5ea : 27cc             					beq		_sCMDexe_rd1		; write addr at begin
f5ec : 20d8             					bra		_sCMDexe_rd2
f5ee : 3262             _sCMDrddone			leas	2,s					; free 16-bit param 2
f5f0 : 3262             					leas	2,s					; free 16-bit param 1
f5f2 : 3540             					puls	u
f5f4 : 39               					rts  						; exit
AS09 Assembler for M6809 [1.42].                                     Page  255
--------------------------------- merge.a09 ----------------------------------

                        
                        ;----------------------------------------------------;
f5f5 :                  sCMDwr
0000 =                  WrAddr				equ		0					; uint WrAddr index
0002 =                  WrData				equ		2					; uchar WrData index
0003 =                  WrRepeat			equ		3					; uint repeat
f5f5 : 3440             					pshs	u
f5f7 : 327e             					leas	-2,s				; allocate 16-bit
f5f9 : 327f             					leas	-1,s				; allocate 8-bit
f5fb : 327e             					leas	-2,s				; allocate 16-bit
f5fd : 33e4             					leau	,s					; use the U as pointer
f5ff : 4f               					clra
f600 : 5f               					clrb
f601 : ed43             					std		WrRepeat,u 			; set to 0 by default
                        					
                        					;------- extract the ' ' only -------------------
f603 : bdfaad           					lbsr	sCMDextr
f606 : c120             					cmpb	#' '
f608 : 262c             					bne		_sCMDwrInvalid
                        
                        					;------- extract 'waddr' --------------------
f60a : bdfaad           					lbsr	sCMDextr
f60d : c10d             					cmpb	#CR
f60f : 2725             					beq		_sCMDwrInvalid		; CR shall come later
f611 : c120             					cmpb	#' '
f613 : 2621             					bne		_sCMDwrInvalid		
f615 : 8ce000           					cmpx	#ROM0_ORG			; avoid write in ROM
f618 : 241c             					bhs		_sCMDwrInvalid
f61a : afc4             					stx		WrAddr,u 			; save read param 1
                        					
                        					;------- extract 'wdata' --------------------
f61c : bdfaad           					lbsr	sCMDextr
f61f : 1e10             					exg		x,d
f621 : e742             					stb		WrData,u 			; save read param 2
f623 : 1e10             					exg		x,d
f625 : c10d             					cmpb	#CR					; check if param ended
f627 : 271a             					beq		_sCMDwr1
f629 : c120             					cmpb	#' '				; check if a repeat param follows
f62b : 2609             					bne		_sCMDwrInvalid				
                        					
                        					;------- extract the optional 'repeat' ----------
f62d : bdfaad           					lbsr	sCMDextr
f630 : af43             					stx		WrRepeat,u 			; save read param 3
f632 : c10d             					cmpb	#CR
f634 : 270d             					beq		_sCMDwr1				
                        				
f636 : bdfaa6           _sCMDwrInvalid		lbsr	sCMDinvalid
f639 : 204812           					lbra	_sCMDwrdone
                        				
f63c : 0d777269746500   STR_CMD_wr			db		CR,"write",0
f643 : 8ef63c           _sCMDwr1			ldx		#STR_CMD_wr
f646 : bdfaf1           					lbsr	sPUTSTR
f649 : c60d             _sCMDexe_wr1     	ldb		#CR					; CR when begin with ad
f64b : bdee42           					lbsr	sMON_PORT_WR
f64e : ecc4             					ldd		WrAddr,u
f650 : 3406             					pshs	d
f652 : bdfc6d           					lbsr	HEXWORD2MONPORT
f655 : 3262             					leas	2,s
f657 : c620             _sCMDexe_wr2		ldb		#' '
f659 : bdee42           					lbsr	sMON_PORT_WR
f65c : e642             					ldb		WrData,u
f65e : 3406             					pshs	d
AS09 Assembler for M6809 [1.42].                                     Page  256
--------------------------------- merge.a09 ----------------------------------

f660 : bdfca2           					lbsr	HEXBYTE2MONPORT
f663 : 3262             					leas	2,s
f665 : a642             					lda		WrData,u
f667 : a7d4             					sta		[WrAddr,u]			; perform the write
f669 : ec43             					ldd		WrRepeat,u
f66b : 10830000         					cmpd	#0
f66f : 2712             					beq		_sCMDwrdone
f671 : 830001           					subd	#1
f674 : ed43             					std		WrRepeat,u
f676 : ecc4             					ldd		WrAddr,u
f678 : c30001           					addd	#1
f67b : edc4             					std		WrAddr,u
f67d : c41f             					andb	#$1f
f67f : 27c8             					beq		_sCMDexe_wr1		; write addr at begin
f681 : 20d4             					bra		_sCMDexe_wr2
                        	
f683 : 3262             _sCMDwrdone			leas	2,s					; free 16-bit param 3
f685 : 3261             					leas	1,s					; free 8-bit param 2
f687 : 3262             					leas	2,s					; free 16-bit param 1
f689 : 3540             					puls	u
f68b : 39               					rts							; exit
                        
                        ;----------------------------------------------------;
f68c : 0d77726974696e.. STR_EW1				db		CR,"writing ",0
f696 : 20627974652873.. STR_EW2				db		" byte(s) from ",0
f6a5 : 20746f2000       STR_EW3				db		" to ",0
f6aa : 2c20706c656173.. STR_EW4				db		", please wait ...",0
f6bc : 0d656570726f6d.. STR_EWdone			db		CR,"eeprom writing done, ",0
f6d3 : 436865636b5375.. STR_EW_CS			db		"CheckSum16: ",0
f6e0 : 3440             sCMDew				pshs	u					; save register(s)
                        					;------- extract ' ' --------------------
f6e2 : bdfaad           					lbsr	sCMDextr
f6e5 : c120             					cmpb	#' '
f6e7 : 262f             					bne		_sCMDewInvalid0					
                        					
                        					;------- extract 'src' until ' ' ----------------
f6e9 : bdfaad           					lbsr	sCMDextr
f6ec : 3410             					pshs	x					; push WriteEEP param 1 (src)
f6ee : c120             					cmpb	#' '
f6f0 : 2624             					bne		_sCMDewInvalid1					
                        					
                        					;------- extract 'dst'until' ' ------------------
f6f2 : bdfaad           					lbsr	sCMDextr
f6f5 : 3410             					pshs	x 					; push WriteEEP param 2 (dst)
f6f7 : c120             					cmpb	#' '
f6f9 : 2619             					bne		_sCMDewInvalid2								
                        					
                        					;------- extract 'len'until' ' ------------------
f6fb : bdfaad           					lbsr	sCMDextr
f6fe : 3410             					pshs	x 					; push WriteEEP param 3 (len)
f700 : 8e0000           					ldx		#0					; no protection param by default
f703 : c10d             					cmpb	#CR
f705 : 2717             					beq		_sCMDew1			; no protection param
f707 : c120             					cmpb	#' '
f709 : 2607             					bne		_sCMDewInvalid3					
                        					
                        					;------- extract 'protection'until'CR' ----------
f70b : bdfaad           					lbsr	sCMDextr					
f70e : c10d             					cmpb	#CR
f710 : 270c             					beq		_sCMDew1				; branch when OK, otherwise free
f712 : 3262             _sCMDewInvalid3		leas	2,s					; free WriteEEP param 3
f714 : 3262             _sCMDewInvalid2		leas	2,s					; free WriteEEP param 2
AS09 Assembler for M6809 [1.42].                                     Page  257
--------------------------------- merge.a09 ----------------------------------

f716 : 3262             _sCMDewInvalid1		leas	2,s					; free WriteEEP param 1
f718 : bdfaa6           _sCMDewInvalid0		lbsr	sCMDinvalid
f71b : 205f12           					lbra	_sCMDewdone
                        
f71e : 3410             _sCMDew1			pshs	x 					; WriteEEP param 4 (protection)
f720 : 33e4             					leau	0,s					; use U as parameter pointer
f722 : 8ef68c           					ldx		#STR_EW1
f725 : bdfaf1           					lbsr	sPUTSTR
f728 : ec42             					ldd		2,u					; print param 3 (length in byte)
f72a : 3406             					pshs	d
f72c : bdfc6d           					lbsr	HEXWORD2MONPORT
f72f : 3262             					leas	2,s
f731 : 8ef696           					ldx		#STR_EW2
f734 : bdfaf1           					lbsr	sPUTSTR
f737 : ec46             					ldd		6,u					; print param 2 (source)
f739 : 3406             					pshs	d
f73b : bdfc6d           					lbsr	HEXWORD2MONPORT
f73e : 3262             					leas	2,s
f740 : 8ef6a5           					ldx		#STR_EW3
f743 : bdfaf1           					lbsr	sPUTSTR
f746 : ec44             					ldd		4,u					; print param 1 (destination)
f748 : 3406             					pshs	d
f74a : bdfc6d           					lbsr	HEXWORD2MONPORT
f74d : 3262             					leas	2,s
f74f : 8ef6aa           					ldx		#STR_EW4
f752 : bdfaf1           					lbsr	sPUTSTR
                        					
f755 : bdfb0b           					lbsr	WriteEEP
f758 : 8ef6bc           					ldx		#STR_EWdone
f75b : bdfaf1           					lbsr	sPUTSTR
                        					
f75e : 8ef6d3           					ldx		#STR_EW_CS
f761 : bdfaf1           					lbsr	sPUTSTR
f764 : ec44             					ldd		4,u					; Checksum calculated in ROM. Take W
f766 : 3406             					pshs	d					; push as 1st arg (CheckSum16 begin ad
f768 : e342             					addd	2,u					; add WriteEEP length in byte
f76a : 3406             					pshs	d					; push as 2nd arg (CheckSum16 end addr
f76c : 4f               					clra						; initial CheckSum16 value shall be 0
f76d : 5f               					clrb
f76e : 3406             					pshs	d					; push as 3rd arg
f770 : bdfc39           					lbsr	getCheckSum16
f773 : 3266             					leas	6,s					; free the 3 args					
f775 : 3406             					pshs	d
f777 : bdfc6d           					lbsr	HEXWORD2MONPORT
f77a : 3262             					leas	2,s
f77c : 3268             _sCMDewdone			leas	8,s					; free the WriteEEP 4 param
f77e : 35c0             					puls	u,pc  				; restore u and return				
                        						
                        ;----------------------------------------------------;
f780 : 0d73656e64206e.. STR_CMD_LD			db		CR,"send now the SRec data, Offset=",
f7a1 : 20627974652873.. STR_CMD_LD2			db		" byte(s) @ addr:",0
f7b2 : 72656365707469.. STR_CMD_LD3			db		"reception completed",CR,0
f7c7 : 20636865636b73.. STR_CMD_LD4			db		" checksum error!",0
0000 =                  ByteCount			equ		0					; uchar byte count index
0001 =                  SRecCheckSum		equ		1					; uchar SRecCheckSum index
0002 =                  Offset				equ		2					; uint Offset index
0004 =                  NewAddr				equ		4					; uint new address
f7d8 : 3440             sCMDld				pshs	u
f7da : 327e             					leas	-2,s				; allocate 16-bit Offset
f7dc : 327e             					leas	-2,s				; allocate 16-bit Offset
f7de : 327f             					leas	-1,s				; allocate 8-bit SRecCheckSum
f7e0 : 327f             					leas	-1,s				; allocate 8-bit ByteCount
AS09 Assembler for M6809 [1.42].                                     Page  258
--------------------------------- merge.a09 ----------------------------------

f7e2 : 33e4             					leau	,s					; use the U as pointer
f7e4 : 4f               					clra
f7e5 : 5f               					clrb
f7e6 : ed42             					std		Offset,u 			; set to 0 by default
                        					
                        					;------- extract 'CR' or optional ' ''offset' ---
f7e8 : bdfaad           					lbsr	sCMDextr
f7eb : c10d             					cmpb	#CR					; no offset
f7ed : 270b             					beq		_sCMDld00
f7ef : c120             					cmpb	#' '
f7f1 : 261a             					bne		_sCMDldInvalid		; with offset data
                        					
                        					;------- extract optional 'offset' --------------
f7f3 : bdfaad           					lbsr	sCMDextr
f7f6 : c10d             					cmpb	#CR
f7f8 : 2613             					bne		_sCMDldInvalid					
                        					
f7fa : af42             _sCMDld00			stx		Offset,u			; save the offset data
f7fc : 8ef780           					ldx		#STR_CMD_LD
f7ff : bdfaf1           					lbsr	sPUTSTR
f802 : ec42             					ldd		Offset,u
f804 : 3406             					pshs	d
f806 : bdfc6d           					lbsr	HEXWORD2MONPORT
f809 : 3262             					leas	2,s
f80b : 2006             					bra		_sCMDld0
f80d : bdfaa6           _sCMDldInvalid		lbsr	sCMDinvalid
f810 : 7ef895           					lbra	_sCMDlddone
                        					;------- seek for 'S1' --------------------
f813 : bdf507           _sCMDld0			lbsr	sRbRead 			; read a byte
f816 : 5d               					tstb
f817 : 27fa             					beq		_sCMDld0
f819 : 8153             					cmpa	#'S'
f81b : 26f6             					bne		_sCMDld0
f81d : bdf507           _sCMDld01			lbsr	sRbRead 			; read a byte
f820 : 5d               					tstb
f821 : 27fa             					beq		_sCMDld01
f823 : 8131             					cmpa	#'1'
f825 : 266e             					bne		_sCMDlddone 		; the last line does not conta
f827 : 6f41             					clr		SRecCheckSum,u		; SRecCheckSum = 0
                        					
f829 : 8602             					lda		#2					; read byte count
f82b : bdfad1           					lbsr	sExtrNByte
f82e : 3404             					pshs	b
f830 : eb41             					addb	SRecCheckSum,u		; SRecCheckSum +=  bytecount
f832 : e741             					stb		SRecCheckSum,u
f834 : 3504             					puls	b
f836 : c003             					subb	#3					; 3 byte already read
f838 : e7c4             					stb		ByteCount,u
f83a : c60d             					ldb		#CR
f83c : bdee42           					lbsr	sMON_PORT_WR
f83f : e6c4             					ldb		ByteCount,u
f841 : 3406             					pshs	d
f843 : bdfca2           					lbsr	HEXBYTE2MONPORT
f846 : 3262             					leas	2,s
f848 : 8ef7a1           					ldx		#STR_CMD_LD2
f84b : bdfaf1           					lbsr	sPUTSTR
                        					
f84e : 8604             					lda		#4  				; read addr
f850 : bdfad1           					lbsr	sExtrNByte
f853 : ed44             					std	    NewAddr,u			; save addr
f855 : ab41             					adda	SRecCheckSum,u		; SRecCheckSum +=  addr hi
f857 : a741             					sta		SRecCheckSum,u
AS09 Assembler for M6809 [1.42].                                     Page  259
--------------------------------- merge.a09 ----------------------------------

f859 : eb41             					addb	SRecCheckSum,u		; SRecCheckSum +=  addr lo
f85b : e741             					stb		SRecCheckSum,u	
f85d : ec44             					ldd	    NewAddr,u			; addr -= offset
f85f : a342             					subd	Offset,u
f861 : ed44             					std	    NewAddr,u			; save new addr
f863 : 3406             					pshs	d
f865 : bdfc6d           					lbsr	HEXWORD2MONPORT
f868 : 3262             					leas	2,s
                        
f86a : 8602             _sCMDld1			lda		#2					; read data
f86c : bdfad1           					lbsr	sExtrNByte
f86f : 3404             					pshs	b
f871 : eb41             					addb	SRecCheckSum,u		; SRecCheckSum +=  data
f873 : e741             					stb		SRecCheckSum,u
f875 : 3504             					puls	b
f877 : ae44             					ldx	    NewAddr,u			; get new addr
f879 : e780             					stb     ,x+ 				; write to dst addr and inc
f87b : af44             					stx	    NewAddr,u			; save new addr
f87d : 6ac4             					dec		ByteCount,u
f87f : 26e9             					bne		_sCMDld1
                        						
f881 : 8602             					lda		#2					; read checksum
f883 : bdfad1           					lbsr	sExtrNByte
f886 : e841             					eorb	SRecCheckSum,u 		; checksum xor with sum sho
f888 : c1ff             					cmpb	#$ff
f88a : 2706             					beq		_sCMDld2
f88c : 8ef7c7           					ldx		#STR_CMD_LD4
f88f : bdfaf1           					lbsr	sPUTSTR
f892 : 7ef813           _sCMDld2			lbra	_sCMDld0
f895 : c60d             _sCMDlddone      	ldb		#CR
f897 : bdee42           					lbsr	sMON_PORT_WR
f89a : 8ef7b2           					ldx		#STR_CMD_LD3
f89d : bdfaf1           					lbsr	sPUTSTR
f8a0 : 3261             					leas	1,s					; free 8-bit
f8a2 : 3261             					leas	1,s					; free 8-bit
f8a4 : 3262             					leas	2,s					; free 16-bit
f8a6 : 3262             					leas	2,s					; free 16-bit
f8a8 : 3540             					puls	u
f8aa : 39               					rts							; exit
                        
                        ;----------------------------------------------------;
f8ab : 0d676f20616464.. STR_GO				db		CR,"go address ",0
f8b8 :                  sCMDgo				;------- extract ' ' --------------------
f8b8 : bdfaad           					lbsr	sCMDextr
f8bb : c120             					cmpb	#' '
f8bd : 2607             					bne		_sCMDgoInvalid
                        					
                        					;------- extract 'addr' with 'CR' ---------------
f8bf : bdfaad           					lbsr	sCMDextr
f8c2 : c10d             					cmpb	#CR								
f8c4 : 2705             					beq		_sCMDgo0			; missing addr param	
f8c6 : bdfaa6           _sCMDgoInvalid		lbsr	sCMDinvalid
f8c9 : 201d             					bra		_sCMDgodone
f8cb : 3410             _sCMDgo0         	pshs	x					; save go addr
f8cd : 8ef8ab           					ldx		#STR_GO
f8d0 : bdfaf1           					lbsr	sPUTSTR					
f8d3 : ece4             					ldd		0,s					; get go addr
f8d5 : 3406             					pshs	d
f8d7 : bdfc6d           					lbsr	HEXWORD2MONPORT
f8da : 3262             					leas	2,s
f8dc : ccffff           					ldd		#$ffff
f8df : 830001           _sCMDgo1			subd	#1
AS09 Assembler for M6809 [1.42].                                     Page  260
--------------------------------- merge.a09 ----------------------------------

f8e2 : 26fb             					bne		_sCMDgo1			; wait until MONPORT output proce
f8e4 : 3510             					puls	x
f8e6 : ad84             					jsr     ,x      			; execute @ addr
f8e8 : 39               _sCMDgodone			rts							; exit
                        
                        ;----------------------------------------------------;
f8e9 : 0d73746f702070.. STR_ST				db		CR,"stop process ",0
f8f8 :                  sCMDStp				;------- extract ' ' --------------------
f8f8 : bdfaad           					lbsr	sCMDextr
f8fb : c120             					cmpb	#' '
f8fd : 2607             					bne		_sCMDstpInvalid
                        					
                        					;------- extract 'process ID' with 'CR' ---------
f8ff : bdfaad           					lbsr	sCMDextr
f902 : c10d             					cmpb	#CR								
f904 : 2705             					beq		_sCMDstp0			; missing ID param	
f906 : bdfaa6           _sCMDstpInvalid		lbsr	sCMDinvalid
f909 : 201d             					bra		_sCMDstpdone
f90b : 3410             _sCMDstp0         	pshs	x					; save process ID
f90d : 8ef8e9           					ldx		#STR_ST
f910 : bdfaf1           					lbsr	sPUTSTR					
f913 : ece4             					ldd		0,s					; get process ID
f915 : 3406             					pshs	d
f917 : bdfca2           					lbsr	HEXBYTE2MONPORT
f91a : 3262             					leas	2,s
f91c : 3506             					puls	d
f91e : c120             					cmpb	#BASIC_PROCESS_ID
f920 : 2606             					bne		_sCMDstpdone
f922 : 7f7ff0           					clr		BasicCallBack		; void the next callback addr
f925 : 7f7ff1           					clr		BasicCallBack+1
f928 : 39               _sCMDstpdone		rts							; exit
                        
                        ;----------------------------------------------------;
f929 : 0d736574206272.. STR_BP				db		CR,"set breakkpoint address ",0
f943 : 0d627265616b6b.. STR_BP1				db		CR,"breakkpoint existing! ",0
f95b :                  sCMDbp				;------- extract ' ' --------------------
f95b : bdfaad           					lbsr	sCMDextr
f95e : c120             					cmpb	#' '
f960 : 2615             					bne		_sCMDbpInvalid
                        					
                        					;------- extract addr param with 'CR ' ----------
f962 : bdfaad           					lbsr	sCMDextr
f965 : c10d             					cmpb	#CR
f967 : 260e             					bne		_sCMDbpInvalid
                        					
f969 : 8c0000           					cmpx	#RAM_ORG			; validate address within RAM
f96c : 2509             					blo		_sCMDbpInvalid
f96e : 8c7fff           					cmpx	#RAM_END
f971 : 2204             					bhi		_sCMDbpInvalid
                        					
f973 : 3410             					pshs	x 					; save bp addr
f975 : 2005             					bra		_sCMDbp1
f977 : bdfaa6           _sCMDbpInvalid		lbsr	sCMDinvalid
f97a : 2036             					bra		_sCMDbpdone
f97c : fc7fb9           _sCMDbp1         	ldd		BrkPtAddr			; verify if breakpo
f97f : 10830000         					cmpd	#BrkPtOff
f983 : 270e             					beq		_sCMDbp2			; breakpoint not existing
f985 : 10830001         					cmpd	#BrkPtTriggered
f989 : 2708             					beq		_sCMDbp2			; breakpoint can be set again				
f98b : 8ef943           					ldx		#STR_BP1
f98e : bdfaf1           					lbsr	sPUTSTR
f991 : 201f             					bra		_sCMDbpdone
AS09 Assembler for M6809 [1.42].                                     Page  261
--------------------------------- merge.a09 ----------------------------------

f993 : 8ef929           _sCMDbp2			ldx		#STR_BP
f996 : bdfaf1           					lbsr	sPUTSTR
f999 : 3506             					puls	d					; restore bp addr
f99b : fd7fb9           					std		BrkPtAddr			; save addr
f99e : 3406             					pshs	d
f9a0 : bdfc6d           					lbsr	HEXWORD2MONPORT
f9a3 : 3262             					leas	2,s
f9a5 : a69f7fb9         					lda		[BrkPtAddr]			; save instruction
f9a9 : b77fbb           					sta		BrkPtInst
f9ac : 863f             					lda		#$3f				;swi instruction
f9ae : a79f7fb9         					sta		[BrkPtAddr]			;replace by swi
f9b2 : 39               _sCMDbpdone			rts							; exit
                        
                        ;----------------------------------------------------;
f9b3 : 0d717569742064.. STR_QBP				db		CR,"quit debugging mode",0
f9c8 : 0d6e6f7420696e.. STR_QBP1			db		CR,"not in debugging mode",0
f9df : fc7fb9           sCMDqbp	    	    ldd		BrkPtAddr			; verify if breakpoi
f9e2 : 10830000         					cmpd	#BrkPtOff			; Off when not in debug mode
f9e6 : 271f             					beq		_sCMDqbp1	
f9e8 : 3406             					pshs	d
f9ea : 8ef9b3           					ldx		#STR_QBP
f9ed : bdfaf1           					lbsr	sPUTSTR
f9f0 : 3506             					puls	d
f9f2 : 10830001         					cmpd	#BrkPtTriggered		; was triggered
f9f6 : 2707             					beq		_sCMDqbp0
f9f8 : b67fbb           					lda		BrkPtInst
f9fb : a79f7fb9         					sta		[BrkPtAddr]			; replace initial instruction 
f9ff : cc0000           _sCMDqbp0			ldd		#BrkPtOff	
fa02 : fd7fb9           					std		BrkPtAddr			; place in off state
fa05 : 2006             					bra		_sCMDqbpdone				
fa07 : 8ef9c8           _sCMDqbp1			ldx		#STR_QBP1
fa0a : bdfaf1           					lbsr	sPUTSTR
fa0d : 39               _sCMDqbpdone		rts							; exit
                        
                        
                        ;----------------------------------------------------;
fa0e : 0d73656e64206e.. STR_CMD_LDBAS		db		CR,"send now the BAS file",CR,0
fa26 : 454e440d00       STR_CMD_LDBASEND	db		"END",CR,0
fa2b : bdf501           sCMDldbas			lbsr	sRbReadCmd
fa2e : 5d               					tstb
fa2f : 10270073         					lbeq	sCMDinvalid				
fa33 : 810d             					cmpa	#CR
fa35 : 1026006d         					lbne	sCMDinvalid  		; not CR, invalid CMD
fa39 : 8efa0e           					ldx		#STR_CMD_LDBAS
fa3c : bdfaf1           					lbsr	sPUTSTR
                        										
                        					;------- read until 'END' --------------------
fa3f : 8efa26           _sCMDldbas0 		ldx		#STR_CMD_LDBASEND
fa42 : bdf507           _sCMDldbas1			lbsr	sRbRead 			; read a byte					
fa45 : 5d               					tstb
fa46 : 27fa             					beq		_sCMDldbas1
fa48 : 810a             					cmpa    #10
fa4a : 27f6             					beq		_sCMDldbas1			; remove LF
fa4c : 3412             					pshs	a,x
fa4e : 1f89             					tfr		a,b
fa50 : bdf0c1           					lbsr	sAPL_KeyboardData
fa53 : bdefff           _sCMDldbas2			lbsr	BASICprocess		; BASIC process call
fa56 : bdf0fb           					lbsr    isKeyboardData		; check if the data is pr
fa59 : 5d               					tstb
fa5a : 26f7             					bne		_sCMDldbas2			; loop until the data is compl
fa5c : 3512             					puls	x,a
fa5e : a180             					cmpa	,x+
AS09 Assembler for M6809 [1.42].                                     Page  262
--------------------------------- merge.a09 ----------------------------------

fa60 : 26dd             					bne		_sCMDldbas0
fa62 : 1f10             					tfr		x,d
fa64 : 83fa26           					subd	#STR_CMD_LDBASEND
fa67 : 10830004         					cmpd	#4
fa6b : 25d5             					blo		_sCMDldbas1
fa6d : 39               					rts
                        
                        ;----------------------------------------------------;
fa6e :                  sCMDbas				;------- extract ' ' ----------------------
fa6e : bdfaad           					lbsr	sCMDextr
fa71 : c120             					cmpb	#' '
fa73 : 2631             					bne		sCMDinvalid
                        					
                        					;------- extract 'BASIC code' with 'CR' ---------
fa75 : bdf507           _sCMDbas0			lbsr	sRbRead
fa78 : 5d               					tstb
fa79 : 2716             					beq		_sCMDbasdone
fa7b : 3402             					pshs    a
fa7d : 1f89             					tfr		a,b
fa7f : bdf0c1           					lbsr	sAPL_KeyboardData
fa82 : bdefff           _sCMDbas1			lbsr	BASICprocess		; BASIC process call
fa85 : bdf0fb           					lbsr    isKeyboardData		; check if the data is pr
fa88 : 5d               					tstb
fa89 : 26f7             					bne		_sCMDbas1			; loop until the data is complet
fa8b : 3502             					puls    a
fa8d : 810d             					cmpa    #CR					; CR ends the command
fa8f : 26e4             					bne		_sCMDbas0
fa91 : 39               _sCMDbasdone		rts	
                        
                        ;----------------------------------------------------;
fa92 : 0d696e76616c69.. STR_CMDinvalid		db		CR,"invalid command!!",CR,0
faa6 : 8efa92           sCMDinvalid			ldx		#STR_CMDinvalid
faa9 : bdfaf1           					lbsr	sPUTSTR
faac : 39               					rts
                        ;}
                        
                        ;----------------------------------------------------;
faad :                  sCMDextr ;{
                        ;---------------------------------------------------;
                        ; extract text command (converted in hex) until a ' ' 
                        ; param: 	none
                        ; return: 	cmd value -> X, end condition -> B (NULL wh
                        ;---------------------------------------------------;
faad : 8e0000           					ldx		#0					; clear
fab0 : bdf501           _sCMDextr0			lbsr	sRbReadCmd 			; read a byte
fab3 : 5d               					tstb
fab4 : 271a             					beq		_sCMDextrEnd			; RB empty, B is NULL
fab6 : 1f89             					tfr		a,b					; B contains the end condition
fab8 : 8120             					cmpa	#' '				; end value?
faba : 2714             					beq		_sCMDextrEnd  		; return value already in B
fabc : 810d             					cmpa	#CR					; or CR ends ?
fabe : 2710             					beq		_sCMDextrEnd  		; not expected
fac0 : bdfce8           					lbsr	sTEXT2HEX			; convert
fac3 : 3402             					pshs	a					; save new value on stack
fac5 : 1f10             					tfr		x,d
fac7 : bdfc55           					lbsr	sWLSL4bit
faca : ebe0             					addb	,s+					; add the new value and free 8-bit s
facc : 1f01             					tfr		d,x
face : 20e0             					bra		_sCMDextr0
fad0 : 39               _sCMDextrEnd     	rts
                        ;}
                        ;----------------------------------------------------;
AS09 Assembler for M6809 [1.42].                                     Page  263
--------------------------------- merge.a09 ----------------------------------

fad1 :                  sExtrNByte ;{
                        ;---------------------------------------------------
                        ; asm call extract (text to hex) 
                        ; param: 	A -> n byte to extract
                        ; return:	out value -> D		
                        ;---------------------------------------------------
fad1 : 3402             					pshs	a					; contains the count
fad3 : 8e0000           					ldx		#0					; clear
fad6 : bdf507           _sExtrNByte0		lbsr	sRbRead				; read a byte
fad9 : 5d               					tstb
fada : 27fa             					beq     _sExtrNByte0 		; loop until RB no more em
fadc : bdfce8           					lbsr	sTEXT2HEX			; convert
fadf : 3402             					pshs	a					; save
fae1 : 1f10             					tfr		x,d
fae3 : bdfc55           					lbsr	sWLSL4bit
fae6 : ebe0             					addb	,s+					; free 8-bit stack
fae8 : 1f01             					tfr		d,x
faea : 6ae4             					dec		,s					; decrease the count					
faec : 26e8             					bne		_sExtrNByte0
faee : 3261             _sExtrEnd        	leas	1,s					; puls, free end param
faf0 : 39               					rts
                        	;}
                        ;}
                        
                        ;----------------------------------------------------;
                        ; asm call send string on debug port
                        ; param: 	X -> pointer
                        ; return:	none
                        ;----------------------------------------------------;
faf1 : 3410             sPUTSTR         	pshs	x
faf3 : bdfc5e           					lbsr	PUTSTR
faf6 : 3262             					leas	2,s
faf8 : 39               					rts
                        ;}
                        
                        
                        
                        ;{ ---------------------------------------------------
                        					code
                        					
faf9 : b6d004           SELECTBANK0			lda		UART+4
fafc : 8a01             					ora		#%00000001		; clear ROM addr line DTR_n=1
fafe : b7d004           					sta		UART+4
fb01 : 39               					rts					
fb02 : b6d004           SELECTBANK1			lda		UART+4
fb05 : 84fe             					anda	#%11111110		; set ROM addr line DTR_n=0
fb07 : b7d004           					sta		UART+4
fb0a : 39               					rts
                        					
                        ;----------------------------------------------------;
                        ; write to EEPROM from RAM
                        ; param: 			0,s -> return addr
                        ;			4th arg:2,s -> protection 	-> 0,u
                        ;			3rd arg:4,s -> len			-> 2,u
                        ;			2nd arg:6,s -> dst 			-> 4,u
                        ;			1st arg:8,s -> src 			-> 6,u
                        ; return:	CheckSum16 value -> D
                        ;----------------------------------------------------;
fb0b : 3470             WriteEEP			pshs	u,y,x				; save used pointers (+6 byte
fb0d : 3368             					leau	8,s					; set 4th arg to 0,u (8 bytes totall
                        										
fb0f : ecc4             					ldd		0,u					; get the protection param					
AS09 Assembler for M6809 [1.42].                                     Page  264
--------------------------------- merge.a09 ----------------------------------

fb11 : 10830000         					cmpd	#0					; 1 is the XICOR protection
fb15 : 2702             					beq		_WriteEEP1
fb17 : 8d2d             					bsr		DISAXICORWP					
                        				
fb19 : 10ae44           _WriteEEP1			ldy		4,u					; get the params (X = src, Y
fb1c : ae46             					ldx		6,u	
fb1e : ec42             					ldd		2,u					; get length value
fb20 : 3406             					pshs	d					; create a length counter variable to 
                        					
fb22 : a680             _WriteEEP2			lda		,x+
fb24 : a1a4             					cmpa	,y
fb26 : 2705             					beq		_no_change
fb28 : a7a4             					sta		,y
fb2a : bdfbb4           					lbsr	DELAY_10MS			; eeprom 10 ms delay loop				
fb2d : 3121             _no_change			leay	1,y					; inc the pointer			
fb2f : ece4             					ldd		0,s					; dec length counter variable
fb31 : 830001           					subd	#1
fb34 : ede4             					std		0,s
fb36 : 26ea             					bne		_WriteEEP2
fb38 : 3262             					leas	2,s					; free the length counter
                        					
fb3a : ecc4             					ldd		0,u					; get the protection param
fb3c : 10830000         					cmpd	#0					; 1 is the XICOR protection
fb40 : 2702             					beq		_WriteEEP5
fb42 : 8d41             					bsr		ENAXICORWP				
fb44 : 35f0             _WriteEEP5			puls	x,y,u,pc			; restore used registers
                        
                        ;----------------------------------------------------;
                        ; asm call remove XICOR 28C64 / 28C256 eeprom write pr
                        ; param:  none
                        ; return: none
                        ;----------------------------------------------------;
fb46 : 3411             DISAXICORWP			pshs	ccr,x				; save ccr (for the disabl
fb48 : 1a50             					orcc	#%01010000			; disable interrupts				
fb4a : 8db6             					bsr		SELECTBANK1
fb4c : 8e9555           					ldx 	#$1555+ROM1_ORG  	; $1555 + base addr / $555
fb4f : 86aa             					lda		#$aa
fb51 : a784             					sta		,x
fb53 : 8da4             					bsr		SELECTBANK0
fb55 : 8eaaaa           					ldx 	#$2aaa+ROM1_ORG
fb58 : 8655             					lda		#$55
fb5a : a784             					sta		,x
fb5c : 8da4             					bsr		SELECTBANK1
fb5e : 8e9555           					ldx 	#$1555+ROM1_ORG
fb61 : 8680             					lda		#$80
fb63 : a784             					sta		,x
fb65 : 8e9555           					ldx 	#$1555+ROM1_ORG
fb68 : 86aa             					lda		#$aa
fb6a : a784             					sta		,x
fb6c : 8d8b             					bsr		SELECTBANK0
fb6e : 8eaaaa           					ldx 	#$2aaa+ROM1_ORG
fb71 : 8655             					lda		#$55
fb73 : a784             					sta		,x
fb75 : 8d8b             					bsr		SELECTBANK1
fb77 : 8e9555           					ldx 	#$1555+ROM1_ORG
fb7a : 8620             					lda		#$20
fb7c : a784             					sta		,x				
fb7e : bdfaf9           					bsr		SELECTBANK0
fb81 : 8d31             					bsr		DELAY_10MS				; eeprom 10 ms delay loop
fb83 : 3591             					puls	x,ccr,pc				; restore registers
                        				
                        ;----------------------------------------------------;
AS09 Assembler for M6809 [1.42].                                     Page  265
--------------------------------- merge.a09 ----------------------------------

                        ; asm call enable XICOR 28C64 / 28C256 eeprom write pr
                        ; param:  none
                        ; return: none
                        ;----------------------------------------------------;
fb85 : 3411             ENAXICORWP			pshs	ccr,x				; save ccr (for the disabli
fb87 : 1a50             					orcc	#%01010000			; disable interrupts				
fb89 : f68000           					ldb		ROM1_ORG			; get the byte
fb8c : bdfb02           					bsr		SELECTBANK1
fb8f : 8e9555           					ldx 	#$1555+ROM1_ORG  	;$1555 + base addr 
fb92 : 86aa             					lda		#$aa
fb94 : a784             					sta		,x
fb96 : bdfaf9           					bsr		SELECTBANK0
fb99 : 8eaaaa           					ldx 	#$2aaa+ROM1_ORG
fb9c : 8655             					lda		#$55
fb9e : a784             					sta		,x
fba0 : bdfb02           					bsr		SELECTBANK1
fba3 : 8e9555           					ldx 	#$1555+ROM1_ORG
fba6 : 86a0             					lda		#$a0
fba8 : a784             					sta		,x
fbaa : bdfaf9           					bsr		SELECTBANK0
                        					; re-write the byte
fbad : f78000           					stb		ROM1_ORG
fbb0 : 8d02             					bsr		DELAY_10MS			; eeprom 10 ms delay loop
fbb2 : 3591             					puls	x,ccr,pc			; restore registers
                        
fbb4 : 4f               DELAY_10MS			clra
fbb5 : c60a             					ldb		#10
fbb7 : 3406             					pshs	d
fbb9 : bdfcfb           					lbsr	msDelay				; 10 ms delay loop
fbbc : 3586             					puls	d,pc					
                        
                        ;----------------------------------------------------;
                        ; asm call ROM integrity check
                        ; param:  D -> CheckSum16 calculated value
                        ;         X -> CheckSum16 addr
                        ; return: 0 -> B when succeed
                        ;----------------------------------------------------;
fbbe : 0d524f4d207665.. ROMcheckSTR0		db		CR,"ROM verified",0
fbcc : 0d436865636b53.. ROMcheckSTR1		db		CR,"CheckSum16 ",0
fbd9 : 20776173206361.. ROMcheckSTR2		db		" was calculated instead ",0
fbf2 : 2c20524f4d2066.. ROMcheckSTR3		db		", ROM failure!",CR,0
fc02 : 10a384           sROMcheck			cmpd	,x
fc05 : 272a             					beq		_sROMok
fc07 : 3410             					pshs	x					; save							
fc09 : 3406             					pshs	d					; param for HEXWORD2MONPORT							
fc0b : 8efbcc           					ldx		#ROMcheckSTR1
fc0e : bdfaf1           					lbsr	sPUTSTR
fc11 : bdfc6d           					lbsr	HEXWORD2MONPORT	
fc14 : 3262             					leas	2,s					; free the last push
fc16 : 8efbd9           					ldx		#ROMcheckSTR2
fc19 : bdfaf1           					lbsr	sPUTSTR
fc1c : 3510             					puls    x
fc1e : ec84             					ldd		,x
fc20 : 3406             					pshs	d					; param for HEXWORD2MONPORT							
fc22 : bdfc6d           					lbsr	HEXWORD2MONPORT
fc25 : 3262             					leas	2,s					; free the last push					
fc27 : 8efbf2           					ldx		#ROMcheckSTR3		; failure
fc2a : bdfaf1           					lbsr	sPUTSTR
fc2d : c601             					ldb		#1					; non zero return value
fc2f : 2007             					bra		sROMcheckdone		; to be removed		
fc31 : 8efbbe           _sROMok				ldx		#ROMcheckSTR0		; success
fc34 : bdfaf1           					lbsr	sPUTSTR
AS09 Assembler for M6809 [1.42].                                     Page  266
--------------------------------- merge.a09 ----------------------------------

fc37 : 5f               					clrb						; zero return value
fc38 : 39               sROMcheckdone		rts
                        
                        ;----------------------------------------------------;
                        ; calculate the 16-bit CheckSum of the ROM
                        ; param: 			0,s -> return addr
                        ;			3rd arg:2,s -> CS16InitialValue -> 0,u
                        ;			2nd arg:4,s -> CS16EndAddr		-> 2,u
                        ;			1st arg 6,s -> start addr 		-> 4,u
                        ; return:	CheckSum16 value -> D
                        ;----------------------------------------------------;
fc39 :                  getCheckSum16	;{	
fc39 : 3450             					pshs	u,x					; save used registers (+4 bytes on s
fc3b : 3366             					leau	6,s					; set arg1 to 0,u (4 bytes after the
fc3d : ae44             					ldx		4,u					; get 3rd arg start addr
fc3f : ec81             _getCheckSum160		ldd		,x++
fc41 : e3c4             					addd	0,u  				; 16-bit checksum
fc43 : edc4             					std		0,u
fc45 : ac42             					cmpx	2,u 				; end
fc47 : 26f6             					bne		_getCheckSum160
fc49 : 35d0             					puls	x,u,pc				; restore used registers
                        ;}
                        
                        ;----------------------------------------------------;
                        ; asm call calculate the string length
                        ; param: 	X -> pointer
                        ; return:	length -> D
                        ;----------------------------------------------------;
fc4b :                  sStrlen  ;{
fc4b : 5f               					clrb
fc4c : a680             _sstrlen1 			lda		,x+
fc4e : 2704             					beq		_sstrlenDone 		; string ends with NULL
fc50 : 5c               					incb
fc51 : 20f9             					bra		_sstrlen1
fc53 : 4f               					clra
fc54 : 39               _sstrlenDone		rts
                        ;}
                        
                        ;----------------------------------------------------;
                        ; asm call shift left D 4-bit
                        ; param: 	D -> value
                        ; return:	out -> D
                        ;----------------------------------------------------;
fc55 : 58               sWLSL4bit	       	lslb
fc56 : 49               					rola
fc57 : 58               					lslb
fc58 : 49               					rola
fc59 : 58               					lslb
fc5a : 49               					rola
fc5b : 58               					lslb
fc5c : 49               					rola
fc5d : 39               					rts
                        
                        ;----------------------------------------------------;
                        ; send string on debug port
                        ; param: 	2,s -> string pointer
                        ; return:	none
                        ;----------------------------------------------------;
fc5e :                  PUTSTR
fc5e : 3410             print_De   			pshs	x				; +2 bytes on stack
fc60 : ae64             					ldx		4,s
fc62 : e680             _putstr0			ldb		,x+
AS09 Assembler for M6809 [1.42].                                     Page  267
--------------------------------- merge.a09 ----------------------------------

fc64 : 2705             					beq		_putstr1 		; string ends with NULL
fc66 : bdee42           					lbsr	sMON_PORT_WR
fc69 : 20f7             					bra		_putstr0
fc6b : 3590             _putstr1			puls	x,pc
                        
                        ;----------------------------------------------------;
                        ; send Word on debug port, displayed in HEX
                        ; param: 	2,s -> 8-bit high byte
                        ;			3,s -> 8-bit low byte
                        ; return:	none, D is not preserved
                        ;----------------------------------------------------;
fc6d :                  HEXWORD2MONPORT		
fc6d : 3440             HEXWORD2			pshs	u					; +2 bytes on stack
fc6f : 3364             					leau	4,s					; fix arg1 pointer to 0,u	
fc71 : c624             					ldb		#'$'
fc73 : bdee42           					lbsr	sMON_PORT_WR
fc76 : e6c4             					ldb		0,u		  			; param high byte
fc78 : 3406             					pshs	d
fc7a : bdfcc8           					lbsr	DHEX2TEXT
fc7d : 3262             					leas	2,s 
fc7f : 3404             					pshs	b					; save low byte
fc81 : 1f89             					tfr		a,b
fc83 : f7c800           					stb		DEBUG_MON_PORT		; write high byte (write dir
fc86 : 3504             					puls	b					; get low byte
fc88 : f7c800           					stb		DEBUG_MON_PORT		; write low byte (write dire
fc8b : e641             					ldb		1,u		  			; param low byte
fc8d : 3406             					pshs	d
fc8f : bdfcc8           					lbsr	DHEX2TEXT
fc92 : 3262             					leas	2,s 
fc94 : 3404             					pshs	b					; save low byte
fc96 : 1f89             					tfr		a,b
fc98 : f7c800           					stb		DEBUG_MON_PORT		; write high byte (write dir
fc9b : 3504             					puls	b					; get low byte
fc9d : f7c800           					stb		DEBUG_MON_PORT		; write low byte (write dire
fca0 : 35c0             					puls	u,pc
                        ;}
                        
                        ;----------------------------------------------------;
                        ; send Byte on debug port, displayed in HEX
                        ; param: 	2,s -> xx
                        ;			3,s -> 8-bit value
                        ; return:	none, D is not preserved
                        ;----------------------------------------------------;
fca2 :                  HEXBYTE2MONPORT
fca2 : 3440             HEXBYTE2			pshs	u
fca4 : 3364             					leau	4,s					; fix arg1 pointer to 0,u		
fca6 : c624             					ldb		#'$'
fca8 : bdee42           					lbsr	sMON_PORT_WR
fcab : e641             					ldb		1,u
fcad : 3406             					pshs	d
fcaf : bdfcc8           					lbsr	DHEX2TEXT
fcb2 : 3262             					leas	2,s 
fcb4 : 3404             					pshs	b
fcb6 : 1f89             					tfr		a,b
fcb8 : f7c800           					stb		DEBUG_MON_PORT			; write high nibble
fcbb : 3504             					puls	b
fcbd : f7c800           					stb		DEBUG_MON_PORT			; write low nibble
fcc0 : 35c0             					puls	u,pc
                        
                        ;----------------------------------------------------;
                        ; send a byte on debug port
                        ; param: 	2,s -> xx
AS09 Assembler for M6809 [1.42].                                     Page  268
--------------------------------- merge.a09 ----------------------------------

                        ;			3,s -> 8-bit value
                        ; return:	none
                        ;----------------------------------------------------;
fcc2 :                  BYTE2MONPORT
fcc2 : e663             BYTE2MON			ldb		3,s
fcc4 : bdee42           					lbsr	sMON_PORT_WR
fcc7 : 39               					rts
                        
                        ;----------------------------------------------------;
                        ; convert a byte to ascii hex value
                        ; param: 	2,s -> xx
                        ;			3,s -> 8-bit value
                        ; return:	high nible -> A
                        ;			low nibble -> B
                        ;----------------------------------------------------;
fcc8 : a663             DHEX2TEXT	   		lda		3,s
fcca : 44               					lsra
fccb : 44               					lsra
fccc : 44               					lsra
fccd : 44               					lsra
fcce : 8d0b             					bsr		sHEX2TEXT
fcd0 : 1f89             					tfr		a,b
fcd2 : a663             					lda		3,s
fcd4 : 840f             					anda	#$f					;lower nible
fcd6 : 8d03             					bsr		sHEX2TEXT
fcd8 : 1e89             					exg		a,b
fcda : 39               					rts
                        
                        ;----------------------------------------------------;
                        ; asm call hex to dec conversion
                        ; param: 	A -> hex value
                        ; return:	dec out -> A
                        ;----------------------------------------------------;
fcdb : 840f             sHEX2TEXT			anda	#$f					;lower nible
fcdd : 8109             					cmpa	#9
fcdf : 2204             					bhi     sHEX2TEXT_1
fce1 : 8b30             					adda	#'0'				;for number
fce3 : 2002             					bra     sHEX2TEXT_2
fce5 : 8b37             sHEX2TEXT_1	    	adda	#$37				;for letter
fce7 : 39               sHEX2TEXT_2			rts
                        
                        ;----------------------------------------------------;
                        ; asm call dec to hex conversion
                        ; param: 	A -> dec value
                        ; return:	hex out -> A
                        ;----------------------------------------------------;
fce8 : 8139             sTEXT2HEX			cmpa	#'9'
fcea : 2204             					bhi     sTEXT2HEX_1
fcec : 840f             					anda	#$f					;for number
fcee : 200a             					bra     sTEXT2HEX_2
fcf0 : 8146             sTEXT2HEX_1      	cmpa	#'F'
fcf2 : 2204             					bhi     sTEXT2HEX_11
fcf4 : 8037             					suba	#$37				;for higher case letter
fcf6 : 2002             					bra     sTEXT2HEX_2
fcf8 : 8057             sTEXT2HEX_11     	suba	#$57				;for lower case letter
fcfa : 39               sTEXT2HEX_2			rts
                        
                        ;-----------------------------------------------------
                        ; delay in ms (C call compatible)
                        ; param: 	2-3,s -> delay value (16-bit)
                        ; return:	none
                        ;-----------------------------------------------------
AS09 Assembler for M6809 [1.42].                                     Page  269
--------------------------------- merge.a09 ----------------------------------

fcfb :                  msDelay ;{
fcfb : cc011a           					ldd		#282		; 3 cycles
fcfe : 830001           _msDelay0			subd	#1			; 4 cycles
fd01 : 26fb             					bne		_msDelay0	; 3 cycles
fd03 : ec62             					ldd		2,s			; 5 cycles
fd05 : 830001           					subd	#1			; 4 cycles
fd08 : ed62             					std		2,s			; 5 cycles
fd0a : 10830000         					cmpd	#0			; 5 cycles
fd0e : 26eb             					bne		msDelay		; 3 cycles
fd10 : 39               					rts
                        										; 3 + (4+3 cycles * 282) + 5+4+5+5+3 = 2000 
                        					
                        ;Interrupt service routines
                        				code
                        				
                        ;{ ---------------------------------------------------
fd11 : be7ff8           IRQ            	ldx		IntVectIRQ			; load the new vecto
fd14 : 2702             				beq		_irq0
fd16 : 6e84             				jmp		,x					; execute the re-mapped isr
fd18 : 8e7fbe           _irq0			ldx     #Rbuffer			; get buffer base addr				
fd1b : b67fbc           				lda		RbHead				; head index value
fd1e : 3086             				leax	a,x					; set X to the head pointer
fd20 : 4c               				inca				
fd21 : 8120             				cmpa	#RbSize
fd23 : 2501             				blo		_irq1
fd25 : 4f               				clra
fd26 : b17fbd           _irq1		    cmpa	RbTail
fd29 : 260b             				bne		_irq2				; stop filling before reaching the t
fd2b : a6e4             				lda		,s 					; modify the stacked CCR
fd2d : 8a10             				ora		#%00010000			; disable irq only when fifo ful
fd2f : a7e4             				sta		,s
fd31 : 7c7fde           				inc 	RbDectCR 			; CR detect on, otherwise the fif
fd34 : 200f             				bra		_irq3
fd36 : b77fbc           _irq2			sta     RbHead
fd39 : b6c000           				lda		sMON_PORT_RD
fd3c : 810d             				cmpa	#CR					; CR compare
fd3e : 2603             				bne		_irq22
fd40 : 7c7fde           				inc 	RbDectCR 			; CR found
fd43 : a784             _irq22			sta		,x					; store data to RB head pointer
fd45 : 3b               _irq3			rti
                        
fd46 : 7d7ff6           FIRQ  			tst		IntVectFIRQ			; cmp the new vector store
fd49 : 2605             				bne		_firq
fd4b : 7d7ff7           				tst		IntVectFIRQ+1		; cmp the new vector stored
fd4e : 2704             				beq		_firq0
fd50 : 6e9f7ff6         _firq			jmp		[IntVectFIRQ]		; execute the re-mapped is
fd54 : 3b               _firq0			rti
                        
fd55 : be7ffc           NMI            	ldx		IntVectNMI			; load the new vecto
fd58 : 2702             				beq		_nmi0
fd5a : 6e84             				jmp		,x					; execute the re-mapped isr
fd5c : 3b               _nmi0			rti
                        ;}
                        
                        ;{ ---------------------------------------------------
fd5d : 0d446562756767.. SWI1_STR1		db		CR,"Debugging Mode: Program execution s
fda9 : 50432c20532c20.. SWI1_STR2		db		"PC, S, U, Y, X, DP, D, CC",CR,0
fdc4 : 2c2000           SWI1_STR3		db		", ",0
                        
fdc7 : be7ffa           SWI1            ldx		IntVectSWI1			; load the new vect
fdca : 2702             				beq		_swi10
fdcc : 6e84             				jmp		,x
AS09 Assembler for M6809 [1.42].                                     Page  270
--------------------------------- merge.a09 ----------------------------------

fdce : 8efd5d           _swi10          ldx		#SWI1_STR1 			; Breakpoint
fdd1 : bdfaf1           				lbsr	sPUTSTR
fdd4 : 8efda9           				ldx		#SWI1_STR2
fdd7 : bdfaf1           				lbsr	sPUTSTR
fdda : ec6a             				ldd		10,s				; PC
fddc : 830001           				subd	#1					; step back the executed swi instructi
fddf : ed6a             				std		10,s
fde1 : 3406             				pshs	d
fde3 : bdfc6d           				lbsr	HEXWORD2MONPORT
fde6 : 3262             				leas	2,s
fde8 : 8efdc4           				ldx		#SWI1_STR3
fdeb : bdfaf1           				lbsr	sPUTSTR
fdee : 1f40             				tfr		s,d		
fdf0 : cb0c             				addb	#12					;PS
fdf2 : 3406             				pshs	d
fdf4 : bdfc6d           				lbsr	HEXWORD2MONPORT
fdf7 : 3262             				leas	2,s
fdf9 : 8efdc4           				ldx		#SWI1_STR3
fdfc : bdfaf1           				lbsr	sPUTSTR
fdff : ec68             				ldd		8,s					;US
fe01 : 3406             				pshs	d
fe03 : bdfc6d           				lbsr	HEXWORD2MONPORT
fe06 : 3262             				leas	2,s
fe08 : 8efdc4           				ldx		#SWI1_STR3
fe0b : bdfaf1           				lbsr	sPUTSTR
fe0e : ec66             				ldd		6,s					;Y
fe10 : 3406             				pshs	d
fe12 : bdfc6d           				lbsr	HEXWORD2MONPORT
fe15 : 3262             				leas	2,s
fe17 : 8efdc4           				ldx		#SWI1_STR3
fe1a : bdfaf1           				lbsr	sPUTSTR
fe1d : ec64             				ldd		4,s					;X
fe1f : 3406             				pshs	d
fe21 : bdfc6d           				lbsr	HEXWORD2MONPORT
fe24 : 3262             				leas	2,s
fe26 : 8efdc4           				ldx		#SWI1_STR3
fe29 : bdfaf1           				lbsr	sPUTSTR
fe2c : e663             				ldb		3,s					;DPR
fe2e : 3406             				pshs	d
fe30 : bdfca2           				lbsr	HEXBYTE2MONPORT
fe33 : 3262             				leas	2,s
fe35 : 8efdc4           				ldx		#SWI1_STR3
fe38 : bdfaf1           				lbsr	sPUTSTR
fe3b : ec62             				ldd		2,s					;D
fe3d : 3406             				pshs	d
fe3f : bdfc6d           				lbsr	HEXWORD2MONPORT
fe42 : 3262             				leas	2,s
fe44 : 8efdc4           				ldx		#SWI1_STR3
fe47 : bdfaf1           				lbsr	sPUTSTR
fe4a : e6e4             				ldb		0,s					;CCR
fe4c : 3406             				pshs	d
fe4e : bdfca2           				lbsr	HEXBYTE2MONPORT
fe51 : 3262             				leas	2,s
fe53 : 8efdc4           				ldx		#SWI1_STR3
fe56 : bdfaf1           				lbsr	sPUTSTR				
                        				
fe59 : b67fbb           				lda		BrkPtInst
fe5c : a79f7fb9         				sta		[BrkPtAddr]			; replace initial instruction a
fe60 : cc0001           				ldd		#BrkPtTriggered
fe63 : fd7fb9           				std		BrkPtAddr			; state to triggered
                        
fe66 : 1cef             				andcc	#ENABLE_MON_INT		; re-enable int
AS09 Assembler for M6809 [1.42].                                     Page  271
--------------------------------- merge.a09 ----------------------------------

fe68 : bdf52c           _swi12			lbsr	sMonProcessCmd		; get next cmd: quit or 
fe6b : fc7fb9           				ldd		BrkPtAddr		
fe6e : 10830001         				cmpd	#BrkPtTriggered		; wait until next command
fe72 : 27f4             				beq		_swi12
fe74 :                  SWI3			
fe74 : 3b               SWI2			rti
                        ;}
                        
                        ;{ ---------------------------------------------------
fff0 =                  				org		ROM_Integrity
fff0 : 35d7             				dw		CheckSum16_ROM0
                        				
fff2 =                  				org    INT_VECTOR
                        
fff2 : fe74             				dw      SWI3
fff4 : fe74             				dw 		SWI2
fff6 : fd46             				dw      FIRQ
fff8 : fd11             				dw      IRQ
fffa : fdc7             				dw      SWI1
fffc : fd55             				dw      NMI
fffe : ee9d             				dw      RESET
                        ;}
                        				end
                        
                        
                        
                        ;{ ---------------------- asm Global Variables and Sta
                        					
7fb9 =                  BSS_SEG_ORG			equ     RAM_END+1 -3-35-5-10-4-14 			; a
7fb9 =                  GV_StackBeginAddr	equ		BSS_SEG_ORG							; C global va
7d59 =                  LV_StackBeginAddr	equ		BSS_SEG_ORG - _GLOBALS				; loc
                        
                        ;{ ---------------------------------------------------
                        					bss						; bss segment is in RAM (hidden in SRec 
7fb9 =                  					org		BSS_SEG_ORG
0000 =                  BrkPtOff			equ     0
0001 =                  BrkPtTriggered		equ     1
7fb9 =                  BrkPtAddr	  		ds		2				; BrkPtOff, BrkPtTriggered or 1
7fbb =                  BrkPtInst       	ds		1				; previous instruction where
                        
0020 =                  RbSize				equ     32
7fbc =                  RbHead		  		ds		1
7fbd =                  RbTail          	ds		1
7fbe =                  Rbuffer				ds		RbSize
7fde =                  RbDectCR        	ds		1
                        
7fdf =                  APLstatus			ds		1
7fe0 =                  APLdate				ds		2
7fe2 =                  APLtime				ds		2
                        
0008 =                  KeyboardRbSize		equ     8
7fe4 =                  KeyboardRbHead		ds		1
7fe5 =                  KeyboardRbTail     	ds		1
7fe6 =                  KeyboardRbuffer		ds		KeyboardRbSize
                        
7fee =                  MonSavReg_S			ds		2				; monitor context saving regist
7ff0 =                  BasicCallBack		ds		2				; BASIC call address
                        
                        	; addresses re-mapping interrupt table
7ff2 =                  IntVectSWI3			ds		2
7ff4 =                  IntVectSWI2			ds		2
7ff6 =                  IntVectFIRQ			ds		2
AS09 Assembler for M6809 [1.42].                                     Page  272
--------------------------------- merge.a09 ----------------------------------

7ff8 =                  IntVectIRQ			ds		2
7ffa =                  IntVectSWI1			ds		2
7ffc =                  IntVectNMI			ds		2
7ffe =                  IntVectSTART		ds		2
                        
                        ;}		
                        
                        
                        
No errors in pass 2.
