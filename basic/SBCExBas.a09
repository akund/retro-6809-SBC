************************************************************************
;
; Microsoft Color Computer Basic

		  direct 0			  ; assembler parameter for optimization (DP is considered as always 0)
		  
BS        equ  $8             ; BACKSPACE CODE
LF        equ  $A             ; LINE FEED CODE
CR        equ  $D             ; ENTER CODE
ESC       equ  $1B            ; ESCAPE CODE
SPACE     equ  $20            ; SPACE (BLANK) CODE
STKBUF    equ  58             ; STACK BUFFER ROOM
LBUFMX    equ  250            ; MAX NUMBER OF CHARS IN A BASIC LINE
MAXLIN    equ  $FA            ; MAXIMUM MS BYTE OF LINE NUMBER
* PSEUDO OPS
SKP1      equ  $21            ; OP CODE OF BRN - SKIP ONE BYTE
SKP2      equ  $8C            ; OP CODE OF CMPX # - SKIP TWO BYTES
SKP1LD    equ  $86            ; OP CODE OF LDA # - SKIP THE NEXT BYTE
*                             ; AND LOAD THE VALUE OF THAT BYTE INTO ACCA - THIS
*                             ; IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE
          org  0
ENDFLG    rmb  1              ; STOP/END FLAG: POSITIVE=STOP, NEG=END
CHARAC    rmb  1              ; TERMINATOR FLAG 1
ENDCHR    rmb  1              ; TERMINATOR FLAG 2
TMPLOC    rmb  1              ; SCRATCH VARIABLE
IFCTR     rmb  1              ; IF COUNTER - HOW MANY IF STATEMENTS IN A LINE
DIMFLG    rmb  1              ; *DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING
VALTYP    rmb  1              ; *DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING
GARBFL    rmb  1              ; *TV STRING SPACE HOUSEKEEPING FLAG
ARYDIS    rmb  1              ; DISABLE ARRAY SEARCH: 00=ALLOW SEARCH
INPFLG    rmb  1              ; *TV INPUT FLAG: READ=0, INPUT<>0
RELFLG    rmb  1              ; *TV RELATIONAL OPERATOR FLAG
TEMPPT    rmb  2              ; *PV TEMPORARY STRING STACK POINTER
LASTPT    rmb  2              ; *PV ADDR OF LAST USED STRING STACK ADDRESS
TEMPTR    rmb  2              ; TEMPORARY POINTER
TMPTR1    rmb  2              ; TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH)
FPA2      rmb  4              ; FLOATING POINT ACCUMULATOR #2 MANTISSA
BOTSTK    rmb  2              ; BOTTOM OF STACK AT LAST CHECK
TXTTAB    rmb  2              ; *PV BEGINNING OF BASIC PROGRAM
VARTAB    rmb  2              ; *PV START OF VARIABLES
ARYTAB    rmb  2              ; *PV START OF ARRAYS
ARYEND    rmb  2              ; *PV END OF ARRAYS (+1)
FRETOP    rmb  2              ; *PV START OF STRING STORAGE (TOP OF FREE RAM)
STRTAB    rmb  2              ; *PV START OF STRING VARIABLES
FRESPC    rmb  2              ; UTILITY STRING POINTER
MEMSIZ    rmb  2              ; *PV TOP OF STRING SPACE
OLDTXT    rmb  2              ; SAVED LINE NUMBER DURING A "STOP"
BINVAL    rmb  2              ; BINARY VALUE OF A CONVERTED LINE NUMBER
OLDPTR    rmb  2              ; SAVED INPUT PTR DURING A "STOP"
TINPTR    rmb  2              ; TEMPORARY INPUT POINTER STORAGE
DATTXT    rmb  2              ; *PV 'DATA' STATEMENT LINE NUMBER POINTER
DATPTR    rmb  2              ; *PV 'DATA' STATEMENT ADDRESS POINTER
DATTMP    rmb  2              ; DATA POINTER FOR 'INPUT' & 'READ'
VARNAM    rmb  2              ; *TV TEMP STORAGE FOR A VARIABLE NAME
VARPTR    rmb  2              ; *TV POINTER TO A VARIABLE DESCRIPTOR
VARDES    rmb  2              ; TEMP POINTER TO A VARIABLE DESCRIPTOR
RELPTR    rmb  2              ; POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE
TRELFL    rmb  1              ; TEMPORARY RELATIONAL OPERATOR FLAG BYTE
* FLOATING POINT ACCUMULATORS #3,4 & 5 ARE MOSTLY
* USED AS SCRATCH PAD VARIABLES.
** FLOATING POINT ACCUMULATOR #3 :PACKED: ($40-$44)
V40       rmb  1
V41       rmb  1
V42       rmb  1
V43       rmb  1
V44       rmb  1
** FLOATING POINT ACCUMULATOR #4 :PACKED: ($45-$49)
V45       rmb  1
V46       rmb  1
V47       rmb  1
V48       rmb  2
** FLOATING POINT ACCUMULATOR #5 :PACKED: ($4A-$4E)
V4A       rmb  1
V4B       rmb  2
V4D       rmb  2
** FLOATING POINT ACCUMULATOR #0
FP0EXP    rmb  1              ; *PV FLOATING POINT ACCUMULATOR #0 EXPONENT
FPA0      rmb  4              ; *PV FLOATING POINT ACCUMULATOR #0 MANTISSA
FP0SGN    rmb  1              ; *PV FLOATING POINT ACCUMULATOR #0 SIGN
COEFCT    rmb  1              ; POLYNOMIAL COEFFICIENT COUNTER
STRDES    rmb  5              ; TEMPORARY STRING DESCRIPTOR
FPCARY    rmb  1              ; FLOATING POINT CARRY BYTE
** FLOATING POINT ACCUMULATOR #1
FP1EXP    rmb  1              ; *PV FLOATING POINT ACCUMULATOR #1 EXPONENT
FPA1      rmb  4              ; *PV FLOATING POINT ACCUMULATOR #1 MANTISSA
FP1SGN    rmb  1              ; *PV FLOATING POINT ACCUMULATOR #1 SIGN
RESSGN    rmb  1              ; SIGN OF RESULT OF FLOATING POINT OPERATION
FPSBYT    rmb  1              ; FLOATING POINT SUB BYTE (FIFTH BYTE)
COEFPT    rmb  2              ; POLYNOMIAL COEFFICIENT POINTER
LSTTXT    rmb  2              ; CURRENT LINE POINTER DURING LIST
CURLIN    rmb  2              ; *PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT
DEVCFW    rmb  1              ; *TV TAB FIELD WIDTH
DEVLCF    rmb  1              ; *TV TAB ZONE
DEVPOS    rmb  1              ; *TV PRINT POSITION
DEVWID    rmb  1              ; *TV PRINT WIDTH
DEVNUM 	  rmb  1			  ; *PV DEVICE NUMBER: -3=DLOAD, -2=PRINTER, -1=CASSETTE, 0=SCREEN, 1-15=DISK
BasicSavReg_S rmb 2
TOPRAM    rmb  2              ; *PV TOP OF RAM
IKEYIM    rmb  1              ; *TV INKEY$ RAM IMAGE
ZERO      rmb  2              ; *PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO
* THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM
LPTCFW    rmb  1              ; 16
LPTLCF    rmb  1              ; 112
LPTWID    rmb  1              ; 132
LPTPOS    rmb  1              ; 0
EXECJP    rmb  2              ; LB4AA

* THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM
* BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE
* INTERPRETED IS STORED AT CHARAD.
GETNCH    inc  <CHARAD+1      ; *PV INCREMENT LS BYTE OF INPUT POINTER
          bne  GETCCH         ; *PV BRANCH IF NOT ZERO (NO CARRY)
          inc  <CHARAD        ; *PV INCREMENT MS BYTE OF INPUT POINTER
GETCCH    fcb  $B6            ; *PV OP CODE OF lda EXTENDED
CHARAD    rmb  2              ; *PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT
*         *    CHARACTER WHICH THE BASIC INTERPRETER IS
*         *    PROCESSING
          jmp  BROMHK         ; JUMP BACK INTO THE BASIC RUM

VAB       rmb  1              ; = LOW ORDER FOUR BYTES OF THE PRODUCT
VAC       rmb  1              ; = OF A FLOATING POINT MULTIPLICATION
VAD       rmb  1              ; = THESE BYTES ARE USE AS RANDOM DATA
VAE       rmb  1              ; = BY THE RND STATEMENT

* EXTENDED BASIC VARIABLES
TRCFLG    rmb  1              ; *PV TRACE FLAG 0=OFF ELSE=ON
USRADR    rmb  2              ; *PV ADDRESS OF THE START OF USR VECTORS

* EXTENDED BASIC SCRATCH PAD VARIABLES
VCF       rmb  2
VD1       rmb  2
VD3       rmb  2
VD5       rmb  2
VD7       rmb  1
VD8       rmb  1
VD9       rmb  1
VDA       rmb  1
USRJMP    rmb  3              ; JUMP ADDRESS FOR BASIC'S USR FUNCTION
RVSEED    rmb  1              ; * FLOATING POINT RANDOM NUMBER SEED EXPONENT
          rmb  4              ; * MANTISSA: INITIALLY SET TO $804FC75259

**** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)
USR0      rmb  2              ; USR 0 VECTOR
          rmb  2              ; USR 1
          rmb  2              ; USR 2
          rmb  2              ; USR 3
          rmb  2              ; USR 4
          rmb  2              ; USR 5
          rmb  2              ; USR 6
          rmb  2              ; USR 7
          rmb  2              ; USR 8
          rmb  2              ; USR 9

STRSTK    rmb  8*5            ; STRING DESCRIPTOR STACK
LINHDR    rmb  2              ; LINE INPUT BUFFER HEADER
LINBUF    rmb  LBUFMX+1       ; BASIC LINE INPUT BUFFER
STRBUF    rmb  41             ; STRING BUFFER
F_PTR     rmb  2              ; POINTER TO THE FILE STRUCTURE
PROGST    rmb  1              ; START OF PROGRAM SPACE

BasicRAMend			equ	$7cff ; RAM section reserved for BASIC 0-$7cff
CSum16_ROM1			equ $C882 ; BASIC ROM CheckSum16

          org  ROM1_ORG
		  dw	CSum16_ROM1
BASIC_ORG
* JUMP TO BASIC COLD START AT START OF ROM FOR CONVENIENCE          
		  orcc #%01010000	  ; ensure init in case of software reset (no interrupt)
		  clra
		  tfr  a,dp
		  lbra RESVEC

; context switching to let run BASIC in parallel
EXITBAS	  pshs d,x,y,u,cc,dp
		  sts  BasicSavReg_S
		  ldx  BasicCallBack
		  ldd  #ENTRYBAS
		  std  BasicCallBack
		  jmp  ,x			  ; EXIT BASIC
ENTRYBAS  lds  BasicSavReg_S  ; ENTRY BASIC
		  puls d,x,y,u,cc,dp,pc

* CONSOLE IN
LA171     ldd  F_PTR		  ; check if file reading open		  
		  beq  LA173
		  
  		  pshs x,y		  ; Note for generated asm from C: the D, X and Y registers need to be preserved. Set Y to GV stack.  		  
*		returnStatus = FILE_GetCh(srcFilePtr);
		  pshs	d
		  lbsr	FILE_Get
		  leas	2,s
		  
* 		if(returnStatus == EOF) {
		  cmpb	#$1a
		  bne	LA172  		  
* 			FILE_Close(srcFilePtr);
		  ldd	F_PTR
		  pshs	d
		  lbsr	FILE_Clo
		  leas	2,s
		  clr   F_PTR		
		  clr   F_PTR+2
		  clrb
*		}
LA172	  puls	x,y
		  tfr  b,a
		  anda #$7F
		  bne  LA174

LA173	  bsr  KEYIN          ; GET A CHARACTER FROM CONSOLE IN          
		  beq  LA173          ; LOOP IF NO KEY DOWN
LA174     rts

*
* THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY
* IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.
*
*
LA1C1
KEYIN     bsr  EXITBAS
		  pshs b
		  jsr  APLgetChar
		  tfr  b,a
		  anda #$7F
          puls b,pc
		  

* CONSOLE OUT
PUTCHR    pshs d              ; PRESERVE ACCD		
		  tst  DEVNUM		  ; CHECK DEVICE NUMBER		  
		  beq  TOSCRN		  ; BRANCH IF SCREEN				  
		  
		  pshs d,x,y		  
		  tfr  a,b	  		  ; char in ACCB
		  pshs d		
		  ldd  F_PTR
		  pshs d
		  lbsr FILE_Put	  	  ; Note for BASIC ASM -> C : the U, X and Y registers needs to be preserved. Set Y to GV stack.
		  leas 4,s
		  puls d,x,y
		  bra  PUTEXIT

TOSCRN	  jsr  APLsendChar          
PUTEXIT	  cmpa #CR            ; IS IT CARRIAGE RETURN?
          beq  NEWLINE        ; YES
          inc  LPTPOS         ; INCREMENT CHARACTER COUNTER
          lda  LPTPOS         ; CHECK FOR END OF LINE PRINTER LINE
          cmpa LPTWID         ; AT END OF LINE PRINTER LINE?
          blo  PUTEND         ; NO
NEWLINE   clr  LPTPOS         ; RESET CHARACTER COUNTER          
PUTEND    bsr  EXITBAS
		  puls d,pc           ; RESTORE ACCD
          

*
RESVEC

* COLD START ENTRY

		  ldu  BasicCallBack  ; preserve the BasicCallBack before earasing RAM
		  ldx  #PROGST+1      ; POINT X TO CLEAR 1ST 1K OF RAM
LA077     clr  ,--x           ; MOVE POINTER DOWN TWO-CLEAR BYTE
		  leax 1,x            ; ADVANCE POINTER ONE
          bne  LA077          ; KEEP GOING IF NOT AT BOTTOM OF PAGE 0
          ldx  #PROGST        ; SET TO START OF PROGRAM SPACE
          clr  ,x+            ; CLEAR 1ST BYTE OF BASIC PROGRAM
          stx  TXTTAB         ; BEGINNING OF BASIC PROGRAM
		  ldx  #BasicRAMend   ; end of BASIC allocated memory		
		  stu  BasicCallBack  ; restore the BasicCallBack
		  stx  TOPRAM         ; SAVE ABSOLUTE TOP OF RAM
          stx  MEMSIZ         ; SAVE TOP OF STRING SPACE
          stx  STRTAB         ; SAVE START OF STRING VARIABLES
          leax -200,x         ; CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES
          stx  FRETOP         ; SAVE START OF STRING SPACE
          tfr  x,s            ; PUT STACK THERE
          ldx  #LA10D         ; POINT X TO ROM SOURCE DATA
          ldu  #LPTCFW        ; POINT U TO RAM DESTINATION
          ldb  #18            ; MOVE 18 BYTES
          jsr  LA59A          ; MOVE 18 BYTES FROM ROM TO RAM
          lda  #$39
          sta  LINHDR-1       ; PUT rts IN LINHDR-1
          jsr  LAD19          ; G0 DO A 'NEW'
* EXTENDED BASIC INITIALISATION
          ldx  #USR0          ; INITIALIZE ADDRESS OF START OF
          stx  USRADR         ; USR JUMP TABLE
* DISK BASIC INITIALISATION
		  clr  DEVNUM		  ; DEFAULT SCREEN
		  clr  F_PTR
		  clr  F_PTR+2
* INITIALIZE THE USR CALLS TO 'FC ERROR'
          ldu  #LB44A         ; ADDRESS OF 'FC ERROR' ROUTINE
          ldb  #10            ; 10 USR CALLS IN EX BASIC
L8031     stu  ,x++           ; STORE 'FC' ERROR AT USR ADDRESSES
          decb                ; FINISHED ALL 10?
          bne  L8031          ; NO
		  		  
          ldx  #LA147-1       ; POINT X TO COLOR BASIC COPYRIGHT MESSAGE
          jsr  LB99C          ; PRINT 'COLOR BASIC'
LA0F3     jmp  LAC73          ; GO TO MAIN LOOP OF BASIC

*
* THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIRECT PAGE
LA10D     fcb  16             ; TAB FIELD WIDTH
          fcb  64             ; LAST TAB ZONE
          fcb  80             ; PRINTER WIDTH
          fcb  0              ; LINE PRINTER POSITION
          fdb  LB44A          ; ARGUMENT OF EXEC COMMAND - SET TO 'FC' ERROR
* LINE INPUT ROUTINE
          inc  CHARAD+1
          bne  LA123
          inc  CHARAD
LA123     lda  >0000
          jmp  BROMHK
*
* THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1
          jmp  LB44A          ; USR ADDRESS FOR 8K BASIC (INITIALIZED TO 'FC' ERROR)
          fcb  $80            ; *RANDOM SEED
          fdb  $4FC7          ; *RANDON SEED OF MANTISSA
          fdb  $5259          ; *.811635157
* BASIC COMMAND INTERPRETATION TABLE ROM IMAGE
COMVEC    fcb  57             ; 57 BASIC COMMANDS
          fdb  LAA66          ; POINTS TO RESERVED WORDS
          fdb  LAB67          ; POINTS TO JUMP TABLE FOR COMMANDS
          fcb  29             ; 29 BASIC SECONDARY COMMANDS
          fdb  LAB1A          ; POINTS TO SECONDARY FUNCTION RESERVED WORDS
          fdb  LAA29          ; POINTS TO SECONDARY FUNCTION JUMP TABLE
          fdb  0              ; NO MORE TABLES (RES WORDS=0)
          fdb  0              ; NO MORE TABLES
          fdb  0              ; NO MORE TABLES
          fdb  0              ; NO MORE TABLES
          fdb  0              ; NO MORE TABLES
          fdb  0              ; NO MORE TABLES (SECONDARY FNS =0)

* COPYRIGHT MESSAGES
LA147     fcc  "6809 DISK EXT COLOR BASIC"
          fcb  CR
          fcc  "(C) 1982 BY MICROSOFT"
LA156     fcb  CR,CR
LA165     fcb  $00


LA35F     pshs x,b,a          ; SAVE REGISTERS
          ldx  LPTCFW         ; TAB FIELD WIDTH AND TAB ZONE
          ldd  LPTWID         ; PRINTER WIDTH AND POSITION
LA37C     stx  DEVCFW         ; SAVE TAB FIELD WIDTH AND ZONE
          stb  DEVPOS         ; SAVE PRINT POSITION
          sta  DEVWID         ; SAVE PRINT WIDTH
          puls a,b,x,pc       ; RESTORE REGISTERS

* THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC
* EXIT WITH BREAK KEY: CARRY = 1
* EXIT WITH ENTER KEY: CARRY = 0
LA38D
LA390     clr  IKEYIM         ; RESET BREAK CHECK KEY TEMP KEY STORAGE
          ldx  #LINBUF+1      ; INPUT LINE BUFFER
          ldb  #1             ; ACCB CHAR COUNTER: SET TO 1 TO ALLOW A BACKSPACE AS FIRST CHARACTER
LA39A     jsr  LA171          ; GO GET A CHARACTER FROM CONSOLE IN
          cmpa #BS            ; BACKSPACE
          bne  LA3B4          ; NO
          decb                ; YES - DECREMENT CHAR COUNTER
          beq  LA390          ; BRANCH IF BACK AT START OF LINE AGAIN
          leax -1,x           ; DECREMENT BUFFER POINTER
          bra  LA3E8          ; ECHO CHAR TO SCREEN
LA3B4     cmpa #$15           ; SHIFT RIGHT ARROW?
          bne  LA3C2          ; NO
* YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE
LA3B8     decb                ; DEC CHAR CTR
          beq  LA390          ; GO BACK TO START IF CHAR CTR = 0
          lda  #BS            ; BACKSPACE?
          jsr  PUTCHR         ; SEND TO CONSOLE OUT (SCREEN)
          bra  LA3B8          ; KEEP GOING
LA3C2     cmpa #3             ; BREAK KEY?
          orcc #1             ; SET CARRY FLAG
          beq  LA3CD          ; BRANCH IF BREAK KEY DOWN
LA3C8     cmpa #CR            ; ENTER KEY?
          bne  LA3D9          ; NO
LA3CC     clra                ; CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY
LA3CD     pshs cc             ; SAVE CARRY FLAG
          jsr  LB958          ; SEND CR TO SCREEN
          clr  ,x             ; MAKE LAST BYTE IN INPUT BUFFER = 0
          ldx  #LINBUF        ; RESET INPUT BUFFER POINTER
		  puls cc,pc          ; RESTORE CARRY FLAG

* INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER
LA3D9     cmpa #$20           ; IS IT CONTROL CHAR?
          blo  LA39A          ; BRANCH IF CONTROL CHARACTER
          cmpa #'z'+1         ; *
          bcc  LA39A          ; * IGNORE IF > LOWER CASE Z
          cmpb #LBUFMX        ; HAVE 250 OR MORE CHARACTERS BEEN ENTERED?
          bcc  LA39A          ; YES, IGNORE ANY MORE
          sta  ,x+            ; PUT IT IN INPUT BUFFER
          incb                ; INCREMENT CHARACTER COUNTER
LA3E8     jsr  PUTCHR         ; ECHO IT TO SCREEN
          bra  LA39A          ; GO SET SOME MORE


* EXEC
EXEC      beq  LA545          ; BRANCH IF NO ARGUMENT
          jsr  LB73D          ; EVALUATE ARGUMENT - ARGUMENT RETURNED IN X
          stx  EXECJP         ; STORE X TO EXEC JUMP ADDRESS
LA545     jmp  [EXECJP]       ; GO DO IT

* BREAK CHECK
LA549     jmp  LADEB          ; GO DO BREAK KEY CHECK

* THIS ROUTINE EVALUATES AN ARGUMENT
* AND MAKES SURE IT IS WITHIN LIMITS OF VIDEO DISPLAY RAM
LA554	  jsr  LB3E4		  ; EVALUATE EXPRESSION AND RETURN VALUE IN ACCD
		  cmpd #639			  ; ONLY 512 VIDEO DISPLAY LOCATIONS (32 COL BY 20 LINES)
		  lbhi LB44A		  ; BRANCH IF > 511 TO ‘ILLEGAL FUNCTION CALL’
		  pshs b  			  ; SAVE LOWER PART 0-31 (5-BIT)
		  lslb				  ; SHIFT 3-BIT VER VALUE TO ACCA
		  rola
		  lslb
		  rola
		  lslb
		  rola				  ; VER VALUE IN ACCA
		  puls b
		  andb #$1F			  ; KEEP HOR VALUE
		  jsr APLsetXY 		  ; GET CHARACTER LOCATION (VER IN ACCa, HOR IN ACCB)
		  rts
		
* INKEY$
INKEY     lda  IKEYIM         ; WAS A KEY DOWN IN THE BREAK CHECK?
          bne  LA56B          ; YES
          jsr  KEYIN          ; GO GET A KEY
LA56B     clr  IKEYIM         ; CLEAR INKEY RAM IMAGE
          sta  FPA0+3         ; STORE THE KEY IN FPA0
          lbne LB68F          ; CONVERT FPA0+3 TO A STRING
          sta  STRDES         ; SET LENGTH OF STRING = 0 IF NO KEY DOWN
          jmp  LB69B          ; PUT A NULL STRING ONTO THE STRING STACK

* MOVE ACCB BYTES FROM (X) TO (U)
LA59A     lda  ,x+            ; GET BYTE FROM X
          sta  ,u+            ; STORE IT AT U
          decb                ; MOVED ALL BYTES?
          bne  LA59A          ; NO
LA5A1     rts

** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BASIC LINE
** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS
** FOLLOWING THE END OF THE NAME
LA5C7     jsr  GETCCH         ; GET CURRENT INPUT CHAR FROM BASIC LINE
LA5C9     beq  LA5A1          ; RETURN IF END OF LINE
          jmp  LB277          ; SYNTAX ERROR IF ANY MORE CHARACTERS

* SET  ; SET(x,y,col)
SET       bsr LA8C1			; GET ABSOLUTE SCREEN POSITION OF GRAPHICS BLOCK
		  pshs d 			; SAVE CHARACTER LOCATION
		  jsr LB738			; SYNTAX CHECK FOR COMMA - RETURN EXPR VALUE IN ACCB		  
		  tstb				; VALID ARGUMENT?
		  beq LA6C6			; IF ARGUMENT <1, USE DEFAULT
		  cmpb #7			; VALID ARGUMENT?
		  bls LA6C7			; ILLEGAL COLOR - ‘ILLEGAL FUNCTION CALL’
LA6C6	  ldb #2			; GREEN DEFAULT VALUE
LA6C7	  					; THE COLOR IN ACCB IS IGNORED
		  jsr LB267		    ; SYNTAX CHECK FOR ‘)‘
		  puls b			; REGET CHARACTER LOCATION (HOR IN ACCB)
		  puls a			; REGET CHARACTER LOCATION (VER IN ACCA)
		  jsr APLsetXY
		  rts

*** THIS ROUTINE WILL CHECK SYNTAX AND CHECK FOR LEGAL VALUES
*** OF SET,RESET & POINT HORIZONTAL AND VERTICAL PARAMETERS
*** AND RETURN THEIR ABSOLUTE SCREEN ADDRESS IN THE X REGISTER
*** WHICH OF THE FOUR PIXELS OF THE GRAPHIC BLOCK SELECTED
*** IS RETURNED IN GRBLOK.
LA8C1 	  jsr LB26A			; SYNTAX CHECK FOR "("
		  jsr LB70B			; EVALUATE EXPRESSION - RETURN VALUE IN ACCB
		  ;cmpb #63			; ONLY 64 HORIZONTAL GRAPHIC BLOCKS
		  ;bhi LA948		; ‘ILLEGAL FUNCTION CALL’
		  pshs b			; SAVE HOR COORD
		  jsr LB738			; SYNTAX CHECK FOR COMMA AND EVALUATE EXPR
		  puls a			; KEEP VERT COORD IN ACCB, GET HOR COORD IN ACCA
		  ;cmpb #31
LA8D5 	  ;bhi LA948		; ‘ILLEGAL FUNCTION CALL’		  
		  rts
		  
* CLS  ; CLS "color" [the color values are: 1 red, 2 green, 3 yellow, 4 blue, 5 magenta, 6 cyan, 7 white]
CLS		  beq LA928			; BRANCH IF NO ARGUMENT
		  jsr LB70B			; CALCULATE ARGUMENT, RETURN VALUE IN ACCB
		  tstb				; VALID ARGUMENT?
		  beq LA928			; IF ARGUMENT <1, USE DEFAULT
		  cmpb #7			; VALID ARGUMENT?
		  bls LA937			; IF ARGUMENT >7, USE DEFAULT
LA928	  ldb #2			; GREEN DEFAULT VALUE
LA937	  jsr APLclearscreen
          rts

LA93F 	  jsr LB26D			; SYNTAX CHECK FOR A COMMA
LA942 	  jsr LB70B			; EVALUATE EXPRESSION, RETURN VALUE IN ACCB
		  tstb				; SET FLAGS
		  bne LA950			; RETURN IF NON ZERO
		  leas 1,s			; CLEAR PUSHED VALUE
LA948	  jmp LB44A			; ‘ILLEGAL FUNCTION CALL’ IF ZERO

* SOUND  ; SOUND tone,duration [tone and duration are each between 0-255]
SOUND     bsr LA942			; EVALUATE EXPRESSION (FREQuENCY), RETURN VALUE IN ACCB
		  pshs b			; SAVE IT
		  lbsr LA93F		; EVALUATE EXPRESSION (SOUND LENGTH), RETURN VALUE IN ACCB
		  puls a			; SAVE FREQuENCY IN ACCa, LENGTH OF SOUND IN ACCB
		  jsr  APLsound
LA950	  rts  

* SET CARRY IF NUMERIC - RETURN WITH
* ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END
* OF BASIC LINE OR SUB LINE
BROMHK    cmpa #'9'+1         ; IS THIS CHARACTER >=(ASCII 9)+1?
          bhs  LAA28          ; BRANCH IF > 9; Z SET IF = COLON
          cmpa #SPACE         ; SPACE?
          bne  LAA24          ; NO - SET CARRY IF NUMERIC
          jmp  GETNCH         ; IF SPACE, GET NECT CHAR (IGNORE SPACES)
LAA24     suba #'0'           ; * SET CARRY IF
          suba #-'0'          ; * CHARACTER > ASCII 0
LAA28     rts

* DISPATCH TABLE FOR SECONDARY FUNCTIONS
* TOKENS ARE PRECEEDED BY $FF
* FIRST SET ALWAYS HAS ONE PARAMETER
FUNC_TAB
LAA29     fdb  SGN            ; SGN
          fdb  INT            ; INT
          fdb  ABS            ; ABS
          fdb  USRJMP         ; USR
TOK_USR   equ  $83			  ; (LL01-FUNC_TAB)/2+$7F
TOK_FF_USR equ  $ff83		  ; (LL01-FUNC_TAB)/2+$FF7F
LL01      fdb  RND            ; RND
          fdb  SIN            ; SIN
          fdb  PEEK           ; PEEK
          fdb  LEN            ; LEN
          fdb  STR            ; STR$
          fdb  VAL            ; VAL
          fdb  ASC            ; ASC
          fdb  CHR            ; CHR$
          fdb  ATN            ; ATN
          fdb  COS            ; COS
          fdb  TAN            ; TAN
          fdb  EXP            ; EXP
          fdb  FIX            ; FIX
          fdb  LOG            ; LOG
          fdb  POS            ; POS
          fdb  SQR            ; SQR
          fdb  HEXDOL         ; HEX$
* LEFT, RIGHT AND MID ARE TREATED SEPARATELY
          fdb  LEFT           ; LEFT$
TOK_LEFT  equ  $95 			  ; ((LL02-FUNC_TAB)/2)+$7F
LL02      fdb  RIGHT          ; RIGHT$
          fdb  MID            ; MID$
TOK_MID   equ  $97			  ; (LL03-FUNC_TAB)/2+$7F
* REMAINING FUNCTIONS
LL03      fdb  INKEY          ; INKEY$
TOK_INKEY equ  $98			  ;(LL04-FUNC_TAB)/2+$7F
LL04      fdb  MEM            ; MEM
          fdb  VARPT          ; VARPTR
          fdb  INSTR          ; INSTR
          fdb  STRING         ; STRING$
NUM_SEC_FNS equ  $1d	      ; (LL05-FUNC_TAB)/2
LL05

* THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESSES FOR ARITHMETIC
* AND LOGICAL OPERATORS - THE NEGATION OPERATORS DO NOT ACT ON TWO OPERANDS
* S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREATED SEPARATELY IN THE
* EXPRESSION EVALUATION ROUTINE. THEY ARE:
* UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGATION (NOT), PRECEDENCE $5A
* THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, PRECEDENCE $64.
* A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSION OR PARENTHESES
*
LAA51     fcb  $79
          fdb  LB9C5          ; +
          fcb  $79
          fdb  LB9BC          ; -
          fcb  $7B
          fdb  LBACC          ; *
          fcb  $7B
          fdb  LBB91          ; /
          fcb  $7F
          fdb  L8489          ; EXPONENTIATION
          fcb  $50
          fdb  LB2D5          ; AND
          fcb  $46
          fdb  LB2D4          ; OR

* THIS IS THE RESERVED WORD TABLE
* FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS
LAA66     fcc  "FO"           ; 80
          fcb  $80+'R'
          fcc  "G"            ; 81
          fcb  $80+'O'
TOK_GO    equ  $81
          fcc  "RE"           ; 82
          fcb  $80+'M'
          fcb  $80+$27        ; 83 + '''
          fcc  "ELS"          ; 84
          fcb  $80+'E'
          fcc  "I"            ; 85
          fcb  $80+'F'
          fcc  "DAT"          ; 86
          fcb  $80+'A'
          fcc  "PRIN"         ; 87
          fcb  $80+'T'
          fcc  "O"            ; 88
          fcb  $80+'N'
          fcc  "INPU"         ; 89
          fcb  $80+'T'
          fcc  "EN"           ; 8A
          fcb  $80+'D'
          fcc  "NEX"          ; 8B
          fcb  $80+'T'
          fcc  "DI"           ; 8C
          fcb  $80+'M'
          fcc  "REA"          ; 8D
          fcb  $80+'D'
          fcc  "RU"           ; 8E
          fcb  $80+'N'
          fcc  "RESTOR"       ; 8F
          fcb  $80+'E'
          fcc  "RETUR"        ; 90
          fcb  $80+'N'
          fcc  "STO"          ; 91
          fcb  $80+'P'
          fcc  "POK"          ; 92
          fcb  $80+'E'
          fcc  "CON"          ; 93
          fcb  $80+'T'
          fcc  "LIS"          ; 94
          fcb  $80+'T'
          fcc  "CLEA"         ; 95
          fcb  $80+'R'
          fcc  "NE"           ; 96
          fcb  $80+'W'
          fcc  "SE"           ; 97
          fcb  $80+'T'
		  fcc  "CL"           ; 98
          fcb  $80+'S'
		  fcc  "SOUN"         ; 99
          fcb  $80+'D'
		  fcc  "EXE"          ; 9A
          fcb  $80+'C'
          fcc  "DE"           ; 9B
          fcb  $80+'L'
          fcc  "EDI"          ; 9C
          fcb  $80+'T'
          fcc  "TRO"          ; 9D
          fcb  $80+'N'
          fcc  "TROF"         ; 9E
          fcb  $80+'F'
          fcc  "DE"           ; 9F
          fcb  $80+'F'
          fcc  "LIN"          ; A0
          fcb  $80+'E'
          fcc  "RENU"         ; A1
          fcb  $80+'M'          
          fcc  "DI"           ; A2
          fcb  $80+'R'
          fcc  "KIL"          ; A3
          fcb  $80+'L'
          fcc  "LOA"          ; A4
          fcb  $80+'D'
          fcc  "SAV"          ; A5
          fcb  $80+'E'          
* END OF EXECUTABLE COMMANDS. THE REMAINDER OF THE TABLE ARE NON-EXECUTABLE TOKENS
          fcc  "TAB"          ; A6
          fcb  $80+'('
TOK_TAB   equ  $A6
          fcc  "T"            ; A7
          fcb  $80+'O'
TOK_TO    equ  $A7
          fcc  "SU"           ; A8
          fcb  $80+'B'
TOK_SUB   equ  $A8
          fcc  "THE"          ; A9
          fcb  $80+'N'
TOK_THEN  equ  $A9
          fcc  "NO"           ; AA
          fcb  $80+'T'
TOK_NOT   equ  $AA
          fcc  "STE"          ; AB
          fcb  $80+'P'
TOK_STEP  equ  $AB
          fcc  "OF"           ; AC
          fcb  $80+'F'
          fcb  '+'+$80        ; AD
TOK_PLUS  equ  $AD
          fcb  $80+'-'        ; AE
TOK_MINUS equ  $AE
          fcb  $80+'*'        ; AF
          fcb  $80+'/'        ; B0
          fcb  $80+'^'        ; B1
          fcc  "AN"           ; B2
          fcb  $80+'D'
          fcc  "O"            ; B3
          fcb  $80+'R'
          fcb  $80+'>'        ; B4
TOK_GREATER equ  $B4
          fcb  $80+'='        ; B5
TOK_EQUALS equ  $B5
          fcb  $80+'<'        ; B6
          fcc  "F"            ; B7
          fcb  $80+'N'
TOK_FN    equ  $B7
          fcc  "USIN"         ; B8
          fcb  $80+'G'
TOK_USING equ  $B8
*

* FIRST SET ALWAYS HAS ONE PARAMETER
LAB1A     fcc  "SG"           ; 80
          fcb  $80+'N'
          fcc  "IN"           ; 81
          fcb  $80+'T'
          fcc  "AB"           ; 82
          fcb  $80+'S'
          fcc  "US"           ; 83
          fcb  $80+'R'
          fcc  "RN"           ; 84
          fcb  $80+'D'
          fcc  "SI"           ; 85
          fcb  $80+'N'
          fcc  "PEE"          ; 86
          fcb  $80+'K'
          fcc  "LE"           ; 87
          fcb  $80+'N'
          fcc  "STR"          ; 88
          fcb  $80+'$'
          fcc  "VA"           ; 89
          fcb  $80+'L'
          fcc  "AS"           ; 8A
          fcb  $80+'C'
          fcc  "CHR"          ; 8B
          fcb  $80+'$'
          fcc  "AT"           ; 8C
          fcb  $80+'N'
          fcc  "CO"           ; 8D
          fcb  $80+'S'
          fcc  "TA"           ; 8E
          fcb  $80+'N'
          fcc  "EX"           ; 8F
          fcb  $80+'P'
          fcc  "FI"           ; 90
          fcb  $80+'X'
          fcc  "LO"           ; 91
          fcb  $80+'G'
          fcc  "PO"           ; 92
          fcb  $80+'S'
          fcc  "SQ"           ; 93
          fcb  $80+'R'
          fcc  "HEX"          ; 94
          fcb  $80+'$'
* LEFT, RIGHT AND MID ARE TREATED SEPARATELY
          fcc  "LEFT"         ; 95
          fcb  $80+'$'
          fcc  "RIGHT"        ; 96
          fcb  $80+'$'
          fcc  "MID"          ; 97
          fcb  $80+'$'
* REMAINING FUNCTIONS
          fcc  "INKEY"        ; 98
          fcb  $80+'$'
          fcc  "ME"           ; 99
          fcb  $80+'M'
          fcc  "VARPT"        ; 9A
          fcb  $80+'R'
          fcc  "INST"         ; 9B
          fcb  $80+'R'
          fcc  "STRING"       ; 9C
          fcb  $80+'$'

*
* DISPATCH TABLE FOR COMMANDS TOKEN #
CMD_TAB
LAB67     fdb  FOR            ; 80
          fdb  GO             ; 81
          fdb  REM            ; 82
TOK_REM   equ  $82			  ; (LL06-CMD_TAB)/2+$7F
LL06      fdb  REM            ; 83 (')
TOK_SNGL_Q equ $83			  ; (LL07-CMD_TAB)/2+$7F
LL07      fdb  REM            ; 84 (ELSE)
TOK_ELSE  equ  $84			  ; (LL08-CMD_TAB)/2+$7F
LL08	  fdb  IF             ; 85
TOK_IF    equ  $85			  ; (LL09-CMD_TAB)/2+$7F
LL09      fdb  DATA           ; 86
TOK_DATA  equ  $86			  ; (LL10-CMD_TAB)/2+$7F
LL10      fdb  PRINT          ; 87
TOK_PRINT equ  $87			  ; (LL11-CMD_TAB)/2+$7F
LL11      fdb  ON             ; 88
          fdb  INPUT          ; 89
TOK_INPUT equ  $89			  ; (LL12-CMD_TAB)/2+$7F
LL12      fdb  END            ; 8A
          fdb  NEXT           ; 8B
          fdb  DIM            ; 8C
          fdb  READ           ; 8D
          fdb  RUN            ; 8E
          fdb  RESTOR         ; 8F
          fdb  RETURN         ; 90
          fdb  STOP           ; 91
          fdb  POKE           ; 92
          fdb  CONT           ; 93
          fdb  LIST           ; 94
          fdb  CLEAR          ; 95
          fdb  NEW            ; 96
          fdb  SET            ; 97
		  fdb  CLS            ; 98
		  fdb  SOUND          ; 99
		  fdb  EXEC           ; 9A
          fdb  DEL            ; 9B
          fdb  EDIT           ; 9C
		  fdb  TRON           ; 9D
          fdb  TROFF          ; 9E
          fdb  DEF            ; 9F
          fdb  LINE           ; A0
          fdb  RENUM          ; A1    
          fdb  DIR            ; A2
          fdb  KILL           ; A3
          fdb  LOAD           ; A4
          fdb  SAVE           ; A5		  
TOK_HIGH_EXEC equ  $a5 ; (LABAF-CMD_TAB)/2+$7F

* ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY
LABAF     fcc  "NF"           ; 0 NEXT WITHOUT FOR
          fcc  "SN"           ; 1 SYNTAX ERROR
          fcc  "RG"           ; 2 RETURN WITHOUT GOSUB
          fcc  "OD"           ; 3 OUT OF DATA
          fcc  "FC"           ; 4 ILLEGAL FUNCTION CALL
          fcc  "OV"           ; 5 OVERFLOW
          fcc  "OM"           ; 6 OUT OF MEMORY
          fcc  "UL"           ; 7 UNDEFINED LINE NUMBER
          fcc  "BS"           ; 8 BAD SUBSCRIPT
          fcc  "DD"           ; 9 REDIMENSIONED ARRAY
          fcc  "/0"           ; 10 DIVISION BY ZERO
          fcc  "ID"           ; 11 ILLEGAL DIRECT STATEMENT
          fcc  "TM"           ; 12 TYPE MISMATCH
          fcc  "OS"           ; 13 OUT OF STRING SPACE
          fcc  "LS"           ; 14 STRING TOO LONG
          fcc  "ST"           ; 15 STRING FORMULA TOO COMPLEX
          fcc  "CN"           ; 16 CAN'T CONTINUE
          fcc  "FD"           ; 17 BAD FILE DATA
          fcc  "AO"           ; 18 FILE ALREADY OPEN
          fcc  "DN"           ; 19 DEVICE NUMBER ERROR
          fcc  "IO"           ; 20 I/O ERROR
          fcc  "FM"           ; 21 BAD FILE MODE
          fcc  "NO"           ; 22 FILE NOT OPEN
          fcc  "IE"           ; 23 INPUT PAST END OF FILE
          fcc  "DS"           ; 24 DIRECT STATEMENT IN FILE
* ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC
L890B     fcc  "UF"           ; 25 UNDEFINED FUNCTION (FN) CALL
L890D     fcc  "NE"           ; 26 FILE NOT FOUND

LABE1     fcc  " ERROR"
          fcb  $00
LABE8     fcc  " IN "
          fcb  $00
LABED     fcb  CR
LABEE     fcc  "OK"
          fcb  CR,$00
LABF2     fcb  CR
          fcc  "BREAK"
          fcb  $00

* SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DATA.
* THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEING
* SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT DATA IS 18
* BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES
* WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA
* IS CONSIDERED 'GOSUB/RETURN'
LABF9     leax 4,s            ; POINT X TO 3RD ADDRESS ON STACK - IGNORE THE
*         FIRST TWO RETURN ADDRESSES ON THE STACK
LABFB     ldb  #18            ; 18 BYTES SAVED ON STACK FOR EACH 'FOR' LOOP
          stx  TEMPTR         ; SAVE POINTER
          lda  ,x             ; GET 1ST BYTE
          suba #$80           ; * CHECK FOR TYPE OF STACK JUMP FOUND
          bne  LAC1A          ; * BRANCH IF NOT 'FOR/NEXT'
          ldx  1,x            ; = GET INDEX VARIABLE DESCRIPTOR
          stx  TMPTR1         ; = POINTER AND SAVE IT IN TMPTR1
          ldx  VARDES         ; GET INDEX VARIABLE BEING SEARCHED FOR
          beq  LAC16          ; BRANCH IF DEFAULT INDEX VARIABLE - USE THE
*                             ; FIRST 'FOR/NEXT' DATA FOUND ON STACK
*                             ; IF NO INDEX VARIABLE AFTER 'NEXT'
          cmpx TMPTR1         ; DOES THE STACK INDEX MATCH THE ONE
*                             ; BEING SEARCHED FOR?
          beq  LAC1A          ; YES
          ldx  TEMPTR         ; * RESTORE INITIAL POINTER, ADD
          abx                 ; * 18 TO IT AND LOOK FOR
          bra  LABFB          ; * NEXT BLOCK OF DATA
LAC16     ldx  TMPTR1         ; = GET 1ST INDEX VARIABLE FOUND AND
          stx  VARDES         ; = SAVE AS 'NEXT' INDEX
LAC1A     ldx  TEMPTR         ; POINT X TO START OF 'FOR/NEXT' DATA
          tsta                ; SET ZERO FLAG IF 'FOR/NEXT' DATA
          rts
* CHECK FOR MEMORY SPACE FOR NEW TOP OF
* ARRAYS AND MOVE ARRAYS TO NEW LOCATION
LAC1E     bsr  LAC37          ; ACCD = NEW BOTTOM OF FREE RAM - IS THERE
*                             ; ROOM FOR THE STACK?
* MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND
* SAVE FINAL VALUE OF U IN V45
LAC20     ldu  V41            ; POINT U TO DESTINATION ADDRESS (V41)
          leau 1,u            ; ADD ONE TO U - COMPENSATE FOR FIRST pshu
          ldx  V43            ; POINT X TO SOURCE ADDRESS (V43)
          leax 1,x            ; ADD ONE - COMPENSATE FOR FIRST lda ,x
LAC28     lda  ,-x            ; GRAB A BYTE FROM SOURCE
          pshu a              ; MOVE IT TO DESTINATION
          cmpx V47            ; DONE?
          bne  LAC28          ; NO - KEEP MOVING BYTES
          stu  V45            ; SAVE FINAL DESTINATION ADDRESS
LAC32     rts
* CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB
* BYTES IN FREE RAM - OM ERROR IF NOT
LAC33     clra                ; * ACCD CONTAINS NUMBER OF EXTRA
          aslb                ; * BYTES TO PUT ON STACK
          addd ARYEND         ; END OF PROGRAM AND VARIABLES
LAC37     addd #STKBUF        ; ADD STACK BUFFER - ROOM FOR STACK?
          bcs  LAC44          ; BRANCH IF GREATER THAN $FFFF
          sts  BOTSTK         ; CURRENT NEW BOTTOM OF STACK STACK POINTER
          cmpd BOTSTK         ; ARE WE GOING TO BE BELOW STACK?
          bcs  LAC32          ; YES - NO ERROR
LAC44     ldb  #6*2           ; OUT OF MEMORY ERROR

* ERROR SERVICING ROUTINE
LAC46     jsr  LAD33          ; RESET STACK, STRING STACK, CONTINUE POINTER
          jsr  LB95C          ; SEND A CR TO SCREEN
          jsr  LB9AF          ; SEND A '?' TO SCREEN
          ldx  #LABAF         ; POINT TO ERROR TABLE
LAC60     abx                 ; ADD MESSAGE NUMBER OFFSET
          bsr  LACA0          ; * GET TWO CHARACTERS FROM X AND
          bsr  LACA0          ; * SEND TO CONSOLE OUT (SCREEN)
          ldx  #LABE1-1       ; POINT TO "ERROR" MESSAGE
LAC68     jsr  LB99C          ; PRINT MESSAGE POINTED TO BY X
          lda  CURLIN         ; GET CURRENT LINE NUMBER (CURL IN)
          inca                ; TEST FOR DIRECT MODE
          beq  LAC73          ; BRANCH IF DIRECT MODE
          jsr  LBDC5          ; PRINT 'IN ****'

* THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE
LAC73     jsr  LB95C          ; MOVE CURSOR TO START OF LINE
          jsr  APLcurBlinking ; SET THE BLINKING CURSOR
		  ldx  #LABED         ; POINT X TO 'OK', CR MESSAGE
          jsr  LB99C          ; PRINT 'OK', CR
LAC7C     jsr  LA390          ; GO GET AN INPUT LINE
          ldu  #$FFFF         ; THE LINE NUMBER FOR DIRECT MODE IS $FFFF
          stu  CURLIN         ; SAVE IT IN CURLIN
          bcs  LAC7C          ; BRANCH IF LINE INPUT TERMINATED BY BREAK
          stx  CHARAD         ; SAVE (X) AS CURRENT INPUT POINTER - THIS WILL
*         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. THE
*         LINE JUST ENTERED WILL BE INTERPRETED
          jsr  GETNCH         ; GET NEXT CHARACTER FROM BASIC
          beq  LAC7C          ; NO LINE INPUT - GET ANOTHER LINE
          bcs  LACA5          ; BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE
*         THE  STATEMENT ENTEREd, SO THIS STATEMENT
*         WILL BE MERGED INTO THE BASIC PROGRAM
          jsr  APLcurOff	  ; STOP THE BLINKING CURSOR		  
		  jsr  LB821          ; GO CRUNCH LINE
          jmp  LADC0          ; GO EXECUTE THE STATEMENT (LIVE KEYBOARD)
*
LACA0     lda  ,x+            ; GET A CHARACTER
          jmp  LB9B1          ; SEND TO CONSOLE OUT
* TAKE A LINE FROM THE LINE INPUT BUFFER
* AND INSERT IT INTO THE BASIC PROGRAM
LACA5     jsr  LAF67          ; CONVERT LINE NUMBER TO BINARY
LACA8     ldx  BINVAL         ; GET CONVERTED LINE NUMBER
          stx  LINHDR         ; STORE IT IN LINE INPUT HEADER
          jsr  LB821          ; GO CRUNCH THE LINE
          stb  TMPLOC         ; SAVE LINE LENGTH
          bsr  LAD01          ; FIND OUT WHERE TO INSERT LINE
          bcs  LACC8          ; RANCH IF LINE NUMBER DOES NOT ALREADY EXIST
          ldd  V47            ; GET ABSOLUTE ADDRESS OF LINE NUMBER
          subd ,x             ; SUBTRACT ADDRESS OF NEXT LINE NUMBER
          addd VARTAB         ; * ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE
          std  VARTAB         ; * THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM
          ldu  ,x             ; POINT U TO ADDRESS OF NEXT LINE NUMBER
* DELETE OLD LINE FROM BASIC PROGRAM
LACC0     pulu a              ; GET A BYTE FROM WHAT'S LEFT OF PROGRAM
          sta  ,x+            ; MOVE IT DOWN
          cmpx VARTAB         ; COMPARE TO END OF BASIC PROGRAM
          bne  LACC0          ; BRANCH IF NOT AT END
LACC8     lda  LINBUF         ; * CHECK TO SEE IF THERE IS A LINE IN
          beq  LACE9          ; * THE BUFFER AND BRANCH IF NONE
          ldd  VARTAB         ; = SAVE CURRENT END OF
          std  V43            ; = PROGRAM IN V43
          addb TMPLOC         ; * ADD LENGTH OF CRUNCHED LINE,
          adca #0             ; * PROPOGATE CARRY AND SAVE NEW END
          std  V41            ; * OF PROGRAM IN V41
          jsr  LAC1E          ; = MAKE SURE THERE'S ENOUGH RAM FOR THIS LINE & MAKE A HOLE IN BASIC FOR NEW LINE
          ldu  #LINHDR-2      ; POINT U TO LINE TO BE INSERTED
LACDD     pulu a              ; GET A BYTE FROM NEW LINE
          sta  ,x+            ; INSERT IT IN PROGRAM
          cmpx V45            ; * COMPARE TO ADDRESS OF END OF INSERTED
          bne  LACDD          ; * LINE AND BRANCH IF NOT DONE
          ldx  V41            ; = GET AND SAVE
          stx  VARTAB         ; = END OF PROGRAM
LACE9     bsr  LAD21          ; RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE
          bsr  LACEF          ; ADJUST START OF NEXT LINE ADDRESSES
          bra  LAC7C          ; EENTER BASIC'S INPUT LOOP
* COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM
LACEF     ldx  TXTTAB         ; POINT X TO START OF PROGRAM
LACF1     ldd  ,x             ; GET ADDRESS OF NEXT LINE
          beq  LAD16          ; RETURN IF END OF PROGRAM
          leau 4,x            ; POINT U TO START OF BASIC TEXT IN LINE
LACF7     lda  ,u+            ; * SKIP THROUGH THE LINE UNTIL A
          bne  LACF7          ; * ZERO (END OF LINE) IS FOUND
          stu  ,x             ; SAVE THE NEW START OF NEXT LINE ADDRESS
          ldx  ,x             ; POINT X TO START OF NEXT LINE
          bra  LACF1          ; KEEP GOING
*
* FIND A LINE NUMBER IN THE BASIC PROGRAM
* RETURN WITH CARRY SET IF NO MATCH FOUND
LAD01     ldd  BINVAL         ; GET THE LINE NUMBER TO FIND
          ldx  TXTTAB         ; BEGINNING OF PROGRAM
LAD05     ldu  ,x             ; GET ADDRESS OF NEXT LINE NUMBER
          beq  LAD12          ; BRANCH IF END OF PROG
          cmpd 2,x            ; IS IT A MATCH?
          bls  LAD14          ; CARRY SET IF LOWER; CARRY CLEAR IF MATCH
          ldx  ,x             ; X = ADDRESS OF NEXT LINE
          bra  LAD05          ; KEEP LOOPING FOR LINE NUMBER
LAD12     orcc #1             ; SET CARRY FLAG
LAD14     stx  V47            ; SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER
*                             ; WHERE IT SHOULD HAVE BEEN
LAD16     rts

* NEW
NEW       bne  LAD14          ; BRANCH IF ARGUMENT GIVEN
LAD19     ldx  TXTTAB         ; GET START OF BASIC
          clr  ,x+            ; * PUT 2 ZERO BYTES THERE - ERASE
          clr  ,x+            ; * THE BASIC PROGRAM
          stx  VARTAB         ; AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM
LAD21     ldx  TXTTAB         ; GET START OF BASIC
          jsr  LAEBB          ; PUT INPUT POINTER ONE BEFORE START OF BASIC
* ERASE ALL VARIABLES
LAD26     ldx  MEMSIZ         ; * RESET START OF STRING VARIABLES
          stx  STRTAB         ; * TO TOP OF STRING SPACE
          jsr  RESTOR         ; RESET 'DATA' POINTER TO START OF BASIC
          ldx  VARTAB         ; * GET START OF VARIABLES AND USE IT
          stx  ARYTAB         ; * TO RESET START OF ARRAYS
          stx  ARYEND         ; RESET END OF ARRAYS
LAD33     ldx  #STRSTK        ; * RESET STRING STACK POINTER TO
          stx  TEMPPT         ; * BOTTOM OF STRING STACK
          ldx  ,s             ; GET RETURN ADDRESS OFF STACK
          lds  FRETOP         ; RESTORE STACK POINTER
          clr  ,-s            ; PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF
*                             ; FOR/NEXT DATA FROM THE STACK
          clr  OLDPTR         ; RESET 'CONT' ADDRESS SO YOU
          clr  OLDPTR+1       ; 'CAN'T CONTINUE'
          clr  ARYDIS         ; CLEAR THE ARRAY DISABLE FLAG
          jmp  ,x             ; RETURN TO CALLING ROUTINE - THIS IS NECESSARY
*                             ; SINCE THE STACK WAS RESET
*
* FOR
*
* THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR
* EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE
* BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);
*         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;
*         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;
* 9-13=FP VALUE OF 'TO' PARAMETER;
* 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END
*         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
FOR       lda  #$80           ; * SAVE THE DISABLE ARRAY FLAG IN VO8
          sta  ARYDIS         ; * DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY
          jsr  LET            ; SET INDEX VARIABLE TO INITIAL VALUE
          jsr  LABF9          ; SEARCH THE STACK FOR 'FOR/NEXT' DATA
          leas 2,s            ; PURGE RETURN ADDRESS OFF OF THE STACK
          bne  LAD59          ; BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED
          ldx  TEMPTR         ; GET (ADDRESS + 18) OF MATCHED 'FOR/NEXT' DATA
          leas b,x            ; MOVE THE STACK POINTER TO THE BEGINNING OF THE
* MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
* OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY
* ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
* THIS POINT ON THE STACK
LAD59     ldb  #$09           ; * CHECK FOR ROOM FOR 18 BYTES
          jsr  LAC33          ; * IN FREE RAM
          jsr  LAEE8          ; GET ADDR OF END OF SUBLINE IN X
          ldd  CURLIN         ; GET CURRENT LINE NUMBER
          pshs x,b,a          ; SAVE LINE ADDR AND LINE NUMBER ON STACK
          ldb  #TOK_TO        ; TOKEN FOR 'TO'
          jsr  LB26F          ; SYNTAX CHECK FOR 'TO'
          jsr  LB143          ; 'TM' ERROR IF INDEX VARIABLE SET TO STRING
          jsr  LB141          ; EVALUATE EXPRESSION
*
          ldb  FP0SGN         ; GET FPA0 MANTISSA SIGN
          orb  #$7F           ; FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA
          andb FPA0           ; PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA
          stb  FPA0           ; SAVE THE PACKED HIGH ORDER MANTISSA
          ldy  #LAD7F         ; LOAD FOLLOWING ADDRESS INTO Y AS A RETURN
          jmp  LB1EA          ; ADDRESS - PUSH FPA0 ONTO THE STACK
LAD7F     ldx  #LBAC5         ; POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE)
          jsr  LBC14          ; MOVE (X) TO FPA0
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          cmpa #TOK_STEP      ; STEP TOKEN
          bne  LAD90          ; BRANCH IF NO 'STEP' VALUE
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          jsr  LB141          ; EVALUATE NUMERIC EXPRESSION
LAD90     jsr  LBC6D          ; CHECK STATUS OF FPA0
          jsr  LB1E6          ; SAVE STATUS AND FPA0 ON THE STACK
          ldd  VARDES         ; * GET DESCRIPTOR POINTER FOR THE 'STEP'
          pshs b,a            ; * VARIABLE AND SAVE IT ON THE STACK
          lda  #$80           ; = GET THE 'FOR' FLAG AND
          pshs a              ; = SAVE IT ON THE STACK
*
* MAIN COMMAND INTERPRETATION LOOP
LAD9E     bsr  LADEB          ; CHECK FOR KEYBOARD BREAK
          ldx  CHARAD         ; GET BASIC'S INPUT POINTER
          stx  TINPTR         ; SAVE IT
          lda  ,x+            ; GET CURRENT INPUT CHAR & MOVE POINTER
          beq  LADB4          ; BRANCH IF END OF LINE
          cmpa #':'            ; CHECK FOR LINE SEPARATOR
          beq  LADC0          ; BRANCH IF COLON
LADB1     jmp  LB277          ; 'SYNTAX ERROR'-IF NOT LINE SEPARATOR
LADB4     lda  ,x++           ; GET MS BYTE OF ADDRESS OF NEXT BASIC LINE
          sta  ENDFLG         ; SAVE IN STOP/END FLAG - CAUSE A STOP IF
*                             ; NEXT LINE ADDRESS IS < $8000; CAUSE
*                             ; AN END IF ADDRESS > $8000
          beq LAE15           ; BRANCH TO 'STOP' - END OF PROGRAM
          ldd  ,x+            ; GET CURRENT LINE NUMBER
          std  CURLIN         ; SAVE IN CURLIN
          stx  CHARAD         ; SAVE ADDRESS OF FIRST BYTE OF LINE
* EXTENDED BASIC TRACE
          lda  TRCFLG         ; TEST THE TRACE FLAG
          beq  LADC0          ; BRANCH IF TRACE OFF
          lda  #$5B           ; <LEFT HAND MARKER FOR TRON LINE NUMBER
          jsr  PUTCHR         ; OUTPUT A CHARACTER
          lda  CURLIN         ; GET MS BYTE OF LINE NUMBER
          jsr  LBDCC          ; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN
          lda  #$5D           ; > RIGHT HAND MARKER FOR TRON LINE NUMBER
          jsr  PUTCHR         ; OUTPUT A CHARACTER
* END OF EXTENDED BASIC TRACE
LADC0     jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          bsr  LADC6          ; GO PROCESS COMMAND
          bra  LAD9E          ; GO BACK TO MAIN LOOP
LADC6     beq  LADEA          ; RETURN IF END OF LINE (rts - was beq LAE40)
          tsta                ; CHECK FOR TOKEN - BIT 7 SET (NEGATIVE)
          lbpl LET            ; BRANCH IF NOT A TOKEN - GO DO A 'LET' WHICH
* 
          cmpa #$FF           ; SECONDARY TOKEN
          beq  SECTOK
          cmpa #TOK_HIGH_EXEC ; SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC
          bhi  LADB1          ; 'SYNTAX ERROR' IF NON-EXECUTABLE TOKEN
          ldx  COMVEC+3       ; GET ADDRESS OF BASIC'S COMMAND TABLE
LADD4     asla                ; X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7
          tfr  a,b            ; SAVE COMMAND OFFSET IN ACCB
          abx                 ; NON X POINTS TO COMMAND JUMP ADDR
          jsr  GETNCH         ; GET AN INPUT CHAR
*
* HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
          jmp  [,x]           ; GO DO A COMMAND
SECTOK
* THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTABLE IS
* THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHECK DONE HERE
          jsr  GETNCH         ; GET AN INPUT CHAR
          cmpa #TOK_MID       ; TOKEN FOR "MID$"
          lbeq L86D6          ; PROCESS MID$ REPLACEMENT
          jmp  LB277          ; SYNTAX ERROR

*
* RESTORE
RESTOR    ldx  TXTTAB         ; BEGINNING OF PROGRAM ADDRESS
          leax -1,x           ; MOVE TO ONE BYTE BEFORE PROGRAM
LADE8     stx  DATPTR         ; SAVE NEW DATA POINTER
LADEA     rts
*
* BREAK CHECK
LADEB     jsr  LA1C1          ; GET A KEYSTROKE ENTRY
          beq  LADFA          ; RETURN IF NO INPUT
LADF0     cmpa #3             ; CONTROL C? (BREAK)
          beq  STOP           ; YES
          cmpa #$13           ; CONTROL S? (PAUSE)
          beq  LADFB          ; YES
          sta  IKEYIM         ; SAVE KEYSTROKE IN INKEY IMAGE
LADFA     rts
LADFB     jsr  KEYIN          ; GET A KEY
          beq  LADFB          ; BRANCH IF NO KEY DOWN
          bra  LADF0          ; CONTINUE - DO A BREAK CHECK
*
* END
END       jsr  GETCCH         ; GET CURRENT INPUT CHAR
          bra  LAE0B
*
* STOP
STOP      orcc #$01           ; SET CARRY FLAG
LAE0B     bne  LAE40          ; BRANCH IF ARGUMENT EXISTS
          ldx  CHARAD         ; * SAVE CURRENT POSITION OF
          stx  TINPTR         ; * BASIC'S INPUT POINTER
LAE11     ror  ENDFLG         ; ROTATE CARRY INTO BIT 7 OF STOP/END FLAG
          leas 2,s            ; PURGE RETURN ADDRESS OFF STACK
LAE15     ldx  CURLIN         ; GET CURRENT LINE NUMBER
          cmpx #$FFFF         ; DIRECT MODE?
          beq  LAE22          ; YES
          stx  OLDTXT         ; SAVE CURRENT LINE NUMBER
          ldx  TINPTR         ; * GET AND SAVE CURRENT POSITION
          stx  OLDPTR         ; * OF BASIC'S INPUT POINTER
LAE22
          ldx  #LABF2-1       ; POINT TO CR, 'BREAK' MESSAGE
          tst  ENDFLG         ; CHECK STOP/END FLAG
          lbpl LAC73          ; BRANCH TO MAIN LOOP OF BASIC IF END
          jmp  LAC68          ; PRINT 'BREAK AT ####' AND GO TO
*                             ; BASIC'S MAIN LOOP IF 'STOP'

* CONT
CONT      bne  LAE40          ; RETURN IF ARGUMENT GIVEN
          ldb  #2*16          ; 'CAN'T CONTINUE' ERROR
          ldx  OLDPTR         ; GET CONTINUE ADDRESS (INPUT POINTER)
          lbeq LAC46          ; 'CN' ERROR IF CONTINUE ADDRESS = 0
          stx  CHARAD         ; RESET BASIC'S INPUT POINTER
          ldx  OLDTXT         ; GET LINE NUMBER
          stx  CURLIN         ; RESET CURRENT LINE NUMBER
LAE40     rts
*
* CLEAR
CLEAR     beq  LAE6F          ; BRANCH IF NO ARGUMENT
          jsr  LB3E6          ; EVALUATE ARGUMENT
          pshs b,a            ; SAVE AMOUNT OF STRING SPACE ON STACK
          ldx  MEMSIZ         ; GET CURRENT TOP OF CLEARED SPACE
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          beq  LAE5A          ; BRANCH IF NO NEW TOP OF CLEARED SPACE
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          jsr  LB73D          ; EVALUATE EXPRESSlON; RETURN VALUE IN X
          leax -1,x           ; X = TOP OF CLEARED SPACE
          cmpx TOPRAM         ; COMPARE TO TOP OF RAM
          bhi  LAE72          ; 'OM' ERROR IF > TOP OF RAM
LAE5A     tfr  x,d            ; ACCD = TOP OF CLEARED SPACE
          subd ,s++           ; SUBTRACT OUT AMOUNT OF CLEARED SPACE
          bcs  LAE72          ; 'OM' ERROR IF FREE MEM < 0
          tfr  d,u            ; U = BOTTOM OF CLEARED SPACE
          subd #STKBUF        ; SUBTRACT OUT STACK BUFFER
          bcs  LAE72          ; 'OM' ERROR IF FREE MEM < 0
          subd VARTAB         ; SUBTRACT OUT START OF VARIABLES
          bcs  LAE72          ; 'OM' ERROR IF FREE MEM < 0
          stu  FRETOP         ; SAVE NEW BOTTOM OF CLEARED SPACE
          stx  MEMSIZ         ; SAVE NEW TOP OF CLEARED SPACE
LAE6F     jmp  LAD26          ; ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC
LAE72     jmp  LAC44          ; 'OM' ERROR
*
* RUN
RUN       jsr  GETCCH         ; * GET CURRENT INPUT CHARACTER
          lbeq LAD21          ; * IF NO LINE NUMBER
          jsr  LAD26          ; ERASE ALL VARIABLES
          bra  LAE9F          ; 'GOTO' THE RUN ADDRESS
*
* GO
GO        tfr  a,b            ; SAVE INPUT CHARACTER IN ACCB
LAE88     jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          cmpb #TOK_TO        ; 'TO' TOKEN
          beq  LAEA4          ; BRANCH IF GOTO
          cmpb #TOK_SUB       ; 'SUB' TOKEN
          bne  LAED7          ; 'SYNTAX ERROR' IF NEITHER
          ldb  #3             ; =ROOM FOR 6
          jsr  LAC33          ; =BYTES ON STACK?
          ldu  CHARAD         ; * SAVE CURRENT BASIC INPUT POINTER, LINE
          ldx  CURLIN         ; * NUMBER AND SUB TOKEN ON STACK
          lda  #TOK_SUB       ; *
          pshs u,x,a          ; *
LAE9F     bsr  LAEA4          ; GO DO A 'GOTO'
          jmp  LAD9E          ; JUMP BACK TO BASIC'S MAIN LOOP
* GOTO
LAEA4     jsr  GETCCH         ; GET CURRENT INPUT CHAR
          jsr  LAF67          ; GET LINE NUMBER TO BINARY IN BINVAL
          bsr  LAEEB          ; ADVANCE BASIC'S POINTER TO END OF LINE
          leax $01,x          ; POINT TO START OF NEXT LINE
          ldd  BINVAL         ; GET THE LINE NUMBER TO RUN
          cmpd CURLIN         ; COMPARE TO CURRENT LINE NUMBER
          bhi  LAEB6          ; IF REO'D LINE NUMBER IS > CURRENT LINE NUMBER,
*              ; DON'T START LOOKING FROM
*              ; START OF PROGRAM
          ldx  TXTTAB         ; BEGINNING OF PROGRAM
LAEB6     jsr  LAD05          ; GO FIND A LINE NUMBER
          bcs  LAED2          ; 'UNDEFINED LINE NUMBER'
LAEBB     leax -1,x           ; MOVE BACK TO JUST BEFORE START OF LINE
          stx  CHARAD         ; RESET BASIC'S INPUT POINTER
LAEBF     rts
*
* RETURN
RETURN    bne  LAEBF          ; EXIT ROUTINE IF ARGUMENT GIVEN
          lda  #$FF           ; * PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF
          sta  VARDES         ; * VARDES WHICH WILL CAUSE 'FOR/NEXT' DATA ON THE
*              ; STACK TO BE IGNORED
          jsr  LABF9          ; CHECK FOR RETURN DATA ON THE STACK
          tfr  x,s            ; RESET STACK POINTER - PURGE TWO RETURN ADDRESSES
*              ; FROM THE STACK
          cmpa #TOK_SUB-$80   ; SUB TOKEN - $80
          beq  LAEDA          ; BRANCH IF 'RETURN' FROM SUBROUTINE
          ldb  #2*2           ; ERROR #2 'RETURN WITHOUT GOSUB'
          fcb  SKP2           ; SKIP TWO BYTES
LAED2     ldb  #7*2           ; ERROR #7 'UNDEFINED LINE NUMBER'
          jmp  LAC46          ; JUMP TO ERROR HANDLER
LAED7     jmp  LB277          ; 'SYNTAX ERROR'
LAEDA     puls a,x,u          ; * RESTORE VALUES OF CURRENT LINE NUMBER AND
          stx  CURLIN         ; * BASIC'S INPUT POINTER FOR THIS SUBROUTINE
          stu  CHARAD         ; * AND LOAD ACCA WITH SUB TOKEN ($A6)
*
* DATA
DATA      bsr  LAEE8          ; MOVE INPUT POINTER TO END OF SUBLINE OR LINE
          fcb  SKP2           ; SKIP 2 BYTES

* REM, ELSE
ELSE
REM       bsr  LAEEB          ; MOVE INPUT POINTER TO END OF LINE
          stx  CHARAD         ; RESET BASIC'S INPUT POINTER
LAEE7     rts
* ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE
LAEE8     ldb  #':'            ; COLON = SUBLINE TERMINATOR CHARACTER
LAEEA     fcb  SKP1LD         ; SKPILD SKIP ONE BYTE; lda #$5F
* ADVANCE BASIC'S INPUT POINTER TO END OF
* LINE - RETURN ADDRESS OF END OF LINE+1 IN X
LAEEB     clrb                ; 0 = LINE TERMINATOR CHARACTER
          stb  CHARAC         ; TEMP STORE PRIMARY TERMINATOR CHARACTER
          clrb                ; 0 (END OF LINE) = ALTERNATE TERM. CHAR.
          ldx  CHARAD         ; LOAD X W/BASIC'S INPUT POINTER
LAEF1     tfr  b,a            ; * CHANGE TERMINATOR CHARACTER
          ldb  CHARAC         ; * FROM ACCB TO CHARAC - SAVE OLD TERMINATOR
*         IN   CHARAC
          sta  CHARAC         ; SWAP PRIMARY AND SECONDARY TERMINATORS
LAEF7     lda  ,x             ; GET NEXT INPUT CHARACTER
          beq  LAEE7          ; RETURN IF 0 (END OF LINE)
          pshs b              ; SAVE TERMINATOR ON STACK
          cmpa ,s+            ; COMPARE TO INPUT CHARACTER
          beq  LAEE7          ; RETURN IF EQUAL
          leax 1,x            ; MOVE POINTER UP ONE
          cmpa #'"'            ; CHECK FOR DOUBLE QUOTES
          beq  LAEF1          ; BRANCH IF " - TOGGLE TERMINATOR CHARACTERS
          inca                ; * CHECK FOR $FF AND BRANCH IF
          bne  LAF0C          ; * NOT SECONDARY TOKEN
          leax 1,x            ; MOVE INPUT POINTER 1 MORE IF SECONDARY
LAF0C     cmpa #TOK_IF+1      ; TOKEN FOR IF?
          bne  LAEF7          ; NO - GET ANOTHER INPUT CHARACTER
          inc  IFCTR          ; INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY
*                             ; 'IF' STATEMENTS ARE NESTED IN ONE LINE
          bra  LAEF7          ; GET ANOTHER INPUT CHARACTER

* IF
IF        jsr  LB141          ; EVALUATE NUMERIC EXPRESSION
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          cmpa #TOK_GO        ; TOKEN FOR GO
          beq  LAF22          ; TREAT 'GO' THE SAME AS 'THEN'
          ldb  #TOK_THEN      ; TOKEN FOR THEN
          jsr  LB26F          ; DO A SYNTAX CHECK ON ACCB
LAF22     lda  FP0EXP         ; CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO
          bne  LAF39          ; BRANCH IF CONDITION TRUE
          clr  IFCTR          ; CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT
*                             ; TO SEARCH FOR IN NESTED 'IF' LOOPS
LAF28     bsr  DATA           ; MOVE BASIC'S POINTER TO END OF SUBLINE
          tsta                ; * CHECK TO SEE IF END OF LINE OR SUBLINE
          beq  LAEE7          ; * AND RETURN IF END OF LINE
          jsr  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
          cmpa #TOK_ELSE      ; TOKEN FOR ELSE
          bne  LAF28          ; IGNORE ALL DATA EXCEPT 'ELSE' UNTIL
*                             ; END OF LINE (ZERO BYTE)
          dec  IFCTR          ; CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE
          bpl  LAF28          ; BRANCH TO SEARCH ANOTHER SUBLINE FOR 'ELSE'
          jsr  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
LAF39     jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          lbcs LAEA4          ; BRANCH TO 'GOTO' IF NUMERIC CHARACTER
          jmp  LADC6          ; RETURN TO MAIN INTERPRETATION LOOP

* ON
ON        jsr  LB70B          ; EVALUATE EXPRESSION
          ldb  #TOK_GO        ; TOKEN FOR GO
          jsr  LB26F          ; SYNTAX CHECK FOR GO
          pshs a              ; SAVE NEW TOKEN (TO,sUB)
          cmpa #TOK_SUB       ; TOKEN FOR SUB?
          beq  LAF54          ; YES
          cmpa #TOK_TO        ; TOKEN FOR TO?
LAF52     lbne LAED7          ; 'SYNTAX' ERROR IF NOT 'SUB' OR 'TO'
LAF54     dec  FPA0+3         ; DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS
*                             ; IS THE ARGUMENT OF THE 'ON' STATEMENT
          bne  LAF5D          ; BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER
          puls b              ; GET BACK THE TOKEN FOLLOWING 'GO'
          jmp  LAE88          ; GO DO A 'GOTO' OR 'GOSUB'
LAF5D     jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          bsr  LAF67          ; CONVERT BASIC LINE NUMBER TO BINARY
          cmpa #','           ; IS CHARACTER FOLLOWING LINE NUMBER A COMMA?
          beq  LAF54          ; YES
          puls b,pc           ; IF NOT, FALL THROUGH TO NEXT COMMAND
LAF67     ldx  ZERO           ; DEFAULT LINE NUMBER OF ZERO
          stx  BINVAL         ; SAVE IT IN BINVAL
*
* CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL
*
LAF6B     bcc  LAFCE          ; RETURN IF NOT NUMERIC CHARACTER
          suba #'0'            ; MASK OFF ASCII
          sta  CHARAC         ; SAVE DIGIT IN VO1
          ldd  BINVAL         ; GET ACCUMULATED LINE NUMBER VALUE
          cmpa #24            ; LARGEST LINE NUMBER IS $F9FF (63999) -
*         (24*256+255)*10+9
          bhi  LAF52          ; 'SYNTAX' ERROR IF TOO BIG
* MULT ACCD X 10
          aslb                ; *
          rola                ; * TIMES 2
          aslb                ; =
          rola                ; = TIMES 4
          addd BINVAL         ; ADD 1 = TIMES 5
          aslb                ; *
          rola                ; * TIMES 10
          addb CHARAC         ; ADD NEXT DIGIT
          adca #0             ; PROPAGATE CARRY
          std  BINVAL         ; SAVE NEW ACCUMULATED LINE NUMBER
          jsr  GETNCH         ; GET NEXT CHARACTER FROM BASIC
          bra  LAF6B          ; LOOP- PROCESS NEXT DIGIT
*
* LET (EXBAS)
* EVALUATE A NON-TOKEN EXPRESSION
* TARGET = REPLACEMENT
LET       jsr  LB357          ; FIND TARGET VARIABLE DESCRIPTOR
          stx  VARDES         ; SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION
          ldb  #TOK_EQUALS    ; TOKEN FOR "="
          jsr  LB26F          ; DO A SYNTAX CHECK FOR '='
          lda  VALTYP         ; * GET VARIABLE TYPE AND
          pshs a              ; * SAVE ON THE STACK
          jsr  LB156          ; EVALUATE EXPRESSION
          puls a              ; * REGET VARIABLE TYPE OF 1ST EXPRESSION AND
          rora                ; * SET CARRY IF STRING
          jsr  LB148          ; TYPE CHECK-TM ERROR IF VARIABLE TYPES ON
*                             ; BOTH SIDES OF EQUALS SIGN NOT THE SAME
          lbeq LBC33          ; GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC
* MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT
* FPA0+2 INTO THE STRING SPACE. TRANSFER THE
* DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES
* DON'T MOVE THE STRING IF IT IS ALREADY IN THE
* STRING SPACE. REMOVE DESCRIPTOR FROM STRING
* STACK IF IT IS LAST ONE ON THE STACK
LAFA4     ldx  FPA0+2         ; POINT X TO DESCRIPTOR OF REPLACEMENT STRING
          ldd  FRETOP         ; LOAD ACCD WITH START OF STRING SPACE
          cmpd 2,x            ; IS THE STRING IN STRING SPACE?
          bcc  LAFBE          ; BRANCH IF IT'S NOT IN THE STRING SPACE
          cmpx VARTAB         ; COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES
          bcs  LAFBE          ; BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES
LAFB1     ldb  ,x             ; GET LENGTH OF REPLACEMENT STRING
          jsr  LB50D          ; RESERVE ACCB BYTES OF STRING SPACE
          ldx  V4D            ; GET DESCRIPTOR ADDRESS BACK
          jsr  LB643          ; MOVE STRING INTO STRING SPACE
          ldx  #STRDES        ; POINT X TO TEMP STRING DESCRIPTOR ADDRESS
LAFBE     stx  V4D            ; SAVE STRING DESCRIPTOR ADDRESS IN V4D
          jsr  LB675          ; REMOVE STRING DESCRIPTOR IF LAST ONE
*              ; ON STRING STACK
          ldu  V4D            ; POINT U TO REPLACEMENT DESCRIPTOR ADDRESS
          ldx  VARDES         ; GET TARGET DESCRIPTOR ADDRESS
          pulu a,b,y          ; GET LENGTH AND START OF REPLACEMENT STRING
          sta  ,x             ; * SAVE STRING LENGTH AND START IN
          sty  2,x            ; * TARGET DESCRIPTOR LOCATION
LAFCE     rts

LAFCF     fcc  "?REDO"        ; ?REDO MESSAGE
          fcb  CR,$00

LAFD6
LAFDC     jmp  LAC46          ; jmp TO ERROR HANDLER
LAFDF     lda  INPFLG         ; = GET THE INPUT FLAG AND BRANCH
          beq  LAFEA          ; = IF 'INPUT'
          ldx  DATTXT         ; * GET LINE NUMBER WHERE THE ERROR OCCURRED
          stx  CURLIN         ; * AND USE IT AS THE CURRENT LINE NUMBER
          jmp  LB277          ; 'SYNTAX ERROR'
LAFEA     ldx  #LAFCF-1       ; * POINT X TO '?REDO' AND PRINT
          jsr  LB99C          ; * IT ON THE SCREEN
          ldx  TINPTR         ; = GET THE SAVED ABSOLUTE ADDRESS OF
          stx  CHARAD         ; = INPUT POINTER AND RESTORE IT
          rts
*
* INPUT
INPUT     ldb  #11*2          ; 'ID' ERROR
          ldx  CURLIN         ; GET CURRENT LINE NUMBER
          leax 1,x            ; ADD ONE
          beq  LAFDC          ; 'ID' ERROR BRANCH IF DIRECT MODE
          bsr  LB00F          ; GET SOME INPUT DATA - WAS LB002
          rts
LB00F     cmpa #'"'           ; CHECK FOR PROMPT STRING DELIMITER
          bne  LB01E          ; BRANCH IF NO PROMPT STRING
          jsr  LB244          ; PUT PROMPT STRING ON STRING STACK
          ldb  #';'           ; *
          jsr  LB26F          ; * DO A SYNTAX CHECK FOR SEMICOLON
          jsr  LB99F          ; PRINT MESSAGE TO CONSOLE OUT
LB01E     ldx  #LINBUF        ; POINT TO BASIC'S LINE BUFFER
          clr  ,x             ; CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA
*              ; IN LINE BUFFER
          bsr  LB02F          ; INPUT A STRING TO LINE BUFFER
          ldb  #','           ; * INSERT A COMMA AT THE END
          stb  ,x             ; * OF THE LINE INPUT BUFFER
          bra  LB049
* FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
LB02F     jsr  LB9AF          ; SEND A "?" TO CONSOLE OUT
          jsr  LB9AC          ; SEND A 'SPACE' TO CONSOLE OUT
LB035     jsr  LA390          ; GO READ IN A BASIC LINE
          bcc  LB03F          ; BRANCH IF ENTER KEY ENDED ENTRY
          leas 4,s            ; PURGE TWO RETURN ADDRESSES OFF THE STACK
          jmp  LAE11          ; GO DO A 'STOP' IF BREAK KEY ENDED LINE ENTRY
LB03F     ldb  #2*23          ; 'INPUT PAST END OF FILE' ERROR
          rts
*
* READ
READ      ldx  DATPTR         ; GET 'READ' START ADDRESS
          fcb  SKP1LD         ; SKIP ONE BYTE - lda #*$4F
LB049     clra                ; 'INPUT' ENTRY POINT: INPUT FLAG = 0
          sta  INPFLG         ; SET INPUT FLAG; 0 = INPUT: <> 0 = READ
          stx  DATTMP         ; SAVE 'READ' START ADDRESS/'INPUT' BUFFER START
LB04E     jsr  LB357          ; EVALUATE A VARIABLE
          stx  VARDES         ; SAVE DESCRIPTOR ADDRESS
          ldx  CHARAD         ; * GET BASIC'S INPUT POINTER
          stx  BINVAL         ; * AND SAVE IT
          ldx  DATTMP         ; GET 'READ' ADDRESS START/'INPUT' BUFFER POINTER
          lda  ,x             ; GET A CHARACTER FROM THE BASIC PROGRAM
          bne  LB069          ; BRANCH IF NOT END OF LINE
          lda  INPFLG         ; * CHECK INPUT FLAG AND BRANCH
          bne  LB0B9          ; * IF LOOKING FOR DATA (READ)
* NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
* NOT COMING FROM SCREEN
          jsr  LB9AF          ; SEND A '?' TO CONSOLE OUT
          bsr  LB02F          ; FILL INPUT BUFFER FROM CONSOLE IN
LB069     stx  CHARAD         ; RESET BASIC'S INPUT POINTER
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          ldb  VALTYP         ; * CHECK VARIABLE TYPE AND
          beq  LB098          ; * BRANCH IF NUMERIC
* READ/INPUT A STRING VARIABLE
          ldx  CHARAD         ; LOAD X WITH CURRENT BASIC INPUT POINTER
          sta  CHARAC         ; SAVE CURRENT INPUT CHARACTER
          cmpa #'"'           ; CHECK FOR STRING DELIMITER
          beq  LB08B          ; BRANCH IF STRING DELIMITER
          leax -1,x           ; BACK UP POINTER
          clra                ; * ZERO = END OF LINE CHARACTER
          sta  CHARAC         ; * SAVE AS TERMINATOR
          jsr  LA35F          ; SET UP PRINT PARAMETERS
          lda  #':'           ; END OF SUBLINE CHARACTER
          sta  CHARAC         ; SAVE AS TERMINATOR I
          lda  #','           ; COMMA
LB08B     sta  ENDCHR         ; SAVE AS TERMINATOR 2
          jsr  LB51E          ; STRIP A STRING FROM THE INPUT BUFFER
          jsr  LB249          ; MOVE INPUT POINTER TO END OF STRING
          jsr  LAFA4          ; PUT A STRING INTO THE STRING SPACE IF NECESSARY
          bra  LB09E          ; CHECK FOR ANOTHER DATA ITEM
* SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM
LB098     jsr  LBD12          ; CONVERT AN ASCII STRING TO FP NUMBER
          jsr  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS IN VARDES -
*                             ; INPUT OR READ DATA ITEM
LB09E     jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          beq  LB0A8          ; BRANCH IF END OF LINE
          cmpa #','            ; CHECK FOR A COMMA
          lbne LAFD6          ; BAD FILE DATA' ERROR OR RETRY
LB0A8     ldx  CHARAD         ; * GET CURRENT INPUT
          stx  DATTMP         ; * POINTER (USED AS A DATA POINTER) AND SAVE IT
          ldx  BINVAL         ; * RESET INPUT POINTER TO INPUT OR
          stx  CHARAD         ; * READ STATEMENT
          jsr  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
          beq  LB0D5          ; BRANCH IF END OF LINE - EXIT COMMAND
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          bra  LB04E          ; GET ANOTHER INPUT OR READ ITEM
* SEARCH FROM ADDRESS IN X FOR
* 1ST OCCURENCE OF THE TOKEN FOR DATA
LB0B9     stx  CHARAD         ; RESET BASIC'S INPUT POINTER
          jsr  LAEE8          ; SEARCH FOR END OF CURRENT LINE OR SUBLINE
          leax 1,x            ; MOVE X ONE PAST END OF LINE
          tsta                ; CHECK FOR END OF LINE
          bne  LB0CD          ; BRANCH IF END OF SUBLINE
          ldb  #2*3           ; 'OUT OF DATA' ERROR
          ldu  ,x++           ; GET NEXT 2 CHARACTERS
          beq  LB10A          ; 'OD' ERROR IF END OF PROGRAM
          ldd  ,x++           ; GET BASIC LINE NUMBER AND
          std  DATTXT         ; SAVE IT IN DATTXT
LB0CD     lda  ,x             ; GET AN INPUT CHARACTER
          cmpa #TOK_DATA      ; DATA TOKEN?
          bne  LB0B9          ; NO - KEEP LOOKING
          bra  LB069          ; YES
* EXIT READ AND INPUT COMMANDS
LB0D5     ldx  DATTMP         ; GET DATA POINTER
          ldb  INPFLG         ; * CHECK INPUT FLAG
          lbne LADE8          ; * SAVE NEW DATA POINTER IF READ
          lda  ,x             ; = CHECK NEXT CHARACTER IN 'INPUT' BUFFER
          beq  LB0E7          ; =
          ldx  #LB0E8-1       ; POINT X TO '?EXTRA IGNORED'
          jmp  LB99C          ; PRINT THE MESSAGE
LB0E7     rts

LB0E8     fcc  "?EXTRA IGNORED" ; ?EXTRA IGNORED MESSAGE


          fcb  CR,$00

* NEXT
NEXT      bne  LB0FE          ; BRANCH IF ARGUMENT GIVEN
          ldx  ZERO           ; X = 0: DEFAULT FOR NO ARGUMENT
          bra  LB101
LB0FE     jsr  LB357          ; EVALUATE AN ALPHA EXPRESSION
LB101     stx  VARDES         ; SAVE VARIABLE DESCRIPTOR POINTER
          jsr  LABF9          ; GO SCAN FOR 'FOR/NEXT' DATA ON STACK
          beq  LB10C          ; BRANCH IF DATA FOUND
          ldb  #0             ; 'NEXT WITHOUT FOR' ERROR (SHOULD BE clrb)
LB10A     bra  LB153          ; PROCESS ERROR
LB10C     tfr  x,s            ; POINT S TO START OF 'FOR/NEXT' DATA
          leax 3,x            ; POINT X TO FP VALUE OF STEP
          jsr  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
          lda  8,s            ; GET THE DIRECTION OF STEP
          sta  FP0SGN         ; SAVE IT AS THE SIGN OF FPA0
          ldx  VARDES         ; POINT (X) TO INDEX VARIABLE DESCRIPTOR
          jsr  LB9C2          ; ADD (X) TO FPA0 (STEP TO INDEX)
          jsr  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS
*                             ; CONTAINED IN VARDES
          leax 9,s            ; POINT (X) TO TERMINAL VALUE OF INDEX
          jsr  LBC96          ; COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX
          subb 8,s            ; ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF
*                             ; STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR
*                             ; STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE
          beq  LB134          ; BRANCH IF 'FOR/NEXT' LOOP DONE
          ldx  14,s           ; * GET LINE NUMBER AND
          stx  CURLIN         ; * BASIC POINTER OF
          ldx  16,s           ; * STATEMENT FOLLOWING THE
          stx  CHARAD         ; * PROPER FOR STATEMENT
LB131     jmp  LAD9E          ; JUMP BACK TO COMMAND INTEPR. LOOP
LB134     leas 18,s           ; PULL THE 'FOR-NEXT' DATA OFF THE STACK
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          cmpa #','            ; CHECK FOR ANOTHER ARGUMENT
          bne  LB131          ; RETURN IF NONE
          jsr  GETNCH         ; GET NEXT CHARACTER FROM BASIC
          bsr  LB0FE          ; bsr SIMULATES A CALL TO 'NEXT' FROM COMMAND LOOP


LB141     bsr  LB156          ; EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC
LB143     andcc #$FE          ; CLEAR CARRY FLAG
LB145     fcb  $7D            ; OP CODE OF tst $1A01 - SKIP TWO BYTES (DO
*              ; NOT CHANGE CARRY FLAG)
LB146     orcc #1             ; SET CARRY

* STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR
* NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR
* IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP
* IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC
* IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.
LB148     tst  VALTYP         ; TEST TYPE FLAG; DO NOT CHANGE CARRY
          bcs  LB14F          ; BRANCH IF STRING
          bpl  LB0E7          ; RETURN ON PLUS
          fcb  SKP2           ; SKIP 2 BYTES - 'TM' ERROR
LB14F     bmi  LB0E7          ; RETURN ON MINUS
          ldb  #12*2          ; 'TYPE M1SMATCH' ERROR
LB153     jmp  LAC46          ; PROCESS ERROR
* EVALUATE EXPRESSION
LB156     bsr  LB1C6          ; BACK UP INPUT POINTER
LB158     clra                ; END OF OPERATION PRECEDENCE FLAG
          fcb  SKP2           ; SKIP TWO BYTES
LB15A     pshs b              ; SAVE FLAG (RELATIONAL OPERATOR FLAG)
          pshs a              ; SAVE FLAG (PRECEDENCE FLAG)
          ldb  #1             ; *
          jsr  LAC33          ; * SEE IF ROOM IN FREE RAM FOR (B) WORDS
          jsr  LB223          ; GO EVALUATE AN EXPRESSION
          clr  TRELFL         ; RESET RELATIONAL OPERATOR FLAG
LB168     jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
* CHECK FOR RELATIONAL OPERATORS
LB16A     suba #TOK_GREATER   ; TOKEN FOR >
          bcs  LB181          ; BRANCH IF LESS THAN RELATIONAL OPERATORS
          cmpa #3             ; *
          bcc  LB181          ; * BRANCH IF GREATER THAN RELATIONAL OPERATORS
          cmpa #1             ; SET CARRY IF '>'
          rola                ; CARRY TO BIT 0
          eora TRELFL         ; * CARRY SET IF
          cmpa TRELFL         ; * TRELFL = ACCA
          bcs  LB1DF          ; BRANCH IF SYNTAX ERROR : == << OR >>
          sta  TRELFL         ; BIT 0: >, BIT 1 =, BIT 2: <
          jsr  GETNCH         ; GET AN INPUT CHARACTER
          bra  LB16A          ; CHECK FOR ANOTHER RELATIONAL OPERATOR
*
LB181     ldb  TRELFL         ; GET RELATIONAL OPERATOR FLAG
          bne  LB1B8          ; BRANCH IF RELATIONAL COMPARISON
          lbcc LB1F4          ; BRANCH IF > RELATIONAL OPERATOR
          adda #7             ; SEVEN ARITHMETIC/LOGICAL OPERATORS
          bcc  LB1F4          ; BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR
          adca VALTYP         ; ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER
          lbeq LB60F          ; BRANCH IF VALTYP = FF, AND ACCA = '+' TOKEN -
*                             ; CONCATENATE TWO STRINGS
          adca #-1            ; RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER
          pshs a              ; * STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2
          asla                ; * THEN ADD THE STORED STACK DATA = MULTIPLY
          adda ,s+            ; * X 3; 3 BYTE/TABLE ENTRY
          ldx  #LAA51         ; JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS
          leax a,x            ; POINT X TO PROPER TABLE
LB19F     puls a              ; GET PRECEDENCE FLAG FROM STACK
          cmpa ,x             ; COMPARE TO CURRENT OPERATOR
          bcc  LB1FA          ; BRANCH IF STACK OPERATOR > CURRENT OPERATOR
          bsr  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING

* OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.
LB1A7     pshs a              ; SAVE PRECEDENCE FLAG
          bsr  LB1D4          ; PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK
          ldx  RELPTR         ; GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR
*                             ; LAST CALCULATED OPERATION
          puls a              ; GET PRECEDENCE FLAG OF PREVIOUS OPERATION
          bne  LB1CE          ; BRANCH IF NOT END OF OPERATION
          tsta                ; CHECK TYPE OF PRECEDENCE FLAG
          lbeq LB220          ; BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION
          bra  LB203          ; EVALUATE AN OPERATION

LB1B8     asl  VALTYP         ; BIT 7 OF TYPE FLAG TO CARRY
          rolb                ; SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0
          bsr  LB1C6          ; MOVE THE INPUT POINTER BACK ONE
          ldx  #LB1CB         ; POINT X TO RELATIONAL COMPARISON JUMP TABLE
          stb  TRELFL         ; SAVE RELATIONAL COMPARISON DATA
          clr  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
          bra  LB19F          ; PERFORM OPERATION OR SAVE ON STACK

LB1C6     ldx  CHARAD         ; * GET BASIC'S INPUT POINTER AND
          jmp  LAEBB          ; * MOVE IT BACK ONE
* RELATIONAL COMPARISON JUMP TABLE
LB1CB     fcb  $64            ; RELATIONAL COMPARISON FLAG
LB1CC     fdb  LB2F4          ; JUMP ADDRESS

LB1CE     cmpa ,x             ; COMPARE PRECEDENCE OF LAST DONE OPERATION TO
*         NEXT TO BE DONE OPERATION
          bcc  LB203          ; EVALUATE OPERATION IF LOWER PRECEDENCE
          bra  LB1A7          ; PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE

* PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR
LB1D4     ldd  1,x            ; GET ADDRESS OF OPERATOR ROUTINE
          pshs b,a            ; SAVE IT ON THE STACK
          bsr  LB1E2          ; PUSH FPA0 ONTO STACK
          ldb  TRELFL         ; GET BACK RELATIONAL OPERATOR FLAG
          jmp  LB15A          ; EVALUATE ANOTHER EXPRESSION
LB1DF     jmp  LB277          ; 'SYNTAX ERROR'
* PUSH FPA0 ONTO THE STACK. ,s   = EXPONENT
* 1-2,s =HIGH ORDER MANTISSA 3-4,s = LOW ORDER MANTISSA
* 5,s = SIGN RETURN WITH PRECEDENCE CODE IN ACCA
LB1E2     ldb  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
          lda  ,x             ; GET PRECEDENCE CODE TO ACCA
LB1E6     puls y              ; GET RETURN ADDRESS FROM STACK & PUT IT IN Y
          pshs b              ; SAVE ACCB ON STACK
LB1EA     ldb  FP0EXP         ; * PUSH FPA0 ONTO THE STACK
          ldx  FPA0           ; *
          ldu  FPA0+2         ; *
          pshs u,x,b          ; *
          jmp  ,y             ; JUMP TO ADDRESS IN Y

* BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALLY ')' OR END OF LINE
LB1F4     ldx  ZERO           ; POINT X TO DUMMY VALUE (ZERO)
          lda  ,s+            ; GET PRECEDENCE FLAG FROM STACK
          beq  LB220          ; BRANCH IF END OF EXPRESSION
LB1FA     cmpa #$64           ; * CHECK FOR RELATIONAL COMPARISON FLAG
          beq  LB201          ; * AND BRANCH IF RELATIONAL COMPARISON
          jsr  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
LB201     stx  RELPTR         ; SAVE POINTER TO OPERATOR ROUTINE
LB203     puls b              ; GET RELATIONAL OPERATOR FLAG FROM STACK
          cmpa #$5A           ; CHECK FOR 'NOT' OPERATOR
          beq  LB222          ; RETURN IF 'NOT' - NO RELATIONAL COMPARISON
          cmpa #$7D           ; CHECK FOR NEGATION (UNARY) FLAG
          beq  LB222          ; RETURN IF NEGATION - NO RELATIONAL COMPARISON

* EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES
* ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH
* WILL EVALUATE THE OPERATION. THE rts AT END OF ROUTINE WILL VECTOR
* TO EVALUATING ROUTINE.
          lsrb                ; = ROTATE VALTYP BIT INTO CARRY
          stb  RELFLG         ; = FLAG AND SAVE NEW RELFLG
          puls a,x,u          ; * PULL A FP VALUE OFF OF THE STACK
          sta  FP1EXP         ; * AND SAVE IT IN FPA1
          stx  FPA1           ; *
          stu  FPA1+2         ; *
          puls b              ; = GET MANTISSA SIGN AND
          stb  FP1SGN         ; = SAVE IT IN FPA1
          eorb FP0SGN         ; EOR IT WITH FPA1 MANTISSA SIGN
          stb  RESSGN         ; SAVE IT IN RESULT SIGN BYTE
LB220     ldb  FP0EXP         ; GET EXPONENT OF FPA0
LB222     rts

LB223     jsr  XVEC15         ; CALL EXTENDED BASIC ADD-IN
          clr  VALTYP         ; INITIALIZE TYPE FLAG TO NUMERIC
          jsr  GETNCH         ; GET AN INPUT CHAR
          bcc  LB22F          ; BRANCH IF NOT NUMERIC
LB22C     jmp  LBD12          ; CONVERT ASCII STRING TO FLOATING POINT -
*         RETURN RESULT IN FPA0
* PROCESS A NON NUMERIC FIRST CHARACTER
LB22F     jsr  LB3A2          ; SET CARRY IF NOT ALPHA
          bcc  LB284          ; BRANCH IF ALPHA CHARACTER
          cmpa #'.'           ; IS IT '.' (DECIMAL POINT)?
          beq  LB22C          ; CONVERT ASCII STRING TO FLOATING POINT
          cmpa #TOK_MINUS     ; MINUS TOKEN
          beq  LB27C          ; YES - GO PROCESS THE MINUS OPERATOR
          cmpa #TOK_PLUS      ; PLUS TOKEN
          beq  LB223          ; YES - GET ANOTHER CHARACTER
          cmpa #'"'           ; STRING DELIMITER?
          bne  LB24E          ; NO
LB244     ldx  CHARAD         ; CURRENT BASIC POINTER TO X
          jsr  LB518          ; SAVE STRING ON STRING STACK
LB249     ldx  COEFPT         ; * GET ADDRESS OF END OF STRING AND
          stx  CHARAD         ; * PUT BASIC'S INPUT POINTER THERE
          rts
LB24E     cmpa #TOK_NOT       ; NOT TOKEN?
          bne  LB25F          ; NO
* PROCESS THE NOT OPERATOR
          lda  #$5A           ; 'NOT' PRECEDENCE FLAG
          jsr  LB15A          ; PROCESS OPERATION FOLLOWING 'NOT'
          jsr  INTCNV         ; CONVERT FPA0 TO INTEGER IN ACCD
          coma                ; * 'NOT' THE INTEGER
          comb                ; *
          jmp  GIVABF         ; CONVERT ACCD TO FLOATING POINT (FPA0)
LB25F     inca                ; CHECK FOR TOKENS PRECEEDED BY $FF
          beq  LB290          ; IT WAS PRECEEDED BY $FF
LB262     bsr  LB26A          ; SYNTAX CHECK FOR A '('
          jsr  LB156          ; EVALUATE EXPRESSIONS WITHIN PARENTHESES AT
*         HIGHEST PRECEDENCE
LB267     ldb  #')'           ; SYNTAX CHECK FOR ')'
          fcb  SKP2           ; SKIP 2 BYTES
LB26A     ldb  #'('           ; SYNTAX CHECK FOR '('
          fcb  SKP2           ; SKIP 2 BYTES
LB26D     ldb  #','            ; SYNTAX CHECK FOR COMMA
LB26F     cmpb [CHARAD]       ; * COMPARE ACCB TO CURRENT INPUT
          bne  LB277          ; * CHARACTER - SYNTAX ERROR IF NO MATCH
          jmp  GETNCH         ; GET A CHARACTER FROM BASIC
LB277     ldb  #2*1           ; SYNTAX ERROR
          jmp  LAC46          ; JUMP TO ERROR HANDLER

* PROCESS THE MINUS (UNARY) OPERATOR
LB27C     lda  #$7D           ; MINUS (UNARY) PRECEDENCE FLAG
          jsr  LB15A          ; PROCESS OPERATION FOLLOWING 'UNARY' NEGATION
          jmp  LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA

* EVALUATE ALPHA EXPRESSION
LB284     jsr  LB357          ; FIND THE DESCRIPTOR ADDRESS OF A VARIABLE
LB287     stx  FPA0+2         ; SAVE DESCRIPTOR ADDRESS IN FPA0
          lda  VALTYP         ; TEST VARIABLE TYPE
          bne  LB222          ; RETURN IF STRING
          jmp  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0

* EVALUATING A SECONDARY TOKEN
LB290     jsr  GETNCH         ; GET AN INPUT CHARACTER (SECONDARY TOKEN)
          tfr  a,b            ; SAVE IT IN ACCB
          aslb                ; X2 & BET RID OF BIT 7
          jsr  GETNCH         ; GET ANOTHER INPUT CHARACTER
          cmpb #(NUM_SEC_FNS-1)*2 ; 29 SECONDARY FUNCTIONS - 1
          bls  LB29F          ; BRANCH IF COLOR BASIC TOKEN
          bra  LB277          ; SYNTAX ERROR
LB29F     pshs b              ; SAVE TOKEN OFFSET ON STACK
		  cmpb #(TOK_LEFT-$80)*2 ; CHECK FOR TOKEN WITH AN ARGUMENT
		  bcs  LB2C7          ; DO SECONDARIES STRING$ OR LESS
          cmpb #(TOK_INKEY-$80)*2 ; *
          bcc  LB2C9          ; * DO SECONDARIES $92 (INKEY$) OR >
          bsr  LB26A          ; SYNTAX CHECK FOR A '('
          lda  ,s             ; GET TOKEN NUMBER
* DO SECONDARIES (LEFT$, RIGHT$, MID$)
          jsr  LB156          ; EVALUATE FIRST STRING IN ARGUMENT
          bsr  LB26D          ; SYNTAX CHECK FOR A COMMA
          jsr  LB146          ; 'TM' ERROR IF NUMERIC VARiABLE
          puls a              ; GET TOKEN OFFSET FROM STACK
          ldu  FPA0+2         ; POINT U TO STRING DESCRIPTOR
          pshs u,a            ; SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS
          jsr  LB70B          ; EVALUATE FIRST NUMERIC ARGUMENT
          puls a              ; GET TOKEN OFFSET FROM STACK
          pshs b,a            ; SAVE TOKEN OFFSET AND NUMERIC ARGUMENT
          fcb  $8E            ; OP CODE OF ldx# - SKlP 2 BYTES
LB2C7     bsr  LB262          ; SYNTAX CHECK FOR A '('
LB2C9     puls b              ; GET TOKEN OFFSET
          ldx  COMVEC+8       ; GET SECONDARY FUNCTION JUMP TABLE ADDRESS
LB2CE     abx                 ; ADD IN COMMAND OFFSET
*
* HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION
          jsr  [,x]           ; GO DO AN SECONDARY FUNCTION
          jmp  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING

* LOGICAL OPERATOR 'OR' JUMPS HERE
LB2D4     fcb  SKP1LD         ; SKIP ONE BYTE - 'OR' FLAG = $4F

* LOGICAL OPERATOR 'AND' JUMPS HERE
LB2D5     clra                ; AND FLAG = 0
          sta  TMPLOC         ; AND/OR FLAG
          jsr  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
          std  CHARAC         ; TEMP SAVE ACCD
          jsr  LBC4A          ; MOVE FPA1 TO FPA0
          jsr  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
          tst  TMPLOC         ; CHECK AND/OR FLAG
          bne  LB2ED          ; BRANCH IF OR
          anda CHARAC         ; * 'AND' ACCD WITH FPA0 INTEGER
          andb ENDCHR         ; * STORED IN ENDCHR
          bra  LB2F1          ; CONVERT TO FP
LB2ED     ora  CHARAC         ; * 'OR' ACCD WITH FPA0 INTEGER
          orb  ENDCHR         ; * STORED IN CHARAC
LB2F1     jmp  GIVABF         ; CONVERT THE VALUE IN ACCD INTO A FP NUMBER

* RELATIONAL COMPARISON PROCESS HANDLER
LB2F4     jsr  LB148          ; 'TM' ERROR IF TYPE MISMATCH
          bne  LB309          ; BRANCH IF STRING VARIABLE
          lda  FP1SGN         ; * 'PACK' THE MANTISSA
          ora  #$7F           ; * SIGN OF FPA1 INTO
          anda FPA1           ; * BIT 7 OF THE
          sta  FPA1           ; * MANTISSA MS BYTE
          ldx  #FP1EXP        ; POINT X TO FPA1
          jsr  LBC96          ; COMPARE FPA0 TO FPA1
          bra  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON

* RELATIONAL COMPARISON OF STRINGS
LB309     clr  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
          dec  TRELFL         ; REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE
*                             ; DESIRED RELATIONAL COMPARISON DATA
          jsr  LB657          ; GET LENGTH AND ADDRESS OF STRING WHOSE
*                             ; DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0
          stb  STRDES         ; * SAVE LENGTH AND ADDRESS IN TEMPORARY
          stx  STRDES+2       ; * DESCRIPTOR (STRING B)
          ldx  FPA1+2         ; = RETURN LENGTH AND ADDRESS OF STRING
          jsr  LB659          ; = WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2
          lda  STRDES         ; LOAD ACCA WITH LENGTH OF STRING B
          pshs b              ; SAVE LENGTH A ON STACK
          suba ,s+            ; SUBTRACT LENGTH A FROM LENGTH B
          beq  LB328          ; BRANCH IF STRINGS OF EQUAL LENGTH
          lda  #1             ; ; TRUE FLAG
          bcc  LB328          ; TRUE IF LENGTH B > LENGTH A
          ldb  STRDES         ; LOAD ACCB WITH LENGTH B
          nega                ; SET FLAG = FALSE (1FF)
LB328     sta  FP0SGN         ; SAVE TRUE/FALSE FLAG
          ldu  STRDES+2       ; POINT U TO START OF STRING
          incb                ; COMPENSATE FOR THE DECB BELOW
* ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING
LB32D     decb                ; DECREMENT SHORTER STRING LENGTH
          bne  LB334          ; BRANCH IF ALL OF STRING NOT COMPARED
          ldb  FP0SGN         ; GET TRUE/FALSE FLAB
          bra  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
LB334     lda  ,x+            ; GET A BYTE FROM STRING A
          cmpa ,u+            ; COMPARE TO STRING B
          beq  LB32D          ; CHECK ANOTHER CHARACTER IF =
          ldb  #$FF           ; FALSE FLAG IF STRING A > B
          bcc  LB33F          ; BRANCH IF STRING A > STRING B
          negb                ; SET FLAG = TRUE

* DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0
LB33F     addb #1             ; CONVERT $FF,0,1 TO 0,1,2
          rolb                ; NOW IT'S 1,2,4 FOR > = <
          andb RELFLG         ; 'AND' THE ACTUAL COMPARISON WITH THE DESIRED -
COMPARISON
          beq  LB348          ; BRANCH IF FALSE (NO MATCHING BITS)
          ldb  #$FF           ; TRUE FLAG
LB348     jmp  LBC7C          ; CONVERT ACCB INTO FP NUMBER IN FPA0

* DIM
LB34B     jsr  LB26D          ; SYNTAX CHECK FOR COMMA
DIM       ldb  #1             ; DIMENSION FLAG
          bsr  LB35A          ; SAVE ARRAY SPACE FOR THIS VARIABLE
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          bne  LB34B          ; KEEP DIMENSIONING IF NOT END OF LINE
          rts
* EVALUATE A VARIABLE - RETURN X AND
* VARPTR POINTING TO VARIABLE DESCRIPTOR
* EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO
* BYTES ARE THE VARIABLE NAME AND THE NEXT 5
* BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE
* FIRST BYTE OF VARlABLE NAME IS SET, THE
* VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF
* THE SECOND BYTE OF VARIABLE NAME IS SET, THE
* VARIABLE IS A STRING, OTHERWISE THE VARIABLE
* IS NUMERIC.
* IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS
* INSERTED INTO THE VARIABLE SPACE
LB357     clrb                ; DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
LB35A     stb  DIMFLG         ; SAVE ARRAY FLAG
* ENTRY POINT FOR DEF FN VARIABLE SEARCH
LB35C     sta  VARNAM         ; SAVE INPUT CHARACTER
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          bsr  LB3A2          ; SET CARRY IF NOT ALPHA
          lbcs LB277          ; SYNTAX ERROR IF NOT ALPHA
          clrb                ; DEFAULT 2ND VARIABLE CHARACTER TO ZERO
          stb  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
          jsr  GETNCH         ; GET ANOTHER CHARACTER FROM BASIC
          bcs  LB371          ; BRANCH IF NUMERIC (2ND CHARACTER IN
*                             ; VARIABLE MAY BE NUMERIC)
          bsr  LB3A2          ; SET CARRY IF NOT ALPHA
          bcs  LB37B          ; BRANCH IF NOT ALPHA
LB371     tfr  a,b            ; SAVE 2ND CHARACTER IN ACCB
* READ INPUT CHARACTERS UNTIL A NON ALPHA OR
* NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS
* IN VARIABLE NAME AFTER THE 1ST TWO
LB373     jsr  GETNCH         ; GET AN INPUT CHARACTER
          bcs  LB373          ; BRANCH IF NUMERIC
          bsr  LB3A2          ; SET CARRY IF NOT ALPHA
          bcc  LB373          ; BRANCH IF ALPHA
LB37B     cmpa #'$'           ; CHECK FOR A STRING VARIABLE
          bne  LB385          ; BRANCH IF IT IS NOT A STRING
          com  VALTYP         ; SET VARIABLE TYPE TO STRING
          addb #$80           ; SET BIT 7 OF 2ND CHARACTER (STRING)
          jsr  GETNCH         ; GET AN INPUT CHARACTER
LB385     stb  VARNAM+1       ; SAVE 2ND CHARACTER IN VARNAM+1
          ora  ARYDIS         ; OR IN THE ARRAY DISABLE FLAG - IF = $80,
*              ; DON'T SEARCH FOR VARIABLES IN THE ARRAYS
          suba #'('           ; IS THIS AN ARRAY VARIABLE?
          lbeq LB404          ; BRANCH IF IT IS
          clr  ARYDIS         ; RESET THE ARRAY DISABLE FLAG
          ldx  VARTAB         ; POINT X TO THE START OF VARIABLES
          ldd  VARNAM         ; GET VARIABLE IN QUESTION
LB395     cmpx ARYTAB         ; COMPARE X TO THE END OF VARIABLES
          beq  LB3AB          ; BRANCH IF END OF VARIABLES
          cmpd ,x++           ; * COMPARE VARIABLE IN QUESTION TO CURRENT
          beq  LB3DC          ; * VARIABLE AND BRANCH IF MATCH
          leax 5,x            ; = MOVE POINTER TO NEXT VARIABLE AND
          bra  LB395          ; = KEEP LOOKING

* SET CARRY IF NOT UPPER CASE ALPHA
LB3A2     cmpa #'A'           ; * CARRY SET IF < 'A'
          bcs  LB3AA          ; *
          suba #'Z'+1         ; =
*         suba #-('Z'+1)      ; = CARRY CLEAR IF <= 'Z'
          fcb  $80,$A5
LB3AA     rts
* PUT A NEW VARIABLE IN TABLE OF VARIABLES
LB3AB     ldx  #ZERO          ; POINT X TO ZERO LOCATION
          ldu  ,s             ; GET CURRENT RETURN ADDRESS
          cmpu #LB287         ; DID WE COME FROM 'EVALUATE ALPHA EXPR'?
          beq  LB3DE          ; YES - RETURN A ZERO VALUE
          ldd  ARYEND         ; * GET END OF ARRAYS ADDRESS AND
          std  V43            ; * SAVE IT AT V43
          addd #7             ; = ADD 7 TO END OF ARRAYS (EACH
          std  V41            ; = VARIABLE = 7 BYTES) AND SAVE AT V41
          ldx  ARYTAB         ; * GET END OF VARIABLES AND SAVE AT V47
          stx  V47            ; *
          jsr  LAC1E          ; MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT
*         TOP  OF VARIABLES
          ldx  V41            ; = GET NEW END OF ARRAYS AND SAVE IT
          stx  ARYEND         ; =
          ldx  V45            ; * GET NEW END OF VARIABLES AND SAVE IT
          stx  ARYTAB         ; *
          ldx  V47            ; GET OLD END OF VARIABLES
          ldd  VARNAM         ; GET NEW VARIABLE NAME
          std  ,x++           ; SAVE VARIABLE NAME
          clra                ; * ZERO OUT THE FP VALUE OF THE NUMERIC
          clrb                ; * VARIABLE OR THE LENGTH AND ADDRESS
          std  ,x             ; * OF A STRING VARIABLE
          std  2,x            ; *
          sta  4,x            ; *
LB3DC     stx  VARPTR         ; STORE ADDRESS OF VARIABLE VALUE
LB3DE     rts
*
LB3DF     fcb  $90,$80,$00,$00,$00 ; * FLOATING POINT -32768
*                             ; SMALLEST SIGNED TWO BYTE INTEGER
*
LB3E4     jsr  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
LB3E6     jsr  LB141          ; GO EVALUATE NUMERIC EXPRESSION
LB3E9     lda  FP0SGN         ; GET FPA0 MANTISSA SIGN
          bmi  LB44A          ; 'FC' ERROR IF NEGATIVE NUMBER


INTCNV    jsr  LB143          ; 'TM' ERROR IF STRING VARIABLE
          lda  FP0EXP         ; GET FPA0 EXPONENT
          cmpa #$90           ; * COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND
          bcs  LB3FE          ; * BRANCH IF FPA0 < 32768
          ldx  #LB3DF         ; POINT X TO FP VALUE OF -32768
          jsr  LBC96          ; COMPARE -32768 TO FPA0
          bne  LB44A          ; 'FC' ERROR IF NOT =
LB3FE     jsr  LBCC8          ; CONVERT FPA0 TO A TWO BYTE INTEGER
          ldd  FPA0+2         ; GET THE INTEGER
          rts
* EVALUATE AN ARRAY VARIABLE
LB404     ldd  DIMFLG         ; GET ARRAY FLAG AND VARIABLE TYPE
          pshs b,a            ; SAVE THEM ON STACK
          nop                 ; DEAD SPACE CAUSED BY 1.2 REVISION
          clrb                ; RESET DIMENSION COUNTER
LB40A     ldx  VARNAM         ; GET VARIABLE NAME
          pshs x,b            ; SAVE VARIABLE NAME AND DIMENSION COUNTER
          bsr  LB3E4          ; EVALUATE EXPRESSION (DIMENSlON LENGTH)
          puls b,x,y          ; PULL OFF VARIABLE NAME, DIMENSlON COUNTER,
*                             ; ARRAY FLAG
          stx  VARNAM         ; SAVE VARIABLE NAME AND VARIABLE TYPE
          ldu  FPA0+2         ; GET DIMENSION LENGTH
          pshs u,y            ; SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE
          incb                ; INCREASE DIMENSION COUNTER
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          cmpa #','           ; CHECK FOR ANOTHER DIMENSION
          beq  LB40A          ; BRANCH IF MORE
          stb  TMPLOC         ; SAVE DIMENSION COUNTER
          jsr  LB267          ; SYNTAX CHECK FOR A ')'
          puls a,b            ; * RESTORE VARIABLE TYPE AND ARRAY
          std  DIMFLG         ; * FLAG - LEAVE DIMENSION LENGTH ON STACK
          ldx  ARYTAB         ; GET START OF ARRAYS
LB42A     cmpx ARYEND         ; COMPARE TO END OF ARRAYS
          beq  LB44F          ; BRANCH IF NO MATCH FOUND
          ldd  VARNAM         ; GET VARIABLE IN QUESTION
          cmpd ,x             ; COMPARE TO CURRENT VARIABLE
          beq  LB43B          ; BRANCH IF =
          ldd  2,x            ; GET OFFSET TO NEXT ARRAY VARIABLE
          leax d,x            ; ADD TO CURRENT POINTER
          bra  LB42A          ; KEEP SEARCHING
LB43B     ldb  #2*9           ; 'REDIMENSIONED ARRAY' ERROR
          lda  DIMFLG         ; * TEST ARRAY FLAG - IF <>0 YOU ARE TRYING
          bne  LB44C          ; * TO REDIMENSION AN ARRAY
          ldb  TMPLOC         ; GET NUMBER OF DIMENSIONS IN ARRAY
          cmpb 4,x            ; COMPARE TO THIS ARRAYS DIMENSIONS
          beq  LB4A0          ; BRANCH IF =
LB447     ldb  #8*2           ; 'BAD SUBSCRIPT'
          fcb  SKP2           ; SKIP TWO BYTES
LB44A     ldb  #4*2           ; 'ILLEGAL FUNCTION CALL'
LB44C     jmp  LAC46          ; JUMP TO ERROR SERVICING ROUTINE

* INSERT A NEW ARRAY INTO ARRAY VARIABLES
* EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-
* SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE
* NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFINED
* AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LENGTH
* OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-
* ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-
* SION 2;... 4+N,5+N:LENGTH OF DIMENSION N.

LB44F     ldd  #5             ; * 5 BYTES/ARRAY ENTRY SAVE AT COEFPT
          std  COEFPT         ; *
          ldd  VARNAM         ; = GET NAME OF ARRAY AND SAVE IN
          std  ,x             ; = FIRST 2 BYTES OF DESCRIPTOR
          ldb  TMPLOC         ; GET NUMBER OF DIMENSIONS AND SAVE IN
          stb  4,x            ; * 5TH BYTE OF DESCRIPTOR
          jsr  LAC33          ; CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM
          stx  V41            ; TEMPoraRILY SAVE DESCRIPTOR ADDRESS
LB461     ldb  #11            ; * DEFAULT DIMENSION VALUE:X(10)
          clra                ; *
          tst  DIMFLG         ; = CHECK ARRAY FLAG AND BRANCH IF
          beq  LB46D          ; = NOT DIMENSIONING AN ARRAY
          puls a,b            ; GET DIMENSION LENGTH
          addd #1             ; ADD ONE (X(0) HAS A LENGTH OF ONE)
LB46D     std  5,x            ; SAVE LENGTH OF ARRAY DIMENSION
          bsr  LB4CE          ; MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH
*                             ; OF NEW DIMENSION
          std  COEFPT         ; TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE
          leax 2,x            ; BUMP POINTER UP TWO
          dec  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND BRANCH IF
          bne  LB461          ; * NOT DONE WITH ALL DIMENSIONS
          stx  TEMPTR         ; SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5)
          addd TEMPTR         ; ADD TOTAL SIZE OF NEW ARRAY
          lbcs LAC44          ; 'OM' ERROR IF > $FFFF
          tfr  d,x            ; SAVE END OF ARRAY IN X
          jsr  LAC37          ; MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY
          subd #STKBUF-5      ; SUBTRACT OUT THE (STACK BUFFER - 5)
          std  ARYEND         ; SAVE NEW END OF ARRAYS
          clra                ; ZERO = TERMINATOR BYTE
LB48C     leax -1,x           ; * STORE TWO TERMINATOR BYTES AT
          sta  5,x            ; * THE END OF THE ARRAY DESCRIPTOR
          cmpx TEMPTR         ; *
          bne  LB48C          ; *
          ldx  V41            ; GET ADDRESS OF START OF DESCRIPTOR
          lda  ARYEND         ; GET MSB OF END OF ARRAYS; LSB ALREADY THERE
          subd V41            ; SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR
          std  2,x            ; SAVE LENGTH OF (ARRAY AND DESCRIPTOR)
          lda  DIMFLG         ; * GET ARRAY FLAG AND BRANCH
          bne  LB4CD          ; * BACK IF DIMENSIONING
* CALCULATE POINTER TO CORRECT ELEMENT
LB4A0     ldb  4,x            ; GET THE NUMBER OF DIMENSIONS
          stb  TMPLOC         ; TEMPoraRILY SAVE
          clra                ; * INITIALIZE POINTER
          clrb                ; * TO ZERO
LB4A6     std  COEFPT         ; SAVE ACCUMULATED POINTER
          puls a,b            ; * PULL DIMENSION ARGUMENT OFF THE
          std  FPA0+2         ; * STACK AND SAVE IT
          cmpd 5,x            ; COMPARE TO STORED 'DIM' ARGUMENT
          bcc  LB4EB          ; 'BS' ERROR IF > = "DIM" ARGUMENT
          ldu  COEFPT         ; * GET ACCUMULATED POINTER AND
          beq  LB4B9          ; * BRANCH IF 1ST DIMENSION
          bsr  LB4CE          ; = MULTIPLY ACCUMULATED POINTER AND DIMENSION
          addd FPA0+2         ; = LENGTH AND ADD TO CURRENT ARGUMENT
LB4B9     leax 2,x            ; MOVE POINTER TO NEXT DIMENSION
          dec  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND
          bne  LB4A6          ; * BRANCH IF ANY DIMENSIONS LEFT
* MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE
          std  ,--s
          aslb
          rola                ; TIMES 2
          aslb
          rola                ; TIMES 4
          addd ,s++           ; TIMES 5
          leax d,x            ; ADD OFFSET TO START OF ARRAY
          leax 5,x            ; ADJUST POINTER FOR SIZE OF DESCRIPTOR
          stx  VARPTR         ; SAVE POINTER TO ARRAY VALUE
LB4CD     rts
* MULTIPLY 2 BYTE NUMBER IN 5,x BY THE 2 BYTE NUMBER
* IN COEFPT. RETURN RESULT IN ACCd, BS ERROR IF > $FFFF
LB4CE     lda  #16            ; 16 SHIFTS TO DO A MULTIPLY
          sta  V45            ; SHIFT COUNTER
          ldd  5,x            ; * GET SIZE OF DIMENSION
          std  BOTSTK         ; * AND SAVE IT
          clra                ; * ZERO
          clrb                ; * ACCD
LB4D8     aslb                ; = SHIFT ACCB LEFT
          rola                ; = ONE BIT
          bcs  LB4EB          ; 'BS' ERROR IF CARRY
          asl  COEFPT+1       ; * SHIFT MULTIPLICAND LEFT ONE
          rol  COEFPT         ; * BIT - ADD MULTIPLIER TO ACCUMULATOR
          bcc  LB4E6          ; * IF CARRY <> 0
          addd BOTSTK         ; ADD MULTIPLIER TO ACCD
          bcs  LB4EB          ; 'BS' ERROR IF CARRY (>$FFFF)
LB4E6     dec  V45            ; * DECREMENT SHIFT COUNTER
          bne  LB4D8          ; * IF NOT DONE
          rts
LB4EB     jmp  LB447          ; 'BS' ERROR
*
* MEM
* THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE
* BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK
* FOR WHICH MEM DOES NOT ALLOW.
*
MEM       tfr  s,d            ; PUT STACK POINTER INTO ACCD
          subd ARYEND         ; SUBTRACT END OF ARRAYS
          fcb  SKP1           ; SKIP ONE BYTE
*CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0
LB4F3     clra                ; CLEAR MS BYTE OF ACCD
* CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0
GIVABF    clr  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
          std  FPA0           ; SAVE ACCD IN TOP OF FACA
          ldb  #$90           ; EXPONENT REQUIRED IF THE TOP TWO BYTES
*         OF   FPA0 ARE TO BE TREATED AS AN INTEGER IN FPA0
          jmp  LBC82          ; CONVERT THE REST OF FPA0 TO AN INTEGER

* STR$
STR       jsr  LB143          ; 'TM' ERROR IF STRING VARIABLE
          ldu  #STRBUF+2      ; *CONVERT FP NUMBER TO ASCII STRING IN
          jsr  LBDDC          ; *THE STRING BUFFER
          leas 2,s            ; PURGE THE RETURN ADDRESS FROM THE STACK
          ldx  #STRBUF+1      ; *POINT X TO STRING BUFFER AND SAVE
          bra  LB518          ; *THE STRING IN THE STRING SPACE
* RESERVE ACCB BYTES OF STRING SPACE. RETURN START
* ADDRESS IN (X) AND FRESPC
LB50D     stx  V4D            ; SAVE X IN V4D
LB50F     bsr  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
LB511     stx  STRDES+2       ; SAVE NEW STRING ADDRESS
          stb  STRDES         ; SAVE LENGTH OF RESERVED BLOCK
          rts
LB516     leax -1,x           ; MOVE POINTER BACK ONE
* SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR
* EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.
* THE RESULTING STRING IS STORED IN THE STRING SPACE
* ONLY IF THE START OF THE STRING IS <= STRBUF+2
LB518     lda  #'"'           ; * INITIALIZE
          sta  CHARAC         ; * TERMINATORS
LB51A     sta  ENDCHR         ; * TO "
LB51E     leax 1,x            ; MOVE POINTER UP ONE
          stx  RESSGN         ; TEMPORARILY SAVE START OF STRING
          stx  STRDES+2       ; SAVE START OF STRING IN TEMP DESCRIPTOR
          ldb  #-1            ; INITIALIZE CHARACTER COUNTER TO - 1
LB526     incb                ; INCREMENT CHARACTER COUNTER
          lda  ,x+            ; GET CHARACTER
          beq  LB537          ; BRANCH IF END OF LINE
          cmpa CHARAC         ; * CHECK FOR TERMINATORS
          beq  LB533          ; * IN CHARAC AND ENDCHR
          cmpa ENDCHR         ; * DON'T MOVE POINTER BACK
          bne  LB526          ; * ONE IF TERMINATOR IS "MATCHED"
LB533     cmpa #'"'           ; = COMPARE CHARACTER TO STRING DELIMITER
          beq  LB539          ; = & DON'T MOVE POINTER BACK IF SO
LB537     leax -1,x           ; MOVE POINTER BACK ONE
LB539     stx  COEFPT         ; SAVE END OF STRING ADDRESS
          stb  STRDES         ; SAVE STRING LENGTH IN TEMP DESCRIPTOR
          ldu  RESSGN         ; GET INITlAL STRING START
          cmpu #STRBUF+2      ; COMPARE TO START OF STRING BUFFER
LB543     bhi  LB54C          ; BRANCH IF > START OF STRING BUFFER
          bsr  LB50D          ; GO RESERVE SPACE FOR THE STRING
          ldx  RESSGN         ; POINT X TO THE BEGINNING OF THE STRING
          jsr  LB645          ; MOVE (B) BYTES FROM (X) TO
*                             [FRESPC] - MOVE STRING DATA
* PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA
* ON THE STRING STACK. SET VARIABLE TYPE TO STRING
LB54C     ldx  TEMPPT         ; GET NEXT AVAILABLE STRING STACK DESCRIPTOR
          cmpx #LINHDR        ; COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF
          bne  LB558          ; FORMULA O.K.
          ldb  #15*2          ; STRING FORMULA TOO COMPLEX' ERROR
LB555     jmp  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
LB558     lda  STRDES         ; * GET LENGTH OF STRING AND SAVE IT
*         sta  ,x             ; * IN BYTE 0 OF DESCRIPTOR
          fcb  $A7,$00
          ldd  STRDES+2       ; = GET START ADDRESS OF ACTUAL STRING
          std  2,x            ; = AND SAVE IN BYTES 2,3 OF DESCRIPTOR
          lda  #$FF           ; * VARIABLE TYPE = STRING
          sta  VALTYP         ; * SAVE IN VARIABLE TYPE FLAG
          stx  LASTPT         ; = SAVE START OF DESCRIPTOR
          stx  FPA0+2         ; = ADDRESS IN LASTPT AND FPA0
          leax 5,x            ; 5 BYTES/STRING DESCRIPTOR
          stx  TEMPPT         ; NEXT AVAILABLE STRING VARIABLE DESCRIPTOR
          rts
* RESERVE ACCB BYTES IN STRING STORAGE SPACE
* RETURN WITH THE STARTING ADDRESS OF THE
* RESERVED STRING SPACE IN (X) AND FRESPC
LB56D     clr  GARBFL         ; CLEAR STRING REORGANIZATION FLAG
LB56F     clra                ; * PUSH THE LENGTH OF THE
          pshs b,a            ; * STRING ONTO THE STACK
          ldd  STRTAB         ; GET START OF STRING VARIABLES
          subd ,s+            ; SUBTRACT STRING LENGTH
          cmpd FRETOP         ; COMPARE TO START OF STRING STORAGE
          bcs  LB585          ; IF BELOW START, THEN REORGANIZE
          std  STRTAB         ; SAVE NEW START OF STRING VARIABLES
          ldx  STRTAB         ; GET START OF STRING VARIABLES
          leax 1,x            ; ADD ONE
          stx  FRESPC         ; SAVE START ADDRESS OF NEWLY RESERVED SPACE
          puls b,pc           ; RESTORE NUMBER OF BYTES RESERVED AND RETURN
LB585     ldb  #2*13          ; OUT OF STRING SPACE' ERROR
          com  GARBFL         ; TOGGLE REORGANIZATiON FLAG
          beq  LB555          ; ERROR IF FRESHLY REORGANIZED
          bsr  LB591          ; GO REORGANIZE STRING SPACE
          puls b              ; GET BACK THE NUMBER OF BYTES TO RESERVE
          bra  LB56F          ; TRY TO RESERVE ACCB BYTES AGAIN
* REORGANIZE THE STRING SPACE
LB591     ldx  MEMSIZ         ; GET THE TOP OF STRING SPACE
LB593     stx  STRTAB         ; SAVE TOP OF UNORGANIZED STRING SPACE
          clra                ; * ZERO OUT ACCD
          clrb                ; * AND RESET VARIABLE
          std  V4B            ; * POINTER TO 0
          ldx  FRETOP         ; POINT X TO START OF STRING SPACE
          stx  V47            ; SAVE POINTER IN V47
          ldx  #STRSTK        ; POINT X TO START OF STRING DESCRIPTOR STACK
LB5A0     cmpx TEMPPT         ; COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR
          beq  LB5A8          ; BRANCH IF TOP OF STRING STACK
          bsr  LB5D8          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
          bra  LB5A0          ; KEEP CHECKING
LB5A8     ldx  VARTAB         ; GET THE END OF BASIC PROGRAM
LB5AA     cmpx ARYTAB         ; COMPARE TO END OF VARIABLES
          beq  LB5B2          ; BRANCH IF AT TOP OF VARIABLES
          bsr  LB5D2          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
          bra  LB5AA          ; KEEP CHECKING VARIABLES
LB5B2     stx  V41            ; SAVE ADDRESS OF THE END OF VARIABLES
LB5B4     ldx  V41            ; GET CURRENT ARRAY POINTER
LB5B6     cmpx ARYEND         ; COMPARE TO THE END OF ARRAYS
          beq  LB5EF          ; BRANCH IF AT END OF ARRAYS
          ldd  2,x            ; GET LENGTH OF ARRAY AND DESCRIPTOR
          addd V41            ; * ADD TO CURRENT ARRAY POINTER
          std  V41            ; * AND SAVE IT
          lda  1,x            ; GET 1ST CHARACTER OF VARIABLE NAME
          bpl  LB5B4          ; BRANCH IF NUMERIC ARRAY
          ldb  4,x            ; GET THE NUMBER OF DIMENSIONS IN THIS ARRAY
          aslb                ; MULTIPLY BY 2
          addb #5             ; ADD FIVE BYTES (VARIABLE NAME, ARRAY
*                             ; LENGTH, NUMBER DIMENSIONS)
          abx                 ; X NOW POINTS TO START OF ARRAY ELEMENTS
LB5CA     cmpx V41            ; AT END OF THIS ARRAY?
          beq  LB5B6          ; YES - CHECK FOR ANOTHER
          bsr  LB5D8          ; CHECK FOR STRING LOCATED IN
*                             ; UNORGANIZED STRING SPACE
          bra  LB5CA          ; KEEP CHECKING ELEMENTS IN THIS ARRAY
LB5D2     lda  1,x            ; GET F1RST BYTE OF VARIABLE NAME
          leax 2,x            ; MOVE POINTER TO DESCRIPTOR
          bpl  LB5EC          ; BRANCH IF VARIABLE IS NUMERIC
* SEARCH FOR STRING - ENTER WITH X POINTING TO
* THE STRING DESCRIPTOR. IF STRING IS STORED
* BETWEEN V47 AND STRTAb, SAVE DESCRIPTOR POINTER
* IN V4B AND RESET V47 TO STRING ADDRESS
LB5D8     ldb  ,x             ; GET THE LENGTH OF THE STRING
          beq  LB5EC          ; BRANCH IF NULL - NO STRING
          ldd  2,x            ; GET STARTING ADDRESS OF THE STRING
          cmpd STRTAB         ; COMPARE TO THE START OF STRING VARIABLES
          bhi  LB5EC          ; BRANCH IF THIS STRING IS STORED IN
*              ; THE STRING VARIABLES
          cmpd V47            ; COMPARE TO START OF STRING SPACE
          bls  LB5EC          ; BRANCH IF NOT STORED IN THE STRING SPACE
          stx  V4B            ; SAVE VARIABLE POINTER IF STORED IN STRING SPACE
          std  V47            ; SAVE STRING STARTING ADDRESS
LB5EC     leax 5,x            ; MOVE TO NEXT VARIABLE DESCRIPTOR
LB5EE     rts
LB5EF     ldx  V4B            ; GET ADDRESS OF THE DESCRIPTOR FOR THE
*              ; STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN
*              ; THE UNORGANIZED STRING SPACE
          beq  LB5EE          ; BRANCH IF NONE FOUND AND REORGANIZATION DONE
          clra                ; CLEAR MS BYTE OF LENGTH
          ldb  ,x             ; GET LENGTH OF STRING
          decb                ; SUBTRACT ONE
          addd V47            ; ADD LENGTH OF STRING TO ITS STARTING ADDRESS
          std  V43            ; SAVE AS MOVE STARTING ADDRESS
          ldx  STRTAB         ; POINT X TO THE START OF orgANIZED STRING VARIABLES
          stx  V41            ; SAVE AS MOVE ENDING ADDRESS
          jsr  LAC20          ; MOVE STRING FROM CURRENT POSITION TO THE
*              ; TOP OF UNORGANIZED STRING SPACE
          ldx  V4B            ; POINT X TO STRING DESCRIPTOR
          ldd  V45            ; * GET NEW STARTING ADDRESS OF STRING AND
          std  2,x            ; * SAVE IT IN DESCRIPTOR
          ldx  V45            ; GET NEW TOP OF UNORGANIZED STRING SPACE
          leax -1,x           ; MOVE POINTER BACK ONE
          jmp  LB593          ; JUMP BACK AND REORGANIZE SOME MORE


LB60F     ldd  FPA0+2         ; * GET DESCRIPTOR ADDRESS OF STRING A
          pshs b,a            ; * AND SAVE IT ON THE STACK
          jsr  LB223          ; GET DESCRIPTOR ADDRESS OF STRING B
          jsr  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
          puls x              ; * POINT X TO STRING A DESCRIPTOR
          stx  RESSGN         ; * ADDRESS AND SAVE IT IN RESSGN
          ldb  ,x             ; GET LENGTH OF STRING A
          ldx  FPA0+2         ; POINT X TO DESCRIPTOR OF STRING B
          addb ,x             ; ADD LENGTH OF STRING B TO STR1NG A
          bcc  LB62A          ; BRANCH IF LENGTH < 256
          ldb  #2*14          ; 'STRING TOO LONG' ERROR IF LENGTH > 255
          jmp  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
LB62A     jsr  LB50D          ; RESERVE ROOM IN STRING SPACE FOR NEW STRING
          ldx  RESSGN         ; GET DESCRIPTOR ADDRESS OF STRING A
          ldb  ,x             ; GET LENGTH OF STRING A
          bsr  LB643          ; MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE
          ldx  V4D            ; GET DESCRIPTOR ADDRESS OF STRING B
          bsr  LB659          ; GET LENGTH AND ADDRESS OF STRING B
          bsr  LB645          ; MOVE STRING B INTO REST OF RESERVED BUFFER
          ldx  RESSGN         ; POINT X TO DESCRIPTOR OF STRING A
          bsr  LB659          ; DELETE STRING A IF LAST STRING ON STRING STACK
          jsr  LB54C          ; PUT STRING DESCRIPTOR ON THE STRING STACK
          jmp  LB168          ; BRANCH BACK TO EXPRESSION EVALUATION

* MOVE (B) BYTES FROM 2,x TO FRESPC
LB643     ldx  2,x            ; POINT X TO SOURCE ADDRESS
LB645     ldu  FRESPC         ; POINT U TO DESTINATION ADDRESS
          incb                ; COMPENSATION FOR THE DECB BELOW
          bra  LB64E          ; GO MOVE THE BYTES
* MOVE B BYTES FROM (X) TO (U)
LB64A     lda  ,x+            ; * GET A SOURCE BYTE AND MOVE IT
          sta  ,u+            ; * TO THE DESTINATION
LB64E     decb                ; DECREMENT BYTE COUNTER
          bne  LB64A          ; BRANCH IF ALL BYTES NOT MOVED
          stu  FRESPC         ; SAVE ENDING ADDRESS IN FRESPC
          rts
* RETURN LENGTH (ACCB) AND ADDRESS (X) OF
* STRING WHOSE DESCRIPTOR IS IN FPA0+2
* DELETE THE STRING IF IT IS THE LAST ONE
* PUT ON THE STRING STACK. REMOVE STRING FROM STRING
* SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.
LB654     jsr  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
LB657     ldx  FPA0+2         ; GET ADDRESS OF SELECTED STRING DESCRIPTOR
LB659     ldb  ,x             ; GET LENGTH OF STRING
          bsr  LB675          ; * CHECK TO SEE IF THIS STRING DESCRIPTOR WAS
          bne  LB672          ; * THE LAST ONE PUT ON THE STRING STACK AND
*                             ; * BRANCH IF NOT
          ldx  5+2,x          ; GET START ADDRESS OF STRING JUST REMOVED
          leax -1,x           ; MOVE POINTER DOWN ONE
          cmpx STRTAB         ; COMPARE TO START OF STRING VARIABLES
          bne  LB66F          ; BRANCH IF THIS STRING IS NOT AT THE BOTTOM
*                             ; OF STRING VARIABLES
          pshs b              ; SAVE LENGTH; ACCA WAS CLEARED
          addd STRTAB         ; * ADD THE LENGTH OF THE JUST REMOVED STRING
          std  STRTAB         ; * TO THE START OF STRING VARIABLES - THIS WILL
*                             ; * REMOVE THE STRING FROM THE STRING SPACE
          puls b              ; RESTORE LENGTH
LB66F     leax 1,x            ; ADD ONE TO POINTER
          rts
LB672     ldx  2,x            ; *POINT X TO ADDRESS OF STRING NOT
          rts                 ; *ON THE STRING STACK
* REMOVE STRING FROM STRING STACK. ENTER WITH X
* POINTING TO A STRING DESCRIPTOR - DELETE THE
* STRING FROM STACK IF IT IS ON TOP OF THE
* STACK. IF THE STRING IS DELETEd, SET THE ZERO FLAG
LB675     cmpx LASTPT         ; *COMPARE TO LAST USED DESCRIPTOR ADDRESS
          bne  LB680          ; *ON THE STRING STACK, RETURN IF DESCRIPTOR
*                             ; *ADDRESS NOT ON THE STRING STACK
          stx  TEMPPT         ; SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE
          leax -5,x           ; * MOVE LAST USED DESCRIPTOR BACK 5 BYTES
          stx  LASTPT         ; * AND SAVE AS THE LAST USED DESCRIPTOR ADDR
          clra                ; SET ZERO FLAG
LB680     rts

* LEN
LEN       bsr  LB686          ; POINT X TO PROPER STRING AND GET LENGTH
LB683     jmp  LB4F3          ; CONVERT ACCB TO FP NUMBER IN FPA0
* POINT X TO STRING ADDRESS LOAD LENGTH INTO
* ACCB. ENTER WITH THE STRING DESCRIPTOR IN
* BOTTOM TWO BYTES OF FPA0
LB686     bsr  LB654          ; GET LENGTH AND ADDRESS OF STRING
          clr  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
          tstb                ; SET FLAGS ACCORDING TO LENGTH
          rts

* CHR$
CHR       jsr  LB70E          ; CONVERT FPA0 TO AN INTEGER IN ACCD
LB68F     ldb  #1             ; * RESERVE ONE BYTE IN
          jsr  LB56D          ; * THE STRING SPACE
          lda  FPA0+3         ; GET ASCII STRING VALUE
          jsr  LB511          ; SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR
          sta  ,x             ; SAVE THE STRING (IT'S ONLY ONE BYTE)
LB69B     leas 2,s            ; PURGE THE RETURN ADDRESS OFF OF THE STACK
LB69D     jmp  LB54C          ; PUT TEMP DESCRIPTOR DATA ONTO STRING STACK


ASC       bsr  LB6A4          ; PUT 1ST CHARACTER OF STRING INTO ACCB
          bra  LB683          ; CONVERT ACCB INTO FP NUMBER IN FPA0
LB6A4     bsr  LB686          ; POINT X TO STRING DESCRIPTOR
          beq  LB706          ; 'FC' ERROR IF NULL STRING
          ldb  ,x             ; GET FIRST BYTE OF STRING
          rts


LEFT      bsr  LB6F5          ; GET ARGUMENTS FROM STACK
LB6AD     clra                ; CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$
LB6AE     cmpb ,x             ; * COMPARE LENGTH PARAMETER TO LENGTH OF
          bls  LB6B5          ; * STRING AND BRANCH IF LENGTH OF STRING
*                             ; >= LENGTH PARAMETER
          ldb  ,x             ; USE LENGTH OF STRING OTHERWISE
          clra                ; CLEAR STRING POINTER OFFSET (0 FOR LEFT$)
LB6B5     pshs b,a            ; PUSH PARAMETERS ONTO STACK
          jsr  LB50F          ; RESERVE ACCB BYTES IN THE STRING SPACE
          ldx  V4D            ; POINT X TO STRING DESCRIPTOR
          bsr  LB659          ; GET ADDRESS OF OLD STRING (X=ADDRESS)
          puls b              ; * PULL STRING POINTER OFFSET OFF OF THE STACK
          abx                 ; * AND ADD IT TO STRING ADDRESS
          puls b              ; PULL LENGTH PARAMETER OFF OF THE STACK
          jsr  LB645          ; MOVE ACCB BYTES FROM (X) TO [FRESPC]
          bra  LB69D          ; PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK

* RIGHT$
RIGHT     bsr  LB6F5          ; GET ARGUMENTS FROM STACK
          suba ,x             ; ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING
          nega                ; NOW ACCA = LENGTH OF OLD STRING
          bra  LB6AE          ; PUT NEW STRING IN THE STRING SPACE

* MID$
MID       ldb  #$FF           ; * GET DEFAULT VALUE OF LENGTH AND
          stb  FPA0+3         ; * SAVE IT IN FPA0
          jsr  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
          cmpa #')'           ; ARGUMENT DELIMITER?
          beq  LB6DE          ; YES - NO LENGTH PARAMETER GIVEN
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          bsr  LB70B          ; EVALUATE NUMERIC EXPRESSION (LENGTH)
LB6DE     bsr  LB6F5          ; GET ARGUMENTS FROM STACK
          beq  LB706          ; 'FC' ERROR IF NULL STRING
          clrb                ; CLEAR LENGTH COUNTER (DEFAULT VALUE)
          deca                ; *SUOTRACT ONE FROM POSITION PARAMETER (THESE
          cmpa ,x             ; *ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE)
*                             ; *AND COMPARE IT TO LENGTH OF OLD STRING
          bcc  LB6B5          ; IF POSITION > LENGTH OF OLD STRING, THEN NEW
*                             ; STRING WILL BE A NULL STRING
          tfr  a,b            ; SAVE ABSOLUTE POSITION PARAMETER IN ACCB
          subb ,x             ; ACCB=POSITION-LENGTH OF OLD STRING
          negb                ; NOW ACCB=LENGTH OF OLDSTRING-POSITION
          cmpb FPA0+3         ; *IF THE AMOUNT OF OLD STRING TO THE RIGHT OF
          bls  LB6B5          ; *POSITION IS <= THE LENGTH PARAMETER, BRANCH AND
* USE ALL OF THE STRING TO THE RIGHT OF THE POSITION
* INSTEAD OF THE LENGTH PARAMETER
          ldb  FPA0+3         ; GET LENGTH OF NEW STRING
          bra  LB6B5          ; PUT NEW STRING IN STRING SPACE
* DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC
* ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK
LB6F5     jsr  LB267          ; SYNTAX CHECK FOR A ")"
          ldu  ,s             ; LOAD THE RETURN ADDRESS INTO U REGISTER
          ldx  5,s            ; * GET ADDRESS OF STRING AND
          stx  V4D            ; * SAVE IT IN V4D
          lda  4,s            ; = PUT LENGTH OF STRING IN
          ldb  4,s            ; = BOTH ACCA AND ACCB
          leas 7,s            ; REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK
          tfr  u,pc           ; JUMP TO ADDRESS IN U REGISTER
LB706     jmp  LB44A          ; 'ILLEGAL FUNCTION CALL'
* EVALUATE AN EXPRESSION - RETURN AN INTEGER IN
* ACCB - 'FC' ERROR IF EXPRESSION > 255
LB709     jsr  GETNCH         ; GET NEXT BASIC INPUT CHARACTER
LB70B     jsr  LB141          ; EVALUATE A NUMERIC EXPRESSION
LB70E     jsr  LB3E9          ; CONVERT FPA0 TO INTEGER IN ACCD
          tsta                ; TEST MS BYTE OF INTEGER
          bne  LB706          ; 'FC' ERROR IF EXPRESSION > 255
          jmp  GETCCH         ; GET CURRENT INPUT CHARACTER FROM BASIC

* VAL
VAL       jsr  LB686          ; POINT X TO STRING ADDRESS
          lbeq LBA39          ; IF NULL STRING SET FPA0
          ldu  CHARAD         ; SAVE INPUT POINTER IN REGISTER U
          stx  CHARAD         ; POINT INPUT POINTER TO ADDRESS OF STRING
          abx                 ; MOVE POINTER TO END OF STRING TERMINATOR
          lda  ,x             ; GET LAST BYTE OF STRING
          pshs u,x,a          ; SAVE INPUT POINTER, STRING TERMINATOR
*         ADDRESS AND CHARACTER
          clr  ,x             ; CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION
          jsr  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
          jsr  LBD12          ; CONVERT AN ASCII STRING TO FLOATING POINT
          puls a,x,u          ; RESTORE CHARACTERS AND POINTERS
          sta  ,x             ; REPLACE STRING TERMINATOR
          stu  CHARAD         ; RESTORE INPUT CHARACTER
          rts

LB734     bsr  LB73D          ; * EVALUATE AN EXPRESSION, RETURN
          stx  BINVAL         ; * THE VALUE IN X; STORE IT IN BINVAL
LB738     jsr  LB26D          ; SYNTAX CHECK FOR A COMMA
          bra  LB70B          ; EVALUATE EXPRESSION IN RANGE 0 <= X < 256
* EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF

LB73D     jsr  LB141          ; EVALUATE NUMERIC EXPRESSION
LB740     lda  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
          bmi  LB706          ; ILLEGAL FUNCTION CALL' IF NEGATIVE
          lda  FP0EXP         ; GET EXPONENT OF FPA0
          cmpa #$90           ; COMPARE TO LARGEST POSITIVE INTEGER
          bhi  LB706          ; ILLEGAL FUNCTION CALL' IF TOO LARGE
          jsr  LBCC8          ; SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0
          ldx  FPA0+2         ; LOAD X WITH LOWER TWO BYTES OF FPA0
          rts

* PEEK
PEEK      bsr  LB740          ; CONVERT FPA0 TO INTEGER IN REGISTER X
          ldb  ,x             ; GET THE VALUE BEING 'PEEK'ED
          jmp  LB4F3          ; CONVERT ACCB INTO A FP NUMBER

* POKE
POKE      bsr  LB734          ; EVALUATE 2 EXPRESSIONS
          ldx  BINVAL         ; GET THE ADDRESS TO BE 'POKE'ED
          stb  ,x             ; STORE THE DATA IN THAT ADDRESS
          rts

* LIST
LIST      pshs cc             ; SAVE ZERO FLAG ON STACK
          jsr  LAF67          ; CONVERT DECIMAL LINE NUMBER TO BINARY
          jsr  LAD01          ; * FIND RAM ADDRESS OF THAT LINE NUMBER AND
          stx  LSTTXT         ; * SAVE IT IN LSTTXT
          puls cc             ; GET ZERO FLAG FROM STACK
          beq  LB784          ; BRANCH IF END OF LINE
          jsr  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
          beq  LB789          ; BRANCH IF END OF LINE
          cmpa #TOK_MINUS     ; MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?)
          bne  LB783          ; NO - RETURN
          jsr  GETNCH         ; GET NEXT CHARACTER FROM BASIC
          beq  LB784          ; BRANCH IF END OF LINE
          jsr  LAF67          ; GET ENDING LINE NUMBER
          beq  LB789          ; BRANCH IF LEGAL LINE NUMBER
LB783     rts
* LIST THE ENTIRE PROGRAM
LB784     ldu  #$FFFF         ; * SET THE DEFAULT ENDING LINE NUMBER
          stu  BINVAL         ; * TO $FFFF
LB789     ldx  LSTTXT         ; POINT X TO STARTING LINE ADDRESS
LB78D     jsr  LB95C          ; MOVE CURSOR TO START OF A NEW LINE
          jsr  LA549          ; CHECK FOR A BREAK OR PAUSE
          ldd  ,x             ; GET ADDRESS OF NEXT BASIC LINE
          bne  LB79F          ; BRANCH IF NOT END OF PROGRAM
LB797
          tst  DEVNUM		  ; null value when screen as output
		  bne  LB783          ; return from call for disk following code execution
		  leas 2,s            ; PURGE RETURN ADDRESS FROM THE STACK		  
		  jmp  LAC73          ; RETURN TO BASIC'S MAIN INPUT LOOP
LB79F     stx  LSTTXT         ; SAVE NEW STARTING LINE ADDRESS
          ldd  2,x            ; * GET THE LINE NUMBER OF THIS LINE AND
          cmpd BINVAL         ; * COMPARE IT TO ENDING LINE NUMBER
          bhi  LB797          ; EXIT IF LINE NUMBER > ENDING LINE NUMBER
          jsr  LBDCC          ; PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL
          jsr  LB9AC          ; SEND A SPACE TO CONSOLE OUT
          ldx  LSTTXT         ; GET RAM ADDRESS OF THIS LINE
          bsr  LB7C2          ; UNCRUNCH A LINE
          ldx  [LSTTXT]       ; POINT X TO START OF NEXT LINE
          ldu  #LINBUF+1      ; POINT U TO BUFFER FULL OF UNCRUNCHED LINE
LB7B9     lda  ,u+            ; GET A BYTE FROM THE BUFFER
          beq  LB78D          ; BRANCH IF END OF BUFFER
          jsr  LB9B1          ; SEND CHARACTER TO CONSOLE OUT
          bra  LB7B9          ; GET ANOTHER CHARACTER

* UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
LB7C2     leax 4,x            ; MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER
          ldy  #LINBUF+1      ; UNCRUNCH LINE INTO LINE INPUT BUFFER
LB7CB     lda  ,x+            ; GET A CHARACTER
          beq  LB820          ; BRANCH IF END OF LINE
          bmi  LB7E6          ; BRANCH IF IT'S A TOKEN
          cmpa #':'           ; CHECK FOR END OF SUB LINE
          bne  LB7E2          ; BRNCH IF NOT END OF SUB LINE
          ldb  ,x             ; GET CHARACTER FOLLOWING COLON
          cmpb #TOK_ELSE      ; TOKEN FOR ELSE?
          beq  LB7CB          ; YES - DON'T PUT IT IN BUFFER
          cmpb #TOK_SNGL_Q    ; TOKEN FOR REMARK?
          beq  LB7CB          ; YES - DON'T PUT IT IN BUFFER
          fcb  SKP2           ; SKIP TWO BYTES
LB7E0     lda  #'!'           ; EXCLAMATION POINT
LB7E2     bsr  LB814          ; PUT CHARACTER IN BUFFER
          bra  LB7CB          ; GET ANOTHER CHARACTER

LB7E6     ldu  #COMVEC-10     ; FIRST DO COMMANDS
          cmpa #$FF           ; CHECK FOR SECONDARY TOKEN
          bne  LB7F1          ; BRANCH IF NON SECONDARY TOKEN
          lda  ,x+            ; GET SECONDARY TOKEN
          leau 5,u            ; BUMP IT UP TO SECONDARY FUNCTIONS
LB7F1     anda #$7F           ; MASK OFF BIT 7 OF TOKEN
LB7F3     leau 10,u           ; MOVE TO NEXT COMMAND TABLE
          tst  ,u             ; IS THIS TABLE ENABLED?
          beq  LB7E0          ; NO - ILLEGAL TOKEN
          suba ,u             ; SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER
          bpl  LB7F3          ; BRANCH IF TOKEN NOT IN THIS TABLE
          adda ,u             ; RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE
          ldu  1,u            ; POINT U TO COMMAND DICTIONARY TABLE
LB801     deca                ; DECREMENT TOKEN NUMBER
          bmi  LB80A          ; BRANCH IF THIS IS THE CORRECT TOKEN
* SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN
LB804     tst  ,u+            ; GRAB A BYTE
          bpl  LB804          ; BRANCH IF BIT 7 NOT SET
          bra  LB801          ; GO SEE IF THIS IS THE CORRECT TOKEN
LB80A     lda  ,u             ; GET A CHARACTER FROM DICTIONARY TABLE
          bsr  LB814          ; PUT CHARACTER IN BUFFER
          tst  ,u+            ; CHECK FOR START OF NEXT TOKEN
          bpl  LB80A          ; BRANCH IF NOT DONE WITH THIS TOKEN
          bra  LB7CB          ; GO GET ANOTHER CHARACTER
LB814     cmpy #LINBUF+LBUFMX ; TEST FOR END OF LINE INPUT BUFFER
          bcc  LB820          ; BRANCH IF AT END OF BUFFER
          anda #$7F           ; MASK OFF BIT 7
          sta  ,y+            ; * SAVE CHARACTER IN BUFFER AND
          clr  ,y             ; * CLEAR NEXT CHARACTER SLOT IN BUFFER
LB820     rts
*
* CRUNCH THE LINE THAT THE INPUT POINTER IS
* POINTING TO INTO THE LINE INPUT BUFFER
* RETURN LENGTH OF CRUNCHED LINE IN ACCD
*
LB821     ldx  CHARAD         ; GET BASIC'S INPUT POINTER ADDRESS
          ldu  #LINBUF        ; POINT X TO LINE INPUT BUFFER
LB829     clr  V43            ; CLEAR ILLEGAL TOKEN FLAG
          clr  V44            ; CLEAR DATA FLAG
LB82D     lda  ,x+            ; GET INPUT CHAR
          beq  LB852          ; BRANCH IF END OF LINE
          tst  V43            ; * CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT
          beq  LB844          ; * PROCESSING AN ILLEGAL TOKEN
          jsr  LB3A2          ; SET CARRY IF NOT UPPER CASE ALPHA
          bcc  LB852          ; BRANCH IF UPPER CASE ALPHA
          cmpa #'0'            ; * DON'T CRUNCH ASCII NUMERIC CHARACTERS
          blo  LB842          ; * BRANCH IF NOT NUMERIC
          cmpa #'9'           ; *
          bls  LB852          ; * BRANCH IF NUMERIC
* END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC
LB842     clr  V43            ; CLEAR ILLEGAL TOKEN FLAG
LB844     cmpa #SPACE         ; SPACE?
          beq  LB852          ; DO NOT REMOVE SPACES
          sta  V42            ; SAVE INPUT CHARACTER AS SCAN DELIMITER
          cmpa #'"'           ; CHECK FOR STRING DELIMITER
          beq  LB886          ; BRANCH IF STRING
          tst  V44            ; * CHECK DATA FLAG AND BRANCH IF CLEAR
          beq  LB86B          ; * DO NOT CRUNCH DATA
LB852     sta  ,u+            ; SAVE CHARACTER IN BUFFER
          beq  LB85C          ; BRANCH IF END OF LINE
          cmpa #':'           ; * CHECK FOR END OF SUBLINE
          beq  LB829          ; * AND RESET FLAGS IF END OF SUBLINE
LB85A     bra  LB82D          ; GO GET ANOTHER CHARACTER
LB85C     clr  ,u+            ; * DOUBLE ZERO AT END OF LINE
          clr  ,u+            ; *
          tfr  u,d            ; SAVE ADDRESS OF END OF LINE IN ACCD
          subd #LINHDR        ; LENGTH OF LINE IN ACCD
          ldx  #LINBUF-1      ; * SET THE INPUT POINTER TO ONE BEFORE
          stx  CHARAD         ; * THE START OF THE CRUNCHED LINE
          rts                 ; EXIT 'CRUNCH'
LB86B     cmpa #'?'           ; CHECK FOR "?" - PRINT ABBREVIATION
          bne  LB873          ; BRANCH IF NOT PRINT ABBREVIATION
          lda  #TOK_PRINT     ; * GET THE PRINT TOKEN AND SAVE IT
          bra  LB852          ; * IN BUFFER
LB873     cmpa #$27           ; #''' APOSTROPHE IS SAME AS REM
          bne  LB88A          ; BRANCH IF NOT REMARK
          ldd  #$3A00+TOK_SNGL_Q ; COLON, REM TOKEN
          std  ,u++           ; SAVE IN BUFFER
LB87C     clr  V42            ; SET DELIMITER = 0 (END OF LINE)
LB87E     lda  ,x+            ; SCAN TILL WE MATCH [V42]
          beq  LB852          ; BRANCH IF END OF LINE
          cmpa V42            ; DELIMITER?
          beq  LB852          ; BRANCH OUT IF SO
LB886     sta  ,u+            ; DON'T CRUNCH REMARKS OR STRINGS
          bra  LB87E          ; GO GET MORE STRING OR REMARK
LB88A     cmpa #'0'            ; * LESS THAN ASCII ZERO?
          bcs  LB892          ; * BRANCH IF SO
          cmpa #';'+1         ; = CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON
          bcs  LB852          ; = AND INSERT IN BUFFER IF SO
LB892     leax -1,x           ; MOVE INPUT POINTER BACK ONE
          pshs u,x            ; SAVE POINTERS TO INPUT STRING, OUTPUT STRING
          clr  V41            ; TOKEN FLAG 0 = COMMANd, FF = SECONDARY
          ldu  #COMVEC-10     ; POINT U TO COMMAND INTERPRETATION
*                             ; TABLE FOR BASIC - 10
LB89B     clr  V42            ; INITIALIZE V42 AS TOKEN COUNTER
LB89D     leau 10,u           ; MOVE TO NEXT COMMAND INTERPRETATION TABLE
          lda  ,u             ; GET NUMBER OF COMMANDS
          beq  LB8D4          ; GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE
          ldy  1,u            ; POINT Y TO COMMAND DICTIONARY TABLE
LB8A6     ldx  ,s             ; GET POINTER TO INPUT STRING
LB8A8     ldb  ,y+            ; GET A BYTE FROM DICTIONARY TABLE
          subb ,x+            ; SUBTRACT INPUT CHARACTER
          beq  LB8A8          ; LOOP IF SAME
          cmpb #$80           ; LAST CHAR IN RESERVED WORD TABLE HAD
*                             ; BIT 7 SET, SO IF WE HAVE $80 HERE
*                             ; THEN IT IS A GOOD COMPARE
          bne  LB8EA          ; BRANCH IF NO MATCH - CHECK ANOTHER COMMAND
          leas 2,s            ; DELETE OLD INPUT POINTER FROM STACK
          puls u              ; GET POINTER TO OUTPUT STRING
          orb  V42            ; OR IN THE TABLE POSITION TO MAKE THE TOKEN
*                             ; - NOTE THAT B ALREADY HAD $80 IN IT -
          lda  V41            ; * CHECK TOKEN FLAG AND BRANCH
          bne  LB8C2          ; * IF SECONDARY
          cmpb #TOK_ELSE      ; IS IT ELSE TOKEN?
          bne  LB8C6          ; NO
          lda  #':'           ; PUT A COLON (SUBLINE) BEFORE ELSE TOKEN
LB8C2     std  ,u++           ; SECONDARY TOKENS PRECEEDED BY $FF
          bra  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
LB8C6     stb  ,u+            ; SAVE THIS TOKEN
          cmpb #TOK_DATA      ; DATA TOKEN?
          bne  LB8CE          ; NO
          inc  V44            ; SET DATA FLAG
LB8CE     cmpb #TOK_REM       ; REM TOKEN?
          beq  LB87C          ; YES
LB8D2     lbra LB85A          ; GO PROCESS MORE INPUT CHARACTERS
* CHECK FOR A SECONDARY TOKEN
LB8D4     ldu  #COMVEC-5      ; NOW DO SECONDARY FUNCTIONS
          com  V41            ; TOGGLE THE TOKEN FLAG
          bne  LB89B          ; BRANCH IF NOW CHECKING SECONDARY COMMANDS

* THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO
* IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN
          puls x,u            ; RESTORE INPUT AND OUTPUT POINTERS
          lda  ,x+            ; * MOVE THE FIRST CHARACTER OF AN
          sta  ,u+            ; * ILLEGAL TOKEN
          jsr  LB3A2          ; SET CARRY IF NOT ALPHA
          bcs  LB8D2          ; BRANCH IF NOT ALPHA
          com  V43            ; SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA
          bra  LB8D2          ; PROCESS MORE INPUT CHARACTERS
LB8EA     inc  V42            ; INCREMENT TOKEN COUNTER
          deca                ; DECR COMMAND COUNTER
          beq  LB89D          ; GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE
          leay -1,y           ; MOVE POINTER BACK ONE
LB8F1     ldb  ,y+            ; * GET TO NEXT
          bpl  LB8F1          ; * RESERVED WORD
          bra  LB8A6          ; GO SEE IF THIS WORD IS A MATCH

* PRINT
PRINT     beq  LB958          ; BRANCH IF NO ARGUMENT
          bsr  LB8FE          ; CHECK FOR ALL PRINT OPTIONS
          rts

LB8FE	cmpa #'@'	; CHECK FOR PRINT @
		bne	LB907	; NOT PRINT @
LB902	jsr	LA554	; MOVE CURSOR TO PROPER PRINT LOCATION
LB905	bra	LB911	; GO PRINT THE DATA
LB907	cmpa #'#'	; CHECK FOR PRINT NUMBER
		bne	LB918	; NOT PRINT#
		;jsr	LA5A5	; CHECK FOR A VALID DEVICE NUMBER
		;jsr	LA406	; CHECK FOR A VALID OUTPUT FILE
LB911	jsr	GETCCH	; GET CURRENT INPUT CHARACTER
		beq	LB958	; BRANCH IF END OF LINE
		jsr	LB26D	; SYNTAX CHECK FOR COMMA

LB918     jsr  XVEC9          ; CALL EXTENDED BASIC ADD-IN
LB91B     beq  LB965          ; RETURN IF END OF LINE
LB91D     cmpa #TOK_TAB       ; TOKEN FOR TAB( ?
          beq  LB97E          ; YES
          cmpa #','           ; COMMA?
          beq  LB966          ; YES - ADVANCE TO NEXT TAB FIELD
          cmpa #';'           ; SEMICOLON?
          beq  LB997          ; YES - DO NOT ADVANCE CURSOR
          jsr  LB156          ; EVALUATE EXPRESSION
          lda  VALTYP         ; * GET VARIABLE TYPE AND
          pshs a              ; * SAVE IT ON THE STACK
          bne  LB938          ; BRANCH IF STRING VARIABLE
          jsr  LBDD9          ; CONVERT FP NUMBER TO AN ASCII STRING
          jsr  LB516          ; PARSE A STRING FROM (X-1) AND PUT
*                             ; DESCRIPTOR ON STRING STACK
LB938     bsr  LB99F          ; PRINT STRING POINTED TO BY X
          puls b              ; GET VARIABLE TYPE BACK
          jsr  LA35F          ; SET UP TAB WIDTH ZONE, ETC
LB949     tstb                ; CHECK CURRENT PRINT POSITION
          bne  LB954          ; BRANCH IF NOT AT START OF LINE
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          cmpa #','            ; COMMA?
          beq  LB966          ; SKIP TO NEXT TAB FIELD
          bsr  LB9AC          ; SEND A SPACE TO CONSOLE OUT
LB954     jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          bne  LB91D          ; BRANCH IF NOT END OF LINE
LB958     lda  #CR            ; * SEND A CR TO
          bra  LB9B1          ; * CONSOLE OUT
LB95C     jsr  LA35F          ; SET UP TAB WIDTH, ZONE ETC
          beq  LB958          ; BRANCH IF WIDTH = ZERO
          lda  DEVPOS         ; GET PRINT POSITION
          bne  LB958          ; BRANCH IF NOT AT START OF LINE
LB965     rts
* SKIP TO NEXT TAB FIELD
LB966     jsr  LA35F          ; SET UP TAB WIDTH, ZONE ETC
          beq  LB975          ; BRANCH IF LINE WIDTH = 0 (CASSETTE)
          ldb  DEVPOS         ; GET CURRENT POSITION
          cmpb DEVLCF         ; COMPARE TO LAST TAB ZONE
          bcs  LB977          ; BRANCH IF < LAST TAB ZONE
          bsr  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
          bra  LB997          ; GET MORE DATA
LB975     ldb  DEVPOS         ; *
LB977     subb DEVCFW         ; * SUBTRACT TAB FIELD WIDTH FROM CURRENT
          bcc  LB977          ; * POSITION UNTIL CARRY SET - NEGATING THE
          negb                ; * REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT
*              ; * TAB ZONE IN ACCB
          bra  LB98E          ; GO ADVANCE TO NEXT TAB ZONE

* PRINT TAB(
LB97E     jsr  LB709          ; EVALUATE EXPRESSION - RETURN VALUE IN B
          cmpa #')'           ; * 'SYNTAX' ERROR IF NOT ')'
          lbne LB277          ; *
          jsr  LA35F          ; SET UP TAB WIDTH, ZONE ETC
          subb DEVPOS         ; GET DIFFERENCE OF PRINT POSITION & TAB POSITION
          bls  LB997          ; BRANCH IF TAB POSITION < CURRENT POSITION
LB98E
LB992     bsr  LB9AC          ; SEND A SPACE TO CONSOLE OUT
          decb                ; DECREMENT DIFFERENCE COUNT
          bne  LB992          ; BRANCH UNTIL CURRENT POSITION = TAB POSITION
LB997     jsr  GETNCH         ; GET NEXT CHARACTER FROM BASIC
          jmp  LB91B          ; LOOK FOR MORE PRINT DATA
* COPY A STRING FROM (X) TO CONSOLE OUT
LB99C     jsr  LB518          ; PARSE A STRING FROM X AND PUT DESCRIPTOR ON STRING STACK
LB99F     jsr  LB657          ; GET LENGTH OF STRING AND REMOVE DESCRIPTOR FROM STRING STACK
          incb                ; COMPENSATE FOR DECB BELOW
LB9A3     decb                ; DECREMENT COUNTER
          beq  LB965          ; EXIT ROUTINE
          lda  ,x+            ; GET A CHARACTER FROM X
          bsr  LB9B1          ; SEND TO CONSOLE OUT
          bra  LB9A3          ; KEEP LOOPING
LB9AC     lda  #SPACE         ; SPACE TO CONSOLE OUT
          fcb  SKP2           ; SKIP NEXT TWO BYTES
LB9AF     lda  #'?'           ; QUESTION MARK TO CONSOLE OUT
LB9B1     jmp  PUTCHR         ; JUMP TO CONSOLE OUT

* FLOATING POINT MATH PACKAGE

* ADD .5 TO FPA0
LB9B4     ldx  #LBEC0         ; FLOATING POINT CONstaNT (.5)
          bra  LB9C2          ; ADD .5 TO FPA0
* SUBTRACT FPA0 FROM FP NUMBER POINTED
* TO BY (X), LEAVE RESULT IN FPA0
LB9B9     jsr  LBB2F          ; COPY PACKED FP DATA FROM (X) TO FPA1

* ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER
* WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)
LB9BC     com  FP0SGN         ; CHANGE MANTISSA SIGN OF FPA0
          com  RESSGN         ; REVERSE RESULT SIGN FLAG
          bra  LB9C5          ; GO ADD FPA1 AND FPA0
* ADD FP NUMBER POINTED TO BY
* (X) TO FPA0 - LEAVE RESULT IN FPA0
LB9C2     jsr  LBB2F          ; UNPACK PACKED FP DATA FROM (X) TO
*         FPA1; RETURN EXPONENT OF FPA1 IN ACCA

* ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO

LB9C5     tstb                ; CHECK EXPONENT OF FPA0
          lbeq LBC4A          ; COPY FPA1 TO FPA0 IF FPA0 =
          ldx  #FP1EXP        ; POINT X TO FPA1
LB9CD     tfr  a,b            ; PUT EXPONENT OF FPA1 INTO ACCB
          tstb                ; CHECK EXPONENT
          beq LBA3E           ; RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0)
          subb FP0EXP         ; SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1
          beq LBA3F           ; BRANCH IF EXPONENTS ARE EQUAL
          bcs  LB9E2          ; BRANCH IF EXPONENT FPA0 > FPA1
          sta  FP0EXP         ; REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT
          lda  FP1SGN         ; * REPLACE FPA0 MANTISSA SIGN
          sta  FP0SGN         ; * WITH FPA1 MANTISSA SIGN
          ldx  #FP0EXP        ; POINT X TO FPA0
          negb                ; NEGATE DIFFERENCE OF EXPONENTS
LB9E2     cmpb #-8            ; TEST DIFFERENCE OF EXPONENTS
          ble  LBA3F          ; BRANCH IF DIFFERENCE OF EXPONENTS <= 8
          clra                ; CLEAR OVERFLOW BYTE
          lsr  1,x            ; SHIFT MS BYTE OF MANTISSA; BIT 7 = 0
          jsr  LBABA          ; GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES
LB9EC     ldb  RESSGN         ; GET SIGN FLAG
          bpl  LB9FB          ; BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME
          com  1,x            ; * COMPLEMENT MANTISSA POINTED
          com  2,x            ; * TO BY (X) THE
          com  3,x            ; * adca BELOW WILL
          com  4,x            ; * CONVERT THIS OPERATION
          coma                ; * INTO A NEG (MANTISSA)
          adca #0             ; ADD ONE TO ACCA - coma ALWAYS SETS THE CARRY FLAG
* THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA
*
* ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0
LB9FB     sta  FPSBYT         ; SAVE FPA SUB BYTE
          lda  FPA0+3         ; * ADD LS BYTE
          adca FPA1+3         ; * OF MANTISSA
          sta  FPA0+3         ; SAVE IN FPA0 LSB
          lda  FPA0+2         ; * ADD NEXT BYTE
          adca FPA1+2         ; * OF MANTISSA
          sta  FPA0+2         ; SAVE IN FPA0
          lda  FPA0+1         ; * ADD NEXT BYTE
          adca FPA1+1         ; * OF MANTISSA
          sta  FPA0+1         ; SAVE IN FPA0
          lda  FPA0           ; * ADD MS BYTE
          adca FPA1           ; * OF MANTISSA
          sta  FPA0           ; SAVE IN FPA0
          tstb                ; TEST SIGN FLAG
          bpl  LBA5C          ; BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE
LBA18     bcs  LBA1C          ; BRANCH IF POSITIVE MANTISSA
          bsr  LBA79          ; NEGATE FPA0 MANTISSA

* NORMALIZE FPA0
LBA1C     clrb                ; CLEAR TEMPORARY EXPONENT ACCUMULATOR
LBA1D     lda  FPA0           ; TEST MSB OF MANTISSA
          bne  LBA4F          ; BRANCH IF <> 0
          lda  FPA0+1         ; * IF THE MSB IS
          sta  FPA0           ; * 0, THEN SHIFT THE
          lda  FPA0+2         ; * MANTISSA A WHOLE BYTE
          sta  FPA0+1         ; * AT A TIME. THIS
          lda  FPA0+3         ; * IS FASTER THAN ONE
          sta  FPA0+2         ; * BIT AT A TIME
          lda  FPSBYT         ; * BUT USES MORE MEMORY.
          sta  FPA0+3         ; * FPSBYT, THE CARRY IN
          clr  FPSBYT         ; * BYTE, REPLACES THE MATISSA LSB.
          addb #8             ; SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT
          cmpb #5*8           ; CHECK FOR 5 SHIFTS
          blt  LBA1D          ; BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0
LBA39     clra                ; A ZERO EXPONENT = 0 FLOATING POINT
LBA3A     sta  FP0EXP         ; ZERO OUT THE EXPONENT
          sta  FP0SGN         ; ZERO OUT THE MANTISSA SIGN
LBA3E     rts
LBA3F     bsr LBAAE           ; SHIFT FPA0 MANTISSA TO RIGHT
          clrb                ; CLEAR CARRY FLAG
          bra  LB9EC
* SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7
* OF MATISSA MS BYTE = 1
LBA44     incb                ; ADD ONE TO EXPONENT ACCUMULATOR
          asl  FPSBYT         ; SHIFT SUB BYTE ONE LEFT
          rol  FPA0+3         ; SHIFT LS BYTE
          rol  FPA0+2         ; SHIFT NS BYTE
          rol  FPA0+1         ; SHIFT NS BYTE
          rol  FPA0           ; SHIFT MS BYTE
LBA4F     bpl  LBA44          ; BRANCH IF NOT YET NORMALIZED
          lda  FP0EXP         ; GET CURRENT EXPONENT
          pshs b              ; SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION
          suba ,s+            ; SUBTRACT ACCUMULATED EXPONENT MODIFIER
          sta  FP0EXP         ; SAVE AS NEW EXPONENT
          bls  LBA39          ; SET FPA0 = 0 IF THE NORMALIZATION CAUSED
*         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE
*         SIZE OF THE EXPONENT
          fcb  SKP2           ; SKIP 2 BYTES
LBA5C     bcs  LBA66          ; BRANCH IF MANTISSA OVERFLOW
          asl  FPSBYT         ; SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF
*                             ; FLAG (TRUNCATE THE REST OF SUB BYTE)
          lda  #0             ; clra, BUT DO NOT CHANGE CARRY FLAG
          sta  FPSBYT         ; CLEAR THE SUB BYTE
          bra  LBA72          ; GO ROUND-OFF RESULT
LBA66     inc  FP0EXP         ; INCREMENT EXPONENT - MULTIPLY BY 2
          beq  LBA92          ; OVERFLOW ERROR IF CARRY PAST $FF
          ror  FPA0           ; * SHIFT MANTISSA
          ror  FPA0+1         ; * ONE TO
          ror  FPA0+2         ; * THE RIGHT -
          ror  FPA0+3         ; * DIVIDE BY TWO
LBA72     bcc  LBA78          ; BRANCH IF NO ROUND-OFF NEEDED
          bsr  LBA83          ; ADD ONE TO MANTISSA - ROUND OFF
          beq  LBA66          ; BRANCH iF OVERFLOW - MANTISSA = 0
LBA78     rts
* NEGATE FPA0 MANTISSA
LBA79     com  FP0SGN         ; TOGGLE SIGN OF MANTISSA
LBA7B     com  FPA0           ; * COMPLEMENT ALL 4 MANTISSA BYTES
          com  FPA0+1         ; *
          com  FPA0+2         ; *
          com  FPA0+3         ; *
* ADD ONE TO FPA0 MANTISSA
LBA83     ldx  FPA0+2         ; * GET BOTTOM 2 MANTISSA
          leax 1,x            ; * BYTES, ADD ONE TO
          stx  FPA0+2         ; * THEM AND SAVE THEM
          bne  LBA91          ; BRANCH IF NO OVERFLOW
          ldx  FPA0           ; * IF OVERFLOW ADD ONE
          leax 1,x            ; * TO TOP 2 MANTISSA
          stx  FPA0           ; * BYTES AND SAVE THEM
LBA91     rts
LBA92     ldb  #2*5           ; OV' OVERFLOW ERROR
          jmp  LAC46          ; PROCESS AN ERROR
LBA97     ldx  #FPA2-1        ; POINT X TO FPA2
* SHIFT FPA POINTED TO BY (X) TO
* THE RIGHT -(B) TIMES. EXIT WITH
* ACCA CONTAINING DATA SHIFTED OUT
* TO THE RIGHT (SUB BYTE) AND THE DATA
* SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY
LBA9A     lda  4,x            ; GET LS BYTE OF MANTISSA (X)
          sta  FPSBYT         ; SAVE IN FPA SUB BYTE
          lda  3,x            ; * SHIFT THE NEXT THREE BYTES OF THE
          sta  4,x            ; * MANTISSA RIGHT ONE COMPLETE BYTE.
          lda  2,x            ; *
          sta  3,x            ; *
          lda  1,x            ; *
          sta  2,x            ; *
          lda  FPCARY         ; GET THE CARRY IN BYTE
          sta  1,x            ; STORE AS THE MS MANTISSA BYTE OF (X)
LBAAE     addb #8             ; ADD 8 TO DIFFERENCE OF EXPONENTS
          ble  LBA9A          ; BRANCH IF EXPONENT DIFFERENCE < -8
          lda  FPSBYT         ; GET FPA SUB BYTE
          subb #8             ; CAST OUT THE 8 ADDED IN ABOVE
          beq  LBAC4          ; BRANCH IF EXPONENT DIFFERENCE = 0


LBAB8     asr  1,x            ; * SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT
LBABA     ror  2,x            ; *
          ror  3,x            ; *
          ror  4,x            ; *
          rora                ; *
          incb                ; ADD ONE TO EXPONENT DIFFERENCE
          bne  LBAB8          ; BRANCH IF EXPONENTS NOT =
LBAC4     rts
LBAC5     fcb  $81,$00,$00,$00,$00 ; FLOATING POINT CONSTANT 1.0

* ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY
* FPA0 BY (X) - RETURN PRODUCT IN FPA0
LBACA     bsr  LBB2F          ; MOVE PACKED FPA FROM (X) TO FPA1
LBACC     beq  LBB2E          ; BRANCH IF EXPONENT OF FPA0 = 0
          bsr  LBB48          ; CALCULATE EXPONENT OF PRODUCT
* MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE
* HIGH ORDER BYTES OF PRODUCT IN FPA0. THE
* LOW ORDER FOUR BYTES OF THE PRODUCT WILL
* BE STORED IN VAB-VAE.
LBAD0     lda  #0             ; * ZERO OUT MANTISSA OF FPA2
          sta  FPA2           ; *
          sta  FPA2+1         ; *
          sta  FPA2+2         ; *
          sta  FPA2+3         ; *
          ldb  FPA0+3         ; GET LS BYTE OF FPA0
          bsr  LBB00          ; MULTIPLY BY FPA1
          ldb  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 4
          stb  VAE            ; *
          ldb  FPA0+2         ; GET NUMBER 3 MANTISSA BYTE OF FPA0
          bsr  LBB00          ; MULTIPLY BY FPA1
          ldb  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 3
          stb  VAD            ; *
          ldb  FPA0+1         ; GET NUMBER 2 MANTISSA BYTE OF FPA0
          bsr  LBB00          ; MULTIPLY BY FPA1
          ldb  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 2
          stb  VAC            ; *
          ldb  FPA0           ; GET MS BYTE OF FPA0 MANTISSA
          bsr  LBB02          ; MULTIPLY BY FPA1
          ldb  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 1
          stb  VAB            ; *
          jsr  LBC0B          ; COPY MANTISSA FROM FPA2 TO FPA0
          jmp  LBA1C          ; NORMALIZE FPA0
LBB00     lbeq LBA97          ; SHIFT FPA2 ONE BYTE TO RIGHT
LBB02     coma                ; SET CARRY FLAG
* MULTIPLY FPA1 MANTISSA BY ACCB AND
* ADD PRODUCT TO FPA2 MANTISSA
LBB03     lda  FPA2           ; GET FPA2 MS BYTE
          rorb                ; ROTATE CARRY FLAG INTO SHIFT COUNTER;
*         DATA BIT INTO CARRY
          beq  LBB2E          ; BRANCH WHEN 8 SHIFTS DONE
          bcc  LBB20          ; DO NOT ADD FPA1 IF DATA BIT = 0
          lda  FPA2+3         ; * ADD MANTISSA LS BYTE
          adda FPA1+3         ; *
          sta  FPA2+3         ; *
          lda  FPA2+2         ; = ADD MANTISSA NUMBER 3 BYTE
          adca FPA1+2         ; =
          sta  FPA2+2         ; =
          lda  FPA2+1         ; * ADD MANTISSA NUMBER 2 BYTE
          adca FPA1+1         ; *
          sta  FPA2+1         ; *
          lda  FPA2           ; = ADD MANTISSA MS BYTE
          adca FPA1           ; =
LBB20     rora                ; * ROTATE CARRY INTO MS BYTE
          sta  FPA2           ; *
          ror  FPA2+1         ; = ROTATE FPA2 ONE BIT TO THE RIGHT
          ror  FPA2+2         ; =
          ror  FPA2+3         ; =
          ror  FPSBYT         ; =
          clra                ; CLEAR CARRY FLAG
          bra  LBB03          ; KEEP LOOPING
LBB2E     rts
* UNPACK A FP NUMBER FROM (X) TO FPA1
LBB2F     ldd  1,x            ; GET TWO MSB BYTES OF MANTISSA FROM
*         FPA  POINTED TO BY X
          sta  FP1SGN         ; SAVE PACKED MANTISSA SIGN BYTE
          ora  #$80           ; FORCE BIT 7 OF MSB MANTISSA = 1
          std  FPA1           ; SAVE 2 MSB BYTES IN FPA1
          ldb  FP1SGN         ; * GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0
          eorb FP0SGN         ; * SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE,
          stb  RESSGN         ; * NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED
*                             ; * MANTISSA SIGN BYTE
          ldd  3,x            ; = GET 2 LSB BYTES OF MANTISSA
          std  FPA1+2         ; = AND PUT IN FPA1
          lda  ,x             ; * GET EXPONENT FROM (X) AND
          sta  FP1EXP         ; * PUT IN EXPONENT OF FPA1
          ldb  FP0EXP         ; GET EXPONENT OF FPA0
          rts
* CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1
* ENTER WITH EXPONENT OF FPA1 IN ACCA
LBB48     tsta                ; TEST EXPONENT OF FPA1
          beq  LBB61          ; PURGE RETURN ADDRESS & SET FPA0 = 0
          adda FP0EXP         ; ADD FPA1 EXPONENT TO FPA0 EXPONENT
          rora                ; ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY
          rola                ; SET OVERFLOW FLAG
          bvc  LBB61          ; BRANCH IF EXPONENT TOO LARGE OR SMALL
          adda #$80           ; ADD $80 BIAS TO EXPONENT
          sta  FP0EXP         ; SAVE NEW EXPONENT
          beq  LBB63          ; SET FPA0
          lda  RESSGN         ; GET MANTISSA SIGN
          sta  FP0SGN         ; SAVE AS MANTISSA SIGN OF FPA0
          rts
* IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0
* = IS NEGATIVE THEN FPA0 = 0
LBB5C     lda  FP0SGN         ; GET MANTISSA SIGN OF FPA0
          coma                ; CHANGE SIGN OF FPA0 MANTISSA
          bra  LBB63
LBB61     leas 2,s            ; PURGE RETURN ADDRESS FROM STACK
LBB63     lbpl LBA39          ; ZERO FPA0 MANTISSA SIGN & EXPONENT
LBB67     jmp  LBA92          ; 'OV' OVERFLOW ERROR
* FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0
LBB6A     jsr  LBC5F          ; TRANSFER FPA0 TO FPA1
          beq  LBB7C          ; BRANCH IF EXPONENT = 0
          adda #2             ; ADD 2 TO EXPONENT (TIMES 4)
          bcs  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
          clr  RESSGN         ; CLEAR RESULT SIGN BYTE
          jsr  LB9CD          ; ADD FPA1 TO FPA0 (TIMES 5)
          inc  FP0EXP         ; ADD ONE TO EXPONENT (TIMES 10)
          beq  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
LBB7C     rts
LBB7D     fcb  $84,$20,$00,$00,$00 ; FLOATING POINT CONSTANT 10
* DIVIDE FPA0 BY 10
LBB82     jsr  LBC5F          ; MOVE FPA0 TO FPA1
          ldx  #LBB7D         ; POINT TO FLOATING POINT CONSTANT 10
          clrb                ; ZERO MANTISSA SIGN BYTE
LBB89     stb  RESSGN         ; STORE THE QUOTIENT MANTISSA SIGN BYTE
          jsr  LBC14          ; UNPACK AN FP NUMBER FROM (X) INTO FPA0
          fcb  SKP2           ; SKIP TWO BYTES
* DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0
LBB8F     bsr  LBB2F          ; GET FP NUMBER FROM (X) TO FPA1

* ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH
* EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY tsta)

* DIVIDE FPA1 BY FPA0
LBB91     beq  LBC06          ; '/0' DIVIDE BY ZERO ERROR
          neg  FP0EXP         ; GET EXPONENT OF RECIPROCAL OF DIVISOR
          bsr  LBB48          ; CALCULATE EXPONENT OF QUOTIENT
          inc  FP0EXP         ; INCREMENT EXPONENT
          beq  LBB67          ; 'OV' OVERFLOW ERROR
          ldx  #FPA2          ; POINT X TO MANTISSA OF FPA2 - HOLD
*                             ; TEMPORARY QUOTIENT IN FPA2
          ldb  #4             ; 5 BYTE DIVIDE
          stb  TMPLOC         ; SAVE BYTE COUNTER
          ldb  #1             ; SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE
* COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -
* SET CARRY FLAG IF FPA1 >= FPA0
LBBA4     lda  FPA0           ; * COMPARE THE TWO MS BYTES
          cmpa FPA1           ; * OF FPA0 AND FPA1 AND
          bne  LBBBD          ; * BRANCH IF <>
          lda  FPA0+1         ; = COMPARE THE NUMBER 2
          cmpa FPA1+1         ; = BYTES AND
          bne  LBBBD          ; = BRANCH IF <>
          lda  FPA0+2         ; * COMPARE THE NUMBER 3
          cmpa FPA1+2         ; * BYTES AND
          bne  LBBBD          ; * BRANCH IF <>
          lda  FPA0+3         ; = COMPARE THE LS BYTES
          cmpa FPA1+3         ; = AND BRANCH
          bne  LBBBD          ; = IF <>
          coma                ; SET CARRY FLAG IF FPA0 = FPA1
LBBBD     tfr  cc,a           ; SAVE CARRY FLAG STATUS IN ACCA; CARRY
*         CLEAR IF FPA0 > FPA1
          rolb                ; ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE
          bcc  LBbcc          ; CARRY WILL BE SET AFTER 8 SHIFTS
          stb  ,x+            ; SAVE TEMPORARY QUOTIENT
          dec  TMPLOC         ; DECREMENT BYTE COUNTER
          bmi  LBBFC          ; BRANCH IF DONE
          beq  LBBF8          ; BRANCH IF LAST BYTE
          ldb  #1             ; RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE
LBbcc     tfr  a,cc           ; RESTORE CARRY FLAG AND
          bcs  LBBDE          ; BRANCH IF FPA0 =< FPA1
LBBD0     asl  FPA1+3         ; * SHIFT FPA1 MANTISSA 1 BIT TO LEFT
          rol  FPA1+2         ; *
          rol  FPA1+1         ; *
          rol  FPA1           ; *
          bcs  LBBBD          ; BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT
          bmi  LBBA4          ; IF MSB OF HIGH ORDER MANTISSA BYTE IS
*         SET, CHECK THE MAGNITUDES OF FPA0, FPA1
          bra  LBBBD          ; CARRY IS CLEAR, CHECK ANOTHER BIT
* SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1
LBBDE     lda  FPA1+3         ; * SUBTRACT THE LS BYTES OF MANTISSA
          suba FPA0+3         ; *
          sta  FPA1+3         ; *
          lda  FPA1+2         ; = THEN THE NEXT BYTE
          sbca FPA0+2         ; =
          sta  FPA1+2         ; =
          lda  FPA1+1         ; * AND THE NEXT
          sbca FPA0+1         ; *
          sta  FPA1+1         ; *
          lda  FPA1           ; = AND FINALLY, THE MS BYTE OF MANTISSA
          sbca FPA0           ; =
          sta  FPA1           ; =
          bra  LBBD0          ; GO SHIFT FPA1
LBBF8     ldb  #$40           ; USE ONLY TWO BITS OF THE LAST BYTE (FIFTH)
          bra  LBbcc          ; GO SHIFT THE LAST BYTE
LBBFC     rorb                ; * SHIFT CARRY (ALWAYS SET HERE) INTO
          rorb                ; * BIT 5 AND MOVE
          rorb                ; * BITS 1,0 TO BITS 7,6
          stb  FPSBYT         ; SAVE SUB BYTE
          bsr  LBC0B          ; MOVE MANTISSA OF FPA2 TO FPA0
          jmp  LBA1C          ; NORMALIZE FPA0
LBC06     ldb  #2*10          ; /0' ERROR
          jmp  LAC46          ; PROCESS THE ERROR
* COPY MANTISSA FROM FPA2 TO FPA0
LBC0B     ldx  FPA2           ; * MOVE TOP 2 BYTES
          stx  FPA0           ; *
          ldx  FPA2+2         ; = MOVE BOTTOM 2 BYTES
          stx  FPA0+2         ; =
          rts
* COPY A PACKED FP NUMBER FROM (X) TO FPA0
LBC14     pshs a              ; SAVE ACCA
          ldd  1,x            ; GET TOP TWO MANTISSA BYTES
          sta  FP0SGN         ; SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN
          ora  #$80           ; UNPACK MS BYTE
          std  FPA0           ; SAVE UNPACKED TOP 2 MANTISSA BYTES
          clr  FPSBYT         ; CLEAR MANTISSA SUB BYTE
          ldb  ,x             ; GET EXPONENT TO ACCB
          ldx  3,x            ; * MOVE LAST 2
          stx  FPA0+2         ; * MANTISSA BYTES
          stb  FP0EXP         ; SAVE EXPONENT
          puls a,pc           ; RESTORE ACCA AND RETURN

LBC2A     ldx  #V45           ; POINT X TO MANTISSA OF FPA4
          bra  LBC35          ; MOVE FPA0 TO FPA4
LBC2F     ldx  #V40           ; POINT X TO MANTISSA OF FPA3
          fcb  SKP2           ; SKIP TWO BYTES
LBC33     ldx  VARDES         ; POINT X TO VARIABLE DESCRIPTOR IN VARDES
* PACK FPA0 AND MOVE IT TO ADDRESS IN X
LBC35     lda  FP0EXP         ; * COPY EXPONENT
          sta  ,x             ; *
          lda  FP0SGN         ; GET MANTISSA SIGN BIT
          ora  #$7F           ; MASK THE BOTTOM 7 BITS
          anda FPA0           ; AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE
          sta  1,x            ; SAVE MS BYTE
          lda  FPA0+1         ; * MOVE 2ND MANTISSA BYTE
          sta  2,x            ; *
          ldu  FPA0+2         ; = MOVE BOTTOM 2 MANTISSA BYTES
          stu  3,x            ; =
          rts
* MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA
LBC4A     lda  FP1SGN         ; * COPY MANTISSA SIGN FROM
LBC4C     sta  FP0SGN         ; * FPA1 TO FPA0
          ldx  FP1EXP         ; = COPY EXPONENT + MS BYTE FROM
          stx  FP0EXP         ; = FPA1 TO FPA0
          clr  FPSBYT         ; CLEAR MANTISSA SUB BYTE
          lda  FPA1+1         ; * COPY 2ND MANTISSA BYTE
          sta  FPA0+1         ; * FROM FPA1 TO FPA0
          lda  FP0SGN         ; GET MANTISSA SIGN
          ldx  FPA1+2         ; * COPY 3RD AND 4TH MANTISSA BYTE
          stx  FPA0+2         ; * FROM FPA1 TO FPA0
          rts
* TRANSFER FPA0 TO FPA1
LBC5F     ldd  FP0EXP         ; * TRANSFER EXPONENT & MS BYTE
          std  FP1EXP         ; *
          ldx  FPA0+1         ; = TRANSFER MIDDLE TWO BYTES
          stx  FPA1+1         ; =
          ldx  FPA0+3         ; * TRANSFER BOTTOM TWO BYTES
          stx  FPA1+3         ; *
          tsta                ; SET FLAGS ACCORDING TO EXPONENT
          rts
* CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,
* ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE
LBC6D     ldb  FP0EXP         ; GET EXPONENT
          beq  LBC79          ; BRANCH IF FPA0 = 0
LBC71     ldb  FP0SGN         ; GET SIGN OF MANTISSA
LBC73     rolb                ; BIT 7 TO CARRY
          ldb  #$FF           ; NEGATIVE FLAG
          bcs  LBC79          ; BRANCH IF NEGATIVE MANTISSA
          negb                ; ACCB = 1 IF POSITIVE MANTISSA
LBC79     rts

* SGN
SGN       bsr  LBC6D          ; SET ACCB ACCORDING TO SIGN OF FPA0
* CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER
LBC7C     stb  FPA0           ; SAVE ACCB IN FPA0
          clr  FPA0+1         ; CLEAR NUMBER 2 MANTISSA BYTE OF FPA0
          ldb  #$88           ; EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER
LBC82     lda  FPA0           ; GET MS BYTE OF MANTISSA
          suba #$80           ; SET CARRY IF POSITIVE MANTISSA
LBC86     stb  FP0EXP         ; SAVE EXPONENT
          ldd  ZERO           ; * ZERO OUT ACCD AND
          std  FPA0+2         ; * BOTTOM HALF OF FPA0
          sta  FPSBYT         ; CLEAR SUB BYTE
          sta  FP0SGN         ; CLEAR SIGN OF FPA0 MANTISSA
          jmp  LBA18          ; GO NORMALIZE FPA0

* ABS
ABS       clr  FP0SGN         ; FORCE MANTISSA SIGN OF FPA0 POSITIVE
          rts
* COMPARE A PACKED FLOATING POINT NUMBER POINTED TO
* BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN
* ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF
* FPA0 > (X); ACCB = $FF IF FPA0 < (X)
LBC96     ldb  ,x             ; CHECK EXPONENT OF (X)
          beq  LBC6D          ; BRANCH IF FPA = 0
          ldb  1,x            ; GET MS BYTE OF MANTISSA OF (X)
          eorb FP0SGN         ; EOR WITH SIGN OF FPA0
          bmi  LBC71          ; BRANCH IF SIGNS NOT =
* COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).
* FPA0 IS NORMALIZEd, (X) IS PACKED.
LBCA0     ldb  FP0EXP         ; * GET EXPONENT OF
          cmpb ,x             ; * FPA0, COMPARE TO EXPONENT OF
          bne  LBCC3          ; * (X) AND BRANCH IF <>.
          ldb  1,x            ; * GET MS BYTE OF (X), KEEP ONLY
          orb  #$7F           ; * THE SIGN BIT - 'AND' THE BOTTOM 7
          andb FPA0           ; * BITS OF FPA0 INTO ACCB
          cmpb 1,x            ; = COMPARE THE BOTTOM 7 BITS OF THE MANTISSA
          bne  LBCC3          ; = MS BYTE AND BRANCH IF <>
          ldb  FPA0+1         ; * COMPARE 2ND BYTE
          cmpb 2,x            ; * OF MANTISSa,
          bne  LBCC3          ; * BRANCH IF <>
          ldb  FPA0+2         ; = COMPARE 3RD BYTE
          cmpb 3,x            ; = OF MANTISSa,
          bne  LBCC3          ; = BRANCH IF <>
          ldb  FPA0+3         ; * SUBTRACT LS BYTE
          subb 4,x            ; * OF (X) FROM LS BYTE OF
          bne  LBCC3          ; * FPA0, BRANCH IF <>
          rts                 ; RETURN IF FP (X) = FPA0
LBCC3     rorb                ; SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X)
          eorb FP0SGN         ; TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE
          bra  LBC73          ; GO SET ACCB ACCORDING TO COMPARISON
* DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT
* OF THE leasT SIGNIFICANT BYTE OF THE MANTISSA
LBCC8     ldb  FP0EXP         ; GET EXPONENT OF FPA0
          beq  LBD09          ; ZERO MANTISSA IF FPA0 = 0
          subb #$A0           ; SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD
*                             ; THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN
*                             ; THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT
*                             ; WILL BE TO THE RIGHT OF THE MANTISSA
          lda  FP0SGN         ; TEST SIGN OF FPA0 MANTISSA
          bpl  LBCD7          ; BRANCH IF POSITIVE
          com  FPCARY         ; COMPLEMENT CARRY IN BYTE
          jsr  LBA7B          ; NEGATE MANTISSA OF FPA0
LBCD7     ldx  #FP0EXP        ; POINT X TO FPA0
          cmpb #-8            ; EXPONENT DIFFERENCE < -8?
          bgt  LBCE4          ; YES
          jsr  LBAAE          ; SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0
          clr  FPCARY         ; CLEAR CARRY IN BYTE
          rts
LBCE4     clr  FPCARY         ; CLEAR CARRY IN BYTE
          lda  FP0SGN         ; * GET SIGN OF FPA0 MANTISSA
          rola                ; * ROTATE IT INTO THE CARRY FLAG
          ror  FPA0           ; ROTATE CARRY (MANTISSA SIGN) INTO BIT 7
*                             ; OF LS BYTE OF MANTISSA
          jmp  LBABA          ; DE-NORMALIZE FPA0

* INT
* THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT
* TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE
* THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT
* BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION
* ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.
*
INT       ldb  FP0EXP         ; GET EXPONENT OF FPA0
          cmpb #$A0           ; LARGEST POSSIBLE INTEGER EXPONENT
          bcc  LBD11          ; RETURN IF FPA0 >= 32768
          bsr  LBCC8          ; SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE
*                             ; LS BYTE OF THE FPA0 MANTISSA
          stb  FPSBYT         ; ACCB = 0: ZERO OUT THE SUB BYTE
          lda  FP0SGN         ; GET MANTISSA SIGN
          stb  FP0SGN         ; FORCE MANTISSA SIGN TO BE POSITIVE
          suba #$80           ; SET CARRY IF MANTISSA
          lda  #$A0           ; * GET DENORMALIZED EXPONENT AND
          sta  FP0EXP         ; * SAVE IT IN FPA0 EXPONENT
          lda  FPA0+3         ; = GET LS BYTE OF FPA0 AND
          sta  CHARAC         ; = SAVE IT IN CHARAC
          jmp  LBA18          ; NORMALIZE FPA0

LBD09     stb  FPA0           ; * LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB
          stb  FPA0+1         ; *
          stb  FPA0+2         ; *
          stb  FPA0+3         ; *
LBD11     rts                 ; *

* CONVERT ASCII STRING TO FLOATING POINT
LBD12     ldx  ZERO           ; (X) = 0
          stx  FP0SGN         ; * ZERO OUT FPA0 & THE SIGN FLAG (COEFCT)
          stx  FP0EXP         ; *
          stx  FPA0+1         ; *
          stx  FPA0+2         ; *
          stx  V47            ; INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO
          stx  V45            ; INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0
          bcs  LBD86          ; IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST
*         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK
          jsr  XVEC19         ; CALL EXTENDED BASIC ADD-IN
LBD25     cmpa #'-'           ; * CHECK FOR A LEADING MINUS SIGN AND BRANCH
          bne  LBD2D          ; * IF NO MINUS SIGN
          com  COEFCT         ; TOGGLE SIGN; 0 = +; FF = -
          bra  LBD31          ; INTERPRET THE REST OF THE STRING
LBD2D     cmpa #'+'           ; * CHECK FOR LEADING PLUS SlGN AND BRANCH
          bne  LBD35          ; * IF NOT A PLUS SIGN
LBD31     jsr  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
          bcs  LBD86          ; BRANCH IF NUMERIC CHARACTER
LBD35     cmpa #'.'           ; DECIMAL POlNT?
          beq  LBD61          ; YES
          cmpa #'E'           ; "E" SHORTHAND FORM (SCIENTIFIC NOTATION)?
          bne  LBD65          ; NO
* EVALUATE EXPONENT OF EXPONENTIAL FORMAT
          jsr  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
          bcs  LBDA5          ; BRANCH IF NUMERIC
          cmpa #TOK_MINUS     ; MINUS TOKEN?
          beq  LBD53          ; YES
          cmpa #'-'           ; ASCII MINUS?
          beq  LBD53          ; YES
          cmpa #TOK_PLUS      ; PLUS TOKEN?
          beq  LBD55          ; YES
          cmpa #'+'           ; ASCII PLUS?
          beq  LBD55          ; YES
          bra  LBD59          ; BRANCH IF NO SIGN FOUND
LBD53     com  V48            ; SET EXPONENT SIGN FLAG TO NEGATIVE
* STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT TO BINARY IN V47
LBD55     jsr  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
          bcs  LBDA5          ; IF NUMERIC CHARACTER, CONVERT TO BINARY
LBD59     tst  V48            ; * CHECK EXPONENT SIGN FLAG
          beq  LBD65          ; * AND BRANCH IF POSITIVE
          neg  V47            ; NEGATE VALUE OF EXPONENT
          bra  LBD65
LBD61     com  V46            ; *TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER
          bne  LBD31          ; *CHARACTER IF <> 0 - TERMINATE INTERPRETATION
*         IF   SECOND DECIMAL POINT
* ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47
LBD65     lda  V47            ; * GET EXPONENT, SUBTRACT THE NUMBER OF
          suba V45            ; * PLACES TO THE RIGHT OF DECIMAL POINT
          sta  V47            ; * AND RESAVE IT.
          beq  LBD7F          ; EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO
          bpl  LBD78          ; BRANCH IF POSITIVE EXPONENT
LBD6F     jsr  LBB82          ; DIVIDE FPA0 BY 10
          inc  V47            ; INCREMENT EXPONENT COUNTER (MULTIPLY BY 10)
          bne  LBD6F          ; KEEP MULTIPLYING
          bra  LBD7F          ; EXIT ROUTINE
LBD78     jsr  LBB6A          ; MULTIPLY FPA0 BY 10
          dec  V47            ; DECREMENT EXPONENT COUNTER (DIVIDE BY 10)
          bne  LBD78          ; KEEP MULTIPLYING
LBD7F     lda  COEFCT         ; GET THE SIGN FLAG
          lbpl  LBD11         ; RETURN IF POSITIVE
          jmp  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE
*MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT
LBD86     ldb  V45            ; *GET THE RIGHT DECIMAL COUNTER AND SUBTRACT
          subb V46            ; *THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT
          stb  V45            ; *FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS
*                             -1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE
          pshs a              ; SAVE NEW DIGIT ON STACK
          jsr  LBB6A          ; MULTIPLY FPA0 BY 10
          puls b              ; GET NEW DIGIT BACK
          subb #'0'            ; MASK OFF ASCII
          bsr  LBD99          ; ADD ACCB TO FPA0
          bra  LBD31          ; GET ANOTHER CHARACTER FROM BASIC
LBD99     jsr  LBC2F          ; PACK FPA0 AND SAVE IT IN FPA3
          jsr  LBC7C          ; CONVERT ACCB TO FP NUMBER IN FPA0
          ldx  #V40           ; * ADD FPA0 TO
          jmp  LB9C2          ; * FPA3


LBDA5     ldb  V47
          aslb                ; TIMES 2
          aslb                ; TIMES 4
          addb V47            ; ADD 1 = TIMES 5
          aslb                ; TIMES 10
          suba #'0'            ; *MASK OFF ASCII FROM ACCa, PUSH
          pshs b              ; *RESULT ONTO THE STACK AND
          adda ,s+            ; ADD lT TO ACCB
          sta  V47            ; SAVE IN V47
          bra  LBD55          ; INTERPRET ANOTHER CHARACTER
*
LBDB6     fcb  $9b,$3E,$BC,$1F,$FD ; * 99999999.9
LBDBB     fcb  $9E,$6E,$6b,$27,$FD ; * 999999999
LBDC0     fcb  $9E,$6E,$6b,$28,$00 ; * 1E + 09
*
LBDC5     ldx  #LABE8-1       ; POINT X TO " IN " MESSAGE
          bsr  LBDD6          ; COPY A STRING FROM (X) TO CONSOLE OUT
          ldd  CURLIN         ; GET CURRENT BASIC LINE NUMBER TO ACCD
* CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER AND PRINT IT TO CONSOLE OUT
LBDCC     std  FPA0           ; SAVE ACCD IN TOP HALF OF FPA0
          ldb  #$90           ; REQ'D EXPONENT IF TOP HALF OF ACCD = INTEGER
          coma                ; SET CARRY FLAG - FORCE POSITIVE MANTISSA
          jsr  LBC86          ; ZERO BOTTOM HALF AND SIGN OF FPA0, THEN SAVE EXPONENT AND NORMALIZE IT
          bsr  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
LBDD6     jmp  LB99C          ; COPY A STRING FROM (X) TO CONSOLE OUT

* CONVERT FP NUMBER TO ASCII STRING
LBDD9     ldu  #STRBUF+3      ; POINT U TO BUFFER WHICH WILL NOT CAUSE
*                             ; THE STRING TO BE STORED IN STRING SPACE
LBDDC     lda  #SPACE         ; SPACE = DEFAULT SIGN FOR POSITIVE #
          ldb  FP0SGN         ; GET SIGN OF FPA0
          bpl  LBDE4          ; BRANCH IF POSITIVE
          lda  #'-'           ; ASCII MINUS SIGN
LBDE4     sta  ,u+            ; STORE SIGN OF NUMBER
          stu  COEFPT         ; SAVE BUFFER POINTER
          sta  FP0SGN         ; SAVE SIGN (IN ASCII)
          lda  #'0'            ; ASCII ZERO IF EXPONENT = 0
          ldb  FP0EXP         ; GET FPA0 EXPONENT
          lbeq LBEB8          ; BRANCH IF FPA0 = 0
          clra                ; BASE 10 EXPONENT=0 FOR FP NUMBER > 1
          cmpb #$80           ; CHECK EXPONENT
          bhi  LBDFF          ; BRANCH IF FP NUMBER > 1
* IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS
          ldx  #LBDC0         ; POINT X TO FP 1E+09
          jsr  LBACA          ; MULTIPLY FPA0 BY (X)
          lda  #-9            ; BASE 10 EXPONENT = -9
LBDFF     sta  V45            ; BASE 10 EXPONENT
* PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE
* OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST
* NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE
* SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING
* SCIENTIFIC NOTATION
LBE01     ldx  #LBDBB         ; POINT X TO FP 999,999,999
          jsr  LBCA0          ; COMPARE FPA0 TO 999,999,999
          bgt  LBE18          ; BRANCH IF > 999,999,999
LBE09     ldx  #LBDB6         ; POINT X TO FP 99,999,999.9
          jsr  LBCA0          ; COMPARE FPA0 TO 99,999,999.9
          bgt  LBE1F          ; BRANCH IF > 99,999,999.9 (IN RANGE)
          jsr  LBB6A          ; MULTIPLY FPA0 BY 10
          dec  V45            ; SUBTRACT ONE FROM DECIMAL OFFSET
          bra  LBE09          ; PSEUDO - NORMALIZE SOME MORE
LBE18     jsr  LBB82          ; DIVIDE FPA0 BY 10
          inc  V45            ; ADD ONE TO BASE 10 EXPONENT
          bra  LBE01          ; PSEUDO - NORMALIZE SOME MORE
LBE1F     jsr  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
          jsr  LBCC8          ; CONVERT FPA0 TO AN INTEGER
          ldb  #1             ; DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT)
          lda  V45            ; * GET BASE 10 EXPONENT AND ADD TEN TO IT
          adda #9+1           ; * (NUMBER 'NORMALIZED' TO 9 PLACES & DECIMAL PT)
          bmi  LBE36          ; BRANCH IF NUMBER < 1.0
          cmpa #9+2           ; NINE PLACES MAY BE DISPLAYED WITHOUT
*         USING SCIENTIFIC NOTATION
          bcc  LBE36          ; BRANCH IF SCIENTIFIC NOTATION REQUIRED
          deca                ; * SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR
          tfr  a,b            ; * AND SAVE IT IN ACCB (DECiMAL POINT FLAG)
          lda  #2             ; FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION
LBE36     deca                ; * SUBTRACT TWO (WITHOUT AFFECTING CARRY)
          deca                ; * FROM BASE 10 EXPONENT
          sta  V47            ; SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY
*         IN   SCIENTIFIC NOTATION
          stb  V45            ; DECIMAL POINT FLAG - NUMBER OF PLACES TO
*         LEFT OF DECIMAL POINT
          bgt  LBE4B          ; BRANCH IF >= 1
          ldu  COEFPT         ; POINT U TO THE STRING BUFFER
          lda  #'.'           ; * STORE A PERIOD
          sta  ,u+            ; * IN THE BUFFER
          tstb                ; CHECK DECIMAL POINT FLAG
          beq  LBE4B          ; BRANCH IF NOTHING TO LEFT OF DECIMAL POINT
          lda  #'0'            ; * STORE A ZERO
          sta  ,u+            ; * IN THE BUFFER

* CONVERT FPA0 INTO A STRING OF ASCII DIGITS
LBE4B     ldx  #LBEC5         ; POINT X TO FP POWER OF 10 MANTISSA
          ldb  #0+$80         ; INITIALIZE DIGIT COUNTER TO 0+$80
* BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
* IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
* THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW
* THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.
LBE50     lda  FPA0+3         ; * ADD MANTISSA LS
          adda 3,x            ; * BYTE OF FPA0
          sta  FPA0+3         ; * AND (X)
          lda  FPA0+2         ; = ADD MANTISSA
          adca 2,x            ; = NUMBER 3 BYTE OF
          sta  FPA0+2         ; = FPA0 AND (X)
          lda  FPA0+1         ; * ADD MANTISSA
          adca 1,x            ; * NUMBER 2 BYTE OF
          sta  FPA0+1         ; * FPA0 AND (X)
          lda  FPA0           ; = ADD MANTISSA
          adca ,x             ; = MS BYTE OF
          sta  FPA0           ; = FPA0 AND (X)
          incb                ; ADD ONE TO DIGIT COUNTER
          rorb                ; ROTATE CARRY INTO BIT 7
          rolb                ; *SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND
          bvc  LBE50          ; *POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA
          bcc  LBE72          ; BRANCH IF NEGATIVE MANTISSA
          subb #10+1          ; * TAKE THE 9'S COMPLEMENT IF
          negb                ; * ADDING MANTISSA
LBE72     addb #'0'-1          ; ADD ASCII OFFSET TO DIGIT
          leax 4,x            ; MOVE TO NEXT POWER OF 10 MANTISSA
          tfr  b,a            ; SAVE DIGIT IN ACCA
          anda #$7F           ; MASK OFF BIT 7 (ADD/SUBTRACT FLAG)
          sta  ,u+            ; STORE DIGIT IN STRING BUFFER
          dec  V45            ; DECREMENT DECIMAL POINT FLAG
          bne  LBE84          ; BRANCH IF NOT TIME FOR DECIMAL POINT
          lda  #'.'           ; * STORE DECIMAL POINT IN
          sta  ,u+            ; * STRING BUFFER
LBE84     comb                ; TOGGLE BIT 7 (ADD/SUBTRACT FLAG)
          andb #$80           ; MASK OFF ALL BUT ADD/SUBTRACT FLAG
          cmpx #LBEC5+36      ; COMPARE X TO END OF MANTISSA TABLE
          bne  LBE50          ; BRANCH IF NOT AT END OF TABLE
* BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY
LBE8C     lda  ,-u            ; GET THE LAST CHARACTER; MOVE POINTER BACK
          cmpa #'0'            ; WAS IT A ZERO?
          beq  LBE8C          ; IGNORE TRAILING ZEROS IF SO
          cmpa #'.'           ; CHECK FOR DECIMAL POINT
          bne  LBE98          ; BRANCH IF NOT DECIMAL POINT
          leau -1,u           ; STEP OVER THE DECIMAL POINT
LBE98     lda  #'+'           ; ASCII PLUS SIGN
          ldb  V47            ; GET SCIENTIFIC NOTATION EXPONENT
          beq  LBEBA          ; BRANCH IF NOT SCIENTIFIC NOTATION
          bpl  LBEA3          ; BRANCH IF POSITIVE EXPONENT
          lda  #'-'           ; ASCII MINUS SIGN
          negb                ; NEGATE EXPONENT IF NEGATIVE
LBEA3     sta  2,u            ; STORE EXPONENT SIGN IN STRING
          lda  #'E'           ; * GET ASCII 'E' (SCIENTIFIC NOTATION
          sta  1,u            ; * FLAG) AND SAVE IT IN THE STRING
          lda  #'0'-1          ; INITIALIZE ACCA TO ASCII ZERO


LBEAB     inca                ; ADD ONE TO 10'S DIGIT OF EXPONENT
          subb #10            ; SUBTRACT 10 FROM ACCB
          bcc  LBEAB          ; ADD 1 TO 10'S DIGIT IF NO CARRY
          addb #'9'+1         ; CONVERT UNITS DIGIT TO ASCII
          std  3,u            ; SAVE EXPONENT IN STRING
          clr  5,u            ; CLEAR LAST BYTE (TERMINATOR)
          bra  LBEBC          ; GO RESET POINTER
LBEB8     sta  ,u             ; STORE LAST CHARACTER
LBEBA     clr  1,u            ; CLEAR LAST BYTE (TERMINATOR - REQUIRED BY
*         PRINT SUBROUTINES)
LBEBC     ldx  #STRBUF+3      ; RESET POINTER TO START OF BUFFER
          rts
*
LBEC0     fcb  $80,$00,$00,$00,$00 ; FLOATING POINT .5
*
*** TABLE OF UNNORMALIZED POWERS OF 10
LBEC5     fcb  $Fa,$0a,$1F,$00 ; -100000000
LBEC9     fcb  $00,$98,$96,$80 ; 10000000
LBECD     fcb  $FF,$F0,$Bd,$C0 ; -1000000
LBED1     fcb  $00,$01,$86,$A0 ; 100000
LBED5     fcb  $FF,$FF,$D8,$F0 ; -10000
LBED9     fcb  $00,$00,$03,$E8 ; 1000
LBEDD     fcb  $FF,$FF,$FF,$9C ; -100
LBEE1     fcb  $00,$00,$00,$0A ; 10
LBEE5     fcb  $FF,$FF,$FF,$FF ; -1
*
*
LBEE9     lda  FP0EXP         ; GET EXPONENT OF FPA0
          beq  LBEEF          ; BRANCH IF FPA0 = 0
          com  FP0SGN         ; TOGGLE MANTISSA SIGN OF FPA0
LBEEF     rts
* EXPAND A POLYNOMIAL OF THE FORM
* AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0
* AND THE X REGISTER POINTS TO A TABLE OF
* COEFFICIENTS A,B,C,D....
LBEF0     stx  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
          jsr  LBC2F          ; MOVE FPA0 TO FPA3
          bsr  LBEFC          ; MULTIPLY FPA3 BY FPA0
          bsr  LBF01          ; EXPAND POLYNOMIAL
          ldx  #V40           ; POINT X TO FPA3
LBEFC     jmp  LBACA          ; MULTIPLY (X) BY FPA0

* CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
* EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
* OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
* NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
* OF PACKED FLOATING POINT NUMBERS. THE
* POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
* (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0...YN)
LBEFF     stx  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
LBF01     jsr  LBC2A          ; MOVE FPA0 TO FPA4
          ldx  COEFPT         ; GET THE COEFFICIENT POINTER
          ldb  ,x+            ; GET THE TOP OF COEFFICIENT TABLE TO
          stb  COEFCT         ; * USE AND STORE IT IN TEMPORARY COUNTER
          stx  COEFPT         ; SAVE NEW COEFFICIENT POINTER
LBF0C     bsr  LBEFC          ; MULTIPLY (X) BY FPA0
          ldx  COEFPT         ; *GET COEFFICIENT POINTER
          leax 5,x            ; *MOVE TO NEXT FP NUMBER
          stx  COEFPT         ; *SAVE NEW COEFFICIENT POINTER
          jsr  LB9C2          ; ADD (X) AND FPA0
          ldx  #V45           ; POINT (X) TO FPA4
          dec  COEFCT         ; DECREMENT TEMP COUNTER
          bne  LBF0C          ; BRANCH IF MORE COEFFICIENTS LEFT
          rts

* RND
RND       jsr  LBC6D          ; TEST FPA0
          bmi  LBF45          ; BRANCH IF FPA0 = NEGATIVE
          beq  LBF3B          ; BRANCH IF FPA0 = 0
          bsr  LBF38          ; CONVERT FPA0 TO AN INTEGER
          jsr  LBC2F          ; PACK FPA0 TO FPA3
          bsr  LBF3B          ; GET A RANDOM NUMBER: FPA0 < 1.0
          ldx  #V40           ; POINT (X) TO FPA3
          bsr  LBEFC          ; MULTIPLY (X) BY FPA0
          ldx  #LBAC5         ; POINT (X) TO FP VALUE OF 1.0
          jsr  LB9C2          ; ADD 1.0 TO FPA0
LBF38     jmp  INT            ; CONVERT FPA0 TO AN INTEGER
* CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0
LBF3B     ldx  RVSEED+1       ; * MOVE VARIABLE
          stx  FPA0           ; * RANDOM NUMBER
          ldx  RVSEED+3       ; * SEED TO
          stx  FPA0+2         ; * FPA0
LBF45     ldx  RSEED          ; = MOVE FIXED
          stx  FPA1           ; = RANDOM NUMBER
          ldx  RSEED+2        ; = SEED TO
          stx  FPA1+2         ; = MANTISSA OF FPA0
          jsr  LBAD0          ; MULTIPLY FPA0 X FPA1
          ldd  VAD            ; GET THE TWO LOWEST ORDER PRODUCT BYTES
          addd #$658B         ; ADD A CONSTANT
          std  RVSEED+3       ; SAVE NEW LOW ORDER VARIABLE RANDOM # SEED
          std  FPA0+2         ; SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA
          ldd  VAB            ; GET 2 MORE LOW ORDER PRODUCT BYTES
          adcb #$B0           ; ADD A CONSTANT
          adca #5             ; ADD A CONSTANT
          std  RVSEED+1       ; SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED
          std  FPA0           ; SAVE NEW HIGH ORDER FPA0 MANTISSA
          clr  FP0SGN         ; FORCE FPA0 MANTISSA = POSITIVE
          lda  #$80           ; * SET FPA0 BIASED EXPONENT
          sta  FP0EXP         ; * TO 0 1 < FPA0 < 0
          lda  FPA2+2         ; GET A BYTE FROM FPA2 (MORE RANDOMNESS)
          sta  FPSBYT         ; SAVE AS SUB BYTE
          jmp  LBA1C          ; NORMALIZE FPA0
*
RSEED     fdb  $40E6          ; *CONSTANT RANDOM NUMBER GENERATOR SEED
          fdb  $4DAB          ; *

* SIN
* THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY
* 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS
* RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE
* MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.

* SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:
* SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)
SIN       jsr  LBC5F          ; COPY FPA0 TO FPA1
          ldx  #LBFBD         ; POINT (X) TO 2*PI
          ldb  FP1SGN         ; *GET MANTISSA SIGN OF FPA1
          jsr  LBB89          ; *AND DIVIDE FPA0 BY 2*PI
          jsr  LBC5F          ; COPY FPA0 TO FPA1
          bsr  LBF38          ; CONVERT FPA0 TO AN INTEGER
          clr  RESSGN         ; SET RESULT SIGN = POSITIVE
          lda  FP1EXP         ; *GET EXPONENT OF FPA1
          ldb  FP0EXP         ; *GET EXPONENT OF FPA0
          jsr  LB9BC          ; *SUBTRACT FPA0 FROM FPA1
* NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI
          ldx  #LBFC2         ; POINT X TO FP (.25)
          jsr  LB9B9          ; SUBTRACT FPA0 FROM .25 (PI/2)
          lda  FP0SGN         ; GET MANTISSA SIGN OF FPA0
          pshs a              ; SAVE IT ON STACK
          bpl  LBFA6          ; BRANCH IF MANTISSA POSITIVE
          jsr  LB9B4          ; ADD .5 (PI) TO FPA0
          lda  FP0SGN         ; GET SIGN OF FPA0
          bmi  LBFA9          ; BRANCH IF NEGATIVE
          com  RELFLG         ; com IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG)
LBFA6     jsr  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0
LBFA9     ldx  #LBFC2         ; POINT X TO FP (.25)
          jsr  LB9C2          ; ADD .25 (PI/2) TO FPA0
          puls a              ; GET OLD MANTISSA SIGN
          tsta                ; * BRANCH IF OLD
          bpl  LBFB7          ; * SIGN WAS POSITIVE
          jsr  LBEE9          ; TOGGLE MANTISSA SIGN
LBFB7     ldx  #LBFC7         ; POINT X TO TABLE OF COEFFICIENTS
          jmp  LBEF0          ; GO CALCULATE POLYNOMIAL VALUE

LBFBD     fcb  $83,$49,$0F,$Da,$A2 ; 6.28318531 (2*PI)
LBFC2     fcb  $7F,$00,$00,$00,$00 ; .25


LBFC7     fcb  6-1            ; SIX COEFFICIENTS
LBFC8     fcb  $84,$E6,$1a,$2d,$1B ; * -((2*PI)**11)/11!
LBFCD     fcb  $86,$28,$07,$Fb,$F8 ; * ((2*PI)**9)/9!
LBFD2     fcb  $87,$99,$68,$89,$01 ; * -((2*PI)**7)/7!
LBFD7     fcb  $87,$23,$35,$DF,$E1 ; * ((2*PI)**5)/5!
LBFDC     fcb  $86,$A5,$5d,$E7,$28 ; * -((2*PI)**3)/3!
LBFE1     fcb  $83,$49,$0F,$Da,$A2 ; *

          fcb  $A1,$54,$46,$8F,$13 ; UNUSED GARBAGE BYTES
          fcb  $8F,$52,$43,$89,$CD ; UNUSED GARBAGE BYTES
* EXTENDED BASIC

* COS
* THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTITY COS(X)=SIN((PI/2)+X)
COS       ldx  #L83AB         ; POINT X TO FP CONSTANT (P1/2)
          jsr  LB9C2          ; ADD FPA0 TO (X)
L837E     jmp  SIN            ; JUMP TO SIN ROUTINE

* TAN
* THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)
TAN       jsr  LBC2F          ; PACK FPA0 AND MOVE IT TO FPA3
          clr  RELFLG         ; RESET QUADRANT FLAG
          bsr  L837E          ; CALCULATE SIN OF ARGUMENT
          ldx  #V4A           ; POINT X TO FPA5
          jsr  LBC35          ; PACK FPA0 AND MOVE IT TO FPA5
          ldx  #V40           ; POINT X TO FPA3
          jsr  LBC14          ; MOVE FPA3 TO FPA0
          clr  FP0SGN         ; FORCE FPA0 MANTISSA TO BE POSITIVE
          lda  RELFLG         ; GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3
          bsr  L83A6          ; CALCULATE VALUE OF COS(FPA0)
          tst  FP0EXP         ; CHECK EXPONENT OF FPA0
          beq  LBA92          ; 'OV' ERROR IF COS(X)=0
          ldx  #V4A           ; POINT X TO FPA5
L83A3     jmp  LBB8F          ; DIVIDE (X) BY FPA0 - SIN(X)/COS(X)
L83A6     pshs a              ; SAVE SIGN FLAG ON STACK
          jmp  LBFA6          ; EXPAND POLYNOMIAL

L83AB     fcb  $81,$49,$0F,$Da,$A2 ; 1.57079633 (PI/2)

* ATN
* A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE
* ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED
* TO EVALUATE THE EXPRESSION DEPENDING UPON
* WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0

* IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .
* IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-. . .)

ATN       lda  FP0SGN         ; * GET THE SIGN OF THE MANTISSA AND
          pshs a              ; * SAVE IT ON THE STACK
          bpl  L83B8          ; BRANCH IF POSITIVE MANTISSA
          bsr  L83DC          ; CHANGE SIGN OF FPA0
L83B8     lda  FP0EXP         ; * GET EXPONENT OF FPA0 AND
          pshs a              ; * SAVE IT ON THE STACK
          cmpa #$81           ; IS FPAO < 1.0?
          blo  L83C5          ; YES
          ldx  #LBAC5         ; POINT X TO FP CONSTANT 1.0
          bsr  L83A3          ; GET RECIPROCAL OF FPA0
L83C5     ldx  #L83E0         ; POINT (X) TO TAYLOR SERIES COEFFICIENTS
          jsr  LBEF0          ; EXPAND POLYNOMIAL
          puls a              ; GET EXPONENT OF ARGUMENT
          cmpa #$81           ; WAS ARGUMENT < 1.0?
          blo  L83D7          ; YES
          ldx  #L83AB         ; POINT (X) TO FP NUMBER (PI/2)
          jsr  LB9B9          ; SUBTRACT FPA0 FROM (PI/2)
L83D7     puls a              ; * GET SIGN OF INITIAL ARGUMENT MANTISSA
          tsta                ; * AND SET FLAGS ACCORDING TO IT
          bpl  L83DF          ; RETURN IF ARGUMENT WAS POSITIVE
L83DC     jmp  LBEE9          ; CHANGE MANTISSA SIGN OF FPA0
L83DF     rts
*
* TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT
L83E0     fcb  $0B            ; TWELVE COEFFICIENTS
L83E1     fcb  $76,$B3,$83,$Bd,$D3 ; -6.84793912E-04 1/23
L83E6     fcb  $79,$1E,$F4,$A6,$F5 ; +4.85094216E-03 1/21
L83EB     fcb  $7b,$83,$FC,$B0,$10 ; -0.0161117018
L83F0     fcb  $7C,$0C,$1F,$67,$CA ; 0.0342096381
L83F5     fcb  $7C,$DE,$53,$Cb,$C1 ; -0.0542791328
L83FA     fcb  $7d,$14,$64,$70,$4C ; 0.0724571965
L83FF     fcb  $7d,$B7,$Ea,$51,$7A ; -0.0898023954
L8404     fcb  $7d,$63,$30,$88,$7E ; 0.110932413
L8409     fcb  $7E,$92,$44,$99,$3A ; -0.142839808
L840E     fcb  $7E,$4C,$CC,$91,$C7 ; 0.199999121
L8413     fcb  $7F,$Aa,$Aa,$Aa,$13 ; -0.333333316
L8418     fcb  $81,$00,$00,$00,$00 ; 1
*
*** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)
*
L841D     fcb  3              ; FOUR COEFFICIENTS
L841E     fcb  $7F,$5E,$56,$Cb,$79 ; 0.434255942
L8423     fcb  $80,$13,$9b,$0b,$64 ; 0.576584541
L8428     fcb  $80,$76,$38,$93,$16 ; 0.961800759
L842D     fcb  $82,$38,$Aa,$3b,$20 ; 2.88539007

L8432     fcb  $80,$35,$04,$F3,$34 ; 1/SQR(2)

L8437     fcb  $81,$35,$04,$F3,$34 ; SQR(2)

L843C     fcb  $80,$80,$00,$00,$00 ; -0.5

L8441     fcb  $80,$31,$72,$17,$F8 ; LN(2)
*
* LOG - NATURAL LOGARITHM (LN)

* THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USING
* MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*(2**B) (SCIENTIFIC
* NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE VALUE OF
* LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WILL EXPAND THIS
* TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)*LN(2). ALL OF
* THE TERMS OF THE LATTER EXPRESSION ARE CONstaNTS EXCEPT FOR THE
* LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLOR SERIES EXPANSION
LOG       jsr  LBC6D          ; CHECK STATUS OF FPA0
          ble  LB44A          ; 'FC' ERROR IF NEGATIVE OR ZERO
          ldx  #L8432         ; POINT (X) TO FP NUMBER (1/SQR(2))
          lda  FP0EXP         ; *GET EXPONENT OF ARGUMENT
          suba #$80           ; *SUBTRACT OFF THE BIAS AND
          pshs a              ; *SAVE IT ON THE STACK
          lda  #$80
          sta  FP0EXP
          jsr  LB9C2          ; ADD FPA0 TO (X)
          ldx  #L8437         ; POINT X TO SQR(2)
          jsr  LBB8F          ; DIVIDE SQR(2) BY FPA0
          ldx  #LBAC5         ; POINT X TO FP VALUE OF 1.00
          jsr  LB9B9          ; SUBTRACT FPA0 FROM (X)
*         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT
          ldx  #L841D         ; POINT X TO TABLE OF COEFFICIENTS
          jsr  LBEF0          ; EXPAND POLYNOMIAL
          ldx  #L843C         ; POINT X TO FP VALUE OF (-.5)
          jsr  LB9C2          ; ADD FPA0 TO X
          puls b              ; GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS)
          jsr  LBD99          ; ADD ACCB TO FPA0
          ldx  #L8441         ; POINT X TO LN(2)
          jmp  LBACA          ; MULTIPLY FPA0 * LN(2)

* SQR
SQR       jsr  LBC5F          ; MOVE FPA0 TO FPA1
          ldx  #LBEC0         ; POINT (X) TO FP NUMBER (.5)
          jsr  LBC14          ; COPY A PACKED NUMBER FROM (X) TO FPA0

* ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS
* HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION
* IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818
L8489     beq  EXP            ; DO A NATURAL EXPONENTIATION IF EXPONENT = 0
          tsta                ; *CHECK VALUE BEING EXPONENTIATED
          bne  L8491          ; *AND BRANCH IF IT IS <> 0
          jmp  LBA3A          ; FPA0=0 IF RAISING ZERO TO A POWER
L8491     ldx  #V4A           ; * PACK FPA0 AND SAVE
          jsr  LBC35          ; * IT IN FPA5 (ARGUMENT'S EXPONENT)
          clrb                ; ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE
          lda  FP1SGN         ; *CHECK THE SIGN OF ARGUMENT
          bpl  L84AC          ; *BRANCH IF POSITIVE
          jsr  INT            ; CONVERT EXPONENT INTO AN INTEGER
          ldx  #V4A           ; POINT X TO FPA5 (ORIGINAL EXPONENT)
          lda  FP1SGN         ; GET MANTISSA SIGN OF FPA1 (ARGUMENT)
          jsr  LBCA0          ; *COMPARE FPA0 TO (X) AND
          bne  L84AC          ; *BRANCH IF NOT EQUAL
          coma                ; TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE
          ldb  CHARAC         ; GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG)
L84AC     jsr  LBC4C          ; COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN
          pshs b              ; PUT RESULT SIGN FLAG ON THE STACK
          jsr  LOG
          ldx  #V4A           ; POINT (X) TO FPA5
          jsr  LBACA          ; MULTIPLY FPA0 BY FPA5
          bsr  EXP            ; CALCULATE E**(FPA0)
          puls a              ; * GET RESULT SIGN FLAG FROM THE STACK
          rora                ; * AND BRANCH IF NEGATIVE
          bcs  LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
          rts

* CORRECTION FACTOR FOR EXPONENTIAL FUNCTION
L84C4     fcb  $81,$38,$Aa,$3b,$29 ; 1.44269504 ( CF )
*
* TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X
*
L84C9     fcb  7              ; EIGHT COEFFICIENTS
L84CA     fcb  $71,$34,$58,$3E,$56 ; 2.14987637E-05: 1/(7!*(CF**7))
L84CF     fcb  $74,$16,$7E,$B3,$1B ; 1.4352314E-04 : 1/(6!*(CF**6))
L84D4     fcb  $77,$2F,$EE,$E3,$85 ; 1.34226348E-03: 1/(5!*(CF**5))
L84D9     fcb  $7A,$1D,$84,$1C,$2A ; 9.61401701E-03: 1/(4!*(CF**4))
L84DE     fcb  $7C,$63,$59,$58,$0A ; 0.0555051269
L84E3     fcb  $7E,$75,$FD,$E7,$C6 ; 0.240226385
L84E8     fcb  $80,$31,$72,$18,$10 ; 0.693147186
L84ED     fcb  $81,$00,$00,$00,$00 ; 1
*
* EXP ( E**X)
* THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTIPLYING THE
* ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN
* ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A
* NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE
* ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT
* THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.

EXP       ldx  #L84C4         ; POINT X TO THE CORRECTION FACTOR
          jsr  LBACA          ; MULTIPLY FPA0 BY (X)
          jsr  LBC2F          ; PACK FPA0 AND STORE IT IN FPA3
          lda  FP0EXP         ; *GET EXPONENT OF FPA0 AND
          cmpa #$88           ; *COMPARE TO THE MAXIMUM VALUE
          blo  L8504          ; BRANCH IF FPA0 < 128
L8501     jmp  LBB5C          ; SET FPA0 = 0 OR 'OV' ERROR
L8504     jsr  INT            ; CONVERT FPA0 TO INTEGER
          lda  CHARAC         ; GET LS BYTE OF INTEGER
          adda #$81           ; * WAS THE ARGUMENT =127, IF SO
          beq  L8501          ; * THEN 'OV' ERROR; THIS WILL ALSO ADD THE $80 BIAS
*              ; * REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW
          deca                ; DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE
          pshs a              ; SAVE EXPONENT OF INTEGER PORTION ON STACK
          ldx  #V40           ; POINT (X) TO FPA3
          jsr  LB9B9          ; SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT
          ldx  #L84C9         ; POINT X TO COEFFICIENTS
          jsr  LBEFF          ; EVALUATE POLYNOMIAL FOR FRACTIONAL PART
          clr  RESSGN         ; FORCE THE MANTISSA TO BE POSITIVE
          puls a              ; GET INTEGER EXPONENT FROM STACK
          jsr  LBB48          ; * CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE
*              ; * INTEGER AND FRACTIONAL PARTS
          rts

* FIX
FIX       jsr  LBC6D          ; CHECK STATUS OF FPA0
          bmi  L852C          ; BRANCH IF FPA0 = NEGATIVE
L8529     jmp  INT            ; CONVERT FPA0 TO INTEGER
L852C     com  FP0SGN         ; TOGGLE SIGN OF FPA0 MANTISSA
          bsr  L8529          ; CONVERT FPA0 TO INTEGER
          jmp  LBEE9          ; TOGGLE SIGN OF FPA0

* EDIT
EDIT      jsr  L89AE          ; GET LINE NUMBER FROM BASIC
          leas $02,s          ; PURGE RETURN ADDRESS OFF OF THE STACK
L8538     lda  #$01           ; 'LIST' FLAG
          sta  VD8            ; SET FLAG TO LIST LINE
          jsr  LAD01          ; GO FIND THE LINE NUMBER IN PROGRAM
          bcs  LAED2          ; ERROR #7 'UNDEFINED LINE #'
          jsr  LB7C2          ; GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1
          tfr  y,d            ; PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD
          subd #LINBUF+2      ; SUBTRACT OUT THE START OF LINE
          stb  VD7            ; SAVE LENGTH OF LINE
L854D     ldd  BINVAL         ; GET THE HEX VALUE OF LINE NUMBER
          jsr  LBDCC          ; LIST THE LINE NUMBER ON THE SCREEN
          jsr  LB9AC          ; PRINT A SPACE
          ldx  #LINBUF+1      ; POINT X TO BUFFER
          ldb  VD8            ; * CHECK TO SEE IF LINE IS TO BE
          bne  L8581          ; * LISTED TO SCREEN - BRANCH IF IT IS
L855C     clrb                ; RESET DIGIT ACCUMULATOR - DEFAULT VALUE
L855D     jsr  L8687          ; GET KEY STROKE
          jsr  L90AA          ; SET CARRY IF NOT NUMERIC
          blo  L8570          ; BRANCH IF NOT NUMERIC
          suba #'0'            ; MASK OFF ASCII
          pshs a              ; SAVE IT ON STACK
          lda  #10            ; NUMBER BEING CONVERTED IS BASE 10
          mul                 ; MULTIPLY ACCUMULATED VALUE BY BASE (10)
          addb ,s+            ; ADD DIGIT TO ACCUMULATED VALUE
          bra  L855D          ; CHECK FOR ANOTHER DIGIT
L8570     subb #$01           ; * REPEAT PARAMETER IN ACCB; IF IT
          adcb #$01           ; *IS 0, THEN MAKE IT '1'
          cmpa #'A'           ; ABORT?
          bne  L857D          ; NO
          jsr  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
          bra  L8538          ; RESTART EDIT PROCESS - CANCEL ALL CHANGES
L857D     cmpa #'L'           ; LIST?
          bne  L858C          ; NO
L8581     bsr  L85B4          ; LIST THE LINE
          clr  VD8            ; RESET THE LIST FLAG TO 'NO LIST'
          jsr  LB958          ; PRINT CARRIAGE RETURN
          bra  L854D          ; GO INTERPRET ANOTHER EDIT COMMAND
L858A     leas $02,s          ; PURGE RETURN ADDRESS OFF OF THE STACK
L858C     cmpa #CR            ; ENTER KEY?
          bne  L859D          ; NO
          bsr  L85B4          ; ECHO THE LINE TO THE SCREEN
L8592     jsr  LB958          ; PRINT CARRIAGE RETURN
          ldx  #LINBUF+1      ; * RESET BASIC'S INPUT POINTER
          stx  CHARAD         ; * TO THE LINE INPUT BUFFER
          jmp  LACA8          ; GO PUT LINE BACK IN PROGRAM
L859D     cmpa #'E'           ; EXIT?
          beq  L8592          ; YES - SAME AS ENTER EXCEPT NO ECHO
          cmpa #'Q'           ; QUIT?
          bne  L85AB          ; NO
          jsr  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
          jmp  LAC73          ; GO TO COMMAND LEVEL - MAKE NO CHANGES
L85AB     bsr  L85AF          ; INTERPRET THE REMAINING COMMANDS AS SUBROUTINES
          bra  L855C          ; GO INTERPRET ANOTHER EDIT COMMAND
L85AF     cmpa #SPACE         ; SPACE BAR?
          bne  L85C3          ; NO
L85B3     fcb  SKP2           ; SKIP TWO BYTES
* DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFER TO THE SCREEN
*
L85B4     ldb  #LBUFMX-1      ; 250 BYTES MAX IN BUFFER
L85B6     lda  ,x             ; GET A CHARACTER FROM BUFFER
          beq  L85C2          ; EXIT IF IT'S A 0
          jsr  PUTCHR         ; SEND CHAR TO CONSOLE OUT
          leax $01,x          ; MOVE POINTER UP ONE
          decb                ; DECREMENT CHARACTER COUNTER
          bne  L85B6          ; LOOP IF NOT DONE
L85C2     rts
L85C3     cmpa #'D'           ; DELETE?
          bne  L860F          ; NO
L85C7     tst  ,x             ; * CHECK FOR END OF LINE
          beq  L85C2          ; * AND BRANCH IF SO
          bsr  L85D1          ; REMOVE A CHARACTER
          decb                ; DECREMENT REPEAT PARAMETER
          bne  L85C7          ; BRANCH IF NOT DONE
          rts
* REMOVE ONE CHARACTER FROM BUFFER
L85D1     dec  VD7            ; DECREMENT LENGTH OF BUFFER
          leay -1,x           ; POINT Y TO ONE BEFORE CURRENT BUFFER POINTER
L85D5     leay $01,y          ; INCREMENT TEMPORARY BUFFER POINTER
          lda  $01,y          ; GET NEXT CHARACTER
          sta  ,y             ; PUT IT IN CURRENT POSITION
          bne  L85D5          ; BRANCH IF NOT END OF LINE
          rts
L85DE     cmpa #'I'           ;  INSERT?
          beq  L85F5          ; YES
          cmpa #'X'           ; EXTEND?
          beq  L85F3          ; YES
          cmpa #'H'           ; HACK?
          bne  L8646          ; NO
          clr  ,x             ; TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG
          tfr  x,d            ; PUT CURRENT BUFFER POINTER IN ACCD
          subd #LINBUF+2      ; SUBTRACT INITIAL POINTER POSITION
          stb  VD7            ; SAVE NEW BUFFER LENGTH
L85F3     bsr  L85B4          ; DISPLAY THE LINE ON THE SCREEN
L85F5     jsr  L8687          ; GET A KEYSTROKE
          cmpa #CR            ; ENTER KEY?
          beq  L858A          ; YES - INTERPRET ANOTHER COMMAND - PRINT LINE
          cmpa #ESC           ; ESCAPE?
          beq  L8625          ; YES - RETURN TO COMMAND LEVEL - DON'T PRINT LINE
          cmpa #BS            ; BACK SPACE?
          bne  L8626          ; NO
          cmpx #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
          beq  L85F5          ; DO NOT ALLOW BS IF AT START
          bsr  L8650          ; MOVE POINTER BACK ONE, BS TO SCREEN
          bsr  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
          bra  L85F5          ; GET INSERT SUB COMMAND
L860F     cmpa #'C'           ; CHANGE?
          bne  L85DE          ; NO
L8613     tst  ,x             ; CHECK CURRENT BUFFER CHARACTER
          beq  L8625          ; BRANCH IF END OF LINE
          jsr  L8687          ; GET A KEYSTROKE
          blo  L861E          ; BRANCH IF LEGITIMATE KEY
          bra  L8613          ; TRY AGAIN IF ILLEGAL KEY
L861E     sta  ,x+            ; INSERT NEW CHARACTER INTO BUFFER
          bsr  L8659          ; SEND NEW CHARACTER TO SCREEN
          decb                ; DECREMENT REPEAT PARAMETER
          bne  L8613          ; BRANCH IF NOT DONE
L8625     rts
L8626     ldb  VD7            ; GET LENGTH OF LINE
          cmpb #LBUFMX-1      ; COMPARE TO MAXIMUM LENGTH
          bne  L862E          ; BRANCH IF NOT AT MAXIMUM
          bra  L85F5          ; IGNORE INPUT IF LINE AT MAXIMUM LENGTH
L862E     pshs x              ; SAVE CURRENT BUFFER POINTER
L8630     tst  ,x+            ; * SCAN THE LINE UNTIL END OF
          bne  L8630          ; * LINE (0) IS FOUND
L8634     ldb  ,-x            ; DECR TEMP LINE POINTER AND GET A CHARACTER
          stb  $01,x          ; PUT CHARACTER BACK DOWN ONE SPOT
          cmpx ,s             ; HAVE WE REACHED STARTING POINT?
          bne  L8634          ; NO - KEEP GOING
          leas $02,s          ; PURGE BUFFER POINTER FROM STACK
          sta  ,x+            ; INSERT NEW CHARACTER INTO THE LINE
          bsr  L8659          ; SEND A CHARACTER TO CONSOLE OUT
          inc  VD7            ; ADD ONE TO BUFFER LENGTH
          bra  L85F5          ; GET INSERT SUB COMMAND
L8646     cmpa #BS            ; BACKSPACE?
          bne  L865C          ; NO
L864A     bsr  L8650          ; MOVE POINTER BACK 1, SEND BS TO SCREEN
          decb                ; DECREMENT REPEAT PARAMETER
          bne  L864A          ; LOOP UNTIL DONE
          rts
L8650     cmpx #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
          beq  L8625          ; DO NOT ALLOW BS IF AT START
          leax -1,x           ; MOVE POINTER BACK ONE
          lda  #BS            ; BACK SPACE
L8659     jmp  PUTCHR         ; SEND TO CONSOLE OUT
L865C     cmpa #'K'           ; KILL?
          beq  L8665          ; YES
          suba #'S'           ; SEARCH?
          beq  L8665          ; YES
          rts
L8665     pshs a              ; SAVE KILL/SEARCH FLAG ON STACK
          bsr  L8687          ; * GET A KEYSTROKE (TARGET CHARACTER)
          pshs a              ; * AND SAVE IT ON STACK
L866B     lda  ,x             ; GET CURRENT BUFFER CHARACTER
          beq  L8685          ; AND RETURN IF END OF LINE
          tst  $01,s          ; CHECK KILL/SEARCH FLAG
          bne  L8679          ; BRANCH IF KILL
          bsr  L8659          ; SEND A CHARACTER TO CONSOLE OUT
          leax $01,x          ; INCREMENT BUFFER POINTER
          bra  L867C          ; CHECK NEXT INPUT CHARACTER
L8679     jsr  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
L867C     lda  ,x             ; GET CURRENT INPUT CHARACTER
          cmpa ,s             ; COMPARE TO TARGET CHARACTER
          bne  L866B          ; BRANCH IF NO MATCH
          decb                ; DECREMENT REPEAT PARAMETER
          bne  L866B          ; BRANCH IF NOT DONE
L8685     puls y,pc           ; THE Y PULL WILL CLEAN UP THE STACK FOR THE 2 pshs a
*
* GET A KEYSTRKE
L8687     jsr  LA171          ; CALL CONSOLE IN : DEV NBR=SCREEN
          cmpa #$7F           ; GRAPHIC CHARACTER?
          bcc  L8687          ; YES - GET ANOTHER CHAR
          cmpa #$5F           ; SHIFT UP ARROW (QUIT INSERT)
          bne  L8694          ; NO
          lda  #ESC           ; REPLACE W/ESCAPE CODE
L8694     cmpa #CR            ; ENTER KEY
          beq  L86A6          ; YES
          cmpa #ESC           ; ESCAPE?
          beq  L86A6          ; YES
          cmpa #BS            ; BACKSPACE?
          beq  L86A6          ; YES
          cmpa #SPACE         ; SPACE
          blo  L8687          ; GET ANOTHER CHAR IF CONTROL CHAR
          orcc #$01           ; SET CARRY
L86A6     rts

* TRON
TRON      fcb  SKP1LD         ; SKIP ONE BYTE AND lda #$4F

* TROFF
TROFF     clra                ; TROFF FLAG
          sta  TRCFLG         ; TRON/TROFF FLAG:0=TROFF, <> 0=TRON
          rts

* POS

POS       lda  #0             ; GET DEVICE NUMBER
          ldb  LPTPOS         ; GET PRINT POSITION
LA5E8     sex                 ; CONVERT ACCB TO 2 DIGIT SIGNED INTEGER
          jmp  GIVABF         ; CONVERT ACCD TO FLOATING POINT


* VARPTR
VARPT     jsr  LB26A          ; SYNTAX CHECK FOR '('
          ldd  ARYEND         ; GET ADDR OF END OF ARRAYS
          pshs b,a            ; SAVE IT ON STACK
          jsr  LB357          ; GET VARIABLE DESCRIPTOR
          jsr  LB267          ; SYNTAX CHECK FOR ')'
          puls a,b            ; GET END OF ARRAYS ADDR BACK
          exg  x,d            ; SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR
          cmpx ARYEND         ; COMPARE TO NEW END OF ARRAYS
          bne  L8724          ; 'FC' ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR
          jmp  GIVABF         ; CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER

* MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT
L86D6     jsr  GETNCH         ; GET INPUT CHAR FROM BASIC
          jsr  LB26A          ; SYNTAX CHECK FOR '('
          jsr  LB357          ; * GET VARIABLE DESCRIPTOR ADDRESS AND
          pshs x              ; * SAVE IT ON THE STACK
          ldd  $02,x          ; POINT ACCD TO START OF OLDSTRING
          cmpd FRETOP         ; COMPARE TO START OF CLEARED SPACE
          bls  L86EB          ; BRANCH IF <=
          subd MEMSIZ         ; SUBTRACT OUT TOP OF CLEARED SPACE
          bls  L86FD          ; BRANCH IF STRING IN STRING SPACE
L86EB     ldb  ,x             ; GET LENGTH OF OLDSTRING
          jsr  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
          pshs x              ; SAVE RESERVED SPACE STRING ADDRESS ON STACK
          ldx  $02,s          ; POINT X TO OLDSTRING DESCRIPTOR
          jsr  LB643          ; MOVE OLDSTRING INTO STRING SPACE
          puls x,u            ; * GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING
          stx  $02,u          ; * ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS
          pshs u              ; SAVE OLDSTRING DESCRIPTOR ADDRESS
L86FD     jsr  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
          pshs b              ; SAVE POSITION PARAMETER ON STACK
          tstb                ; * CHECK POSITION PARAMETER AND BRANCH
          beq  L8724          ; * IF START OF STRING
          ldb  #$FF           ; DEFAULT REPLACEMENT LENGTH = $FF
          cmpa #')'           ; * CHECK FOR END OF MID$ STATEMENT AND
          beq  L870E          ; * BRANCH IF AT END OF STATEMENT
          jsr  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
L870E     pshs b              ; SAVE LENGTH PARAMETER ON STACK
          jsr  LB267          ; SYNTAX CHECK FOR ')'
          ldb  #TOK_EQUALS    ; TOKEN FOR =
          jsr  LB26F          ; SYNTAX CHECK FOR '='
          bsr  L8748          ; EVALUATE REPLACEMENT STRING
          tfr  x,u            ; SAVE REPLACEMENT STRING ADDRESS IN U
          ldx  $02,s          ; POINT X TO OLOSTRING DESCRIPTOR ADDRESS
          lda  ,x             ; GET LENGTH OF OLDSTRING
          suba $01,s          ; SUBTRACT POSITION PARAMETER
          bcc  L8727          ; INSERT REPLACEMENT STRING INTO OLDSTRING
L8724     jmp  LB44A          ; 'FC' ERROR IF POSITION > LENGTH OF OLDSTRING
L8727     inca                ; * NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT
*                             ; * (INCLUSIVE) OF THE POSITION PARAMETER
          cmpa ,s
          bcc  L872E          ; BRANCH IF NEW STRING WILL FIT IN OLDSTRING
          sta  ,s             ; IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT
L872E     lda  $01,s          ; GET POSITION PARAMETER
          exg  a,b            ; ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER
          ldx  $02,x          ; POINT X TO OLDSTRING ADDRESS
          decb                ; * BASIC'S POSITION PARAMETER STARTS AT 1; THIS ROUTINE
*                             ; * WANTS IT TO START AT ZERO
          abx                 ; POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO
          tsta                ; * IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO
          beq  L8746          ; * THEN RETURN
          cmpa ,s
          bls  L873F          ; ADJUSTED LENGTH PARAMETER, THEN BRANCH
          lda  ,s             ; OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE
L873F     tfr  a,b            ; SAVE NUMBER OF BYTES TO MOVE IN ACCB
          exg  u,x            ; SWAP SOURCE AND DESTINATION POINTERS
          jsr  LA59A          ; MOVE (B) BYTES FROM (X) TO (U)
L8746     puls a,b,x,pc
L8748     jsr  LB156          ; EVALUATE EXPRESSION
          jmp  LB654          ; *'TM' ERROR IF NUMERIC; RETURN WITH X POINTING
*                             ; *TO STRING, ACCB = LENGTH

* STRING
STRING    jsr  LB26A          ; SYNTAX CHECK FOR '('
          jsr  LB70B          ; EVALUATE EXPRESSION; ERROR IF > 255
          pshs b              ; SAVE LENGTH OF STRING
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          jsr  LB156          ; EVALUATE EXPRESSION
          jsr  LB267          ; SYNTAX CHECK FOR ')'
          lda  VALTYP         ; GET VARIABLE TYPE
          bne  L8768          ; BRANCH IF STRING
          jsr  LB70E          ; CONVERT FPA0 INTO AN INTEGER IN ACCB
          bra  L876B          ; SAVE THE STRING IN STRING SPACE
L8768     jsr  LB6A4          ; GET FIRST BYTE OF STRING
L876B     pshs b              ; SAVE FIRST BYTE OF EXPRESSION
          ldb  $01,s          ; GET LENGTH OF STRING
          jsr  LB50F          ; RESERVE ACCB BYTES IN STRING SPACE
          puls a,b            ; GET LENGTH OF STRING AND CHARACTER
          beq  L877B          ; BRANCH IF NULL STRING
L8776     sta  ,x+            ; SAVE A CHARACTER IN STRING SPACE
          decb                ; DECREMENT LENGTH
          bne  L8776          ; BRANCH IF NOT DONE
L877B     jmp  LB69B          ; PUT STRING DESCRIPTOR ONTO STRING STACK

* INSTR
INSTR     jsr  LB26A          ; SYNTAX CHECK FOR '('
          jsr  LB156          ; EVALUATE EXPRESSION
          ldb  #$01           ; DEFAULT POSITION = 1 (SEARCH START)
          pshs b              ; SAVE START
          lda  VALTYP         ; GET VARIABLE TYPE
          bne  L879C          ; BRANCH IF STRING
          jsr  LB70E          ; CONVERT FPA0 TO INTEGER IN ACCB
          stb  ,s             ; SAVE START SEARCH VALUE
          beq  L8724          ; BRANCH IF START SEARCH AT ZERO
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          jsr  LB156          ; EVALUATE EXPRESSION - SEARCH STRING
          jsr  LB146          ; 'TM' ERROR IF NUMERIC
L879C     ldx  FPA0+2         ; SEARCH STRING DESCRIPTOR ADDRESS
          pshs x              ; SAVE ON THE STACK
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          jsr  L8748          ; EVALUATE TARGET STRING EXPRESSION
          pshs x,b            ; SAVE ADDRESS AND LENGTH ON STACK
          jsr  LB267          ; SYNTAX CHECK FOR ')'
          ldx  $03,s          ; * LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS
          jsr  LB659          ; * AND GET THE LENGTH AND ADDRESS OF SEARCH STRING
          pshs b              ; SAVE LENGTH ON STACK
*
* AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATION
* ON IT: 0,s-SEARCH LENGTH; 1,s-TARGET LENGTH; 2 3,s-TARGET
* ADDRESS; 4 5,s-SEARCH DESCRIPTOR ADDRESS; 6,s-SEARCH POSITION
          cmpb $06,s          ; COMPARE LENGTH OF SEARCH STRING TO START
          blo  L87D9          ; POSITION; RETURN 0 IF LENGTH < START
          lda  $01,s          ; GET LENGTH OF TARGET STRING
          beq  L87D6          ; BRANCH IF TARGET STRING = NULL
          ldb  $06,s          ; GET START POSITION
          decb                ; MOVE BACK ONE
          abx                 ; POINT X TO POSITION IN SEARCH STRING WHERE SEARCHING WILL START
L87BE     leay ,x             ; POINT Y TO SEARCH POSITION
          ldu  $02,s          ; POINT U TO START OF TARGET
          ldb  $01,s          ; LOAD ACCB WITH LENGTH OF TARGET
          lda  ,s             ; LOAD ACCA WITH LENGTH OF SEARCH
          suba $06,s          ; SUBTRACT SEARCH POSITION FROM SEARCH LENGTH
          inca                ; ADD ONE
          cmpa $01,s          ; COMPARE TO TARGET LENGTH
          blo  L87D9          ; RETURN 0 IF TARGET LENGTH > WHAT'S LEFT OF SEARCH STRING
L87CD     lda  ,x+            ; GET A CHARACTER FROM SEARCH STRING
          cmpa ,u+            ; COMPARE IT TO TARGET STRING
          bne  L87DF          ; BRANCH IF NO MATCH
          decb                ; DECREMENT TARGET LENGTH
          bne  L87CD          ; CHECK ANOTHER CHARACTER
L87D6     ldb  $06,s          ; GET MATCH POSITION
L87D8     fcb  SKP1           ; SKIP NEXT BYTE
L87D9     clrb                ; MATCH ADDRESS = 0
          leas $07,s          ; CLEAN UP THE STACK
          jmp  LB4F3          ; CONVERT ACCB TO FP NUMBER
L87DF     inc  $06,s          ; INCREMENT SEARCH POSITION
          leax $01,y          ; MOVE X TO NEXT SEARCH POSITION
          bra  L87BE          ; KEEP LOOKING FOR A MATCH

* EXTENDED BASIC RVEC19 HOOK CODE
XVEC19    cmpa #'&'           ; *
          bne  L8845          ; * RETURN IF NOT HEX OR OCTAL VARIABLE
          leas $02,s          ; PURGE RETURN ADDRESS FROM STACK
* PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
L87EB     clr  FPA0+2         ; * CLEAR BOTTOM TWO
          clr  FPA0+3         ; * BYTES OF FPA0
          ldx  #FPA0+2        ; BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR)
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          cmpa #'O'
          beq  L880A          ; YES
          cmpa #'H'
          beq  L881F          ; YES
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          bra  L880C          ; DEFAULT TO OCTAL (&O)
L8800     cmpa #'8'
          bhi  LB277
          ldb  #$03           ; BASE 8 MULTIPLIER
          bsr  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
* EVALUATE AN &O VARIABLE
L880A     jsr  GETNCH         ; GET A CHARACTER FROM BASIC
L880C     blo  L8800          ; BRANCH IF NUMERIC
L880E     clr  FPA0           ; * CLEAR 2 HIGH ORDER
          clr  FPA0+1         ; * BYTES OF FPA0
          clr  VALTYP         ; SET VARXABLE TYPE TO NUMERIC
          clr  FPSBYT         ; ZERO OUT SUB BYTE OF FPA0
          clr  FP0SGN         ; ZERO OUT MANTISSA SIGN OF FPA0
          ldb  #$A0           ; * SET EXPONENT OF FPA0
          stb  FP0EXP         ; *
          jmp  LBA1C          ; GO NORMALIZE FPA0
* EVALUATE AN &H VARIABLE
L881F     jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          blo  L882E          ; BRANCH IF NUMERIC
          jsr  LB3A2          ; SET CARRY IF NOT ALPHA
          blo  L880E          ; BRANCH IF NOT ALPHA OR NUMERIC
          cmpa #'G'           ; CHECK FOR LETTERS A-F
          bcc  L880E          ; BRANCH IF >= G (ILLEGAL HEX LETTER)
          suba #7             ; SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9
L882E     ldb  #$04           ; BASE 16 DIGIT MULTIPLIER = 2**4
          bsr  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
          bra  L881F          ; KEEP EVALUATING VARIABLE
L8834     asl  $01,x          ; * MULTIPLY TEMPORARY
          rol  ,x             ; * ACCUMULATOR BY TWO
          bcs  LBA92          ; 'OV' OVERFLOW ERROR
          decb                ; DECREMENT SHIFT COUNTER
          bne  L8834          ; MULTIPLY TEMPORARY ACCUMULATOR AGAIN
          suba #'0'            ; MASK OFF ASCII
          adda $01,x          ; * ADD DIGIT TO TEMPORARY
          sta  $01,x          ; * ACCUMULATOR AND SAVE IT
L8845     rts

XVEC15    puls u              ; PULL RETURN ADDRESS AND SAVE IN U REGISTER
          clr  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
          ldx  CHARAD         ; CURRENT INPUT POINTER TO X
          jsr  GETNCH         ; GET CHARACTER FROM BASIC
          cmpa #'&'           ; HEX AND OCTAL VARIABLES ARE PRECEEDED BY &
          beq  L87EB          ; PROCESS A '&' VARIABLE
          cmpa #TOK_FN        ; TOKEN FOR FN
          beq  L88B4          ; PROCESS FN CALL
          cmpa #$FF           ; CHECK FOR SECONDARY TOKEN
          bne  L8862          ; NOT SECONDARY
          jsr  GETNCH         ; GET CHARACTER FROM BASIC
          cmpa #TOK_USR       ; TOKEN FOR USR
          lbeq L892C          ; PROCESS USR CALL
L8862     stx  CHARAD         ; RESTORE BASIC'S INPUT POINTER
          jmp  ,u             ; RETURN TO CALLING ROUTINE
L8866     ldx  CURLIN         ; GET CURRENT LINE NUMBER
          leax $01,x          ; IN DIRECT MODE?
          bne  L8845          ; RETURN IF NOT IN DIRECT MODE
          ldb  #2*11          ; 'ILLEGAL DIRECT STATEMENT' ERROR
L886E     jmp  LAC46          ; PROCESS ERROR

DEF       ldx  [CHARAD]       ; GET TWO INPUT CHARS
          cmpx #TOK_FF_USR    ; TOKEN FOR USR
          beq  L890F          ; BRANCH IF DEF USR
          bsr  L88A1          ; GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME
          bsr  L8866          ; DON'T ALLOW DEF FN IF IN DIRECT MODE
          jsr  LB26A          ; SYNTAX CHECK FOR '('
          ldb  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE
          stb  ARYDIS         ; * AND SAVE IT IN THE ARRAY DISABLE FLAG
          jsr  LB357          ; GET VARIABLE DESCRIPTOR
          bsr  L88B1          ; 'TM' ERROR IF STRING
          jsr  LB267          ; SYNTAX CHECK FOR ')'
          ldb  #TOK_EQUALS    ; TOKEN FOR '='
          jsr  LB26F          ; DO A SYNTAX CHECK FOR =
          ldx  V4B            ; GET THE ADDRESS OF THE FN NAME DESCRIPTOR
          ldd  CHARAD         ; * GET THE CURRENT INPUT POINTER ADDRESS AND
          std  ,x             ; * SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR
          ldd  VARPTR         ; = GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT
          std  $02,x          ; = VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME
          jmp  DATA           ; MOVE INPUT POINTER TO END OF LINE OR SUBLINE
L88A1     ldb  #TOK_FN        ; TOKEN FOR FN
          jsr  LB26F          ; DO A SYNTAX CHECK FOR FN
          ldb  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG
          stb  ARYDIS         ; * AND SAVE IT IN ARRAY VARIABLE FLAG
          ora  #$80           ; SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE
          jsr  LB35C          ; * GET THE DESCRIPTOR ADDRESS OF THIS
          stx  V4B            ; * VARIABLE AND SAVE IT IN V4B
L88B1     jmp  LB143          ; 'TM' ERROR IF STRING VARIABLE
* EVALUATE AN FN CALL
L88B4     bsr  L88A1          ; * GET THE DESCRIPTOR OF THE FN NAME
          pshs x              ; * VARIABLE AND SAVE IT ON THE STACK
          jsr  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
          bsr  L88B1          ; 'TM' ERROR IF STRING VARIABLE
          puls u              ; POINT U TO FN NAME DESCRIPTOR
          ldb  #2*25          ; 'UNDEFINED FUNCTION CALL' ERROR
          ldx  $02,u          ; POINT X TO ARGUMENT VARIABLE DESCRIPTOR
          beq  L886E          ; BRANCH TO ERROR HANDLER
          ldy  CHARAD         ; SAVE CURRENT INPUT POINTER IN Y
          ldu  ,u             ; * POINT U TO START OF FN FORMULA AND
          stu  CHARAD         ; * SAVE IT IN INPUT POINTER
          lda  $04,x          ; = GET FP VALUE OF
          pshs a              ; = ARGUMENT VARIABLE, CURRENT INPUT
          ldd  ,x             ; = POINTER, AND ADDRESS OF START
          ldu  $02,x          ; = OF FN FORMULA AND SAVE
          pshs u,y,x,b,a      ; = THEM ON THE STACK
          jsr  LBC35          ; PACK FPA0 AND SAVE IT IN (X)
L88D9     jsr  LB141          ; EVALUATE FN EXPRESSION
          puls a,b,x,y,u      ; RESTORE REGISTERS
          std  ,x             ; * GET THE FP
          stu  $02,x          ; * VALUE OF THE ARGUMENT
          puls a              ; * VARIABLE OFF OF THE
          sta  $04,x          ; * STACK AND RE-SAVE IT
          jsr  GETCCH         ; GET FINAL CHARACTER OF THE FN FORMULA
          lbne LB277          ; 'SYNTAX' ERROR IF NOT END OF LINE
          sty  CHARAD         ; RESTORE INPUT POINTER
L88EF     rts



* DEF USR
L890F     jsr  GETNCH         ; SKIP PAST SECOND BYTE OF DEF USR TOKEN
          bsr  L891C          ; GET FN NUMBER
          pshs x              ; SAVE FN EXEC ADDRESS STORAGE LOC
          bsr  L8944          ; CALCULATE EXEC ADDRESS
          puls u              ; GET FN EXEC ADDRESS STORAGE LOC
          stx  ,u             ; SAVE EXEC ADDRESS
          rts
L891C     clrb                ; DEFAULT TO USR0 IF NO ARGUMENT
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          bcc  L8927          ; BRANCH IF NOT NUMERIC
          suba #'0'            ; MASK OFF ASCII
          tfr  a,b            ; SAVE USR NUMBER IN ACCB
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
L8927     ldx  USRADR         ; GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS
          aslb                ; X2 - 2 BYTES/USR ADDRESS
          abx                 ; ADD OFFSET TO START ADDRESS OF STORAGE LOCs
          rts
* PROCESS A USR CALL
L892C     bsr  L891C          ; GET STORAGE LOC OF EXEC ADDRESS FOR USR N
          ldx  ,x             ; * GET EXEC ADDRESS AND
          pshs x              ; * PUSH IT ONTO STACK
          jsr  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
          ldx  #FP0EXP        ; POINT X TO FPA0
          lda  VALTYP         ; GET VARIABLE TYPE
          beq  L8943          ; BRANCH IF NUMERIC, STRING IF <> 0
          jsr  LB657          ; GET LENGTH & ADDRESS OF STRING VARIABLE
          ldx  FPA0+2         ; GET POINTER TO STRING DESCRIPTOR
          lda  VALTYP         ; GET VARIABLE TYPE
L8943     rts                 ; JUMP TO USR ROUTINE (pshs x ABOVE)
L8944     ldb  #TOK_EQUALS    ; TOKEN FOR '='
          jsr  LB26F          ; DO A SYNTAX CHECK FOR =
          jmp  LB73D          ; EVALUATE EXPRESSION, RETURN VALUE IN X



* DEL
DEL       beq  LB44A          ; 'FC' ERROR IF NO ARGUMENT
          jsr  LAF67          ; CONVERT A DECIMAL BASiC NUMBER TO BINARY
          jsr  LAD01          ; FIND RAM ADDRESS OF START OF A BASIC LINE
          stx  VD3            ; SAVE RAM ADDRESS OF STARTING LINE NUMBER
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          beq  L8990          ; BRANCH IF END OF LINE
          cmpa #TOK_MINUS     ; TOKEN FOR '-'
          bne  L89BF          ; TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY '-'
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          beq  L898C          ; IF END OF LINE, USE DEFAULT ENDING LINE NUMBER
          bsr  L89AE          ; * CONVERT ENDING LINE NUMBER TO BINARY
          bra  L8990          ; * AND SAVE IT IN BINVAL
L898C     lda  #$FF           ; = USE $FFXX AS DEFAULT ENDING
          sta  BINVAL         ; = LINE NUMBER - SAVE IT IN BINVAL
L8990     ldu  VD3            ; POINT U TO STARTING LINE NUMBER ADDRESS
L8992     fcb  SKP2           ; SKIP TWO BYTES
L8993     ldu  ,u             ; POINT U TO START OF NEXT LINE
          ldd  ,u             ; CHECK FOR END OF PROGRAM
          beq  L899F          ; BRANCH IF END OF PROGRAM
          ldd  $02,u          ; LOAD ACCD WITH THIS LINE'S NUMBER
          subd BINVAL         ; SUBTRACT ENDING LINE NUMBER ADDRESS
          bls  L8993          ; BRANCH IF = < ENDING LINE NUMBER
L899F     ldx  VD3            ; GET STARTING LINE NUMBER
          bsr  L89B8          ; MOVE (U) TO (X) UNTIL END OF PROGRAM
          jsr  LAD21          ; RESET BASIC'S INPUT POINTER AND ERASE VARIABLES
          ldx  VD3            ; GET STARTING LINE NUMBER ADDRESS
          jsr  LACF1          ; RECOMPUTE START OF NEXT LINE ADDRESSES
          jmp  LAC73          ; JUMP TO BASIC'S MAIN COMMAND LOOP
L89AE     jsr  LAF67          ; GO GET LINE NUMBER CONVERTED TO BINARY
          jmp  LA5C7          ; MAKE SURE THERE'S NO MORE ON THIS LINE
L89B4     lda  ,u+            ; GET A BYTE FROM (U)
          sta  ,x+            ; MOVE THE BYTE TO (X)
L89B8     cmpu VARTAB         ; COMPARE TO END OF BASIC
          bne  L89B4          ; BRANCH IF NOT AT END
          stx  VARTAB         ; SAVE (X) AS NEW END OF BASIC
L89BF     rts


L89C0     jsr  L8866          ; 'BS' ERROR IF IN DIRECT MODE
          jsr  GETNCH         ; GET A CHAR FROM BASIC
L89D2     cmpa #'"'           ; CHECK FOR PROMPT STRING
          bne  L89E1          ; BRANCH IF NO PROMPT STRING
          jsr  LB244          ; STRIP OFF PROMPT STRING & PUT IT ON STRING STACK
          ldb  #';'           ; *
          jsr  LB26F          ; * DO A SYNTAX CHECK FOR;
          jsr  LB99F          ; REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT
L89E1     leas -2,s           ; RESERVE TWO STORAGE SLOTS ON STACK
          jsr  LB035          ; INPUT A LINE FROM CURRENT INPUT DEVICE
          leas $02,s          ; CLEAN UP THE STACK
          jsr  LB357          ; SEARCH FOR A VARIABLE
          stx  VARDES         ; SAVE POINTER TO VARIABLE DESCRIPTOR
          jsr  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
          ldx  #LINBUF        ; POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED
          clra                ; TERMINATOR CHARACTER 0 (END OF LINE)
          jsr  LB51A          ; PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE
          jmp  LAFA4          ; REMOVE DESCRIPTOR FROM STRING STACK
		  		  
L89FC     jsr  LAF67          ; STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE
          ldx  BINVAL         ; GET BINARY VALUE
          rts
L8A02     ldx  VD1            ; GET CURRENT OLD NUMBER BEING RENUMBERED
L8A04     stx  BINVAL         ; SAVE THE LINE NUMBER BEING SEARCHED FOR
          jmp  LAD01          ; GO FIND THE LINE NUMBER IN BASIC PROGRAM

* RENUM
RENUM     jsr  LAD26          ; ERASE VARIABLES
          ldd  #10            ; DEFAULT LINE NUMBER INTERVAL
          std  VD5            ; SAVE DEFAULT RENUMBER START LINE NUMBER
          std  VCF            ; SAVE DEFAULT INTERVAL
          clrb                ; NOW ACCD = 0
          std  VD1            ; DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          bcc  L8A20          ; BRANCH IF NOT NUMERIC
          bsr  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
          stx  VD5            ; SAVE LINE NUMBER WHERE RENUMBERING STARTS
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
L8A20     beq  L8A3D          ; BRANCH IF END OF LINE
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          bcc  L8A2D          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
          bsr  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
          stx  VD1            ; SAVE NEW RENUMBER LINE
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
L8A2D     beq  L8A3D          ; BRANCH IF END OF LINE
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          bcc  L8A3A          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
          bsr  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
          stx  VCF            ; SAVE NEW INTERVAL
          beq  L8A83          ; 'FC' ERROR
L8A3A     jsr  LA5C7          ; CHECK FOR MORE CHARACTERS ON LINE - 'SYNTAX' ERROR IF ANY
L8A3D     bsr  L8A02          ; GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED
          stx  VD3            ; SAVE ADDRESS
          ldx  VD5            ; GET NEXT RENUMBERED LINE NUMBER TO USE
          bsr  L8A04          ; FIND THE LINE NUMBER IN THE BASIC PROGRAM
          cmpx VD3            ; COMPARE TO ADDRESS OF OLD LINE NUMBER
          blo  L8A83          ; 'FC' ERROR IF NEW ADDRESS < OLD ADDRESS
          bsr  L8A67          ; MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE
          jsr  L8ADD          ; CONVERT ASCII LINE NUMBERS TO 'EXPANDED' BINARY
          jsr  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESSES
          bsr  L8A02          ; GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED
          stx  VD3            ; SAVE IT
          bsr  L8A91          ; MAKE SURE LINE NUMBERS EXIST
          bsr  L8A68          ; INSERT NEW LINE NUMBERS IN LINE HEADERS
          bsr  L8A91          ; INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS
          jsr  L8B7B          ; CONVERT PACKED BINARY LINE NUMBERS TO ASCII
          jsr  LAD26          ; ERASE VARIABLES
          jsr  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESS
          jmp  LAC73          ; GO BACK TO BASIC'S MAIN LOOP
L8A67     fcb  SKP1LD         ; SKIP ONE BYTE - lda #$4F
L8A68     clra                ; NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS
          sta  VD8            ; SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS
          ldx  VD3            ; GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED
          ldd  VD5            ; GET THE CURRENT RENUMBERED LINE NUMBER
          bsr  L8A86          ; RETURN IF END OF PROGRAM
L8A71     tst  VD8            ; CHECK NEW LINE NUMBER FLAG
          bne  L8A77          ; BRANCH IF NOT INSERTING NEW LINE NUMBERS
          std  $02,x          ; STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM
L8A77     ldx  ,x             ; POINT X TO THE NEXT LINE IN BASIC
          bsr  L8A86          ; RETURN IF END OF PROGRAM
          addd VCF            ; ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER
          blo  L8A83          ; 'FC' ERROR IF LINE NUMBER > $FFFF
          cmpa #MAXLIN        ; LARGEST LINE NUMBER = $F9FF
          blo  L8A71          ; BRANCH IF LEGAL LINE NUMBER
L8A83     jmp  LB44A          ; 'FC' ERROR IF LINE NUMBER MS BYTE > $F9
* TEST THE TWO BYTES POINTED TO BY (X).
* NORMAL RETURN IF <> 0. IF = 0 (END OF
* PROGRAM) RETURN IS PULLED OFF STACK AND
* YOU RETURN TO PREVIOUS SUBROUTINE CALL.
L8A86     pshs b,a            ; SAVE ACCD
          ldd  ,x             ; TEST THE 2 BYTES POINTED TO BY X
          puls a,b            ; RESTORE ACCD
          bne  L8A90          ; BRANCH IF NOT END OF PROGRAM
          leas $02,s          ; PURGE RETURN ADDRESS FROM STACK
L8A90     rts
L8A91     ldx  TXTTAB         ; GET START OF BASIC PROGRAM
          leax -1,x           ; MOVE POINTER BACK ONE
L8A95     leax $01,x          ; MOVE POINTER UP ONE
          bsr  L8A86          ; RETURN IF END OF PROGRAM
L8A99     leax $03,x          ; SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER
L8A9B     leax $01,x          ; MOVE POINTER TO NEXT CHARACTER
          lda  ,x             ; CHECK CURRENT CHARACTER
          beq  L8A95          ; BRANCH IF END OF LINE
          stx  TEMPTR         ; SAVE CURRENT POINTER
          deca                ; =
          beq  L8AB2          ; =BRANCH IF START OF PACKED NUMERIC LINE
          deca                ; *
          beq  L8AD3          ; *BRANCH IF LINE NUMBER EXISTS
          deca                ; =
          bne  L8A9B          ; =MOVE TO NEXT CHARACTER IF > 3
L8AAC     lda  #$03           ; * SET 1ST BYTE = 3 TO INDICATE LINE
          sta  ,x+            ; * NUMBER DOESN'T CURRENTLY EXIST
          bra  L8A99          ; GO GET ANOTHER CHARACTER
L8AB2     ldd  $01,x          ; GET MS BYTE OF LINE NUMBER
          dec  $02,x          ; DECREMENT ZERO CHECK BYTE
          beq  L8AB9          ; BRANCH IF MS BYTE <> 0
          clra                ; CLEAR MS BYTE
L8AB9     ldb  $03,x          ; GET LS BYTE OF LINE NUMBER
          dec  $04,x          ; DECREMENT ZERO CHECK FLAG
          beq  L8AC0          ; BRANCH IF IS BYTE <> 0
          clrb                ; CLEAR LS BYTE
L8AC0     std  $01,x          ; SAVE BINARY LINE NUMBER
          std  BINVAL         ; SAVE TRIAL LINE NUMBER
          jsr  LAD01          ; FIND RAM ADDRESS OF A BASIC LINE NUMBER
L8AC7     ldx  TEMPTR         ; GET BACK POINTER TO START OF PACKED LINE NUMBER
          blo  L8AAC          ; BRANCH IF NO LINE NUMBER MATCH FOUND
          ldd  V47            ; GET START ADDRESS OF LINE NUMBER
          inc  ,x+            ; * SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXIsts IF CHECKING FOR
*              ; * EXISTENCE OF LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS

          std  ,x             ; SAVE RAM ADDRESS OF CORRECT LINE NUMBER
          bra  L8A99          ; GO GET ANOTHER CHARACTER
L8AD3     clr  ,x             ; CLEAR CARRY FLAG AND 1ST BYTE
          ldx  $01,x          ; POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER
          ldx  $02,x          ; PUT CORRECT LINE NUMBER INTO (X)
          stx  V47            ; SAVE IT TEMPoraRILY
          bra  L8AC7          ; GO INSERT IT INTO BASIC LINE
L8ADD     ldx  TXTTAB         ; GET BEGINNING OF BASIC PROGRAM
          bra  L8AE5
L8AE1     ldx  CHARAD         ; *GET CURRENT INPUT POINTER
          leax $01,x          ; *AND BUMP IT ONE
L8AE5     bsr  L8A86          ; RETURN IF END OF PROGRAM
          leax $02,x          ; SKIP PAST NEXT LINE ADDRESS
L8AE9     leax $01,x          ; ADVANCE POINTER BY ONE
L8AEB     stx  CHARAD         ; SAVE NEW BASIC INPUT POINTER
L8AED     jsr  GETNCH         ; GET NEXT CHARACTER FROM BASIC
L8AEF     tsta                ; CHECK THE CHARACTER
          beq  L8AE1          ; BRANCH IF END OF LINE
          bpl  L8AED          ; BRANCH IF NOT A TOKEN
          ldx  CHARAD         ; GET CURRENT INPUT POINTER
          cmpa #$FF           ; IS THIS A SECONDARY TOKEN?
          beq  L8AE9          ; YES - IGNORE IT
          cmpa #TOK_THEN      ; TOKEN FOR THEN?
          beq  L8B13          ; YES
          cmpa #TOK_ELSE      ; TOKEN FOR ELSE?
          beq  L8B13          ; YES
          cmpa #TOK_GO        ; TOKEN FOR GO?
          bne  L8AED          ; NO
          jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          cmpa #TOK_TO        ; TOKEN FOR TO?
          beq  L8B13          ; YES
          cmpa #TOK_SUB       ; TOKEN FOR SUB?
          bne  L8AEB          ; NO
L8B13     jsr  GETNCH         ; GET A CHARACTER FROM BASIC
          blo  L8B1B          ; BRANCH IF NUMERIC
L8B17     jsr  GETCCH         ; GET CURRENT BASIC INPUT CHARRACTER
          bra  L8AEF          ; KEEP CHECKING THE LINE
L8B1B     ldx  CHARAD         ; GET CURRENT INPUT ADDRESS
          pshs x              ; SAVE IT ON THE STACK
          jsr  LAF67          ; CONVERT DECIMAL BASIC NUMBER TO BINARY
          ldx  CHARAD         ; GET CURRENT INPUT POINTER
L8B24     lda  ,-x            ; GET PREVIOUS INPUT CHARACTER
          jsr  L90AA          ; CLEAR CARRY IF NUMERIC INPUT VALUE
          blo  L8B24          ; BRANCH IF NON-NUMERIC
          leax $01,x          ; MOVE POINTER UP ONE
          tfr  x,d            ; NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER
          subb $01,s          ; SUBTRACT PRE-NUMERIC POINTER LS BYTE
          subb #$05           ; MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE
*
          beq  L8B55          ; BRANCH IF EXACTLY 5
          blo  L8B41          ; BRANCH IF < 5
          leau ,x             ; TRANSFER X TO U
          negb                ; NEGATE B
          leax b,x            ; MOVE X BACK B BYTES
          jsr  L89B8          ; *MOVE BYTES FROM (U) TO (X) UNTIL
*         *U   = END OF BASIC; (I) = NEW END OF BASIC
          bra  L8B55
* FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER
L8B41     stx  V47            ; SAVE END OF NUMERIC VALUE
          ldx  VARTAB         ; GET END OF BASIC PROGRAM
          stx  V43            ; SAVE IT
          negb                ; NEGATE B
          leax b,x            ; ADD IT TO END OF NUMERIC POiNTER
          stx  V41            ; SAVE POINTER
          stx  VARTAB         ; STORE END OF BASIC PROGRAM
          jsr  LAC1E          ; ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM
          ldx  V45            ; * GET AND SAVE THE
          stx  CHARAD         ; * NEW CURRENT INPUT POINTER
L8B55     puls x              ; RESTORE POINTER TO START OF NUMERIC VALUE
          lda  #$01           ; NEW LINE NUMBER FLAG
          sta  ,x             ; * SAVE NEW LINE FLAG
          sta  $02,x          ; *
          sta  $04,x          ; *
          ldb  BINVAL         ; GET MS BYTE OF BINARY LINE NUMBER
          bne  L8B67          ; BRANCH IF IT IS NOT ZERO
          ldb  #$01           ; ; SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL
*              ; THINK IT IS THE END OF A LINE
          inc  $02,x          ; IF 2,x = 2, THEN PREVIOUS BYTE WAS A ZERO
L8B67     stb  $01,x          ; SAVE MS BYTE OF BINARY LINE NUMBER
          ldb  BINVAL+1       ; GET IS BYTE OF BINARY LINE NUMBER
          bne  L8B71          ; BRANCH IF NOT A ZERO BYTE
          ldb  #$01           ; SAVE A 1 IF BYTE IS A 0
          inc  $04,x          ; IF 4,x = 2, THEN PREVIOUS BYTE WAS A 0
L8B71     stb  $03,x          ; SAVE LS BYTE OF BINARY LINE NUMBER
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          cmpa #','            ; IS IT A COMMA?
          beq  L8B13          ; YES - PROCESS ANOTHER NUMERIC VALUE
          bra  L8B17          ; NO - GO GET AND PROCESS AN INPUT CHARACTER
L8B7B     ldx  TXTTAB         ; POINT X TO START OF BASIC PROGRAM
          leax -1,x           ; MOVE POINTER BACK ONE
L8B7F     leax $01,x          ; MOVE POINTER UP ONE
          ldd  $02,x          ; GET ADDRESS OF NEXT LINE
          std  CURLIN         ; SAVE IT IN CURLIN
          jsr  L8A86          ; RETURN IF END OF PROGRAM
          leax $03,x          ; SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER
L8B8A     leax $01,x          ; MOVE POINTER UP ONE
L8B8C     lda  ,x             ; GET CURRENT CHARACTER
          beq  L8B7F          ; BRANCH IF END OF LINE
          deca                ; INPUT CHARACTER = 1? - VALID LINE NUMBER
          beq  L8BAE          ; YES
          suba #$02           ; INPUT CHARACTER 3? - UL LINE NUMBER
          bne  L8B8A          ; NO
          pshs x              ; SAVE CURRENT POSITION OF INPUT POINTER
          ldx  #L8BD9-1       ; POINT X TO 'UL' MESSAGE
          jsr  LB99C          ; PRINT STRING TO THE SCREEN
          ldx  ,s             ; GET INPUT POINTER
          ldd  $01,x          ; GET THE UNDEFINED LINE NUMBER
          jsr  LBDCC          ; CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT
          jsr  LBDC5          ; PRINT 'IN XXXX' XXXX = CURRENT LINE NUMBER
          jsr  LB958          ; SEND A CR TO CONSOLE OUT
          puls x              ; GET INPUT POINTER BACK
L8BAE     pshs x              ; SAVE CURRENT POSITION OF INPUT POINTER
          ldd  $01,x          ; LOAD ACCD WITH BINARY VALUE OF LINE NUMBER
          std  FPA0+2         ; SAVE IN BOTTOM 2 BYTES OF FPA0
          jsr  L880E          ; ADJUST REST OF FPA0 AS AN INTEGER
          jsr  LBDD9          ; CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER
          puls u              ; LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER
          ldb  #$05           ; EACH EXPANDED LINE NUMBER USES 5 BYTES
L8BBE     leax $01,x          ; MOVE POINTER FORWARD ONE
          lda  ,x             ; GET AN ASCII BYTE
          beq  L8BC9          ; BRANCH IF END OF NUMBER
          decb                ; DECREMENT BYTE COUNTER
          sta  ,u+            ; STORE ASCII NUMBER IN BASIC LINE
          bra  L8BBE          ; CHECK FOR ANOTHER DIGIT
L8BC9     leax ,u             ; TRANSFER NEW LINE POINTER TO (X)
          tstb                ; DOES THE NEW LINE NUMBER REQUIRE 5 BYTES?
          beq  L8B8C          ; YES - GO GET ANOTHER INPUT CHARACTER
          leay ,u             ; SAVE NEW LINE POINTER IN Y
          leau b,u            ; POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK
          jsr  L89B8          ; MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM
          leax ,y             ; LOAD (X) WITH NEW LINE POINTER
          bra  L8B8C          ; GO GET ANOTHER INPUT CHARACTER

L8BD9     fcc  "UL "          ; UNKNOWN LINE NUMBER MESSAGE
          fcb  0


HEXDOL    jsr  LB740          ; CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER
          ldx  #STRBUF+2      ; POINT TO TEMPORARY BUFFER
          ldb  #$04           ; CONVERT 4 NIBBLES
L8BE5     pshs b              ; SAVE NIBBLE COUNTER
          clrb                ; CLEAR CARRY FLAG
          lda  #$04           ; 4 SHIFTS
L8BEA     asl  FPA0+3         ; * SHIFT BOTTOM TWO BYTES OF
          rol  FPA0+2         ; * FPA0 LEFT ONE BIT (X2)
          rolb                ; IF OVERFLOW, ACCB <> 0
          deca                ; * DECREMENT SHIFT COUNTER AND
          bne  L8BEA          ; * BRANCH IF NOT DONE
          tstb                ; CHECK FOR OVERFLOW
          bne  L8BFF          ; BRANCH IF OVERFLOW
          lda  ,s             ; * GET NIBBLE COUNTER,
          deca                ; * DECREMENT IT AND
          beq  L8BFF          ; * BRANCH IF DONE
          cmpx #STRBUF+2      ; DO NOT DO A CONVERSION UNTIL A NON-ZERO
          beq  L8C0B          ; BYTE IS FOUND - LEADING ZERO SUPPRESSION
L8BFF     addb #'0'            ; ADD IN ASCII ZERO
          cmpb #'9'           ; COMPARE TO ASCII 9
          bls  L8C07          ; BRANCH IF < 9
          addb #7             ; ADD ASCII OFFSET IF HEX LETTER
L8C07     stb  ,x+            ; STORE HEX VALUE AND ADVANCE POINTER
          clr  ,x             ; CLEAR NEXT BYTE - END OF STRING FLAG
L8C0B     puls b              ; * GET NIBBLE COUNTER,
          decb                ; * DECREMENT IT AND
          bne  L8BE5          ; * BRANCH IF NOT DONE
          leas $02,s          ; PURGE RETURN ADDRESS OFF OF STACK
          ldx  #STRBUF+1      ; RESET POINTER
          jmp  LB518          ; SAVE STRING ON STRING STACK
* PROCESS EXCLAMATION POINT
L8E37     lda  #$01           ; * SET SPACES
          sta  VD9            ; * COUNTER = 1		 
* PROCESS STRING ITEM - LIST
L8E3B     decb                ; DECREMENT FORMAT STRING LENGTH COUNTER
          jsr  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <>0
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          lbeq L8ED8          ; EXIT PRINT USING IF END OF LINE
          stb  VD3            ; SAVE REMAINDER FORMAT STRING LENGTH
          jsr  LB156          ; EVALUATE EXPRESSION
          jsr  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
          ldx  FPA0+2         ; * GET ITEM - LIST DESCRIPTOR ADDRESS
          stx  V4D            ; * AND SAVE IT IN V4D
          ldb  VD9            ; GET SPACES COUNTER
          jsr  LB6AD          ; PUT ACCB BYTES INTO STRING SPACE & PUT DESCRIPTOR ON STRING STACK
          jsr  LB99F          ; PRINT THE FORMATTED STRING TO CONSOLE OUT
* PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING < FORMAT STRING LENGTH
          ldx  FPA0+2         ; POINT X TO FORMATTED STRING DESCRIPTOR ADDRESS
          ldb  VD9            ; GET SPACES COUNTER
          subb ,x             ; SUBTRACT LENGTH OF FORMATTED STRING
L8E5F     decb                ; DECREMENT DIFFERENCE
          lbmi L8FB3          ; GO INTERPRET ANOTHER ITEM - LIST
          jsr  LB9AC          ; PAD FORMAT STRING WITH A SPACE
          bra  L8E5F          ; KEEP PADDING
* PERCENT SIGN - PROCESS A %SPACES% COMMAND
L8E69     stb  VD3            ; * SAVE THE CURRENT FORMAT STRING
          stx  TEMPTR         ; * COUNTER AND POINTER
          lda  #$02           ; INITIAL SPACES COUNTER = 2
          sta  VD9            ; SAVE IN SPACES COUNTER
L8E71     lda  ,x             ; GET A CHARACTER FROM FORMAT STRING
          cmpa #'%'           ; COMPARE TO TERMINATOR CHARACTER
          beq  L8E3B          ; BRANCH IF END OF SPACES COMMAND
          cmpa #' '           ; BLANK
          bne  L8E82          ; BRANCH IF ILLEGAL CHARACTER
          inc  VD9            ; ADD ONE TO SPACES COUNTER
          leax $01,x          ; MOVE FORMAT POINTER UP ONE
          decb                ; DECREMENT LENGTH COUNTER
          bne  L8E71          ; BRANCH IF NOT END OF FORMAT STRING
L8E82     ldx  TEMPTR         ; * RESTORE CURRENT FORMAT STRING COUNTER
          ldb  VD3            ; * AND POINTER TO POSITION BEFORE SPACES COMMAND
          lda  #'%'           ; SEND A '%' TO CONSOLE OUT AS A DEBUGGING AID
* ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN FORMAT STRING
L8E88     jsr  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
          jsr  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
          bra  L8EB9          ; GET NEXT CHARACTER IN FORMAT STRING

* PRINT RAM HOOK
XVEC9     cmpa #TOK_USING     ; USING TOKEN
          beq  L8E95          ; BRANCH IF PRINT USING
          rts

* PRINT USING
* VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE
* BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FORCE
* BIT 3 = PRE SIGN FORCE; BIT 2 = POST SIGN FORCE; BIT 0 = EXPONENTIAL FORCE
L8E95     leas $02,s          ; PURGE RETURN ADDRESS OFF THE STACK
          jsr  LB158          ; EVALUATE FORMAT STRING
          jsr  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
          ldb  #';'           ; CHECK FOR ITEM LIST SEPARATOR
          jsr  LB26F          ; SYNTAX CHECK FOR ;
          ldx  FPA0+2         ; * GET FORMAT STRING DESCRIPTOR ADDRESS
          stx  VD5            ; * AND SAVE IT IN VD5
          bra  L8EAE          ; GO PROCESS FORMAT STRING
L8EA8     lda  VD7            ; *CHECK NEXT PRINT ITEM FLAG AND
          beq  L8EB4          ; *'FC' ERROR IF NO FURTHER PRINT ITEMS
          ldx  VD5            ; RESET FORMAT STRING POINTER TO START OF STRING
L8EAE     clr  VD7            ; RESET NEXT PRINT ITEM FLAG
          ldb  ,x             ; GET LENGTH OF FORMAT STRING
          bne  L8EB7          ; INTERPRET FORMAT STRING IF LENGTH > 0
L8EB4     jmp  LB44A          ; 'FC' ERROR IF FORMAT STRING = NULL
L8EB7     ldx  $02,x          ; POINT X TO START OF FORMAT STRING
* INTERPRET THE FORMAT STRING
L8EB9     clr  VDA            ; CLEAR THE STATUS BYTE
L8EBB     clr  VD9            ; CLEAR LEFT DIGIT COUNTER
          lda  ,x+            ; GET A CHARACTER FROM FORMAT STRING
          cmpa #'!'           ; EXCLAMATION POINT?
          beq L8E37           ; YES - STRING TYPE FORMAT
          cmpa #'#'           ; NUMBER SIGN? (DIGIT LOCATOR)
          beq  L8F24          ; YES - NUMERIC TYPE FORMAT
          decb                ; DECREMENT FORMAT STRING LENGTH
          bne  L8EE2          ; BRANCH IF NOT DONE
          jsr  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
          jsr  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
L8ED2     jsr  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
          bne  L8EA8          ; BRANCH IF NOT END OF LINE
          lda  VD7            ; GET NEXT PRINT ITEM FLAG
L8ED8     bne  L8EDD          ; BRANCH IF MORE PRINT ITEMS
          jsr  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
L8EDD     ldx  VD5            ; POINT X TO FORMAT STRING DESCRIPTOR
          jmp  LB659          ; RETURN ADDRESS AND LENGTH OF FORMAT STRING - EXIT PRINT USING
L8EE2     cmpa #'+'           ; CHECK FOR '+' (PRE-SIGN FORCE)
          bne  L8EEF          ; NO PLUS
          jsr  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
          lda  #$08           ; * LOAD THE STATUS BYTE WITH 8;
          sta  VDA            ; * PRE-SIGN FORCE FLAG
          bra  L8EBB          ; INTERPRET THE REST OF THE FORMAT STRING
L8EEF     cmpa #'.'           ; DECIMAL POINT?
          beq  L8F41          ; YES
          cmpa #'%'           ; PERCENT SIGN?
          lbeq L8E69          ; YES
          cmpa ,x             ; COMPARE THE PRESENT FORMAT STRING INPUT
*              ; CHARACTER TO THE NEXT ONE IN THE STRING
L8EFB     bne  L8E88          ; NO MATCH - ILLEGAL CHARACTER
* TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING
          cmpa #'$'           ; DOLLAR SIGN?
          beq  L8F1A          ; YES - MAKE THE DOLLAR SIGN FLOAT
          cmpa #'*'           ; ASTERISK?
          bne  L8EFB          ; NO - ILLEGAL CHARACTER
          lda  VDA            ; * GRAB THE STATUS BYTE AND BET BIT 5
          ora  #$20           ; * TO INDICATE THAT THE OUTPUT WILL
          sta  VDA            ; * BE LEFT PADDED WITH ASTERISKS
          cmpb #2             ; * CHECK TO SEE IF THE $$ ARE THE LAST TWO
          blo  L8F20          ; * CHARACTERS IN THE FORMAT STRING AND BRANCH IF SO
          lda  $01,x          ; GET THE NEXT CHARACTER AFTER **
          cmpa #'$'           ; CHECK FOR **$
          bne  L8F20          ; CHECK FOR MORE CHARACTERS
          decb                ; DECREMENT STRING LENGTH COUNTER
          leax $01,x          ; MOVE FORMAT STRING POINTER UP ONE
          inc  VD9            ; ADD ONE TO LEFT DIGIT COUNTER - FOR ASTERISK PAD AND
*              ; FLOATING DOLLAR SIGN COMBINATION
L8F1A     lda  VDA            ; * GET THE STATUS BYTE AND SET
          ora  #$10           ; * BIT 4 TO INDICATE A
          sta  VDA            ; * FLOATING DOLLAR SIGN
L8F20     leax $01,x          ; MOVE FORMAT STRING POINTER UP ONE
          inc  VD9            ; ADD ONE TO LEFT DIGIT (FLOATING $ OR ASTERISK PAD)
* PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT IN THE FORMAT STRING
L8F24     clr  VD8            ; CLEAR THE RIGHT DIGIT COUNTER
L8F26     inc  VD9            ; ADD ONE TO LEFT DIGIT COUNTER
          decb                ; DECREMENT FORMAT STRING LENGTH COUNTER
          beq  L8F74          ; BRANCH IF END OF FORMAT STRING
          lda  ,x+            ; GET THE NEXT FORMAT CHARACTER
          cmpa #'.'           ; DECIMAL POINT?
          beq  L8F4F          ; YES
          cmpa #'#'           ; NUMBER SIGN?
          beq  L8F26          ; YES
          cmpa #','            ; COMMA?
          bne  L8F5A          ; NO
          lda  VDA            ; * GET THE STATUS BYTE
          ora  #$40           ; * AND SET BIT 6 WHICH IS THE
          sta  VDA            ; * COMMA SEPARATOR FLAG
          bra  L8F26          ; PROCESS MORE CHARACTERS TO LEFT OF DECIMAL POINT
* PROCESS DECIMAL POINT IF NO DIGITS TO LEFT OF IT
L8F41     lda  ,x             ; GET NEXT FORMAT CHARACTER
          cmpa #'#'           ; IS IT A NUMBER SIGN?
          lbne L8E88          ; NO
          lda  #1             ; * SET THE RIGHT DIGIT COUNTER TO 1 -
          sta  VD8            ; * ALLOW ONE SPOT FOR DECIMAL POINT
          leax $01,x          ; MOVE FORMAT POINTER UP ONE
* PROCESS DIGITS TO RIGHT OF DECIMAL POINT
L8F4F     inc  VD8            ; ADD ONE TO RIGHT DIGIT COUNTER
          decb                ; DECREMENT FORMAT LENGTH COUNTER
          beq  L8F74          ; BRANCH IF END OF FORMAT STRING
          lda  ,x+            ; GET A CHARACTER FROM FORMAT STRING
          cmpa #'#'           ; IS IT NUMBER SIGN?
          beq  L8F4F          ; YES - KEEP CHECKING
* CHECK FOR EXPONENTIAL FORCE
L8F5A     cmpa #$5E           ; CHECK FOR UP ARROW
          bne  L8F74          ; NO UP ARROW
          cmpa ,x             ; IS THE NEXT CHARACTER AN UP ARROW?
          bne  L8F74          ; NO
          cmpa $01,x          ; AND THE NEXT CHARACTER?
          bne  L8F74          ; NO
          cmpa $02,x          ; HOW ABOUT THE 4TH CHARACTER?
          bne  L8F74          ; NO, ALSO
          cmpb #4             ; * CHECK TO SEE IF THE 4 UP ARROWS ARE IN THE
          blo  L8F74          ; * FORMAT STRING AND BRANCH IF NOT
          subb #4             ; * MOVE POINTER UP 4 AND SUBTRACT
          leax $04,x          ; * FOUR FROM LENGTH
          inc  VDA            ; INCREMENT STATUS BYTE - EXPONENTIAL FORM

* CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMAT STRING
L8F74     leax -1,x           ; MOVE POINTER BACK ONE
          inc  VD9            ; ADD ONE TO LEFT DIGIT COUNTER FOR PRE-SIGN FORCE
          lda  VDA            ; * PRE-SIGN
          bita #$08           ; * FORCE AND
          bne  L8F96          ; * BRANCH IF SET
          dec  VD9            ; DECREMENT LEFT DIGIT - NO PRE-SIGN FORCE
          tstb                ; * CHECK LENGTH COUNTER AND BRANCH
          beq  L8F96          ; * IF END OF FORMAT STRING
          lda  ,x             ; GET NEXT FORMAT STRING CHARACTER
          suba #'-'           ; CHECK FOR MINUS SIGN
          beq  L8F8F          ; BRANCH IF MINUS SIGN
          cmpa #$FE           ; * WAS cmpa #('+')-('-')
          bne  L8F96          ; BRANCH IF NO PLUS SIGN
          lda  #$08           ; GET THE PRE-SIGN FORCE FLAG
L8F8F     ora  #$04           ; 'OR' IN POST-SIGN FORCE FLAG
          ora  VDA            ; 'OR' IN THE STATUS BYTE
          sta  VDA            ; SAVE THE STATUS BYTE
          decb                ; DECREMENT FORMAT STRING LENGTH

* EVALUATE NUMERIC ITEM-LIST
L8F96     jsr  GETCCH         ; GET CURRENT CHARACTER
          lbeq L8ED8          ; BRANCH IF END OF LINE
          stb  VD3            ; SAVE FORMAT STRING LENGTH WHEN FORMAT EVALUATION ENDED
          jsr  LB141          ; EVALUATE EXPRESSION
          lda  VD9            ; GET THE LEFT DIGIT COUNTER
          adda VD8            ; ADD IT TO THE RIGHT DIGIT COUNTER
          cmpa #17            ; *
          lbhi LB44A          ; *'FC' ERROR IF MORE THAN 16 DIGITS AND DECIMAL POiNT
          jsr  L8FE5          ; CONVERT ITEM-LIST TO FORMATTED ASCII STRING
          leax -1,x           ; MOVE BUFFER POINTER BACK ONE
          jsr  LB99C          ; DISPLAY THE FORMATTED STRING TO CONSOLE OUT
L8FB3     clr  VD7            ; RESET NEXT PRINT ITEM FLAG
          jsr  GETCCH         ; GET CURRENT INPUT CHARACTER
          beq  L8FC6          ; BRANCH IF END OF LINE
          sta  VD7            ; SAVE CURRENT CHARACTER (<>0) IN NEXT PRINT ITEM FLAG
          cmpa #';'           ; * CHECK FOR ; - ITEM-LIST SEPARATOR AND
          beq  L8FC4          ; * BRANCH IF SEMICOLON
          jsr  LB26D          ; SYNTAX CHECK FOR COMMA
          bra  L8FC6          ; PROCESS NEXT PRINT ITEM
L8FC4     jsr  GETNCH         ; GET NEXT INPUT CHARACTER
L8FC6     ldx  VD5            ; GET FORMAT STRING DESCRIPTOR ADDRESS
          ldb  ,x             ; GET LENGTH OF FORMAT STRING
          subb VD3            ; SUBTRACT AMOUNT OF FORMAT STRING LEFT AFTER LAST PRINT ITEM
          ldx  $02,x          ; *GET FORMAT STRING START ADDRESS AND ADVANCE
          abx                 ; *POINTER TO START OF UNUSED FORMAT STRING
          ldb  VD3            ; * GET AMOUNT OF UNUSED FORMAT STRING
          lbne L8EB9          ; * REINTERPRET FORMAT STRING FROM THAT POINT
          jmp  L8ED2          ; REINTERPRET FORMAT STRING FROM THE START IF ENTIRELY
*         USED ON LAST PRINT ITEM

* PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
L8FD8     pshs a              ; RESTORE ACCA AND RETURN
          lda  #'+'           ; GET ASCII PLUS SIGN
          tst  VDA            ; * CHECK THE STATUS BYTE AND
          beq  L8FE3          ; * RETURN IF = 0
          jsr  PUTCHR         ; SEND A CHARACTER TO CONSOLE OUT
L8FE3     puls a,pc           ; RETURN ACCA AND RETURN

* CONVERT ITEM-LIST TO DECIMAL ASCII STRING
L8FE5     ldu  #STRBUF+4      ; POINT U TO STRING BUFFER
          ldb  #SPACE         ; BLANK
          lda  VDA            ; * GET THE STATUS FLAG AND
          bita #$08           ; * CHECK FOR A PRE-SIGN FORCE
          beq  L8FF2          ; * BRANCH IF NO PRE-SIGN FORCE
          ldb  #'+'           ; PLUS SIGN
L8FF2     tst  FP0SGN         ; CHECK THE SIGN OF FPA0
          bpl  L8FFA          ; BRANCH IF POSITIVE
          clr  FP0SGN         ; FORCE FPA0 SIGN TO BE POSITIVE
          ldb  #'-'           ; MINUS SIGN
L8FFA     stb  ,u+            ; SAVE THE SIGN IN BUFFER
          ldb  #'0'            ; * PUT A ZERO INTO THE BUFFER
          stb  ,u+            ; *
          anda #$01           ; * CHECK THE EXPONENTIAL FORCE FLAG IN
          lbne L910D          ; * THE STATUS BYTE - BRANCH IF ACTIVE
          ldx  #LBDC0         ; POINT X TO FLOATING POINT 1E + 09
          jsr  LBCA0          ; COMPARE FPA0 TO (X)
          bmi  L9023          ; BRANCH IF FPA0 < 1E+09
          jsr  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
L9011     lda  ,x+            ; * ADVANCE POINTER TO END OF
          bne  L9011          ; * ASCII STRING (ZERO BYTE)
L9015     lda  ,-x            ; MOVE THE
          sta  $01,x          ; ENTIRE STRING
          cmpx #STRBUF+3      ; UP ONE
          bne  L9015          ; BYTE
          lda  #'%'           ; * INSERT A % SIGN AT START OF
          sta  ,x             ; * STRING - OVERFLOW ERROR
          rts

L9023     lda  FP0EXP         ; GET EXPONENT OF FPA0
          sta  V47            ; AND SAVE IT IN V74
          beq  L902C          ; BRANCH IF FPA0 = 0
          jsr  L91CD          ; CONVERT FPA0 TO NUMBER WITH 9 SIGNIFICANT
*              ; PLACES TO LEFT OF DECIMAL POINT
L902C     lda  V47            ; GET BASE 10 EXPONENT OFFSET
          lbmi L90B3          ; BRANCH IF FPA0 < 100,000,000
          nega                ; * CALCULATE THE NUMBER OF LEADING ZEROES TO INSERT -
          adda VD9            ; * SUBTRACT BASE 10 EXPONENT OFFSET AND 9 (FPA0 HAS
          suba #$09           ; * 9 PLACES TO LEFT OF EXPONENT) FROM LEFT DIGIT COUNTER
          jsr  L90EA          ; PUT ACCA ZEROES IN STRING BUFFER
          jsr  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
          jsr  L9202          ; CONVERT FPA0 TO DECIMAL ASCII IN THE STRING BUFFER
          lda  V47            ; * GET BASE 10 EXPONENT AND PUT THAT MANY
          jsr  L9281          ; * ZEROES IN STRING BUFFER - STOP AT DECIMAL POINT
          lda  V47            ; WASTED INSTRUCTION - SERVES NO PURPOSE
          jsr  L9249          ; CHECK FOR DECIMAL POINT
          lda  VD8            ; GET THE RIGHT DIGIT COUNTER
          bne  L9050          ; BRANCH IF RIGHT DIGlT COUNTER <> 0
          leau -1,u           ; * MOVE BUFFER POINTER BACK ONE - DELETE
*                             ; * DECIMAL POINT IF NO RIGHT DIGITS SPECiFIED
L9050     deca                ; SUBTRACT ONE (DECIMAL POINT)
          jsr  L90EA          ; PUT ACCA ZEROES INTO BUFFER (TRAILING ZEROES)
L9054     jsr  L9185          ; INSERT ASTERISK PADDING, FLOATING $, AND POST-SIGN
          tsta                ; WAS THERE A POST-SIGN?
          beq  L9060          ; NO
          cmpb #'*'           ; IS THE FIRST CHARACTER AN $?
          beq  L9060          ; YES
          stb  ,u+            ; STORE THE POST-SIGN
L9060     clr  ,u             ; CLEAR THE LAST CHARACTER IN THE BUFFER
*
* REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE
* STRING BUFFER TO THE LEFT OF THE DECIMAL POINT
          ldx  #STRBUF+3      ; POINT X TO THE START OF THE BUFFER
L9065     leax $01,x          ; MOVE BUFFER POINTER UP ONE
          stx  TEMPTR         ; SAVE BUFFER POINTER IN TEMPTR
          lda  VARPTR+1       ; * GET ADDRESS OF DECIMAL POINT IN BUFFER, SUBTRACT
          suba TEMPTR+1       ; * CURRENT POSITION AND SUBTRACT LEFT DIGIT COUNTER -
          suba VD9            ; * THE RESULT WILL BE ZERO WHEN TEMPTR+1 IS POINTING
*              ; * TO THE FIRST DIGIT OF THE FORMAT STRING
          beq  L90A9          ; RETURN IF NO DIGITS TO LEFT OF THE DECiMAL POINT
          lda  ,x             ; GET THE CURRENT BUFFER CHARACTER
          cmpa #SPACE         ; SPACE?
          beq  L9065          ; YES - ADVANCE POINTER
          cmpa #'*'           ; ASTERISK?
          beq  L9065          ; YES - ADVANCE POINTER
          clra                ; A ZERO ON THE STACK IS END OF DATA POINTER
L907C     pshs a              ; PUSH A CHARACTER ONTO THE STACK
          lda  ,x+            ; GET NEXT CHARACTER FROM BUFFER
          cmpa #'-'           ; MINUS SIGN?
          beq  L907C          ; YES
          cmpa #'+'           ; PLUS SIGN?
          beq  L907C          ; YES
          cmpa #'$'           ; DOLLAR SIGN?
          beq  L907C          ; YES
          cmpa #'0'            ; ZERO?
          bne  L909E          ; NO - ERROR
          lda  $01,x          ; GET CHARACTER FOLLOWING ZERO
          bsr  L90AA          ; CLEAR CARRY IF NUMERIC
          blo  L909E          ; BRANCH IF NOT A NUMERIC CHARACTER - ERROR
L9096     puls a              ; * PULL A CHARACTER OFF OF THE STACK
          sta  ,-x            ; * AND PUT IT BACK IN THE STRING BUFFER
          bne  L9096          ; * KEEP GOING UNTIL ZERO FLAG
          bra  L9065          ; KEEP CLEANING UP THE INPUT BUFFER
L909E     puls a              ;
          tsta                ; * THE STACK AND EXIT WHEN
          bne  L909E          ; * ZERO FLAG FOUND
          ldx  TEMPTR         ; GET THE STRING BUFFER START POINTER
          lda  #'%'           ; * PUT A % SIGN BEFORE THE ERROR POSITION TO
          sta  ,-x            ; * INDICATE AN ERROR
L90A9     rts
*
* CLEAR CARRY IF NUMERIC
L90AA     cmpa #'0'            ; ASCII ZERO
          blo  L90B2          ; RETURN IF ACCA < ASCII 0
          suba #$3A           ; *  #'9'+1
          suba #$C6           ; * #-('9'+1)  CARRY CLEAR IF NUMERIC
L90B2     rts
*
* PROCESS AN ITEM-LIST WHICH IS < 100,000,000
L90B3     lda  VD8            ; GET RIGHT DIGIT COUNTER
          beq  L90B8          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT OF DECIMAL PT
          deca                ; SUBTRACT ONE FOR DECIMAL POINT
L90B8     adda V47            ; *ADD THE BASE 10 EXPONENT OFFSET - ACCA CONTAINS THE
*         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO THE SPECIFIED
*         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMAL POINT
          bmi  L90BD          ; IF ACCA >= 0 THEN NO SHIFTS ARE REQUIRED
          clra                ; FORCE SHIFT COUNTER = 0
L90BD     pshs a              ; SAVE INITIAL SHIFT COUNTER ON THE STACK
L90BF     bpl  L90CB          ; EXIT ROUTINE IF POSITIVE
          pshs a              ; SAVE SHIFT COUNTER ON STACK
          jsr  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT ONE DIGIT TO RIGHT
          puls a              ; GET SHIFT COUNTER FROM THE STACK
          inca                ; BUMP SHIFT COUNTER UP BY ONE
          bra  L90BF          ; CHECK FOR FURTHER DIVISION
L90CB     lda  V47            ; * GET BASE 10 EXPONENT OFFSET, ADD INITIAL SHIFT COUNTER
          suba ,s+            ; * AND SAVE NEW BASE 10 EXPONENT OFFSET - BECAUSE
          sta  V47            ; * FPA0 WAS SHIFTED ABOVE
          adda #$09           ; * ADD NINE (SIGNIFICANT PLACES) AND BRANCH IF THERE ARE NO
          bmi  L90EE          ; * ZEROES TO THE LEFT OF THE DECIMAL POINT IN THIS PRINT ITEM
          lda  VD9            ; *DETERMINE HOW MANY FILLER ZEROES TO THE LEFT OF THE DECIMAL
          suba #$09           ; *POINT. GET THE NUMBER OF FORMAT PLACES TO LEFT OF DECIMAL
          suba V47            ; *POINT, SUBTRACT THE BASE 10 EXPONENT OFFSET AND THE CONstaNT 9
          bsr  L90EA          ; *(UNNORMALIZATION)-THEN OUTPUT THAT MANY ZEROES TO THE BUFFER
          jsr  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
          bra  L90FF          ; PROCESS THE REMAINDER OF THE PRINT ITEM
*
* PUT (ACCA+1) ASCII ZEROES IN BUFFER
L90E2     pshs a              ; SAVE ZERO COUNTER
          lda  #'0'            ; * INSERT A ZERO INTO
          sta  ,u+            ; * THE BUFFER
          puls a              ; RESTORE ZERO COUNTER

* PUT ACCA ASCII ZEROES INTO THE BUFFER
L90EA     deca                ; DECREMENT ZERO COUNTER
          bpl  L90E2          ; BRANCH IF NOT DONE
          rts

L90EE     lda  VD9            ; * GET THE LEFT DIGIT COUNTER AND PUT
          bsr  L90EA          ; * THAT MANY ZEROES IN THE STRiNG BUFFER
          jsr  L924D          ; PUT THE DECIMAL POINT IN THE STRING BUFFER
          lda  #-9            ; *DETERMINE HOW MANY FILLER ZEROES BETWEEN THE DECIMAL POINT
          suba V47            ; *AND SIGNIFICANT DATA. SUBTRACT BASE 10 EXPONENT FROM -9
          bsr  L90EA          ; *(UNNORMALIZATION) AND OUTPUT THAT MANY ZEROES TO BUFFER
          clr  V45            ; CLEAR THE DECIMAL POINT COUNTER - SUPPRESS THE DECIMAL POINT
          clr  VD7            ; CLEAR THE COMMA COUNTER - SUPPRESS COMMAS
L90FF     jsr  L9202          ; DECODE FPA0 INTO A DECIMAL ASCII STRING
          lda  VD8            ; GET THE RIGHT DIGIT COUNTER
          bne  L9108          ; BRANCH IF RIGHT DIGIT COUNTER <> 0
          ldu  VARPTR         ; RESET BUFFER PTR TO THE DECIMAL POINT IF NO DIGITS TO RIGHT
L9108     adda V47            ; *ADD BASE 10 EXPONENT - A POSITIVE ACCA WILL CAUSE THAT MANY
* *FILLER ZEROES TO BE OUTPUT ; TO THE RIGHT OF LAST SIGNIFICANT DATA
*         *SIGNIFICANT DATA
          jmp  L9050          ; INSERT LEADING ASTERISKS, FLOATING DOLLAR SIGN, ETC
*
* FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FORMAT
L910D     lda  FP0EXP         ; * GET EXPONENT OF FPA0 AND
          pshs a              ; * SAVE IT ON THE STACK
          beq  L9116          ; BRANCH IF FPA0 = 0
          jsr  L91CD          ; *CONVERT FPA0 INTO A NUMBER WITH 9 SIGNIFICANT
*         *DIGITS TO THE LEFT OF THE DECIMAL POINT
L9116     lda  VD8            ; GET THE RIGHT DIGIT COUNTER
          beq  L911B          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT
          deca                ; SUBTRACT ONE FOR THE DECIMAL POINT
L911B     adda VD9            ; ADD TO THE LEFT DIGIT COUNTER
          clr  STRBUF+3       ; CLEAR BUFFER BYTE AS TEMPORARY STORAGE LOCATION
          ldb  VDA            ; * GET THE STATUS BYTE FOR A
          andb #$04           ; * POST-BYTE FORCE; BRANCH IF
          bne  L9129          ; * A POST-BYTE FORCE
          com  STRBUF+3       ; TOGGLE BUFFER BYTE TO -1 IF NO POST-BYTE FORCE
L9129     adda STRBUF+3       ; SUBTRACT 1 IF NO POST BYTE FORCE
          suba #$09           ; *SUBTRACT 9 (DUE TO THE CONVERSION TO 9
*         *SIGNIFICANT DIGITS TO LEFT OF DECIMAL POINT)
          pshs a              ; * SAVE SHIFT COUNTER ON THE STACK - ACCA CONTAINS THE NUMBER
*         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE NUMBER OF
*         FORMATTED PLACES TO THE RIGHT OF THE DECIMAL POINT.
L9130     bpl  L913C          ; NO MORE SHIFTS WHEN ACCA >= 0
          pshs a              ; SAVE SHIFT COUNTER
          jsr  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT TO RIGHT ONE
          puls a              ; RESTORE THE SHIFT COUNTER
          inca                ; ADD 1 TO SHIFT COUNTER
          bra  L9130          ; CHECK FOR FURTHER SHIFTING (DIVISION)
L913C     lda  ,s             ; *GET THE INITIAL VALUE OF THE SHIFT COUNTER
          bmi  L9141          ; *AND BRANCH IF SHIFTING HAS TAKEN PLACE
          clra                ; RESET ACCA IF NO SHIFTING HAS TAKEN PLACE
L9141     nega                ; *CALCULATE THE POSITION OF THE DECIMAL POINT BY
          adda VD9            ; *NEGATING SHIFT COUNTER, ADDING THE LEFT DIGIT COUNTER
          inca                ; *PLUS ONE AND THE POST-BYTE POSlTION, IF USED
          adda STRBUF+3       ; *
          sta  V45            ; SAVE DECIMAL POINT COUNTER
          clr  VD7            ; CLEAR COMMA COUNTER - NO COMMAS INSERTED
          jsr  L9202          ; CONVERT FPA0 INTO ASCII DECIMAL STRING
          puls a              ; * GET THE INITIAL VALUE OF SHIFT COUNTER AND
          jsr  L9281          ; * INSERT THAT MANY ZEROES INTO THE BUFFER
          lda  VD8            ; *GET THE RIGHT DIGIT COUNTER AND BRANCH
          bne  L915A          ; *IF NOT ZERO
          leau -1,u           ; MOVE BUFFER POINTER BACK ONE

* CALCULATE VALUE OF EXPONENT AND PUT IN STRING BUFFER
L915A     ldb  ,s+            ; GET ORIGINAL EXPONENT OF FPA0
          beq  L9167          ; BRANCH IF EXPONENT = 0
          ldb  V47            ; GET BASE 10 EXPONENT
          addb #$09           ; ADD 9 FOR 9 SIGNIFICANT DIGIT CONVERSION
          subb VD9            ; SUBTRACT LEFT DIGIT COUNTER
          subb STRBUF+3       ; ADD ONE TO EXPONENT IF POST-SIGN FORCE
L9167     lda  #'+'           ; PLUS SIGN
          tstb                ; TEST EXPONENT
          bpl  L916F          ; BRANCH IF POSITIVE EXPONENT
          lda  #'-'           ; MINUS SIGN
          negb                ; CONVERT EXPONENT TO POSITIVE NUMBER
L916F     sta  $01,u          ; PUT SIGN OF EXPONENT IN STRING BUFFER
          lda  #'E'           ; * PUT AN 'E' (EXPONENTIATION FLAG) IN
          sta  ,u++           ; * BUFFER AND SKIP OVER THE SIGN
          lda  #$2F           ; * WAS lda #'0'-1
*CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACCA
L9177     inca                ; ADD ONE TO TENS DIGIT COUNTER
          subb #10            ; *SUBTRACT 10 FROM EXPONENT AND ADD ONE TO TENS
          bcc  L9177          ; * DIGIT IF NO CARRY. TENS DIGIT DONE IF THERE IS A CARRY
          addb #$3A           ; WAS addb #'9'+1
          std  ,u++           ; SAVE EXPONENT IN BUFFER
          clr  ,u             ; CLEAR FINAL BYTE IN BUFFER - PRINT TERMINATOR
          jmp  L9054          ; INSERT ASTERISK PADDING, FLOATING DOLLAR SIGN, ETC.

* INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN
L9185     ldx  #STRBUF+4      ; POINT X TO START OF PRINT ITEM BUFFER
          ldb  ,x             ; * GET SIGN BYTE OF ITEM-LIST BUFFER
          pshs b              ; * AND SAVE IT ON THE STACK
          lda  #SPACE         ; DEFAULT PAD WITH BLANKS
          ldb  VDA            ; * GET STATUS BYTE AND CHECK FOR
          bitb #$20           ; * ASTERISK LEFT PADDING
          puls b              ; GET SIGN BYTE AGAIN
          beq  L919E          ; BRANCH IF NO PADDING
          lda  #'*'           ; PAD WITH ASTERISK
          cmpb #SPACE         ; WAS THE FIRST BYTE A BLANK (POSITIVE)?
          bne  L919E          ; NO
          tfr  a,b            ; TRANSFER PAD CHARACTER TO ACCB
L919E     pshs b              ; SAVE FIRST CHARACTER ON STACK
L91A0     sta  ,x+            ; STORE PAD CHARACTER IN BUFFER
          ldb  ,x             ; GET NEXT CHARACTER IN BUFFER
          beq  L91B6          ; INSERT A ZERO IF END OF BUFFER
          cmpb #'E'           ; * CHECK FOR AN 'E' AND
          beq  L91B6          ; * PUT A ZERO BEFORE IT
          cmpb #'0'           ; * REPLACE LEADING ZEROES WITH
          beq  L91A0          ; * PAD CHARACTERS
          cmpb #','           ; * REPLACE LEADING COMMAS
          beq  L91A0          ; * WITH PAD CHARACTERS
          cmpb #'.'           ; * CHECK FOR DECIMAL POINT
          bne  L91BA          ; * AND DON'T PUT A ZERO BEFORE IT
L91B6     lda  #'0'           ; * REPLACE PREVIOUS CHARACTER
          sta  ,-x            ; * WITH A ZERO
L91BA     lda  VDA            ; * GET STATUS BYTE, CHECK
          bita #$10           ; * FOR FLOATING $
          beq  L91C4          ; * BRANCH IF NO FLOATING $
          ldb  #'$'           ; * STORE A $ IN
          stb  ,-x            ; * BUFFER
L91C4     anda #$04           ; CHECK PRE-SIGN FLAG
          puls b              ; GET SIGN CHARACTER
          bne  L91CC          ; RETURN IF POST-SIGN REQUIRED
          stb  ,-x            ; STORE FIRST CHARACTER
L91CC     rts
*
* CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN X 10**M.
* THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPONENT).
L91CD     pshs u              ; SAVE BUFFER POINTER
          clra                ; INITIAL EXPONENT OFFSET = 0
L91D0     sta  V47            ; SAVE EXPONENT OFFSET
          ldb  FP0EXP         ; GET EXPONENT OF FPA0
          cmpb #$80           ; * COMPARE TO EXPONENT OF .5
          bhi  L91E9          ; * AND BRANCH IF FPA0 > = 1.0

* IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1
          ldx  #LBDC0         ; POINT X TO FP NUMBER (1E+09)
          jsr  LBACA          ; MULTIPLY FPA0 BY 1E+09
          lda  V47            ; GET EXPONENT OFFSET
          suba #$09           ; SUBTRACT 9 (BECAUSE WE MULTIPLIED BY 1E+09 ABOVE)
          bra  L91D0          ; CHECK TO SEE IF > 1.0
L91E4     jsr  LBB82          ; DIVIDE FPA0 BY 10
          inc  V47            ; INCREMENT EXPONENT OFFSET
L91E9     ldx  #LBDBB         ; POINT X TO FP NUMBER (999,999,999)
          jsr  LBCA0          ; COMPARE FPA0 TO X
          bgt  L91E4          ; BRANCH IF FPA0 > 999,999,999
L91F1     ldx  #LBDB6         ; POINT X TO FP NUMBER (99,999,999.9)
          jsr  LBCA0          ; COMPARE FPA0 TO X
          bgt  L9200          ; RETURN IF 999,999,999 > FPA0 > 99,999,999.9
          jsr  LBB6A          ; MULTIPLY FPA0 BY 10
          dec  V47            ; DECREMENT EXPONENT OFFSET
          bra  L91F1          ; KEEP UNNORMALIZING
L9200     puls u,pc           ; RESTORE BUFFER POINTER AND RETURN
*
* CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT
* INTO A DECIMAL ASCII STRING IN THE BUFFER
L9202     pshs u              ; SAVE BUFFER POINTER
          jsr  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
          jsr  LBCC8          ; CONVERT FPA0 TO INTEGER FORMAT
          puls u              ; RESTORE BUFFER POINTER
*
* CONVERT FPA0 INTO A DECIMAL ASCII STRING
          ldx  #LBEC5         ; POINT X TO UNNORMALIZED POWERS OF 10
          ldb  #$80           ; INITIALIZE DIGIT COUNTER TO 0 + $80.
* BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
* IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSa, IT IS
* THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB
* IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURRING.
L9211     bsr  L9249          ; CHECK FOR COMMA INSERTION
L9213     lda  FPA0+3         ; * 'ADD' A POWER OF 10 MANTISSA TO FPA0.
          adda $03,x          ; * IF THE MANTISSA IS NEGATIVE, A SUBTRACTION
          sta  FPA0+3         ; * WILL BE WHAT REALLY TAKES PLACE.
          lda  FPA0+2         ; *
          adca $02,x          ; *
          sta  FPA0+2         ; *
          lda  FPA0+1         ; *
          adca $01,x          ; *
          sta  FPA0+1         ; *
          lda  FPA0           ; *
          adca ,x             ; *
          sta  FPA0           ; *
          incb                ; ADD ONE TO DIGIT COUNTER
          rorb                ; ROTATE CARRY INTO BIT 7
          rolb                ; * SET OVERFLOW FLAG - BRANCH IF CARRY SET AND
          bvc  L9213          ; * ADDING MANTISSA OR CARRY CLEAR AND SUBTRACTING MANTISSA
          bcc  L9235          ; BRANCH IF SUBTRACTING MANTISSA
          subb #10+1          ; WAS subb #10+1
          negb                ; * IF ADDING MANTISSA
L9235     addb #$2F           ; WAS addb #'0'-1
          leax $04,x          ; MOVE TO NEXT POWER OF 10 MANTISSA
          tfr  b,a            ; SAVE DIGIT IN ACCA
          anda #$7F           ; MASK OFF ADD/SUBTRACT FLAG (BIT 7)
          sta  ,u+            ; STORE DIGIT IN BUFFER
          comb                ; TOGGLE ADD/SUBTRACT FLAG
          andb #$80           ; MASK OFF EVERYTHING BUT ADD/SUB FLAG
          cmpx #LBEE9         ; COMPARE TO END OF UNNORMALIZED POWERS OF 10
          bne  L9211          ; BRANCH IF NOT DONE
          clr  ,u             ; PUT A ZERO AT END OF INTEGER

* DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA INSERTION
L9249     dec  V45            ; DECREMENT DECIMAL POINT COUNTER
          bne  L9256          ; NOT TIME FOR DECIMAL POINT
L924D     stu  VARPTR         ; SAVE BUFFER POINTER-POSITION OF THE DECIMAL POINT
          lda  #'.'           ; * STORE A DECIMAL
          sta  ,u+            ; * POINT IN THE OUTPUT BUFFER
          clr  VD7            ; * CLEAR COMMA COUNTER - NOW IT WILL TAKE 255
*                             ; * DECREMENTS BEFORE ANOTHER COMMA WILL BE INSERTED
          rts
L9256     dec  VD7            ; DECREMENT COMMA COUNTER
          bne  L9262          ; RETURN IF NOT TIME FOR COMMA
          lda  #$03           ; * RESET COMMA COUNTER TO 3; THREE
          sta  VD7            ; * DIGITS BETWEEN COMMAS
          lda  #','            ; * PUT A COMMA INTO
          sta  ,u+            ; * THE BUFFER
L9262     rts

* INITIALIZE DECIMAL POINT AND COMMA COUNTERS
L9263     lda  V47            ; GET THE BASE 10 EXPONENT OFFSET
          adda #10            ; * ADD 10 (FPA0 WAS 'NORMALIZED' TO 9 PLACES LEFT
          sta  V45            ; * OF DECIMAL POINT) - SAVE IN DECIMAL POINT COUNTER
          inca                ; ADD ONE FOR THE DECIMAL POINT
L926A     suba #$03           ; * DIVIDE DECIMAL POINT COUNTER BY 3; LEAVE
          bcc  L926A          ; * THE REMAINDER IN ACCA
          adda #$05           ; CONVERT REMAINDER INTO A NUMBER FROM 1-3
          sta  VD7            ; SAVE COMMA COUNTER
          lda  VDA            ; GET STATUS BYTE
          anda #$40           ; CHECK FOR COMMA FLAG
          bne  L927A          ; BRANCH IF COMMA FLAG ACTIVE
          sta  VD7            ; CLEAR COMMA COUNTER - 255 DIGITS OUTPUT BEFORE A COMMA
L927A     rts
*
* INSERT ACCA ZEROES INTO THE BUFFER
L927B     pshs a              ; SAVE ZEROES COUNTER
          bsr  L9249          ; CHECK FOR DECIMAL POINT
          puls a              ; RESTORE ZEROES COUNTER
L9281     deca                ; * DECREMENT ZEROES COUNTER AND
          bmi  L928E          ; * RETURN IF < 0
          pshs a              ; SAVE ZEROES COUNTER
          lda  #'0'            ; * PUT A ZERO INTO
          sta  ,u+            ; * THE BUFFER
          lda  ,s+            ; RESTORE THE ZEROES COUNTER
          bne  L927B          ; BRANCH IF NOT DONE
L928E     rts


* LINE
LINE      cmpa #TOK_INPUT     ; 'INPUT' TOKEN
          lbeq L89C0          ; GO DO 'LINE INPUT' COMMAND
          jmp  LB277          ; 'SYNTAX ERROR' IF NOT "LINE INPUT"
		  

* END OF EXTENDED BASIC

* DIR COMMAND				; DIR "DRIVE NUMBER"
DIR 	  jsr LD24F 		; SCAN DRIVE NUMBER FROM INPUT LINE		  
		  ;jsr LC79D 		; GET FAT FOR THIS DRIVE
		  ;jsr LB958 		; PRINT CARRIAGE RETURN TO CONSOLE OUT
		  ;ldd #$1102 		; * GET TRACK 17 AND
		  ;sta DCTRK 		; * READ OP CODE AND
		  ;stb DCOPC 		; * SAVE IN DSKCON VARIABLES
		  ;ldb #$03 		; START WITH SECTOR 3 (FIRST DIRECTORY SECTOR)
		  jsr DSK_FDIR		; CALL THE DISK FILE LISTING FUNCTION
		  rts

* GET DRIVE NUMBER FROM BASIC - USE THE DEFAULT DRIVE IF NONE GIVEN
LD24F	  ;ldb				; DEFDRV	GET DEFAULT DRIVE NUMBER		
		  jsr	GETCCH		; GET NEXT INPUT CHAR (TO MAINTAIN BACKWARD COMPATIBILITY)
		  clrb				; ONLY DRIVE 0 SUPPORTED
		  ;beq LD25F			; USE DEFAULT DRIVE NUMBER IF NONE GIVEN
LD256	  ;jsr EVALEXPB		; EVALUATE EXPRESSION
		  ;cmpb #$03		; 4 DRIVES MAX
		  ;lbhi LA61F		; 'DEVICE NUMBER ERROR' IF > 3
LD25F	  ;stb DCDRV		; STORE IN DSKCON VARIABLE
		  rts

FILELENGTH    equ  13		; FORMAT 8.3 + NULL GIVES 13 BYTES

* KILL COMMAND  ; FROM DISK BASIC UNRAVELLED II
KILL	  leas -FILELENGTH,s; ALLOCATE FILENAME STORAGE
		  jsr GET_FN
		  jsr DSK_FDEL		; CALL THE DISK FILE DELETION FUNCTION
		  leas FILELENGTH,s	; FREE FILENAME STACK		  
		  rts

; KILL	  ldb #FILELENGTH
		  ; pshs b			; SAVE FILE LENGTH POSITION
; LC6E9_	  jsr  GETNCH		; GET THE CHARS  
		  ; puls b			; RESTORE FILE LENGTH POSITION
		  ; cmpa #'"'			; UNTIL THE STRING ENDS WITH "
		  ; beq LC6EA_
		  ; pshs a			; THE FILENAME STRING ON THE STACK
		  ; decb
		  ; beq LC6EE_
		  ; pshs b		  	; RE-SAVE FILE LENGTH POSITION
		  ; bra LC6E9_
; LC6EA_	  clra
		  ; pshs a			; FILL FILENAME STRING WITH NULL
		  ; decb
		  ; bne LC6EA_
; LC6EE_	  jsr DSK_FDEL		; CALL THE DISK FILE DELETION FUNCTION
		  ; leas FILELENGTH,s	; FREE FILENAME STACK		  
		  ; rts
		  
* LOAD COMMAND ; FROM DISK BASIC UNRAVELLED II
LOAD 	  leas -FILELENGTH,s; ALLOCATE FILENAME STORAGE
		  jsr GET_FN
		  jsr DSK_FRD		; CALL THE DISK FILE READING FUNCTION
		  leas FILELENGTH,s	; FREE FILENAME STACK		  
		  rts

*LOAD	  cmpa #'M'			; "LOADM" COMMAND
*		  lbeq LCFC1		; *BRANCH IF LOADM
*		 clra 				; RUN	FLAG = ZERO (DON'T RUN)
*LCA4F	 clrb				; CLEAR	MERGE FLAG
*LCA50	 sta	DRUNFL	RUN FLAG (0 = DON'T RUN, 2 = RUN)
*		 stb	DMRGFL	MERGE FLAG (0 = NO MERGE, $FF = MERGE)
*		  bsr	LCA33	GO GET FILENAME, ETC. FROM BASIC
*		  jsr	GETCCH	GET CURRENT INPUT CHAR
*		  beq	LCA6C	BRANCH IF END OF LINE
*		  jsr	SYNCOMMA	SYNTAX CHECK FOR COMMA
		  rts

* SAVE COMMAND
SAVE 	  leas -FILELENGTH,s; ALLOCATE FILENAME STORAGE
		  jsr GET_FN
		  jsr DSK_FWR		; CALL THE DISK FILE WRITING FUNCTION
		  leas FILELENGTH,s	; FREE FILENAME STACK
		  leas 2,s          ; PURGE RETURN ADDRESS FROM THE STACK		  
		  jmp  LAC73        ; RETURN TO BASIC'S MAIN INPUT LOOP
		  
* SAVE COMMAND ; FROM DISK BASIC UNRAVELLED II
*SAVE	cmpa	#'M	*
;	lbeq	LCF68	*BRANCH IF SAVEM
;	bsr	LCA33	GO GET FILENAME, ETC. FROM BASIC
;	ldx	ZERO	ZERO OUT X REG
;	stx	DFLTYP	SET FILE TYPE AND ASCII FLAG TO ZERO
;	jsr	GETCCH	GET CURRENT INPUT CHARACTER FROM BASIC
;	beq	LCA12	BRANCH IF END OF LINE
;	jsr	SYNCOMMA	SYNTAX CHECK FOR COMMA
;	ldb	#'A		*ASCII FILE?
;	jsr	>LB26F	*SYNTAX CHECK ON CONTENTS OF ACCB
;	bne	LC9DF	RETURN IF NO MORE CHARACTERS ON LINE
;	COM	DASCFL	SET CRUNCHED/ASCII FLAG TO ASCII
;	bsr	LCA04	OPEN A SEQUENTIAL FILE FOR OUTPUT
;	clra		SET	ZERO FLAG - CAUSE ENTIRE FILE TO BE LISTED
;	jmp	LIST	'LIST' THE FILE TO CONSOLE OUT


GET_FN	  pshs u
		  leau 4,s ; +4 BYTES FOR RETURN ADDR + U
		  ldb #FILELENGTH
		  pshs u,b			; SAVE FILE LENGTH POSITION
LC6E9	  jsr  GETNCH		; GET THE CHARS  
		  puls b,u			; RESTORE FILE LENGTH POSITION
		  cmpa #'"'			; UNTIL THE STRING ENDS WITH "
		  beq LC6EA
		  sta ,u+			; THE FILENAME STRING ON THE STACK
		  decb
		  lbeq LC6EA
		  pshs u,b		  	; RE-SAVE FILE LENGTH POSITION
		  bra LC6E9
LC6EA	  clra
		  sta ,u+			; FILL FILENAME STRING WITH NULL
		  decb
		  bne LC6EA
		  jsr  GETNCH		; purge the command
		  puls u
		  rts
		    
*************************CALLING FAT32 FUNCTIONS ****************************************		  
* Generated code from C and optimized afterward
* Note for BASIC ASM -> C : the U, X and Y registers needs to be preserved. Set Y to GV stack.
*****************************************************************************************

* DSK_FDIR()
* {
* 	fileInfo fileList; //18 bytes
* 	
* 	while(FILE_List(&fileList) != END_OF_FILE_LIST) {
DSK_FDIR		
	pshs 	u,x,y
	leau 	,s
	leas -18,s				; alloc 18 bytes
	lbsr    initDISK
	lbne    FDIR_2			; return when failed
FDIR_3	  
	leax -18,u
	pshs 	x
	lbsr	FILE_Lis
	leas 2,s		
	subd #$9
	lbeq 	FDIR_2
* 		PUTCHR('\r');
	lda	#$d
	lbsr	PUTCHR	
* 		if(fileList.FI_Attr == ATTR_VOLUME_ID) {
	ldb	-14,u
	cmpb	#$8
	bne	FDIR_4
* 		L85B4("VOLUME NAME IS ");
	leax	FDIR_5_,pc
	bra	FDIR_5
FDIR_5_
	fcb	$56, $4f, $4c, $55, $4d, $45, $20, $4e
	fcb	$41, $4d, $45, $20, $49, $53, $20, $0
FDIR_5
	lbsr	L85B4
* 		}
* 		L85B4(fileList.FI_Name); PUTCHR(' ');
FDIR_4
	leax -13,u
	jsr 	L85B4			; PRINT STRING TO THE SCREEN
	lda #SPACE
	lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN)
* 		if((fileList.FI_Attr != ATTR_VOLUME_ID) && (fileList.FI_Attr != ATTR_DIRECTORY)) {
	ldb	-14,u
	cmpb	#$8
	beq		FDIR_6
	ldb	-14,u
	cmpb	#$10
	beq		FDIR_6	
* 			if(fileList.FI_Size.h != 0) {
	ldd	-18,u
	beq		FDIR_7
* 				if(fileList.FI_Size.h > 0xf) {
	cmpd	#$f
	lbls	FDIR_8
* 					LBDCC(fileList.FI_Size.h >> 4); PUTCHR(' '); PUTCHR('M');
	lsra
	rorb
	lsra
	rorb
	lsra
	rorb
	lsra
	rorb
	pshs	u
	lbsr 	LBDCC			; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN	
	puls	u
	lda #SPACE
	lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN)
	lda	#'M'
	lbsr	PUTCHR	
* 				}
* 				else {
	lbra	FDIR_9
FDIR_8
* 					reg = ((fileList.FI_Size.h & 0xf) << 8) | (fileList.FI_Size.l >> 8);
	ldd	-18,u
	andb	#$f
	tfr b,a
	ldb	-16,u	
* 					reg = reg >> 2;
	lsra
	rorb
	lsra
	rorb	
* 					LBDCC(i);  PUTCHR(' '); PUTCHR('K');					
	pshs	u
	lbsr 	LBDCC			; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN	
	puls	u
	lda #SPACE
	lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN)
	lda	#'K'
	lbsr	PUTCHR	
* 				}
* 			}
FDIR_9
* 			else {
	lbra	FDIR_10
FDIR_7
* 				LBDCC(fileList.FI_Size.l); PUTCHR(' ');
	ldd	-16,u
	pshs	u
	lbsr 	LBDCC			; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN	
	puls	u
	lda #SPACE
	lbsr	PUTCHR         	; SEND TO CONSOLE OUT (SCREEN)
* 			}
* 			L85B4("byte(s)");
FDIR_10
	leax	FDIR_11_,pc
	bra	FDIR_11
FDIR_11_
	fcb	$62, $79, $74, $65, $28, $73, $29, $0
FDIR_11
	pshs	x
	lbsr	L85B4
	leas	2,s
* 		}
* 	}
FDIR_6
* }
	lbra	FDIR_3
FDIR_2
	leas	,u			; free allocated bytes
	puls	u,x,y,pc

DSK_FDEL 
		  pshs u,x,y
		  leau 	,s
		  lbsr initDISK
		  bne  DSK_FDL1				; return when failed
		  		  
* 	returnStatus = FILE_Delete(ptr);		  
		  leax 8,u	; +8 BYTES (RETURN ADDR, U, X, Y)
		  pshs	x
		  lbsr	FILE_Del
		  leas	2,s
DSK_FDL1  puls	u,x,y,pc

DSK_FRD   pshs  u,x,y
		  leau 	,s
		  lbsr  initDISK		  
		  lbne  DSK_FRD1			; return when failed
		  
* 	unsigned char returnStatus; //1 byte
		  leas	-1,s		; alloc 1 byte
* 	srcFilePtr = FILE_Open(ptr, READ, &returnStatus);
	 	  leax	-1,u
		  pshs	x
		  clra
		  clrb
		  pshs	d		  
		  leax  8,u			; +8 BYTES (RETURN ADDR, U, X, Y)
		  pshs	x
		  lbsr	FILE_Ope	; file pointer in ACCD
		  leas	6,s		  	; CCR unchanged	
* 	if(srcFilePtr != 0)	{
		  beq   DSK_FRD1
		  std	F_PTR		; let the ConsoleIn pull the file content
* 	}
DSK_FRD1  leas	,u			; free allocated bytes
		  puls	u,x,y,pc


DSK_FWR   pshs  u,x,y	  
		  leau 	,s
		  lbsr  initDISK
		  lbne  FWR_20				; return when failed
		  
* 	fileConfig_st *srcFilePtr; //2 bytes
* 	unsigned char returnStatus; //1 byte
		  leas	-3,s	; alloc 3 bytes
* 	srcFilePtr = FILE_Open(ptr, WRITE, &returnStatus);
		  leax	-3,u
		  pshs	x
		  ldd	#$2
		  pshs	d
		  leax 8,u	; +8 BYTES (RETURN ADDR, U, X, Y)		  
		  pshs	x
		  lbsr	FILE_Ope
		  leas	6,s
		  std	-2,u
		  
* 	if(srcFilePtr == 0)	{
		  ldd	-2,u
		  bne	FWR_19
* 		//print_DebugMsg("\nFile Opening Failed!"); HEXBYTE2(returnStatus); 
		  lbra	FWR_20
* 	}
* 	else {		  
FWR_19
*      send BAS program to the file
		  ldd	-2,u
		  std	F_PTR
		  inc	DEVNUM
		  pshs  u,y			; save U,Y overwritten in LIST routine
		  clra				; SET	ZERO FLAG - CAUSE ENTIRE FILE TO BE LISTED
		  jsr	LIST		; Note for C -> BASIC ASM : the U and Y registers need to be preserved. The C has no persistance in D and X.
		  puls  u,y
		  clr	DEVNUM
		  clr	F_PTR
		  clr	F_PTR+2
		  
* 		FILE_PutCh(srcFilePtr,EOF);
		  ldd	#$1a
		  pshs	d
		  ldd	-2,u
		  pshs	d
		  lbsr	FILE_Put
		  leas	4,s
* 		FILE_Close(srcFilePtr);
		  ldd	-2,u
		  pshs	d
		  lbsr	FILE_Clo
		  leas	2,s
* 	}
* }
FWR_20		  
		  leas	,u			; free allocated bytes
		  puls	u,x,y,pc		  
					

* initDISK() {
* 	unsigned char returnStatus, sdcardType; //2 bytes  -1,u -2,u
initDISK
	pshs	u,x,y
	leau	,s
	leas	-2,s	
* 	
* 	setPins();
	lbsr	setPins
* 	
* 	returnStatus = SD_Init(&sdcardType);		
	leax	-2,u
	pshs	x
	lbsr	SD_Init
	leas	2,s
	stb	-1,u
* 
* 	if(returnStatus != INIT_SUCCESSFUL) {
	ldb	-1,u
	lbeq	init_8
* 		if(returnStatus == NOT_DETECTED)	print_DebugMsg("SD card not detected!\n");
	cmpb	#$1
	bne		init_9
	leax	init_10_,pc
	bra	init_10
init_10_
	fcb	$53, $44, $20, $63, $61, $72, $64, $20
	fcb	$6e, $6f, $74, $20, $64, $65, $74, $65
	fcb	$63, $74, $65, $64, $21, $a, $0
init_10
	pshs	x
	lbsr	print_De
	leas	2,s
* 		if(returnStatus == INIT_FAILED) print_DebugMsg("Card Initialization failed!\n");
init_9
	ldb	-1,u
	cmpb	#$2
	bne		init_15
	leax	init_12_,pc
	bra	init_12
init_12_
	fcb	$43, $61, $72, $64, $20, $49, $6e, $69
	fcb	$74, $69, $61, $6c, $69, $7a, $61, $74
	fcb	$69, $6f, $6e, $20, $66, $61, $69, $6c
	fcb	$65, $64, $21, $a, $0
init_12
	pshs	x
	lbsr	print_De
	leas	2,s
* 	}
    bne		init_15
* 	else {		
init_8
* 		returnStatus = getBootSectorData (); //read boot sector and keep necessary data in global variables
	lbsr	getBootS
	stb	-1,u
* 		if(returnStatus == FAT_INVALID) print_DebugMsg("Invalid FAT file system!\n");
	cmpb #$3
	bne		init_15
	leax	init_16_,pc
	bra	init_16
init_16_
	fcb	$49, $6e, $76, $61, $6c, $69, $64, $20
	fcb	$46, $41, $54, $20, $66, $69, $6c, $65
	fcb	$20, $73, $79, $73, $74, $65, $6d, $21
	fcb	$a, $0
init_16
	pshs	x
	lbsr	print_De
	leas	2,s
* 	}    
init_15
	ldb	-1,u
	clra
* }
	leas	,u			; free allocated bytes
	puls	y,x,u,pc
		  
* END OF DISK BASIC

