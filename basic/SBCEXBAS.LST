0001                         ************************************************************************
0002                         ;
0003                         ; Microsoft Color Computer Basic
0004                         
0005                         
0006 0008                    BS        EQU  $8             ; BACKSPACE CODE
0007 000a                    LF        EQU  $A             ; LINE FEED CODE
0008 000d                    CR        EQU  $D             ; ENTER CODE
0009 001b                    ESC       EQU  $1B            ; ESCAPE CODE
0010 0020                    SPACE     EQU  $20            ; SPACE (BLANK) CODE
0011 003a                    STKBUF    EQU  58             ; STACK BUFFER ROOM
0012 00fa                    LBUFMX    EQU  250            ; MAX NUMBER OF CHARS IN A BASIC LINE
0013 00fa                    MAXLIN    EQU  $FA            ; MAXIMUM MS BYTE OF LINE NUMBER
0014                         * PSEUDO OPS
0015 0021                    SKP1      EQU  $21            ; OP CODE OF BRN - SKIP ONE BYTE
0016 008c                    SKP2      EQU  $8C            ; OP CODE OF CMPX # - SKIP TWO BYTES
0017 0086                    SKP1LD    EQU  $86            ; OP CODE OF LDA # - SKIP THE NEXT BYTE
0018                         *                             ; AND LOAD THE VALUE OF THAT BYTE INTO ACCA - THIS
0019                         *                             ; IS USUALLY USED TO LOAD ACCA WITH A NON ZERO VALUE
0020 0000                              ORG  0
0021 0000                    ENDFLG    RMB  1              ; STOP/END FLAG: POSITIVE=STOP, NEG=END
0022 0001                    CHARAC    RMB  1              ; TERMINATOR FLAG 1
0023 0002                    ENDCHR    RMB  1              ; TERMINATOR FLAG 2
0024 0003                    TMPLOC    RMB  1              ; SCRATCH VARIABLE
0025 0004                    IFCTR     RMB  1              ; IF COUNTER - HOW MANY IF STATEMENTS IN A LINE
0026 0005                    DIMFLG    RMB  1              ; *DV* ARRAY FLAG 0=EVALUATE, 1=DIMENSIONING
0027 0006                    VALTYP    RMB  1              ; *DV* *PV TYPE FLAG: 0=NUMERIC, $FF=STRING
0028 0007                    GARBFL    RMB  1              ; *TV STRING SPACE HOUSEKEEPING FLAG
0029 0008                    ARYDIS    RMB  1              ; DISABLE ARRAY SEARCH: 00=ALLOW SEARCH
0030 0009                    INPFLG    RMB  1              ; *TV INPUT FLAG: READ=0, INPUT<>0
0031 000a                    RELFLG    RMB  1              ; *TV RELATIONAL OPERATOR FLAG
0032 000b                    TEMPPT    RMB  2              ; *PV TEMPORARY STRING STACK POINTER
0033 000d                    LASTPT    RMB  2              ; *PV ADDR OF LAST USED STRING STACK ADDRESS
0034 000f                    TEMPTR    RMB  2              ; TEMPORARY POINTER
0035 0011                    TMPTR1    RMB  2              ; TEMPORARY DESCRIPTOR STORAGE (STACK SEARCH)
0036 0013                    FPA2      RMB  4              ; FLOATING POINT ACCUMULATOR #2 MANTISSA
0037 0017                    BOTSTK    RMB  2              ; BOTTOM OF STACK AT LAST CHECK
0038 0019                    TXTTAB    RMB  2              ; *PV BEGINNING OF BASIC PROGRAM
0039 001b                    VARTAB    RMB  2              ; *PV START OF VARIABLES
0040 001d                    ARYTAB    RMB  2              ; *PV START OF ARRAYS
0041 001f                    ARYEND    RMB  2              ; *PV END OF ARRAYS (+1)
0042 0021                    FRETOP    RMB  2              ; *PV START OF STRING STORAGE (TOP OF FREE RAM)
0043 0023                    STRTAB    RMB  2              ; *PV START OF STRING VARIABLES
0044 0025                    FRESPC    RMB  2              ; UTILITY STRING POINTER
0045 0027                    MEMSIZ    RMB  2              ; *PV TOP OF STRING SPACE
0046 0029                    OLDTXT    RMB  2              ; SAVED LINE NUMBER DURING A "STOP"
0047 002b                    BINVAL    RMB  2              ; BINARY VALUE OF A CONVERTED LINE NUMBER
0048 002d                    OLDPTR    RMB  2              ; SAVED INPUT PTR DURING A "STOP"
0049 002f                    TINPTR    RMB  2              ; TEMPORARY INPUT POINTER STORAGE
0050 0031                    DATTXT    RMB  2              ; *PV 'DATA' STATEMENT LINE NUMBER POINTER
0051 0033                    DATPTR    RMB  2              ; *PV 'DATA' STATEMENT ADDRESS POINTER
0052 0035                    DATTMP    RMB  2              ; DATA POINTER FOR 'INPUT' & 'READ'
0053 0037                    VARNAM    RMB  2              ; *TV TEMP STORAGE FOR A VARIABLE NAME
0054 0039                    VARPTR    RMB  2              ; *TV POINTER TO A VARIABLE DESCRIPTOR
0055 003b                    VARDES    RMB  2              ; TEMP POINTER TO A VARIABLE DESCRIPTOR
0056 003d                    RELPTR    RMB  2              ; POINTER TO RELATIONAL OPERATOR PROCESSING ROUTINE
0057 003f                    TRELFL    RMB  1              ; TEMPORARY RELATIONAL OPERATOR FLAG BYTE
0058                         * FLOATING POINT ACCUMULATORS #3,4 & 5 ARE MOSTLY
0059                         * USED AS SCRATCH PAD VARIABLES.
0060                         ** FLOATING POINT ACCUMULATOR #3 :PACKED: ($40-$44)
0061 0040                    V40       RMB  1
0062 0041                    V41       RMB  1
0063 0042                    V42       RMB  1
0064 0043                    V43       RMB  1
0065 0044                    V44       RMB  1
0066                         ** FLOATING POINT ACCUMULATOR #4 :PACKED: ($45-$49)
0067 0045                    V45       RMB  1
0068 0046                    V46       RMB  1
0069 0047                    V47       RMB  1
0070 0048                    V48       RMB  2
0071                         ** FLOATING POINT ACCUMULATOR #5 :PACKED: ($4A-$4E)
0072 004a                    V4A       RMB  1
0073 004b                    V4B       RMB  2
0074 004d                    V4D       RMB  2
0075                         ** FLOATING POINT ACCUMULATOR #0
0076 004f                    FP0EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 EXPONENT
0077 0050                    FPA0      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #0 MANTISSA
0078 0054                    FP0SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #0 SIGN
0079 0055                    COEFCT    RMB  1              ; POLYNOMIAL COEFFICIENT COUNTER
0080 0056                    STRDES    RMB  5              ; TEMPORARY STRING DESCRIPTOR
0081 005b                    FPCARY    RMB  1              ; FLOATING POINT CARRY BYTE
0082                         ** FLOATING POINT ACCUMULATOR #1
0083 005c                    FP1EXP    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 EXPONENT
0084 005d                    FPA1      RMB  4              ; *PV FLOATING POINT ACCUMULATOR #1 MANTISSA
0085 0061                    FP1SGN    RMB  1              ; *PV FLOATING POINT ACCUMULATOR #1 SIGN
0086 0062                    RESSGN    RMB  1              ; SIGN OF RESULT OF FLOATING POINT OPERATION
0087 0063                    FPSBYT    RMB  1              ; FLOATING POINT SUB BYTE (FIFTH BYTE)
0088 0064                    COEFPT    RMB  2              ; POLYNOMIAL COEFFICIENT POINTER
0089 0066                    LSTTXT    RMB  2              ; CURRENT LINE POINTER DURING LIST
0090 0068                    CURLIN    RMB  2              ; *PV CURRENT LINE # OF BASIC PROGRAM, $FFFF = DIRECT
0091 006a                    DEVCFW    RMB  1              ; *TV TAB FIELD WIDTH
0092 006b                    DEVLCF    RMB  1              ; *TV TAB ZONE
0093 006c                    DEVPOS    RMB  1              ; *TV PRINT POSITION
0094 006d                    DEVWID    RMB  1              ; *TV PRINT WIDTH
0095 006e                    BasicSavReg_S RMB 2
0096 0070                    TOPRAM    RMB  2              ; *PV TOP OF RAM
0097 0072                    IKEYIM    RMB  1              ; *TV INKEY$ RAM IMAGE
0098 0073                    ZERO      RMB  2              ; *PV DUMMY - THESE TWO BYTES ARE ALWAYS ZERO
0099                         * THE FOLLOWING BYTES ARE MOVED DOWN FROM ROM
0100 0075                    LPTCFW    RMB  1              ; 16
0101 0076                    LPTLCF    RMB  1              ; 112
0102 0077                    LPTWID    RMB  1              ; 132
0103 0078                    LPTPOS    RMB  1              ; 0
0104 0079                    EXECJP    RMB  2              ; LB4AA
0105                         
0106                         * THIS ROUTINE PICKS UP THE NEXT INPUT CHARACTER FROM
0107                         * BASIC. THE ADDRESS OF THE NEXT BASIC BYTE TO BE
0108                         * INTERPRETED IS STORED AT CHARAD.
0109 007b 0c 83              GETNCH    INC  <CHARAD+1      ; *PV INCREMENT LS BYTE OF INPUT POINTER
0110 007d 26 02                        BNE  GETCCH         ; *PV BRANCH IF NOT ZERO (NO CARRY)
0111 007f 0c 82                        INC  <CHARAD        ; *PV INCREMENT MS BYTE OF INPUT POINTER
0112 0081 b6                 GETCCH    FCB  $B6            ; *PV OP CODE OF LDA EXTENDED
0113 0082                    CHARAD    RMB  2              ; *PV THESE 2 BYTES CONTAIN ADDRESS OF THE CURRENT
0114                         *         *    CHARACTER WHICH THE BASIC INTERPRETER IS
0115                         *         *    PROCESSING
0116 0084 7e 81 f9                     JMP  BROMHK         ; JUMP BACK INTO THE BASIC RUM
0117                         
0118 0087                    VAB       RMB  1              ; = LOW ORDER FOUR BYTES OF THE PRODUCT
0119 0088                    VAC       RMB  1              ; = OF A FLOATING POINT MULTIPLICATION
0120 0089                    VAD       RMB  1              ; = THESE BYTES ARE USE AS RANDOM DATA
0121 008a                    VAE       RMB  1              ; = BY THE RND STATEMENT
0122                         
0123                         * EXTENDED BASIC VARIABLES
0124 008b                    TRCFLG    RMB  1              ; *PV TRACE FLAG 0=OFF ELSE=ON
0125 008c                    USRADR    RMB  2              ; *PV ADDRESS OF THE START OF USR VECTORS
0126                         
0127                         * EXTENDED BASIC SCRATCH PAD VARIABLES
0128 008e                    VCF       RMB  2
0129 0090                    VD1       RMB  2
0130 0092                    VD3       RMB  2
0131 0094                    VD5       RMB  2
0132 0096                    VD7       RMB  1
0133 0097                    VD8       RMB  1
0134 0098                    VD9       RMB  1
0135 0099                    VDA       RMB  1
0136 009a                    USRJMP    RMB  3              ; JUMP ADDRESS FOR BASIC'S USR FUNCTION
0137 009d                    RVSEED    RMB  1              ; * FLOATING POINT RANDOM NUMBER SEED EXPONENT
0138 009e                              RMB  4              ; * MANTISSA: INITIALLY SET TO $804FC75259
0139                         
0140                         **** USR FUNCTION VECTOR ADDRESSES (EX BASIC ONLY)
0141 00a2                    USR0      RMB  2              ; USR 0 VECTOR
0142 00a4                              RMB  2              ; USR 1
0143 00a6                              RMB  2              ; USR 2
0144 00a8                              RMB  2              ; USR 3
0145 00aa                              RMB  2              ; USR 4
0146 00ac                              RMB  2              ; USR 5
0147 00ae                              RMB  2              ; USR 6
0148 00b0                              RMB  2              ; USR 7
0149 00b2                              RMB  2              ; USR 8
0150 00b4                              RMB  2              ; USR 9
0151                         
0152 00b6                    STRSTK    RMB  8*5            ; STRING DESCRIPTOR STACK
0153 00de                    LINHDR    RMB  2              ; LINE INPUT BUFFER HEADER
0154 00e0                    LINBUF    RMB  LBUFMX+1       ; BASIC LINE INPUT BUFFER
0155 01db                    STRBUF    RMB  41             ; STRING BUFFER
0156                         
0157 0204                    PROGST    RMB  1              ; START OF PROGRAM SPACE
0158                         
0159                         ; external definition
0160 7eff                    BasicRAMend			EQU	$7eff	; RAM section reserved for BASIC 0-$7eff
0161 7ff0                    BasicCallBack		EQU	$7ff0
0162                         
0163 f000                    APLgetChar			EQU $f000
0164 f003                    APLsendChar			EQU $f003
0165 f00f                    APLcurBlinking	    EQU $f00f
0166 f012                    APLcurOff		    EQU $f012
0167 f015                    APLclearscreen	    EQU $f015
0168 f01c                    APLsound	    	EQU $f01c
0169 f02b                    APLsetXY    		EQU $f02b
0170                         
0171 8000                              ORG  $8000
0172                         
0173                         * JUMP TO BASIC COLD START AT START OF ROM FOR CONVENIENCE          
0174 8000 1a 50              		  ORCC #%01010000	  ; ensure init in case of software reset (no interrupt)
0175 8002 4f                 		  CLRA
0176 8003 1f 8b              		  TFR  A,DP
0177 8005 7e 80 48           		  JMP  RESVEC
0178                         
0179                         ; context switching to let run BASIC in parallel
0180 8008 34 7f              EXITBAS	  PSHS D,X,Y,U,CC,DP
0181 800a 10 df 6e           		  STS  BasicSavReg_S
0182 800d be 7f f0           		  LDX  BasicCallBack
0183 8010 10 8e 80 1a        		  LDY  #ENTRYBAS
0184 8014 10 bf 7f f0        		  STY  BasicCallBack
0185 8018 6e 84              		  JMP  ,X			  ; EXIT BASIC
0186 801a 10 de 6e           ENTRYBAS  LDS  BasicSavReg_S  ; ENTRY BASIC
0187 801d 35 ff              		  PULS D,X,Y,U,CC,DP,PC
0188                         
0189                         * CONSOLE IN
0190 801f 8d 03              LA171     BSR  KEYIN          ; GET A CHARACTER FROM CONSOLE IN          
0191 8021 27 fc              		  BEQ  LA171          ; LOOP IF NO KEY DOWN
0192 8023 39                           RTS
0193                         
0194                         *
0195                         * THIS ROUTINE GETS A KEYSTROKE FROM THE KEYBOARD IF A KEY
0196                         * IS DOWN. IT RETURNS ZERO TRUE IF THERE WAS NO KEY DOWN.
0197                         *
0198                         *
0199                         LA1C1
0200 8024 8d e2              KEYIN     BSR  EXITBAS
0201 8026 34 04              		  PSHS B
0202 8028 17 6f d5           		  LBSR APLgetChar
0203 802b 1f 98              		  TFR  B,A
0204 802d 84 7f              		  ANDA #$7F
0205 802f 35 84                        PULS B,PC
0206                         		  
0207                         
0208                         * CONSOLE OUT
0209 8031 34 06              PUTCHR    PSHS D              ; PRESERVE D
0210 8033 17 6f cd                     LBSR  APLsendChar          
0211 8036 81 0d              		  CMPA #CR            ; IS IT CARRIAGE RETURN?
0212 8038 27 08                        BEQ  NEWLINE        ; YES
0213 803a 0c 78                        INC  LPTPOS         ; INCREMENT CHARACTER COUNTER
0214 803c 96 78                        LDA  LPTPOS         ; CHECK FOR END OF LINE PRINTER LINE
0215 803e 91 77                        CMPA LPTWID         ; AT END OF LINE PRINTER LINE?
0216 8040 25 02                        BLO  PUTEND         ; NO
0217 8042 0f 78              NEWLINE   CLR  LPTPOS         ; RESET CHARACTER COUNTER          
0218 8044 8d c2              PUTEND    BSR  EXITBAS
0219 8046 35 86              		  PULS D,PC           ; RESTORE D
0220                                   
0221                         
0222                         *
0223                         RESVEC
0224 8048 10 ce 01 db        LA00E     LDS  #LINBUF+LBUFMX+1 ; SET STACK TO TOP OF LINE INPUT BUFFER
0225                         
0226                         * COLD START ENTRY
0227                         
0228 804c 10 be 7f f0        BACDST    LDY  BasicCallBack  ; save the BasicCallBack before earasing RAM
0229 8050 8e 02 05           		  LDX  #PROGST+1      ; POINT X TO CLEAR 1ST 1K OF RAM
0230 8053 6f 83              LA077     CLR  ,--X           ; MOVE POINTER DOWN TWO-CLEAR BYTE
0231 8055 30 01              		  LEAX 1,X            ; ADVANCE POINTER ONE
0232 8057 26 fa                        BNE  LA077          ; KEEP GOING IF NOT AT BOTTOM OF PAGE 0
0233 8059 8e 02 04                     LDX  #PROGST        ; SET TO START OF PROGRAM SPACE
0234 805c 6f 80                        CLR  ,X+            ; CLEAR 1ST BYTE OF BASIC PROGRAM
0235 805e 9f 19                        STX  TXTTAB         ; BEGINNING OF BASIC PROGRAM
0236 8060 8e 7e ff           		  LDX  #BasicRAMend   ; end of BASIC allocated memory		
0237 8063 10 bf 7f f0        		  STY  BasicCallBack  ; restore the BasicCallBack
0238 8067 9f 70              		  STX  TOPRAM         ; SAVE ABSOLUTE TOP OF RAM
0239 8069 9f 27                        STX  MEMSIZ         ; SAVE TOP OF STRING SPACE
0240 806b 9f 23                        STX  STRTAB         ; SAVE START OF STRING VARIABLES
0241 806d 30 89 ff 38                  LEAX -200,X         ; CLEAR 200 - DEFAULT STRING SPACE TO 200 BYTES
0242 8071 9f 21                        STX  FRETOP         ; SAVE START OF STRING SPACE
0243 8073 1f 14                        TFR  X,S            ; PUT STACK THERE
0244 8075 8e 80 9f                     LDX  #LA10D         ; POINT X TO ROM SOURCE DATA
0245 8078 ce 00 75                     LDU  #LPTCFW        ; POINT U TO RAM DESTINATION
0246 807b c6 12                        LDB  #18            ; MOVE 18 BYTES
0247 807d bd 81 94                     JSR  LA59A          ; MOVE 18 BYTES FROM ROM TO RAM
0248 8080 86 39                        LDA  #$39
0249 8082 97 dd                        STA  LINHDR-1       ; PUT RTS IN LINHDR-1
0250 8084 bd 85 0b                     JSR  LAD19          ; G0 DO A 'NEW'
0251                         * EXTENDED BASIC INITIALISATION
0252 8087 8e 00 a2                     LDX  #USR0          ; INITIALIZE ADDRESS OF START OF
0253 808a 9f 8c                        STX  USRADR         ; USR JUMP TABLE
0254                         * INITIALIZE THE USR CALLS TO 'FC ERROR'
0255 808c ce 8c 1d                     LDU  #LB44A         ; ADDRESS OF 'FC ERROR' ROUTINE
0256 808f c6 0a                        LDB  #10            ; 10 USR CALLS IN EX BASIC
0257 8091 ef 81              L8031     STU  ,X++           ; STORE 'FC' ERROR AT USR ADDRESSES
0258 8093 5a                           DECB                ; FINISHED ALL 10?
0259 8094 26 fb                        BNE  L8031          ; NO
0260                         		  		  
0261 8096 8e 80 ce                     LDX  #LA147-1       ; POINT X TO COLOR BASIC COPYRIGHT MESSAGE
0262 8099 bd 91 48                     JSR  LB99C          ; PRINT 'COLOR BASIC'
0263 809c 7e 84 6d           LA0F3     JMP  LAC73          ; GO TO MAIN LOOP OF BASIC
0264                         
0265                         *
0266                         * THESE BYTES ARE MOVED TO ADDRESSES $76 - $85 THE DIRECT PAGE
0267 809f 10                 LA10D     FCB  16             ; TAB FIELD WIDTH
0268 80a0 40                           FCB  64             ; LAST TAB ZONE
0269 80a1 50                           FCB  80             ; PRINTER WIDTH
0270 80a2 00                           FCB  0              ; LINE PRINTER POSITION
0271 80a3 8c 1d                        FDB  LB44A          ; ARGUMENT OF EXEC COMMAND - SET TO 'FC' ERROR
0272                         * LINE INPUT ROUTINE
0273 80a5 0c 83                        INC  CHARAD+1
0274 80a7 26 02                        BNE  LA123
0275 80a9 0c 82                        INC  CHARAD
0276 80ab b6 00 00           LA123     LDA  >0000
0277 80ae 7e 81 f9                     JMP  BROMHK
0278                         *
0279                         * THESE BYTES ARE MOVED TO ADDRESSES $A7-$B1
0280 80b1 7e 8c 1d                     JMP  LB44A          ; USR ADDRESS FOR 8K BASIC (INITIALIZED TO 'FC' ERROR)
0281 80b4 80                           FCB  $80            ; *RANDOM SEED
0282 80b5 4f c7                        FDB  $4FC7          ; *RANDON SEED OF MANTISSA
0283 80b7 52 59                        FDB  $5259          ; *.811635157
0284                         * BASIC COMMAND INTERPRETATION TABLE ROM IMAGE
0285 80b9 35                 COMVEC    FCB  53             ; 53 BASIC COMMANDS
0286 80ba 82 57                        FDB  LAA66          ; POINTS TO RESERVED WORDS
0287 80bc 83 6f                        FDB  LAB67          ; POINTS TO JUMP TABLE FOR COMMANDS
0288 80be 1d                           FCB  29             ; 29 BASIC SECONDARY COMMANDS
0289 80bf 83 02                        FDB  LAB1A          ; POINTS TO SECONDARY FUNCTION RESERVED WORDS
0290 80c1 82 08                        FDB  LAA29          ; POINTS TO SECONDARY FUNCTION JUMP TABLE
0291 80c3 00 00                        FDB  0              ; NO MORE TABLES (RES WORDS=0)
0292 80c5 00 00                        FDB  0              ; NO MORE TABLES
0293 80c7 00 00                        FDB  0              ; NO MORE TABLES
0294 80c9 00 00                        FDB  0              ; NO MORE TABLES
0295 80cb 00 00                        FDB  0              ; NO MORE TABLES
0296 80cd 00 00                        FDB  0              ; NO MORE TABLES (SECONDARY FNS =0)
0297                         
0298                         * COPYRIGHT MESSAGES
0299 80cf 36 38 30 39 20 45  LA147     FCC  "6809 EXTENDED BASIC"
     58 54 45 4e 44 45
     44 20 42 41 53 49
     43
0300 80e2 0d                           FCB  CR
0301 80e3 28 43 29 20 31 39            FCC  "(C) 1982 BY MICROSOFT"
     38 32 20 42 59 20
     4d 49 43 52 4f 53
     4f 46 54
0302 80f8 0d 0d              LA156     FCB  CR,CR
0303 80fa 00                 LA165     FCB  $00
0304                         
0305                         
0306 80fb 34 16              LA35F     PSHS X,B,A          ; SAVE REGISTERS
0307 80fd 9e 75                        LDX  LPTCFW         ; TAB FIELD WIDTH AND TAB ZONE
0308 80ff dc 77                        LDD  LPTWID         ; PRINTER WIDTH AND POSITION
0309 8101 9f 6a              LA37C     STX  DEVCFW         ; SAVE TAB FIELD WIDTH AND ZONE
0310 8103 d7 6c                        STB  DEVPOS         ; SAVE PRINT POSITION
0311 8105 97 6d                        STA  DEVWID         ; SAVE PRINT WIDTH
0312 8107 35 96                        PULS A,B,X,PC       ; RESTORE REGISTERS
0313                         
0314                         * THIS IS THE ROUTINE THAT GETS AN INPUT LINE FOR BASIC
0315                         * EXIT WITH BREAK KEY: CARRY = 1
0316                         * EXIT WITH ENTER KEY: CARRY = 0
0317                         LA38D
0318 8109 0f 72              LA390     CLR  IKEYIM         ; RESET BREAK CHECK KEY TEMP KEY STORAGE
0319 810b 8e 00 e1                     LDX  #LINBUF+1      ; INPUT LINE BUFFER
0320 810e c6 01                        LDB  #1             ; ACCB CHAR COUNTER: SET TO 1 TO ALLOW A
0321                         *         BACKSPACE AS FIRST CHARACTER
0322 8110 bd 80 1f           LA39A     JSR  LA171          ; GO GET A CHARACTER FROM CONSOLE IN
0323 8113 81 08                        CMPA #BS            ; BACKSPACE
0324 8115 26 07                        BNE  LA3B4          ; NO
0325 8117 5a                           DECB                ; YES - DECREMENT CHAR COUNTER
0326 8118 27 ef                        BEQ  LA390          ; BRANCH IF BACK AT START OF LINE AGAIN
0327 811a 30 1f                        LEAX -1,X           ; DECREMENT BUFFER POINTER
0328 811c 20 34                        BRA  LA3E8          ; ECHO CHAR TO SCREEN
0329 811e 81 15              LA3B4     CMPA #$15           ; SHIFT RIGHT ARROW?
0330 8120 26 0a                        BNE  LA3C2          ; NO
0331                         * YES, RESET BUFFER TO BEGINNING AND ERASE CURRENT LINE
0332 8122 5a                 LA3B8     DECB                ; DEC CHAR CTR
0333 8123 27 e4                        BEQ  LA390          ; GO BACK TO START IF CHAR CTR = 0
0334 8125 86 08                        LDA  #BS            ; BACKSPACE?
0335 8127 bd 80 31                     JSR  PUTCHR         ; SEND TO CONSOLE OUT (SCREEN)
0336 812a 20 f6                        BRA  LA3B8          ; KEEP GOING
0337 812c 81 03              LA3C2     CMPA #3             ; BREAK KEY?
0338 812e 1a 01                        ORCC #1             ; SET CARRY FLAG
0339 8130 27 05                        BEQ  LA3CD          ; BRANCH IF BREAK KEY DOWN
0340 8132 81 0d              LA3C8     CMPA #CR            ; ENTER KEY?
0341 8134 26 0d                        BNE  LA3D9          ; NO
0342 8136 4f                 LA3CC     CLRA                ; CLEAR CARRY FLAG IF ENTER KEY - END LINE ENTRY
0343 8137 34 01              LA3CD     PSHS CC             ; SAVE CARRY FLAG
0344 8139 bd 91 08                     JSR  LB958          ; SEND CR TO SCREEN
0345 813c 6f 84                        CLR  ,X             ; MAKE LAST BYTE IN INPUT BUFFER = 0
0346 813e 8e 00 e0                     LDX  #LINBUF        ; RESET INPUT BUFFER POINTER
0347 8141 35 81                        PULS CC,PC          ; RESTORE CARRY FLAG
0348                         
0349                         * INSERT A CHARACTER INTO THE BASIC LINE INPUT BUFFER
0350 8143 81 20              LA3D9     CMPA #$20           ; IS IT CONTROL CHAR?
0351 8145 25 c9                        BLO  LA39A          ; BRANCH IF CONTROL CHARACTER
0352 8147 81 7b                        CMPA #'z+1          ; *
0353 8149 24 c5                        BCC  LA39A          ; * IGNORE IF > LOWER CASE Z
0354 814b c1 fa                        CMPB #LBUFMX        ; HAVE 250 OR MORE CHARACTERS BEEN ENTERED?
0355 814d 24 c1                        BCC  LA39A          ; YES, IGNORE ANY MORE
0356 814f a7 80                        STA  ,X+            ; PUT IT IN INPUT BUFFER
0357 8151 5c                           INCB                ; INCREMENT CHARACTER COUNTER
0358 8152 bd 80 31           LA3E8     JSR  PUTCHR         ; ECHO IT TO SCREEN
0359 8155 20 b9                        BRA  LA39A          ; GO SET SOME MORE
0360                         
0361                         
0362                         * EXEC
0363 8157 27 05              EXEC      BEQ  LA545          ; BRANCH IF NO ARGUMENT
0364 8159 bd 8f 10                     JSR  LB73D          ; EVALUATE ARGUMENT - ARGUMENT RETURNED IN X
0365 815c 9f 79                        STX  EXECJP         ; STORE X TO EXEC JUMP ADDRESS
0366 815e 6e 9f 00 79        LA545     JMP  [EXECJP]       ; GO DO IT
0367                         
0368                         * BREAK CHECK
0369 8162 7e 85 f2           LA549     JMP  LADEB          ; GO DO BREAK KEY CHECK
0370                         
0371                         * THIS ROUTINE EVALUATES AN ARGUMENT
0372                         * AND MAKES SURE IT IS WITHIN LIMITS OF VIDEO DISPLAY RAM
0373 8165 bd 8b b7           LA554	  JSR		LB3E4	; EVALUATE EXPRESSION AND RETURN VALUE IN ACCD
0374 8168 10 83 02 7f        		  CMPD	#639	; ONLY 512 VIDEO DISPLAY LOCATIONS (32 COL BY 20 LINES)
0375 816c 10 22 0a ad        		  LBHI	LB44A	; BRANCH IF > 511 TO ‘ILLEGAL FUNCTION CALL’
0376 8170 34 04              		  PSHS B  ; SAVE LOWER PART 0-31 (5-BIT)
0377 8172 58                 		  LSLB	; SHIFT 3-BIT VER VALUE TO ACCA
0378 8173 49                 		  ROLA
0379 8174 58                 		  LSLB
0380 8175 49                 		  ROLA
0381 8176 58                 		  LSLB
0382 8177 49                 		  ROLA				  ; VER VALUE IN ACCA
0383 8178 35 04              		  PULS B
0384 817a c4 1f              		  ANDB #$1F			  ; KEEP HOR VALUE
0385 817c bd f0 2b           		  JSR APLsetXY 		  ; GET CHARACTER LOCATION (VER IN ACCA, HOR IN ACCB)
0386 817f 39                 		  RTS
0387                         		
0388                         * INKEY$
0389 8180 96 72              INKEY     LDA  IKEYIM         ; WAS A KEY DOWN IN THE BREAK CHECK?
0390 8182 26 03                        BNE  LA56B          ; YES
0391 8184 bd 80 24                     JSR  KEYIN          ; GO GET A KEY
0392 8187 0f 72              LA56B     CLR  IKEYIM         ; CLEAR INKEY RAM IMAGE
0393 8189 97 53                        STA  FPA0+3         ; STORE THE KEY IN FPA0
0394 818b 10 26 0c d3                  LBNE LB68F          ; CONVERT FPA0+3 TO A STRING
0395 818f 97 56                        STA  STRDES         ; SET LENGTH OF STRING = 0 IF NO KEY DOWN
0396 8191 7e 8e 6e                     JMP  LB69B          ; PUT A NULL STRING ONTO THE STRING STACK
0397                         
0398                         * MOVE ACCB BYTES FROM (X) TO (U)
0399 8194 a6 80              LA59A     LDA  ,X+            ; GET BYTE FROM X
0400 8196 a7 c0                        STA  ,U+            ; STORE IT AT U
0401 8198 5a                           DECB                ; MOVED ALL BYTES?
0402 8199 26 f9                        BNE  LA59A          ; NO
0403 819b 39                 LA5A1     RTS
0404                         
0405                         ** THIS ROUTINE WILL SCAN OFF THE FILE NAME FROM A BASIC LINE
0406                         ** AND RETURN A SYNTAX ERROR IF THERE ARE ANY CHARACTERS
0407                         ** FOLLOWING THE END OF THE NAME
0408 819c 9d 81              LA5C7     JSR  GETCCH         ; GET CURRENT INPUT CHAR FROM BASIC LINE
0409 819e 27 fb              LA5C9     BEQ  LA5A1          ; RETURN IF END OF LINE
0410 81a0 7e 8a 4f                     JMP  LB277          ; SYNTAX ERROR IF ANY MORE CHARACTERS
0411                         
0412                         * SET  ; SET(x,y,col)
0413 81a3 8d 19              SET       BSR LA8C1			; GET ABSOLUTE SCREEN POSITION OF GRAPHICS BLOCK
0414 81a5 34 06              		  PSHS D			; SAVE CHARACTER LOCATION
0415 81a7 bd 8f 0b           		  JSR LB738			; SYNTAX CHECK FOR COMMA - RETURN EXPR VALUE IN ACCB		  
0416 81aa 5d                 		  TSTB				; VALID ARGUMENT?
0417 81ab 27 04              		  BEQ LA6C6			; IF ARGUMENT <1, USE DEFAULT
0418 81ad c1 07              		  CMPB #7			; VALID ARGUMENT?
0419 81af 23 02              		  BLS LA6C7			; ILLEGAL COLOR - ‘ILLEGAL FUNCTION CALL’
0420 81b1 c6 02              LA6C6	  LDB #2			; GREEN DEFAULT VALUE
0421                         LA6C7	  					; THE COLOR IN ACCB IS IGNORED
0422 81b3 17 08 89           		  LBSR LB267		; SYNTAX CHECK FOR ‘)‘
0423 81b6 35 04              		  PULS B			; REGET CHARACTER LOCATION (HOR IN ACCB)
0424 81b8 35 02              		  PULS A			; REGET CHARACTER LOCATION (VER IN ACCA)
0425 81ba bd f0 2b           		  JSR APLsetXY
0426 81bd 39                 		  RTS
0427                         
0428                         *** THIS ROUTINE WILL CHECK SYNTAX AND CHECK FOR LEGAL VALUES
0429                         *** OF SET,RESET & POINT HORIZONTAL AND VERTICAL PARAMETERS
0430                         *** AND RETURN THEIR ABSOLUTE SCREEN ADDRESS IN THE X REGISTER
0431                         *** WHICH OF THE FOUR PIXELS OF THE GRAPHIC BLOCK SELECTED
0432                         *** IS RETURNED IN GRBLOK.
0433 81be bd 8a 42           LA8C1 	  JSR LB26A			; SYNTAX CHECK FOR "("
0434 81c1 bd 8e de           		  JSR LB70B			; EVALUATE EXPRESSION - RETURN VALUE IN ACCB
0435                         		  ;CMPB #63			; ONLY 64 HORIZONTAL GRAPHIC BLOCKS
0436                         		  ;BHI LA948			; ‘ILLEGAL FUNCTION CALL’
0437 81c4 34 04              		  PSHS B			; SAVE HOR COORD
0438 81c6 bd 8f 0b           		  JSR LB738			; SYNTAX CHECK FOR COMMA AND EVALUATE EXPR
0439 81c9 35 02              		  PULS A			; KEEP VERT COORD IN ACCB, GET HOR COORD IN ACCA
0440                         		  ;CMPB #31
0441                         LA8D5 	  ;BHI LA948			; ‘ILLEGAL FUNCTION CALL’		  
0442 81cb 39                 		  RTS
0443                         		  
0444                         * CLS  ; CLS "color" [the color values are: 1 red, 2 green, 3 yellow, 4 blue, 5 magenta, 6 cyan, 7 white]
0445 81cc 27 0a              CLS		  BEQ LA928			; BRANCH IF NO ARGUMENT
0446 81ce bd 8e de           		  JSR LB70B			; CALCULATE ARGUMENT, RETURN VALUE IN ACCB
0447 81d1 5d                 		  TSTB				; VALID ARGUMENT?
0448 81d2 27 04              		  BEQ LA928			; IF ARGUMENT <1, USE DEFAULT
0449 81d4 c1 07              		  CMPB #7			; VALID ARGUMENT?
0450 81d6 23 02              		  BLS LA937			; IF ARGUMENT >7, USE DEFAULT
0451 81d8 c6 02              LA928	  LDB #2			; GREEN DEFAULT VALUE
0452 81da bd f0 15           LA937	  JSR APLclearscreen
0453 81dd 39                           RTS
0454                         
0455 81de bd 8a 45           LA93F 	  JSR LB26D			; SYNTAX CHECK FOR A COMMA
0456 81e1 bd 8e de           LA942 	  JSR LB70B			; EVALUATE EXPRESSION, RETURN VALUE IN ACCB
0457 81e4 5d                 		  TSTB				; SET FLAGS
0458 81e5 26 11              		  BNE LA984			; RETURN IF NON ZERO
0459 81e7 32 61              		  LEAS 1,S			; CLEAR PUSHED VALUE
0460 81e9 7e 8c 1d           LA948	  JMP LB44A			; ‘ILLEGAL FUNCTION CALL’ IF ZERO
0461                         
0462                         * SOUND  ; SOUND tone,duration [tone and duration are each between 0-255]
0463 81ec 8d f3              SOUND     BSR LA942			; EVALUATE EXPRESSION (FREQUENCY), RETURN VALUE IN ACCB
0464 81ee 34 04              		  PSHS B			; SAVE IT
0465 81f0 17 ff eb           		  LBSR LA93F		; EVALUATE EXPRESSION (SOUND LENGTH), RETURN VALUE IN ACCB
0466 81f3 35 02              		  PULS A			; SAVE FREQUENCY IN ACCA, LENGTH OF SOUND IN ACCB
0467 81f5 bd f0 1c           		  JSR  APLsound
0468 81f8 39                 LA984	  RTS
0469                         
0470                         * SET CARRY IF NUMERIC - RETURN WITH
0471                         * ZERO FLAG SET IF ACCA = 0 OR 3A(:) - END
0472                         * OF BASIC LINE OR SUB LINE
0473 81f9 81 3a              BROMHK    CMPA #'9+1          ; IS THIS CHARACTER >=(ASCII 9)+1?
0474 81fb 24 0a                        BHS  LAA28          ; BRANCH IF > 9; Z SET IF = COLON
0475 81fd 81 20                        CMPA #SPACE         ; SPACE?
0476 81ff 26 02                        BNE  LAA24          ; NO - SET CARRY IF NUMERIC
0477 8201 0e 7b                        JMP  GETNCH         ; IF SPACE, GET NECT CHAR (IGNORE SPACES)
0478 8203 80 30              LAA24     SUBA #'0            ; * SET CARRY IF
0479 8205 80 d0                        SUBA #-'0           ; * CHARACTER > ASCII 0
0480 8207 39                 LAA28     RTS
0481                         
0482                         * DISPATCH TABLE FOR SECONDARY FUNCTIONS
0483                         * TOKENS ARE PRECEEDED BY $FF
0484                         * FIRST SET ALWAYS HAS ONE PARAMETER
0485                         FUNC_TAB
0486 8208 94 26              LAA29     FDB  SGN            ; SGN
0487 820a 94 9a                        FDB  INT            ; INT
0488 820c 94 3f                        FDB  ABS            ; ABS
0489 820e 00 9a                        FDB  USRJMP         ; USR
0490 0083                    TOK_USR   EQU  *-FUNC_TAB/2+$7F
0491 ff83                    TOK_FF_USR EQU  *-FUNC_TAB/2+$FF7F
0492 8210 96 cb                        FDB  RND            ; RND
0493 8212 97 20                        FDB  SIN            ; SIN
0494 8214 8f 23                        FDB  PEEK           ; PEEK
0495 8216 8e 54                        FDB  LEN            ; LEN
0496 8218 8c d0                        FDB  STR            ; STR$
0497 821a 8e e9                        FDB  VAL            ; VAL
0498 821c 8e 73                        FDB  ASC            ; ASC
0499 821e 8e 5f                        FDB  CHR            ; CHR$
0500 8220 97 d0                        FDB  ATN            ; ATN
0501 8222 97 98                        FDB  COS            ; COS
0502 8224 97 a1                        FDB  TAN            ; TAN
0503 8226 99 12                        FDB  EXP            ; EXP
0504 8228 99 44                        FDB  FIX            ; FIX
0505 822a 98 66                        FDB  LOG            ; LOG
0506 822c 9a cc                        FDB  POS            ; POS
0507 822e 98 a0                        FDB  SQR            ; SQR
0508 8230 e1 de                        FDB  HEXDOL         ; HEX$
0509                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
0510 8232 8e 7e                        FDB  LEFT           ; LEFT$
0511 0095                    TOK_LEFT  EQU  *-FUNC_TAB/2+$7F
0512 8234 8e 9b                        FDB  RIGHT          ; RIGHT$
0513 8236 8e a2                        FDB  MID            ; MID$
0514 0097                    TOK_MID   EQU  *-FUNC_TAB/2+$7F
0515                         * REMAINING FUNCTIONS
0516 8238 81 80                        FDB  INKEY          ; INKEY$
0517 0098                    TOK_INKEY EQU  *-FUNC_TAB/2+$7F
0518 823a 8c c1                        FDB  MEM            ; MEM
0519 823c 9a d4                        FDB  VARPT          ; VARPTR
0520 823e 9b 94                        FDB  INSTR          ; INSTR
0521 8240 9b 64                        FDB  STRING         ; STRING$
0522 001d                    NUM_SEC_FNS EQU  *-FUNC_TAB/2
0523                         
0524                         * THIS TABLE CONTAINS PRECEDENCES AND DISPATCH ADDRESSES FOR ARITHMETIC
0525                         * AND LOGICAL OPERATORS - THE NEGATION OPERATORS DO NOT ACT ON TWO OPERANDS
0526                         * S0 THEY ARE NOT LISTED IN THIS TABLE. THEY ARE TREATED SEPARATELY IN THE
0527                         * EXPRESSION EVALUATION ROUTINE. THEY ARE:
0528                         * UNARY NEGATION (-), PRECEDENCE &7D AND LOGICAL NEGATION (NOT), PRECEDENCE $5A
0529                         * THE RELATIONAL OPERATORS < > = ARE ALSO NOT LISTED, PRECEDENCE $64.
0530                         * A PRECEDENCE VALUE OF ZERO INDICATES END OF EXPRESSION OR PARENTHESES
0531                         *
0532 8242 79                 LAA51     FCB  $79
0533 8243 91 71                        FDB  LB9C5          ; +
0534 8245 79                           FCB  $79
0535 8246 91 68                        FDB  LB9BC          ; -
0536 8248 7b                           FCB  $7B
0537 8249 92 78                        FDB  LBACC          ; *
0538 824b 7b                           FCB  $7B
0539 824c 93 3d                        FDB  LBB91          ; /
0540 824e 7f                           FCB  $7F
0541 824f 98 a9                        FDB  L8489          ; EXPONENTIATION
0542 8251 50                           FCB  $50
0543 8252 8a a8                        FDB  LB2D5          ; AND
0544 8254 46                           FCB  $46
0545 8255 8a a7                        FDB  LB2D4          ; OR
0546                         
0547                         * THIS IS THE RESERVED WORD TABLE
0548                         * FIRST PART OF THE TABLE CONTAINS EXECUTABLE COMMANDS
0549 8257 46 4f              LAA66     FCC  "FO"           ; 80
0550 8259 d2                           FCB  $80+'R
0551 825a 47                           FCC  "G"            ; 81
0552 825b cf                           FCB  $80+'O
0553 0081                    TOK_GO    EQU  $81
0554 825c 52 45                        FCC  "RE"           ; 82
0555 825e cd                           FCB  $80+'M
0556 825f a7                           FCB  ''+$80         ; 83
0557 8260 45 4c 53                     FCC  "ELS"          ; 84
0558 8263 c5                           FCB  $80+'E
0559 8264 49                           FCC  "I"            ; 85
0560 8265 c6                           FCB  $80+'F
0561 8266 44 41 54                     FCC  "DAT"          ; 86
0562 8269 c1                           FCB  $80+'A
0563 826a 50 52 49 4e                  FCC  "PRIN"         ; 87
0564 826e d4                           FCB  $80+'T
0565 826f 4f                           FCC  "O"            ; 88
0566 8270 ce                           FCB  $80+'N
0567 8271 49 4e 50 55                  FCC  "INPU"         ; 89
0568 8275 d4                           FCB  $80+'T
0569 8276 45 4e                        FCC  "EN"           ; 8A
0570 8278 c4                           FCB  $80+'D
0571 8279 4e 45 58                     FCC  "NEX"          ; 8B
0572 827c d4                           FCB  $80+'T
0573 827d 44 49                        FCC  "DI"           ; 8C
0574 827f cd                           FCB  $80+'M
0575 8280 52 45 41                     FCC  "REA"          ; 8D
0576 8283 c4                           FCB  $80+'D
0577 8284 52 55                        FCC  "RU"           ; 8E
0578 8286 ce                           FCB  $80+'N
0579 8287 52 45 53 54 4f 52            FCC  "RESTOR"       ; 8F
0580 828d c5                           FCB  $80+'E
0581 828e 52 45 54 55 52               FCC  "RETUR"        ; 90
0582 8293 ce                           FCB  $80+'N
0583 8294 53 54 4f                     FCC  "STO"          ; 91
0584 8297 d0                           FCB  $80+'P
0585 8298 50 4f 4b                     FCC  "POK"          ; 92
0586 829b c5                           FCB  $80+'E
0587 829c 43 4f 4e                     FCC  "CON"          ; 93
0588 829f d4                           FCB  $80+'T
0589 82a0 4c 49 53                     FCC  "LIS"          ; 94
0590 82a3 d4                           FCB  $80+'T
0591 82a4 43 4c 45 41                  FCC  "CLEA"         ; 95
0592 82a8 d2                           FCB  $80+'R
0593 82a9 4e 45                        FCC  "NE"           ; 96
0594 82ab d7                           FCB  $80+'W
0595 82ac 53 45                        FCC  "SE"           ; 97
0596 82ae d4                           FCB  $80+'T
0597 82af 43 4c              		  FCC  "CL"           ; 98
0598 82b1 d3                           FCB  $80+'S
0599 82b2 53 4f 55 4e        		  FCC  "SOUN"         ; 99
0600 82b6 c4                           FCB  $80+'D
0601 82b7 45 58 45           		  FCC  "EXE"          ; 9A
0602 82ba c3                           FCB  $80+'C
0603 82bb 44 45                        FCC  "DE"           ; 9B
0604 82bd cc                           FCB  $80+'L
0605 82be 45 44 49                     FCC  "EDI"          ; 9C
0606 82c1 d4                           FCB  $80+'T
0607 82c2 54 52 4f                     FCC  "TRO"          ; 9D
0608 82c5 ce                           FCB  $80+'N
0609 82c6 54 52 4f 46                  FCC  "TROF"         ; 9E
0610 82ca c6                           FCB  $80+'F
0611 82cb 44 45                        FCC  "DE"           ; 9F
0612 82cd c6                           FCB  $80+'F
0613 82ce 4c 49 4e                     FCC  "LIN"          ; A0
0614 82d1 c5                           FCB  $80+'E
0615 82d2 52 45 4e 55                  FCC  "RENU"         ; A1
0616 82d6 cd                           FCB  $80+'M          
0617                         * END OF EXECUTABLE COMMANDS. THE REMAINDER OF THE TABLE ARE NON-EXECUTABLE TOKENS
0618 82d7 54 41 42                     FCC  "TAB"          ; A2
0619 82da a8                           FCB  $80+'(
0620 00a2                    TOK_TAB   EQU  $A2
0621 82db 54                           FCC  "T"            ; A3
0622 82dc cf                           FCB  $80+'O
0623 00a3                    TOK_TO    EQU  $A3
0624 82dd 53 55                        FCC  "SU"           ; A4
0625 82df c2                           FCB  $80+'B
0626 00a4                    TOK_SUB   EQU  $A4
0627 82e0 54 48 45                     FCC  "THE"          ; A5
0628 82e3 ce                           FCB  $80+'N
0629 00a5                    TOK_THEN  EQU  $A5
0630 82e4 4e 4f                        FCC  "NO"           ; A6
0631 82e6 d4                           FCB  $80+'T
0632 00a6                    TOK_NOT   EQU  $A6
0633 82e7 53 54 45                     FCC  "STE"          ; A7
0634 82ea d0                           FCB  $80+'P
0635 00a7                    TOK_STEP  EQU  $A7
0636 82eb 4f 46                        FCC  "OF"           ; A8
0637 82ed c6                           FCB  $80+'F
0638 82ee ab                           FCB  '++$80         ; A9
0639 00a9                    TOK_PLUS  EQU  $A9
0640 82ef ad                           FCB  '-+$80         ; AA
0641 00aa                    TOK_MINUS EQU  $AA
0642 82f0 aa                           FCB  '*+$80         ; AB
0643 82f1 af                           FCB  '/+$80         ; AC
0644 82f2 de                           FCB  '^+$80         ; AD
0645 82f3 41 4e                        FCC  "AN"           ; AE
0646 82f5 c4                           FCB  $80+'D
0647 82f6 4f                           FCC  "O"            ; AF
0648 82f7 d2                           FCB  $80+'R
0649 82f8 be                           FCB  '>+$80         ; B0
0650 00b0                    TOK_GREATER EQU  $B0
0651 82f9 bd                           FCB  '=+$80         ; B1
0652 00b1                    TOK_EQUALS EQU  $B1
0653 82fa bc                           FCB  '<+$80         ; B2
0654 82fb 46                           FCC  "F"            ; B3
0655 82fc ce                           FCB  $80+'N
0656 00b3                    TOK_FN    EQU  $B3
0657 82fd 55 53 49 4e                  FCC  "USIN"         ; B4
0658 8301 c7                           FCB  $80+'G
0659 00b4                    TOK_USING EQU  $B4
0660                         *
0661                         
0662                         * FIRST SET ALWAYS HAS ONE PARAMETER
0663 8302 53 47              LAB1A     FCC  "SG"           ; 80
0664 8304 ce                           FCB  $80+'N
0665 8305 49 4e                        FCC  "IN"           ; 81
0666 8307 d4                           FCB  $80+'T
0667 8308 41 42                        FCC  "AB"           ; 82
0668 830a d3                           FCB  $80+'S
0669 830b 55 53                        FCC  "US"           ; 83
0670 830d d2                           FCB  $80+'R
0671 830e 52 4e                        FCC  "RN"           ; 84
0672 8310 c4                           FCB  $80+'D
0673 8311 53 49                        FCC  "SI"           ; 85
0674 8313 ce                           FCB  $80+'N
0675 8314 50 45 45                     FCC  "PEE"          ; 86
0676 8317 cb                           FCB  $80+'K
0677 8318 4c 45                        FCC  "LE"           ; 87
0678 831a ce                           FCB  $80+'N
0679 831b 53 54 52                     FCC  "STR"          ; 88
0680 831e a4                           FCB  $80+'$
0681 831f 56 41                        FCC  "VA"           ; 89
0682 8321 cc                           FCB  $80+'L
0683 8322 41 53                        FCC  "AS"           ; 8A
0684 8324 c3                           FCB  $80+'C
0685 8325 43 48 52                     FCC  "CHR"          ; 8B
0686 8328 a4                           FCB  $80+'$
0687 8329 41 54                        FCC  "AT"           ; 8C
0688 832b ce                           FCB  $80+'N
0689 832c 43 4f                        FCC  "CO"           ; 8D
0690 832e d3                           FCB  $80+'S
0691 832f 54 41                        FCC  "TA"           ; 8E
0692 8331 ce                           FCB  $80+'N
0693 8332 45 58                        FCC  "EX"           ; 8F
0694 8334 d0                           FCB  $80+'P
0695 8335 46 49                        FCC  "FI"           ; 90
0696 8337 d8                           FCB  $80+'X
0697 8338 4c 4f                        FCC  "LO"           ; 91
0698 833a c7                           FCB  $80+'G
0699 833b 50 4f                        FCC  "PO"           ; 92
0700 833d d3                           FCB  $80+'S
0701 833e 53 51                        FCC  "SQ"           ; 93
0702 8340 d2                           FCB  $80+'R
0703 8341 48 45 58                     FCC  "HEX"          ; 94
0704 8344 a4                           FCB  $80+'$
0705                         * LEFT, RIGHT AND MID ARE TREATED SEPARATELY
0706 8345 4c 45 46 54                  FCC  "LEFT"         ; 95
0707 8349 a4                           FCB  $80+'$
0708 834a 52 49 47 48 54               FCC  "RIGHT"        ; 96
0709 834f a4                           FCB  $80+'$
0710 8350 4d 49 44                     FCC  "MID"          ; 97
0711 8353 a4                           FCB  $80+'$
0712                         * REMAINING FUNCTIONS
0713 8354 49 4e 4b 45 59               FCC  "INKEY"        ; 98
0714 8359 a4                           FCB  $80+'$
0715 835a 4d 45                        FCC  "ME"           ; 99
0716 835c cd                           FCB  $80+'M
0717 835d 56 41 52 50 54               FCC  "VARPT"        ; 9A
0718 8362 d2                           FCB  $80+'R
0719 8363 49 4e 53 54                  FCC  "INST"         ; 9B
0720 8367 d2                           FCB  $80+'R
0721 8368 53 54 52 49 4e 47            FCC  "STRING"       ; 9C
0722 836e a4                           FCB  $80+'$
0723                         
0724                         *
0725                         * DISPATCH TABLE FOR COMMANDS TOKEN #
0726                         CMD_TAB
0727 836f 85 39              LAB67     FDB  FOR            ; 80
0728 8371 86 82                        FDB  GO             ; 81
0729 8373 86 df                        FDB  REM            ; 82
0730 0082                    TOK_REM   EQU  *-CMD_TAB/2+$7F
0731 8375 86 df                        FDB  REM            ; 83 (')
0732 0083                    TOK_SNGL_Q EQU  *-CMD_TAB/2+$7F
0733 8377 86 df                        FDB  REM            ; 84 (ELSE)
0734 0084                    TOK_ELSE  EQU  *-CMD_TAB/2+$7F
0735 8379 87 10                        FDB  IF             ; 85
0736 0085                    TOK_IF    EQU  *-CMD_TAB/2+$7F
0737 837b 86 dc                        FDB  DATA           ; 86
0738 0086                    TOK_DATA  EQU  *-CMD_TAB/2+$7F
0739 837d 90 b9                        FDB  PRINT          ; 87
0740 0087                    TOK_PRINT EQU  *-CMD_TAB/2+$7F
0741 837f 87 3e                        FDB  ON             ; 88
0742 8381 87 eb                        FDB  INPUT          ; 89
0743 0089                    TOK_INPUT EQU  *-CMD_TAB/2+$7F
0744 8383 86 09                        FDB  END            ; 8A
0745 8385 88 d0                        FDB  NEXT           ; 8B
0746 8387 8b 21                        FDB  DIM            ; 8C
0747 8389 88 25                        FDB  READ           ; 8D
0748 838b 86 77                        FDB  RUN            ; 8E
0749 838d 85 eb                        FDB  RESTOR         ; 8F
0750 838f 86 bc                        FDB  RETURN         ; 90
0751 8391 86 0d                        FDB  STOP           ; 91
0752 8393 8f 2a                        FDB  POKE           ; 92
0753 8395 86 32                        FDB  CONT           ; 93
0754 8397 8f 31                        FDB  LIST           ; 94
0755 8399 86 43                        FDB  CLEAR          ; 95
0756 839b 85 09                        FDB  NEW            ; 96
0757 839d 81 a3                        FDB  SET            ; 97
0758 839f 81 cc              		  FDB  CLS            ; 98
0759 83a1 81 ec              		  FDB  SOUND          ; 99
0760 83a3 81 57              		  FDB  EXEC           ; 9A
0761 83a5 9d 43                        FDB  DEL            ; 9B
0762 83a7 99 53                        FDB  EDIT           ; 9C
0763 83a9 9a c7              		  FDB  TRON           ; 9D
0764 83ab 9a c8                        FDB  TROFF          ; 9E
0765 83ad 9c 87                        FDB  DEF            ; 9F
0766 83af e6 71                        FDB  LINE           ; A0
0767 83b1 e0 0d                        FDB  RENUM          ; A1          
0768 00a1                    TOK_HIGH_EXEC EQU  *-CMD_TAB/2+$7F
0769                         
0770                         * ERROR MESSAGES AND THEIR NUMBERS AS USED INTERNALLY
0771 83b3 4e 46              LABAF     FCC  "NF"           ; 0 NEXT WITHOUT FOR
0772 83b5 53 4e                        FCC  "SN"           ; 1 SYNTAX ERROR
0773 83b7 52 47                        FCC  "RG"           ; 2 RETURN WITHOUT GOSUB
0774 83b9 4f 44                        FCC  "OD"           ; 3 OUT OF DATA
0775 83bb 46 43                        FCC  "FC"           ; 4 ILLEGAL FUNCTION CALL
0776 83bd 4f 56                        FCC  "OV"           ; 5 OVERFLOW
0777 83bf 4f 4d                        FCC  "OM"           ; 6 OUT OF MEMORY
0778 83c1 55 4c                        FCC  "UL"           ; 7 UNDEFINED LINE NUMBER
0779 83c3 42 53                        FCC  "BS"           ; 8 BAD SUBSCRIPT
0780 83c5 44 44                        FCC  "DD"           ; 9 REDIMENSIONED ARRAY
0781 83c7 2f 30                        FCC  "/0"           ; 10 DIVISION BY ZERO
0782 83c9 49 44                        FCC  "ID"           ; 11 ILLEGAL DIRECT STATEMENT
0783 83cb 54 4d                        FCC  "TM"           ; 12 TYPE MISMATCH
0784 83cd 4f 53                        FCC  "OS"           ; 13 OUT OF STRING SPACE
0785 83cf 4c 53                        FCC  "LS"           ; 14 STRING TOO LONG
0786 83d1 53 54                        FCC  "ST"           ; 15 STRING FORMULA TOO COMPLEX
0787 83d3 43 4e                        FCC  "CN"           ; 16 CAN'T CONTINUE
0788 83d5 46 44                        FCC  "FD"           ; 17 BAD FILE DATA
0789 83d7 41 4f                        FCC  "AO"           ; 18 FILE ALREADY OPEN
0790 83d9 44 4e                        FCC  "DN"           ; 19 DEVICE NUMBER ERROR
0791 83db 49 4f                        FCC  "IO"           ; 20 I/O ERROR
0792 83dd 46 4d                        FCC  "FM"           ; 21 BAD FILE MODE
0793 83df 4e 4f                        FCC  "NO"           ; 22 FILE NOT OPEN
0794 83e1 49 45                        FCC  "IE"           ; 23 INPUT PAST END OF FILE
0795 83e3 44 53                        FCC  "DS"           ; 24 DIRECT STATEMENT IN FILE
0796                         * ADDITIONAL ERROR MESSAGES ADDED BY EXTENDED BASIC
0797 83e5 55 46              L890B     FCC  "UF"           ; 25 UNDEFINED FUNCTION (FN) CALL
0798 83e7 4e 45              L890D     FCC  "NE"           ; 26 FILE NOT FOUND
0799                         
0800 83e9 20 45 52 52 4f 52  LABE1     FCC  " ERROR"
0801 83ef 00                           FCB  $00
0802 83f0 20 49 4e 20        LABE8     FCC  " IN "
0803 83f4 00                           FCB  $00
0804 83f5 0d                 LABED     FCB  CR
0805 83f6 4f 4b              LABEE     FCC  "OK"
0806 83f8 0d 00                        FCB  CR,$00
0807 83fa 0d                 LABF2     FCB  CR
0808 83fb 42 52 45 41 4b               FCC  "BREAK"
0809 8400 00                           FCB  $00
0810                         
0811                         * SEARCH THE STACK FOR 'GOSUB/RETURN' OR 'FOR/NEXT' DATA.
0812                         * THE 'FOR/NEXT' INDEX VARIABLE DESCRIPTOR ADDRESS BEING
0813                         * SOUGHT IS STORED IN VARDES. EACH BLOCK OF FOR/NEXT DATA IS 18
0814                         * BYTES WITH A $80 LEADER BYTE AND THE GOSUB/RETURN DATA IS 5 BYTES
0815                         * WITH AN $A6 LEADER BYTE. THE FIRST NON "FOR/NEXT" DATA
0816                         * IS CONSIDERED 'GOSUB/RETURN'
0817 8401 30 64              LABF9     LEAX 4,S            ; POINT X TO 3RD ADDRESS ON STACK - IGNORE THE
0818                         *         FIRST TWO RETURN ADDRESSES ON THE STACK
0819 8403 c6 12              LABFB     LDB  #18            ; 18 BYTES SAVED ON STACK FOR EACH 'FOR' LOOP
0820 8405 9f 0f                        STX  TEMPTR         ; SAVE POINTER
0821 8407 a6 84                        LDA  ,X             ; GET 1ST BYTE
0822 8409 80 80                        SUBA #$80           ; * CHECK FOR TYPE OF STACK JUMP FOUND
0823 840b 26 15                        BNE  LAC1A          ; * BRANCH IF NOT 'FOR/NEXT'
0824 840d ae 01                        LDX  1,X            ; = GET INDEX VARIABLE DESCRIPTOR
0825 840f 9f 11                        STX  TMPTR1         ; = POINTER AND SAVE IT IN TMPTR1
0826 8411 9e 3b                        LDX  VARDES         ; GET INDEX VARIABLE BEING SEARCHED FOR
0827 8413 27 09                        BEQ  LAC16          ; BRANCH IF DEFAULT INDEX VARIABLE - USE THE
0828                         *                             ; FIRST 'FOR/NEXT' DATA FOUND ON STACK
0829                         *                             ; IF NO INDEX VARIABLE AFTER 'NEXT'
0830 8415 9c 11                        CMPX TMPTR1         ; DOES THE STACK INDEX MATCH THE ONE
0831                         *                             ; BEING SEARCHED FOR?
0832 8417 27 09                        BEQ  LAC1A          ; YES
0833 8419 9e 0f                        LDX  TEMPTR         ; * RESTORE INITIAL POINTER, ADD
0834 841b 3a                           ABX                 ; * 18 TO IT AND LOOK FOR
0835 841c 20 e5                        BRA  LABFB          ; * NEXT BLOCK OF DATA
0836 841e 9e 11              LAC16     LDX  TMPTR1         ; = GET 1ST INDEX VARIABLE FOUND AND
0837 8420 9f 3b                        STX  VARDES         ; = SAVE AS 'NEXT' INDEX
0838 8422 9e 0f              LAC1A     LDX  TEMPTR         ; POINT X TO START OF 'FOR/NEXT' DATA
0839 8424 4d                           TSTA                ; SET ZERO FLAG IF 'FOR/NEXT' DATA
0840 8425 39                           RTS
0841                         * CHECK FOR MEMORY SPACE FOR NEW TOP OF
0842                         * ARRAYS AND MOVE ARRAYS TO NEW LOCATION
0843 8426 8d 17              LAC1E     BSR  LAC37          ; ACCD = NEW BOTTOM OF FREE RAM - IS THERE
0844                         *                             ; ROOM FOR THE STACK?
0845                         * MOVE BYTES FROM V43(X) TO V41(U) UNTIL (X) = V47 AND
0846                         * SAVE FINAL VALUE OF U IN V45
0847 8428 de 41              LAC20     LDU  V41            ; POINT U TO DESTINATION ADDRESS (V41)
0848 842a 33 41                        LEAU 1,U            ; ADD ONE TO U - COMPENSATE FOR FIRST PSHU
0849 842c 9e 43                        LDX  V43            ; POINT X TO SOURCE ADDRESS (V43)
0850 842e 30 01                        LEAX 1,X            ; ADD ONE - COMPENSATE FOR FIRST LDA ,X
0851 8430 a6 82              LAC28     LDA  ,-X            ; GRAB A BYTE FROM SOURCE
0852 8432 36 02                        PSHU A              ; MOVE IT TO DESTINATION
0853 8434 9c 47                        CMPX V47            ; DONE?
0854 8436 26 f8                        BNE  LAC28          ; NO - KEEP MOVING BYTES
0855 8438 df 45                        STU  V45            ; SAVE FINAL DESTINATION ADDRESS
0856 843a 39                 LAC32     RTS
0857                         * CHECK TO SEE IF THERE IS ROOM TO STORE 2*ACCB
0858                         * BYTES IN FREE RAM - OM ERROR IF NOT
0859 843b 4f                 LAC33     CLRA                ; * ACCD CONTAINS NUMBER OF EXTRA
0860 843c 58                           ASLB                ; * BYTES TO PUT ON STACK
0861 843d d3 1f                        ADDD ARYEND         ; END OF PROGRAM AND VARIABLES
0862 843f c3 00 3a           LAC37     ADDD #STKBUF        ; ADD STACK BUFFER - ROOM FOR STACK?
0863 8442 25 08                        BCS  LAC44          ; BRANCH IF GREATER THAN $FFFF
0864 8444 10 df 17                     STS  BOTSTK         ; CURRENT NEW BOTTOM OF STACK STACK POINTER
0865 8447 10 93 17                     CMPD BOTSTK         ; ARE WE GOING TO BE BELOW STACK?
0866 844a 25 ee                        BCS  LAC32          ; YES - NO ERROR
0867 844c c6 0c              LAC44     LDB  #6*2           ; OUT OF MEMORY ERROR
0868                         
0869                         * ERROR SERVICING ROUTINE
0870 844e bd 85 25           LAC46     JSR  LAD33          ; RESET STACK, STRING STACK, CONTINUE POINTER
0871 8451 bd 91 0c                     JSR  LB95C          ; SEND A CR TO SCREEN
0872 8454 bd 91 5b                     JSR  LB9AF          ; SEND A '?' TO SCREEN
0873 8457 8e 83 b3                     LDX  #LABAF         ; POINT TO ERROR TABLE
0874 845a 3a                 LAC60     ABX                 ; ADD MESSAGE NUMBER OFFSET
0875 845b 8d 37                        BSR  LACA0          ; * GET TWO CHARACTERS FROM X AND
0876 845d 8d 35                        BSR  LACA0          ; * SEND TO CONSOLE OUT (SCREEN)
0877 845f 8e 83 e8                     LDX  #LABE1-1       ; POINT TO "ERROR" MESSAGE
0878 8462 bd 91 48           LAC68     JSR  LB99C          ; PRINT MESSAGE POINTED TO BY X
0879 8465 96 68                        LDA  CURLIN         ; GET CURRENT LINE NUMBER (CURL IN)
0880 8467 4c                           INCA                ; TEST FOR DIRECT MODE
0881 8468 27 03                        BEQ  LAC73          ; BRANCH IF DIRECT MODE
0882 846a bd 95 71                     JSR  LBDC5          ; PRINT 'IN ****'
0883                         
0884                         * THIS IS THE MAIN LOOP OF BASIC WHEN IN DIRECT MODE
0885 846d bd 91 0c           LAC73     JSR  LB95C          ; MOVE CURSOR TO START OF LINE
0886 8470 17 6b 9c                     LBSR APLcurBlinking ; SET THE BLINKING CURSOR
0887 8473 8e 83 f5           		  LDX  #LABED         ; POINT X TO 'OK', CR MESSAGE
0888 8476 bd 91 48                     JSR  LB99C          ; PRINT 'OK', CR
0889 8479 bd 81 09           LAC7C     JSR  LA390          ; GO GET AN INPUT LINE
0890 847c ce ff ff                     LDU  #$FFFF         ; THE LINE NUMBER FOR DIRECT MODE IS $FFFF
0891 847f df 68                        STU  CURLIN         ; SAVE IT IN CURLIN
0892 8481 25 f6                        BCS  LAC7C          ; BRANCH IF LINE INPUT TERMINATED BY BREAK
0893 8483 9f 82                        STX  CHARAD         ; SAVE (X) AS CURRENT INPUT POINTER - THIS WILL
0894                         *         ENABLE THE 'LIVE KEYBOARD' (DIRECT) MODE. THE
0895                         *         LINE JUST ENTERED WILL BE INTERPRETED
0896 8485 9d 7b                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
0897 8487 27 f0                        BEQ  LAC7C          ; NO LINE INPUT - GET ANOTHER LINE
0898 8489 25 0e                        BCS  LACA5          ; BRANCH IF NUMER1C - THERE WAS A LINE NUMBER BEFORE
0899                         *         THE  STATEMENT ENTERED, SO THIS STATEMENT
0900                         *         WILL BE MERGED INTO THE BASIC PROGRAM
0901 848b 17 6b 84                     LBSR APLcurOff	  ; STOP THE BLINKING CURSOR		  
0902 848e bd 8f e6           		  JSR  LB821          ; GO CRUNCH LINE
0903 8491 7e 85 c0                     JMP  LADC0          ; GO EXECUTE THE STATEMENT (LIVE KEYBOARD)
0904                         *
0905 8494 a6 80              LACA0     LDA  ,X+            ; GET A CHARACTER
0906 8496 7e 91 5d                     JMP  LB9B1          ; SEND TO CONSOLE OUT
0907                         * TAKE A LINE FROM THE LINE INPUT BUFFER
0908                         * AND INSERT IT INTO THE BASIC PROGRAM
0909 8499 bd 87 63           LACA5     JSR  LAF67          ; CONVERT LINE NUMBER TO BINARY
0910 849c 9e 2b              LACA8     LDX  BINVAL         ; GET CONVERTED LINE NUMBER
0911 849e 9f de                        STX  LINHDR         ; STORE IT IN LINE INPUT HEADER
0912 84a0 bd 8f e6                     JSR  LB821          ; GO CRUNCH THE LINE
0913 84a3 d7 03                        STB  TMPLOC         ; SAVE LINE LENGTH
0914 84a5 8d 4c                        BSR  LAD01          ; FIND OUT WHERE TO INSERT LINE
0915 84a7 25 12                        BCS  LACC8          ; RANCH IF LINE NUMBER DOES NOT ALREADY EXIST
0916 84a9 dc 47                        LDD  V47            ; GET ABSOLUTE ADDRESS OF LINE NUMBER
0917 84ab a3 84                        SUBD ,X             ; SUBTRACT ADDRESS OF NEXT LINE NUMBER
0918 84ad d3 1b                        ADDD VARTAB         ; * ADD TO CURRENT END OF PROGRAM - THIS WILL REMOVE
0919 84af dd 1b                        STD  VARTAB         ; * THE LENGTH OF THIS LINE NUMBER FROM THE PROGRAM
0920 84b1 ee 84                        LDU  ,X             ; POINT U TO ADDRESS OF NEXT LINE NUMBER
0921                         * DELETE OLD LINE FROM BASIC PROGRAM
0922 84b3 37 02              LACC0     PULU A              ; GET A BYTE FROM WHAT'S LEFT OF PROGRAM
0923 84b5 a7 80                        STA  ,X+            ; MOVE IT DOWN
0924 84b7 9c 1b                        CMPX VARTAB         ; COMPARE TO END OF BASIC PROGRAM
0925 84b9 26 f8                        BNE  LACC0          ; BRANCH IF NOT AT END
0926 84bb 96 e0              LACC8     LDA  LINBUF         ; * CHECK TO SEE IF THERE IS A LINE IN
0927 84bd 27 1c                        BEQ  LACE9          ; * THE BUFFER AND BRANCH IF NONE
0928 84bf dc 1b                        LDD  VARTAB         ; = SAVE CURRENT END OF
0929 84c1 dd 43                        STD  V43            ; = PROGRAM IN V43
0930 84c3 db 03                        ADDB TMPLOC         ; * ADD LENGTH OF CRUNCHED LINE,
0931 84c5 89 00                        ADCA #0             ; * PROPOGATE CARRY AND SAVE NEW END
0932 84c7 dd 41                        STD  V41            ; * OF PROGRAM IN V41
0933 84c9 bd 84 26                     JSR  LAC1E          ; = MAKE SURE THERE'S ENOUGH RAM FOR THIS
0934                         *         =    LINE & MAKE A HOLE IN BASIC FOR NEW LINE
0935 84cc ce 00 dc                     LDU  #LINHDR-2      ; POINT U TO LINE TO BE INSERTED
0936 84cf 37 02              LACDD     PULU A              ; GET A BYTE FROM NEW LINE
0937 84d1 a7 80                        STA  ,X+            ; INSERT IT IN PROGRAM
0938 84d3 9c 45                        CMPX V45            ; * COMPARE TO ADDRESS OF END OF INSERTED
0939 84d5 26 f8                        BNE  LACDD          ; * LINE AND BRANCH IF NOT DONE
0940 84d7 9e 41                        LDX  V41            ; = GET AND SAVE
0941 84d9 9f 1b                        STX  VARTAB         ; = END OF PROGRAM
0942 84db 8d 36              LACE9     BSR  LAD21          ; RESET INPUT POINTER, CLEAR VARIABLES, INITIALIZE
0943 84dd 8d 02                        BSR  LACEF          ; ADJUST START OF NEXT LINE ADDRESSES
0944 84df 20 98                        BRA  LAC7C          ; EENTER BASIC'S INPUT LOOP
0945                         * COMPUTE THE START OF NEXT LINE ADDRESSES FOR THE BASIC PROGRAM
0946 84e1 9e 19              LACEF     LDX  TXTTAB         ; POINT X TO START OF PROGRAM
0947 84e3 ec 84              LACF1     LDD  ,X             ; GET ADDRESS OF NEXT LINE
0948 84e5 27 21                        BEQ  LAD16          ; RETURN IF END OF PROGRAM
0949 84e7 33 04                        LEAU 4,X            ; POINT U TO START OF BASIC TEXT IN LINE
0950 84e9 a6 c0              LACF7     LDA  ,U+            ; * SKIP THROUGH THE LINE UNTIL A
0951 84eb 26 fc                        BNE  LACF7          ; * ZERO (END OF LINE) IS FOUND
0952 84ed ef 84                        STU  ,X             ; SAVE THE NEW START OF NEXT LINE ADDRESS
0953 84ef ae 84                        LDX  ,X             ; POINT X TO START OF NEXT LINE
0954 84f1 20 f0                        BRA  LACF1          ; KEEP GOING
0955                         *
0956                         * FIND A LINE NUMBER IN THE BASIC PROGRAM
0957                         * RETURN WITH CARRY SET IF NO MATCH FOUND
0958 84f3 dc 2b              LAD01     LDD  BINVAL         ; GET THE LINE NUMBER TO FIND
0959 84f5 9e 19                        LDX  TXTTAB         ; BEGINNING OF PROGRAM
0960 84f7 ee 84              LAD05     LDU  ,X             ; GET ADDRESS OF NEXT LINE NUMBER
0961 84f9 27 09                        BEQ  LAD12          ; BRANCH IF END OF PROG
0962 84fb 10 a3 02                     CMPD 2,X            ; IS IT A MATCH?
0963 84fe 23 06                        BLS  LAD14          ; CARRY SET IF LOWER; CARRY CLEAR IF MATCH
0964 8500 ae 84                        LDX  ,X             ; X = ADDRESS OF NEXT LINE
0965 8502 20 f3                        BRA  LAD05          ; KEEP LOOPING FOR LINE NUMBER
0966 8504 1a 01              LAD12     ORCC #1             ; SET CARRY FLAG
0967 8506 9f 47              LAD14     STX  V47            ; SAVE MATCH LINE NUMBER OR NUMBER OF LINE JUST AFTER
0968                         *                             ; WHERE IT SHOULD HAVE BEEN
0969 8508 39                 LAD16     RTS
0970                         
0971                         * NEW
0972 8509 26 fb              NEW       BNE  LAD14          ; BRANCH IF ARGUMENT GIVEN
0973 850b 9e 19              LAD19     LDX  TXTTAB         ; GET START OF BASIC
0974 850d 6f 80                        CLR  ,X+            ; * PUT 2 ZERO BYTES THERE - ERASE
0975 850f 6f 80                        CLR  ,X+            ; * THE BASIC PROGRAM
0976 8511 9f 1b                        STX  VARTAB         ; AND THE NEXT ADDRESS IS NOW THE END OF PROGRAM
0977 8513 9e 19              LAD21     LDX  TXTTAB         ; GET START OF BASIC
0978 8515 bd 86 b7                     JSR  LAEBB          ; PUT INPUT POINTER ONE BEFORE START OF BASIC
0979                         * ERASE ALL VARIABLES
0980 8518 9e 27              LAD26     LDX  MEMSIZ         ; * RESET START OF STRING VARIABLES
0981 851a 9f 23                        STX  STRTAB         ; * TO TOP OF STRING SPACE
0982 851c bd 85 eb                     JSR  RESTOR         ; RESET 'DATA' POINTER TO START OF BASIC
0983 851f 9e 1b                        LDX  VARTAB         ; * GET START OF VARIABLES AND USE IT
0984 8521 9f 1d                        STX  ARYTAB         ; * TO RESET START OF ARRAYS
0985 8523 9f 1f                        STX  ARYEND         ; RESET END OF ARRAYS
0986 8525 8e 00 b6           LAD33     LDX  #STRSTK        ; * RESET STRING STACK POINTER TO
0987 8528 9f 0b                        STX  TEMPPT         ; * BOTTOM OF STRING STACK
0988 852a ae e4                        LDX  ,S             ; GET RETURN ADDRESS OFF STACK
0989 852c 10 de 21                     LDS  FRETOP         ; RESTORE STACK POINTER
0990 852f 6f e2                        CLR  ,-S            ; PUT A ZERO BYTE ON STACK - TO CLEAR ANY RETURN OF
0991                         *                             ; FOR/NEXT DATA FROM THE STACK
0992 8531 0f 2d                        CLR  OLDPTR         ; RESET 'CONT' ADDRESS SO YOU
0993 8533 0f 2e                        CLR  OLDPTR+1       ; 'CAN'T CONTINUE'
0994 8535 0f 08                        CLR  ARYDIS         ; CLEAR THE ARRAY DISABLE FLAG
0995 8537 6e 84                        JMP  ,X             ; RETURN TO CALLING ROUTINE - THIS IS NECESSARY
0996                         *                             ; SINCE THE STACK WAS RESET
0997                         *
0998                         * FOR
0999                         *
1000                         * THE FOR COMMAND WILL STORE 18 BYTES ON THE STACK FOR
1001                         * EACH FOR-NEXT LOOP WHICH IS BEING PROCESSED. THESE
1002                         * BYTES ARE DEFINED AS FOLLOWS: 0- $80 (FOR FLAG);
1003                         *         1,2=INDEX VARIABLE DESCRIPTOR POINTER; 3-7=FP VALUE OF STEP;
1004                         *         8=STEP DIRECTION: $FF IF NEGATIVE; 0 IF ZERO; 1 IF POSITIVE;
1005                         * 9-13=FP VALUE OF 'TO' PARAMETER;
1006                         * 14,15=CURRENT LINE NUMBER; 16,17=RAM ADDRESS OF THE END
1007                         *         OF   THE LINE CONTAINING THE 'FOR' STATEMENT
1008 8539 86 80              FOR       LDA  #$80           ; * SAVE THE DISABLE ARRAY FLAG IN VO8
1009 853b 97 08                        STA  ARYDIS         ; * DO NOT ALLOW THE INDEX VARIABLE TO BE AN ARRAY
1010 853d bd 87 85                     JSR  LET            ; SET INDEX VARIABLE TO INITIAL VALUE
1011 8540 bd 84 01                     JSR  LABF9          ; SEARCH THE STACK FOR 'FOR/NEXT' DATA
1012 8543 32 62                        LEAS 2,S            ; PURGE RETURN ADDRESS OFF OF THE STACK
1013 8545 26 04                        BNE  LAD59          ; BRANCH IF INDEX VARIABLE NOT ALREADY BEING USED
1014 8547 9e 0f                        LDX  TEMPTR         ; GET (ADDRESS + 18) OF MATCHED 'FOR/NEXT' DATA
1015 8549 32 85                        LEAS B,X            ; MOVE THE STACK POINTER TO THE BEGINNING OF THE
1016                         * MATCHED 'FOR/NEXT' DATA SO THE NEW DATA WILL
1017                         * OVERLAY THE OLD DATA. THIS WILL ALSO DESTROY
1018                         * ALL OF THE 'RETURN' AND 'FOR/NEXT' DATA BELOW
1019                         * THIS POINT ON THE STACK
1020 854b c6 09              LAD59     LDB  #$09           ; * CHECK FOR ROOM FOR 18 BYTES
1021 854d bd 84 3b                     JSR  LAC33          ; * IN FREE RAM
1022 8550 bd 86 e4                     JSR  LAEE8          ; GET ADDR OF END OF SUBLINE IN X
1023 8553 dc 68                        LDD  CURLIN         ; GET CURRENT LINE NUMBER
1024 8555 34 16                        PSHS X,B,A          ; SAVE LINE ADDR AND LINE NUMBER ON STACK
1025 8557 c6 a3                        LDB  #TOK_TO        ; TOKEN FOR 'TO'
1026 8559 bd 8a 47                     JSR  LB26F          ; SYNTAX CHECK FOR 'TO'
1027 855c bd 89 1b                     JSR  LB143          ; 'TM' ERROR IF INDEX VARIABLE SET TO STRING
1028 855f bd 89 19                     JSR  LB141          ; EVALUATE EXPRESSION
1029                         *
1030 8562 d6 54                        LDB  FP0SGN         ; GET FPA0 MANTISSA SIGN
1031 8564 ca 7f                        ORB  #$7F           ; FORM A MASK TO SAVE DATA BITS OF HIGH ORDER MANTISSA
1032 8566 d4 50                        ANDB FPA0           ; PUT THE MANTISSA SIGN IN BIT 7 OF HIGH ORDER MANTISSA
1033 8568 d7 50                        STB  FPA0           ; SAVE THE PACKED HIGH ORDER MANTISSA
1034 856a 10 8e 85 71                  LDY  #LAD7F         ; LOAD FOLLOWING ADDRESS INTO Y AS A RETURN
1035 856e 7e 89 c2                     JMP  LB1EA          ; ADDRESS - PUSH FPA0 ONTO THE STACK
1036 8571 8e 92 71           LAD7F     LDX  #LBAC5         ; POINT X TO FLOATING POINT NUMBER 1.0 (DEFAULT STEP VALUE)
1037 8574 bd 93 c0                     JSR  LBC14          ; MOVE (X) TO FPA0
1038 8577 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1039 8579 81 a7                        CMPA #TOK_STEP      ; STEP TOKEN
1040 857b 26 05                        BNE  LAD90          ; BRANCH IF NO 'STEP' VALUE
1041 857d 9d 7b                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1042 857f bd 89 19                     JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
1043 8582 bd 94 19           LAD90     JSR  LBC6D          ; CHECK STATUS OF FPA0
1044 8585 bd 89 be                     JSR  LB1E6          ; SAVE STATUS AND FPA0 ON THE STACK
1045 8588 dc 3b                        LDD  VARDES         ; * GET DESCRIPTOR POINTER FOR THE 'STEP'
1046 858a 34 06                        PSHS B,A            ; * VARIABLE AND SAVE IT ON THE STACK
1047 858c 86 80                        LDA  #$80           ; = GET THE 'FOR' FLAG AND
1048 858e 34 02                        PSHS A              ; = SAVE IT ON THE STACK
1049                         *
1050                         * MAIN COMMAND INTERPRETATION LOOP
1051 8590 8d 60              LAD9E     BSR  LADEB          ; CHECK FOR KEYBOARD BREAK
1052 8592 9e 82                        LDX  CHARAD         ; GET BASIC'S INPUT POINTER
1053 8594 9f 2f                        STX  TINPTR         ; SAVE IT
1054 8596 a6 80                        LDA  ,X+            ; GET CURRENT INPUT CHAR & MOVE POINTER
1055 8598 27 07                        BEQ  LADB4          ; BRANCH IF END OF LINE
1056 859a 81 3a                        CMPA #':            ; CHECK FOR LINE SEPARATOR
1057 859c 27 22                        BEQ  LADC0          ; BRANCH IF COLON
1058 859e 7e 8a 4f           LADB1     JMP  LB277          ; 'SYNTAX ERROR'-IF NOT LINE SEPARATOR
1059 85a1 a6 81              LADB4     LDA  ,X++           ; GET MS BYTE OF ADDRESS OF NEXT BASIC LINE
1060 85a3 97 00                        STA  ENDFLG         ; SAVE IN STOP/END FLAG - CAUSE A STOP IF
1061                         *                             ; NEXT LINE ADDRESS IS < $8000; CAUSE
1062                         *                             ; AN END IF ADDRESS > $8000
1063 85a5 27 72                        BEQ  LAE15          ; BRANCH TO 'STOP' - END OF PROGRAM
1064 85a7 ec 80                        LDD  ,X+            ; GET CURRENT LINE NUMBER
1065 85a9 dd 68                        STD  CURLIN         ; SAVE IN CURLIN
1066 85ab 9f 82                        STX  CHARAD         ; SAVE ADDRESS OF FIRST BYTE OF LINE
1067                         * EXTENDED BASIC TRACE
1068 85ad 96 8b                        LDA  TRCFLG         ; TEST THE TRACE FLAG
1069 85af 27 0f                        BEQ  LADC0          ; BRANCH IF TRACE OFF
1070 85b1 86 5b                        LDA  #$5B           ; <LEFT HAND MARKER FOR TRON LINE NUMBER
1071 85b3 bd 80 31                     JSR  PUTCHR         ; OUTPUT A CHARACTER
1072 85b6 96 68                        LDA  CURLIN         ; GET MS BYTE OF LINE NUMBER
1073 85b8 bd 95 78                     JSR  LBDCC          ; CONVERT ACCD TO DECIMAL AND PRINT ON SCREEN
1074 85bb 86 5d                        LDA  #$5D           ; > RIGHT HAND MARKER FOR TRON LINE NUMBER
1075 85bd bd 80 31                     JSR  PUTCHR         ; OUTPUT A CHARACTER
1076                         * END OF EXTENDED BASIC TRACE
1077 85c0 9d 7b              LADC0     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1078 85c2 8d 02                        BSR  LADC6          ; GO PROCESS COMMAND
1079 85c4 20 ca                        BRA  LAD9E          ; GO BACK TO MAIN LOOP
1080 85c6 27 29              LADC6     BEQ  LADEA          ; RETURN IF END OF LINE (RTS - was BEQ LAE40)
1081 85c8 4d                           TSTA                ; CHECK FOR TOKEN - BIT 7 SET (NEGATIVE)
1082 85c9 10 2a 01 b8                  LBPL LET            ; BRANCH IF NOT A TOKEN - GO DO A 'LET' WHICH
1083                         *                             ; IS THE 'DEFAULT' TOKEN FOR MICROSOFT BASIC
1084 85cd 81 ff                        CMPA #$FF           ; SECONDARY TOKEN
1085 85cf 27 0f                        BEQ  SECTOK
1086 85d1 81 a1                        CMPA #TOK_HIGH_EXEC ; SKIPF TOKEN - HIGHEST EXECUTABLE COMMAND IN BASIC
1087 85d3 22 c9                        BHI  LADB1          ; 'SYNTAX ERROR' IF NON-EXECUTABLE TOKEN
1088 85d5 be 80 bc                     LDX  COMVEC+3       ; GET ADDRESS OF BASIC'S COMMAND TABLE
1089 85d8 48                 LADD4     ASLA                ; X2 (2 BYTE/JUMP ADDRESS) & DISCARD BIT 7
1090 85d9 1f 89                        TFR  A,B            ; SAVE COMMAND OFFSET IN ACCB
1091 85db 3a                           ABX                 ; NON X POINTS TO COMMAND JUMP ADDR
1092 85dc 9d 7b                        JSR  GETNCH         ; GET AN INPUT CHAR
1093                         *
1094                         * HERE IS WHERE WE BRANCH TO DO A 'COMMAND'
1095 85de 6e 94                        JMP  [,X]           ; GO DO A COMMAND
1096                         SECTOK
1097                         * THE ONLY SECONDARY TOKEN THAT CAN ALSO BE AN EXECUTABLE IS
1098                         * THE MID$ REPLACEMENT STATEMENT. SO SPECIAL-CASE CHECK DONE HERE
1099 85e0 9d 7b                        JSR  GETNCH         ; GET AN INPUT CHAR
1100 85e2 81 97                        CMPA #TOK_MID       ; TOKEN FOR "MID$"
1101 85e4 10 27 15 04                  LBEQ L86D6          ; PROCESS MID$ REPLACEMENT
1102 85e8 7e 8a 4f                     JMP  LB277          ; SYNTAX ERROR
1103                         
1104                         *
1105                         * RESTORE
1106 85eb 9e 19              RESTOR    LDX  TXTTAB         ; BEGINNING OF PROGRAM ADDRESS
1107 85ed 30 1f                        LEAX -1,X           ; MOVE TO ONE BYTE BEFORE PROGRAM
1108 85ef 9f 33              LADE8     STX  DATPTR         ; SAVE NEW DATA POINTER
1109 85f1 39                 LADEA     RTS
1110                         *
1111                         * BREAK CHECK
1112 85f2 bd 80 24           LADEB     JSR  LA1C1          ; GET A KEYSTROKE ENTRY
1113 85f5 27 0a                        BEQ  LADFA          ; RETURN IF NO INPUT
1114 85f7 81 03              LADF0     CMPA #3             ; CONTROL C? (BREAK)
1115 85f9 27 12                        BEQ  STOP           ; YES
1116 85fb 81 13                        CMPA #$13           ; CONTROL S? (PAUSE)
1117 85fd 27 03                        BEQ  LADFB          ; YES
1118 85ff 97 72                        STA  IKEYIM         ; SAVE KEYSTROKE IN INKEY IMAGE
1119 8601 39                 LADFA     RTS
1120 8602 bd 80 24           LADFB     JSR  KEYIN          ; GET A KEY
1121 8605 27 fb                        BEQ  LADFB          ; BRANCH IF NO KEY DOWN
1122 8607 20 ee                        BRA  LADF0          ; CONTINUE - DO A BREAK CHECK
1123                         *
1124                         * END
1125 8609 9d 81              END       JSR  GETCCH         ; GET CURRENT INPUT CHAR
1126 860b 20 02                        BRA  LAE0B
1127                         *
1128                         * STOP
1129 860d 1a 01              STOP      ORCC #$01           ; SET CARRY FLAG
1130 860f 26 31              LAE0B     BNE  LAE40          ; BRANCH IF ARGUMENT EXISTS
1131 8611 9e 82                        LDX  CHARAD         ; * SAVE CURRENT POSITION OF
1132 8613 9f 2f                        STX  TINPTR         ; * BASIC'S INPUT POINTER
1133 8615 06 00              LAE11     ROR  ENDFLG         ; ROTATE CARRY INTO BIT 7 OF STOP/END FLAG
1134 8617 32 62                        LEAS 2,S            ; PURGE RETURN ADDRESS OFF STACK
1135 8619 9e 68              LAE15     LDX  CURLIN         ; GET CURRENT LINE NUMBER
1136 861b 8c ff ff                     CMPX #$FFFF         ; DIRECT MODE?
1137 861e 27 06                        BEQ  LAE22          ; YES
1138 8620 9f 29                        STX  OLDTXT         ; SAVE CURRENT LINE NUMBER
1139 8622 9e 2f                        LDX  TINPTR         ; * GET AND SAVE CURRENT POSITION
1140 8624 9f 2d                        STX  OLDPTR         ; * OF BASIC'S INPUT POINTER
1141                         LAE22
1142 8626 8e 83 f9                     LDX  #LABF2-1       ; POINT TO CR, 'BREAK' MESSAGE
1143 8629 0d 00                        TST  ENDFLG         ; CHECK STOP/END FLAG
1144 862b 10 2a fe 3e                  LBPL LAC73          ; BRANCH TO MAIN LOOP OF BASIC IF END
1145 862f 7e 84 62                     JMP  LAC68          ; PRINT 'BREAK AT ####' AND GO TO
1146                         *                             ; BASIC'S MAIN LOOP IF 'STOP'
1147                         
1148                         * CONT
1149 8632 26 0e              CONT      BNE  LAE40          ; RETURN IF ARGUMENT GIVEN
1150 8634 c6 20                        LDB  #2*16          ; 'CAN'T CONTINUE' ERROR
1151 8636 9e 2d                        LDX  OLDPTR         ; GET CONTINUE ADDRESS (INPUT POINTER)
1152 8638 10 27 fe 12                  LBEQ LAC46          ; 'CN' ERROR IF CONTINUE ADDRESS = 0
1153 863c 9f 82                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1154 863e 9e 29                        LDX  OLDTXT         ; GET LINE NUMBER
1155 8640 9f 68                        STX  CURLIN         ; RESET CURRENT LINE NUMBER
1156 8642 39                 LAE40     RTS
1157                         *
1158                         * CLEAR
1159 8643 27 2c              CLEAR     BEQ  LAE6F          ; BRANCH IF NO ARGUMENT
1160 8645 bd 8b b9                     JSR  LB3E6          ; EVALUATE ARGUMENT
1161 8648 34 06                        PSHS B,A            ; SAVE AMOUNT OF STRING SPACE ON STACK
1162 864a 9e 27                        LDX  MEMSIZ         ; GET CURRENT TOP OF CLEARED SPACE
1163 864c 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1164 864e 27 0c                        BEQ  LAE5A          ; BRANCH IF NO NEW TOP OF CLEARED SPACE
1165 8650 bd 8a 45                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
1166 8653 bd 8f 10                     JSR  LB73D          ; EVALUATE EXPRESSlON; RETURN VALUE IN X
1167 8656 30 1f                        LEAX -1,X           ; X = TOP OF CLEARED SPACE
1168 8658 9c 70                        CMPX TOPRAM         ; COMPARE TO TOP OF RAM
1169 865a 22 18                        BHI  LAE72          ; 'OM' ERROR IF > TOP OF RAM
1170 865c 1f 10              LAE5A     TFR  X,D            ; ACCD = TOP OF CLEARED SPACE
1171 865e a3 e1                        SUBD ,S++           ; SUBTRACT OUT AMOUNT OF CLEARED SPACE
1172 8660 25 12                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
1173 8662 1f 03                        TFR  D,U            ; U = BOTTOM OF CLEARED SPACE
1174 8664 83 00 3a                     SUBD #STKBUF        ; SUBTRACT OUT STACK BUFFER
1175 8667 25 0b                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
1176 8669 93 1b                        SUBD VARTAB         ; SUBTRACT OUT START OF VARIABLES
1177 866b 25 07                        BCS  LAE72          ; 'OM' ERROR IF FREE MEM < 0
1178 866d df 21                        STU  FRETOP         ; SAVE NEW BOTTOM OF CLEARED SPACE
1179 866f 9f 27                        STX  MEMSIZ         ; SAVE NEW TOP OF CLEARED SPACE
1180 8671 7e 85 18           LAE6F     JMP  LAD26          ; ERASE ALL VARIABLES, INITIALIZE POINTERS, ETC
1181 8674 7e 84 4c           LAE72     JMP  LAC44          ; 'OM' ERROR
1182                         *
1183                         * RUN
1184 8677 9d 81              RUN       JSR  GETCCH         ; * GET CURRENT INPUT CHARACTER
1185 8679 10 27 fe 96                  LBEQ LAD21          ; * IF NO LINE NUMBER
1186 867d bd 85 18                     JSR  LAD26          ; ERASE ALL VARIABLES
1187 8680 20 19                        BRA  LAE9F          ; 'GOTO' THE RUN ADDRESS
1188                         *
1189                         * GO
1190 8682 1f 89              GO        TFR  A,B            ; SAVE INPUT CHARACTER IN ACCB
1191 8684 9d 7b              LAE88     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1192 8686 c1 a3                        CMPB #TOK_TO        ; 'TO' TOKEN
1193 8688 27 16                        BEQ  LAEA4          ; BRANCH IF GOTO
1194 868a c1 a4                        CMPB #TOK_SUB       ; 'SUB' TOKEN
1195 868c 26 45                        BNE  LAED7          ; 'SYNTAX ERROR' IF NEITHER
1196 868e c6 03                        LDB  #3             ; =ROOM FOR 6
1197 8690 bd 84 3b                     JSR  LAC33          ; =BYTES ON STACK?
1198 8693 de 82                        LDU  CHARAD         ; * SAVE CURRENT BASIC INPUT POINTER, LINE
1199 8695 9e 68                        LDX  CURLIN         ; * NUMBER AND SUB TOKEN ON STACK
1200 8697 86 a4                        LDA  #TOK_SUB       ; *
1201 8699 34 52                        PSHS U,X,A          ; *
1202 869b 8d 03              LAE9F     BSR  LAEA4          ; GO DO A 'GOTO'
1203 869d 7e 85 90                     JMP  LAD9E          ; JUMP BACK TO BASIC'S MAIN LOOP
1204                         * GOTO
1205 86a0 9d 81              LAEA4     JSR  GETCCH         ; GET CURRENT INPUT CHAR
1206 86a2 bd 87 63                     JSR  LAF67          ; GET LINE NUMBER TO BINARY IN BINVAL
1207 86a5 8d 40                        BSR  LAEEB          ; ADVANCE BASIC'S POINTER TO END OF LINE
1208 86a7 30 01                        LEAX $01,X          ; POINT TO START OF NEXT LINE
1209 86a9 dc 2b                        LDD  BINVAL         ; GET THE LINE NUMBER TO RUN
1210 86ab 10 93 68                     CMPD CURLIN         ; COMPARE TO CURRENT LINE NUMBER
1211 86ae 22 02                        BHI  LAEB6          ; IF REO'D LINE NUMBER IS > CURRENT LINE NUMBER,
1212                         *              ; DON'T START LOOKING FROM
1213                         *              ; START OF PROGRAM
1214 86b0 9e 19                        LDX  TXTTAB         ; BEGINNING OF PROGRAM
1215 86b2 bd 84 f7           LAEB6     JSR  LAD05          ; GO FIND A LINE NUMBER
1216 86b5 25 17                        BCS  LAED2          ; 'UNDEFINED LINE NUMBER'
1217 86b7 30 1f              LAEBB     LEAX -1,X           ; MOVE BACK TO JUST BEFORE START OF LINE
1218 86b9 9f 82                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1219 86bb 39                 LAEBF     RTS
1220                         *
1221                         * RETURN
1222 86bc 26 fd              RETURN    BNE  LAEBF          ; EXIT ROUTINE IF ARGUMENT GIVEN
1223 86be 86 ff                        LDA  #$FF           ; * PUT AN ILLEGAL VARIABLE NAME IN FIRST BYTE OF
1224 86c0 97 3b                        STA  VARDES         ; * VARDES WHICH WILL CAUSE 'FOR/NEXT' DATA ON THE
1225                         *              ; STACK TO BE IGNORED
1226 86c2 bd 84 01                     JSR  LABF9          ; CHECK FOR RETURN DATA ON THE STACK
1227 86c5 1f 14                        TFR  X,S            ; RESET STACK POINTER - PURGE TWO RETURN ADDRESSES
1228                         *              ; FROM THE STACK
1229 86c7 81 24                        CMPA #TOK_SUB-$80   ; SUB TOKEN - $80
1230 86c9 27 0b                        BEQ  LAEDA          ; BRANCH IF 'RETURN' FROM SUBROUTINE
1231 86cb c6 04                        LDB  #2*2           ; ERROR #2 'RETURN WITHOUT GOSUB'
1232 86cd 8c                           FCB  SKP2           ; SKIP TWO BYTES
1233 86ce c6 0e              LAED2     LDB  #7*2           ; ERROR #7 'UNDEFINED LINE NUMBER'
1234 86d0 7e 84 4e                     JMP  LAC46          ; JUMP TO ERROR HANDLER
1235 86d3 7e 8a 4f           LAED7     JMP  LB277          ; 'SYNTAX ERROR'
1236 86d6 35 52              LAEDA     PULS A,X,U          ; * RESTORE VALUES OF CURRENT LINE NUMBER AND
1237 86d8 9f 68                        STX  CURLIN         ; * BASIC'S INPUT POINTER FOR THIS SUBROUTINE
1238 86da df 82                        STU  CHARAD         ; * AND LOAD ACCA WITH SUB TOKEN ($A6)
1239                         *
1240                         * DATA
1241 86dc 8d 06              DATA      BSR  LAEE8          ; MOVE INPUT POINTER TO END OF SUBLINE OR LINE
1242 86de 8c                           FCB  SKP2           ; SKIP 2 BYTES
1243                         
1244                         * REM, ELSE
1245                         ELSE
1246 86df 8d 06              REM       BSR  LAEEB          ; MOVE INPUT POINTER TO END OF LINE
1247 86e1 9f 82                        STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1248 86e3 39                 LAEE7     RTS
1249                         * ADVANCE INPUT POINTER TO END OF SUBLINE OR LINE
1250 86e4 c6 3a              LAEE8     LDB  #':            ; COLON = SUBLINE TERMINATOR CHARACTER
1251 86e6 86                 LAEEA     FCB  SKP1LD         ; SKPILD SKIP ONE BYTE; LDA #$5F
1252                         * ADVANCE BASIC'S INPUT POINTER TO END OF
1253                         * LINE - RETURN ADDRESS OF END OF LINE+1 IN X
1254 86e7 5f                 LAEEB     CLRB                ; 0 = LINE TERMINATOR CHARACTER
1255 86e8 d7 01                        STB  CHARAC         ; TEMP STORE PRIMARY TERMINATOR CHARACTER
1256 86ea 5f                           CLRB                ; 0 (END OF LINE) = ALTERNATE TERM. CHAR.
1257 86eb 9e 82                        LDX  CHARAD         ; LOAD X W/BASIC'S INPUT POINTER
1258 86ed 1f 98              LAEF1     TFR  B,A            ; * CHANGE TERMINATOR CHARACTER
1259 86ef d6 01                        LDB  CHARAC         ; * FROM ACCB TO CHARAC - SAVE OLD TERMINATOR
1260                         *         IN   CHARAC
1261 86f1 97 01                        STA  CHARAC         ; SWAP PRIMARY AND SECONDARY TERMINATORS
1262 86f3 a6 84              LAEF7     LDA  ,X             ; GET NEXT INPUT CHARACTER
1263 86f5 27 ec                        BEQ  LAEE7          ; RETURN IF 0 (END OF LINE)
1264 86f7 34 04                        PSHS B              ; SAVE TERMINATOR ON STACK
1265 86f9 a1 e0                        CMPA ,S+            ; COMPARE TO INPUT CHARACTER
1266 86fb 27 e6                        BEQ  LAEE7          ; RETURN IF EQUAL
1267 86fd 30 01                        LEAX 1,X            ; MOVE POINTER UP ONE
1268 86ff 81 22                        CMPA #'"            ; CHECK FOR DOUBLE QUOTES
1269 8701 27 ea                        BEQ  LAEF1          ; BRANCH IF " - TOGGLE TERMINATOR CHARACTERS
1270 8703 4c                           INCA                ; * CHECK FOR $FF AND BRANCH IF
1271 8704 26 02                        BNE  LAF0C          ; * NOT SECONDARY TOKEN
1272 8706 30 01                        LEAX 1,X            ; MOVE INPUT POINTER 1 MORE IF SECONDARY
1273 8708 81 86              LAF0C     CMPA #TOK_IF+1      ; TOKEN FOR IF?
1274 870a 26 e7                        BNE  LAEF7          ; NO - GET ANOTHER INPUT CHARACTER
1275 870c 0c 04                        INC  IFCTR          ; INCREMENT IF COUNTER - KEEP TRACK OF HOW MANY
1276                         *                             ; 'IF' STATEMENTS ARE NESTED IN ONE LINE
1277 870e 20 e3                        BRA  LAEF7          ; GET ANOTHER INPUT CHARACTER
1278                         
1279                         * IF
1280 8710 bd 89 19           IF        JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
1281 8713 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1282 8715 81 81                        CMPA #TOK_GO        ; TOKEN FOR GO
1283 8717 27 05                        BEQ  LAF22          ; TREAT 'GO' THE SAME AS 'THEN'
1284 8719 c6 a5                        LDB  #TOK_THEN      ; TOKEN FOR THEN
1285 871b bd 8a 47                     JSR  LB26F          ; DO A SYNTAX CHECK ON ACCB
1286 871e 96 4f              LAF22     LDA  FP0EXP         ; CHECK FOR TRUE/FALSE - FALSE IF FPA0 EXPONENT = ZERO
1287 8720 26 13                        BNE  LAF39          ; BRANCH IF CONDITION TRUE
1288 8722 0f 04                        CLR  IFCTR          ; CLEAR FLAG - KEEP TRACK OF WHICH NESTED ELSE STATEMENT
1289                         *                             ; TO SEARCH FOR IN NESTED 'IF' LOOPS
1290 8724 8d b6              LAF28     BSR  DATA           ; MOVE BASIC'S POINTER TO END OF SUBLINE
1291 8726 4d                           TSTA                ; * CHECK TO SEE IF END OF LINE OR SUBLINE
1292 8727 27 ba                        BEQ  LAEE7          ; * AND RETURN IF END OF LINE
1293 8729 9d 7b                        JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
1294 872b 81 84                        CMPA #TOK_ELSE      ; TOKEN FOR ELSE
1295 872d 26 f5                        BNE  LAF28          ; IGNORE ALL DATA EXCEPT 'ELSE' UNTIL
1296                         *                             ; END OF LINE (ZERO BYTE)
1297 872f 0a 04                        DEC  IFCTR          ; CHECK TO SEE IF YOU MUST SEARCH ANOTHER SUBLINE
1298 8731 2a f1                        BPL  LAF28          ; BRANCH TO SEARCH ANOTHER SUBLINE FOR 'ELSE'
1299 8733 9d 7b                        JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
1300 8735 9d 81              LAF39     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1301 8737 10 25 ff 65                  LBCS LAEA4          ; BRANCH TO 'GOTO' IF NUMERIC CHARACTER
1302 873b 7e 85 c6                     JMP  LADC6          ; RETURN TO MAIN INTERPRETATION LOOP
1303                         
1304                         * ON
1305 873e bd 8e de           ON        JSR  LB70B          ; EVALUATE EXPRESSION
1306 8741 c6 81                        LDB  #TOK_GO        ; TOKEN FOR GO
1307 8743 bd 8a 47                     JSR  LB26F          ; SYNTAX CHECK FOR GO
1308 8746 34 02                        PSHS A              ; SAVE NEW TOKEN (TO,SUB)
1309 8748 81 a4                        CMPA #TOK_SUB       ; TOKEN FOR SUB?
1310 874a 27 04                        BEQ  LAF54          ; YES
1311 874c 81 a3                        CMPA #TOK_TO        ; TOKEN FOR TO?
1312 874e 26 83              LAF52     BNE  LAED7          ; 'SYNTAX' ERROR IF NOT 'SUB' OR 'TO'
1313 8750 0a 53              LAF54     DEC  FPA0+3         ; DECREMENT IS BYTE OF MANTISSA OF FPA0 - THIS
1314                         *                             ; IS THE ARGUMENT OF THE 'ON' STATEMENT
1315 8752 26 05                        BNE  LAF5D          ; BRANCH IF NOT AT THE PROPER GOTO OR GOSUB LINE NUMBER
1316 8754 35 04                        PULS B              ; GET BACK THE TOKEN FOLLOWING 'GO'
1317 8756 7e 86 84                     JMP  LAE88          ; GO DO A 'GOTO' OR 'GOSUB'
1318 8759 9d 7b              LAF5D     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1319 875b 8d 06                        BSR  LAF67          ; CONVERT BASIC LINE NUMBER TO BINARY
1320 875d 81 2c                        CMPA #',            ; IS CHARACTER FOLLOWING LINE NUMBER A COMMA?
1321 875f 27 ef                        BEQ  LAF54          ; YES
1322 8761 35 84                        PULS B,PC           ; IF NOT, FALL THROUGH TO NEXT COMMAND
1323 8763 9e 73              LAF67     LDX  ZERO           ; DEFAULT LINE NUMBER OF ZERO
1324 8765 9f 2b                        STX  BINVAL         ; SAVE IT IN BINVAL
1325                         *
1326                         * CONVERT LINE NUMBER TO BINARY - RETURN VALUE IN BINVAL
1327                         *
1328 8767 24 61              LAF6B     BCC  LAFCE          ; RETURN IF NOT NUMERIC CHARACTER
1329 8769 80 30                        SUBA #'0            ; MASK OFF ASCII
1330 876b 97 01                        STA  CHARAC         ; SAVE DIGIT IN VO1
1331 876d dc 2b                        LDD  BINVAL         ; GET ACCUMULATED LINE NUMBER VALUE
1332 876f 81 18                        CMPA #24            ; LARGEST LINE NUMBER IS $F9FF (63999) -
1333                         *         (24*256+255)*10+9
1334 8771 22 db                        BHI  LAF52          ; 'SYNTAX' ERROR IF TOO BIG
1335                         * MULT ACCD X 10
1336 8773 58                           ASLB                ; *
1337 8774 49                           ROLA                ; * TIMES 2
1338 8775 58                           ASLB                ; =
1339 8776 49                           ROLA                ; = TIMES 4
1340 8777 d3 2b                        ADDD BINVAL         ; ADD 1 = TIMES 5
1341 8779 58                           ASLB                ; *
1342 877a 49                           ROLA                ; * TIMES 10
1343 877b db 01                        ADDB CHARAC         ; ADD NEXT DIGIT
1344 877d 89 00                        ADCA #0             ; PROPAGATE CARRY
1345 877f dd 2b                        STD  BINVAL         ; SAVE NEW ACCUMULATED LINE NUMBER
1346 8781 9d 7b                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
1347 8783 20 e2                        BRA  LAF6B          ; LOOP- PROCESS NEXT DIGIT
1348                         *
1349                         * LET (EXBAS)
1350                         * EVALUATE A NON-TOKEN EXPRESSION
1351                         * TARGET = REPLACEMENT
1352 8785 bd 8b 2a           LET       JSR  LB357          ; FIND TARGET VARIABLE DESCRIPTOR
1353 8788 9f 3b                        STX  VARDES         ; SAVE DESCRIPTOR ADDRESS OF 1ST EXPRESSION
1354 878a c6 b1                        LDB  #TOK_EQUALS    ; TOKEN FOR "="
1355 878c bd 8a 47                     JSR  LB26F          ; DO A SYNTAX CHECK FOR '='
1356 878f 96 06                        LDA  VALTYP         ; * GET VARIABLE TYPE AND
1357 8791 34 02                        PSHS A              ; * SAVE ON THE STACK
1358 8793 bd 89 2e                     JSR  LB156          ; EVALUATE EXPRESSION
1359 8796 35 02                        PULS A              ; * REGET VARIABLE TYPE OF 1ST EXPRESSION AND
1360 8798 46                           RORA                ; * SET CARRY IF STRING
1361 8799 bd 89 20                     JSR  LB148          ; TYPE CHECK-TM ERROR IF VARIABLE TYPES ON
1362                         *                             ; BOTH SIDES OF EQUALS SIGN NOT THE SAME
1363 879c 10 27 0c 3f                  LBEQ LBC33          ; GO PUT FPA0 INTO VARIABLE DESCRIPTOR IF NUMERIC
1364                         * MOVE A STRING WHOSE DESCRIPTOR IS LOCATED AT
1365                         * FPA0+2 INTO THE STRING SPACE. TRANSFER THE
1366                         * DESCRIPTOR ADDRESS TO THE ADDRESS IN VARDES
1367                         * DON'T MOVE THE STRING IF IT IS ALREADY IN THE
1368                         * STRING SPACE. REMOVE DESCRIPTOR FROM STRING
1369                         * STACK IF IT IS LAST ONE ON THE STACK
1370 87a0 9e 52              LAFA4     LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF REPLACEMENT STRING
1371 87a2 dc 21                        LDD  FRETOP         ; LOAD ACCD WITH START OF STRING SPACE
1372 87a4 10 a3 02                     CMPD 2,X            ; IS THE STRING IN STRING SPACE?
1373 87a7 24 11                        BCC  LAFBE          ; BRANCH IF IT'S NOT IN THE STRING SPACE
1374 87a9 9c 1b                        CMPX VARTAB         ; COMPARE DESCRIPTOR ADDRESS TO START OF VARIABLES
1375 87ab 25 0d                        BCS  LAFBE          ; BRANCH IF DESCRIPTOR ADDRESS NOT IN VARIABLES
1376 87ad e6 84              LAFB1     LDB  ,X             ; GET LENGTH OF REPLACEMENT STRING
1377 87af bd 8c e0                     JSR  LB50D          ; RESERVE ACCB BYTES OF STRING SPACE
1378 87b2 9e 4d                        LDX  V4D            ; GET DESCRIPTOR ADDRESS BACK
1379 87b4 bd 8e 16                     JSR  LB643          ; MOVE STRING INTO STRING SPACE
1380 87b7 8e 00 56                     LDX  #STRDES        ; POINT X TO TEMP STRING DESCRIPTOR ADDRESS
1381 87ba 9f 4d              LAFBE     STX  V4D            ; SAVE STRING DESCRIPTOR ADDRESS IN V4D
1382 87bc bd 8e 48                     JSR  LB675          ; REMOVE STRING DESCRIPTOR IF LAST ONE
1383                         *              ; ON STRING STACK
1384 87bf de 4d                        LDU  V4D            ; POINT U TO REPLACEMENT DESCRIPTOR ADDRESS
1385 87c1 9e 3b                        LDX  VARDES         ; GET TARGET DESCRIPTOR ADDRESS
1386 87c3 37 26                        PULU A,B,Y          ; GET LENGTH AND START OF REPLACEMENT STRING
1387 87c5 a7 84                        STA  ,X             ; * SAVE STRING LENGTH AND START IN
1388 87c7 10 af 02                     STY  2,X            ; * TARGET DESCRIPTOR LOCATION
1389 87ca 39                 LAFCE     RTS
1390                         
1391 87cb 3f 52 45 44 4f     LAFCF     FCC  "?REDO"        ; ?REDO MESSAGE
1392 87d0 0d 00                        FCB  CR,$00
1393                         
1394                         LAFD6
1395 87d2 7e 84 4e           LAFDC     JMP  LAC46          ; JMP TO ERROR HANDLER
1396 87d5 96 09              LAFDF     LDA  INPFLG         ; = GET THE INPUT FLAG AND BRANCH
1397 87d7 27 07                        BEQ  LAFEA          ; = IF 'INPUT'
1398 87d9 9e 31                        LDX  DATTXT         ; * GET LINE NUMBER WHERE THE ERROR OCCURRED
1399 87db 9f 68                        STX  CURLIN         ; * AND USE IT AS THE CURRENT LINE NUMBER
1400 87dd 7e 8a 4f                     JMP  LB277          ; 'SYNTAX ERROR'
1401 87e0 8e 87 ca           LAFEA     LDX  #LAFCF-1       ; * POINT X TO '?REDO' AND PRINT
1402 87e3 bd 91 48                     JSR  LB99C          ; * IT ON THE SCREEN
1403 87e6 9e 2f                        LDX  TINPTR         ; = GET THE SAVED ABSOLUTE ADDRESS OF
1404 87e8 9f 82                        STX  CHARAD         ; = INPUT POINTER AND RESTORE IT
1405 87ea 39                           RTS
1406                         *
1407                         * INPUT
1408 87eb c6 16              INPUT     LDB  #11*2          ; 'ID' ERROR
1409 87ed 9e 68                        LDX  CURLIN         ; GET CURRENT LINE NUMBER
1410 87ef 30 01                        LEAX 1,X            ; ADD ONE
1411 87f1 27 df                        BEQ  LAFDC          ; 'ID' ERROR BRANCH IF DIRECT MODE
1412 87f3 8d 01                        BSR  LB00F          ; GET SOME INPUT DATA - WAS LB002
1413 87f5 39                           RTS
1414 87f6 81 22              LB00F     CMPA #'"            ; CHECK FOR PROMPT STRING DELIMITER
1415 87f8 26 0b                        BNE  LB01E          ; BRANCH IF NO PROMPT STRING
1416 87fa bd 8a 1c                     JSR  LB244          ; PUT PROMPT STRING ON STRING STACK
1417 87fd c6 3b                        LDB  #';            ; *
1418 87ff bd 8a 47                     JSR  LB26F          ; * DO A SYNTAX CHECK FOR SEMICOLON
1419 8802 bd 91 4b                     JSR  LB99F          ; PRINT MESSAGE TO CONSOLE OUT
1420 8805 8e 00 e0           LB01E     LDX  #LINBUF        ; POINT TO BASIC'S LINE BUFFER
1421 8808 6f 84                        CLR  ,X             ; CLEAR 1ST BYTE - FLAG TO INDICATE NO DATA
1422                         *              ; IN LINE BUFFER
1423 880a 8d 06                        BSR  LB02F          ; INPUT A STRING TO LINE BUFFER
1424 880c c6 2c                        LDB  #',            ; * INSERT A COMMA AT THE END
1425 880e e7 84                        STB  ,X             ; * OF THE LINE INPUT BUFFER
1426 8810 20 16                        BRA  LB049
1427                         * FILL BASIC'S LINE INPUT BUFFER CONSOLE IN
1428 8812 bd 91 5b           LB02F     JSR  LB9AF          ; SEND A "?" TO CONSOLE OUT
1429 8815 bd 91 58                     JSR  LB9AC          ; SEND A 'SPACE' TO CONSOLE OUT
1430 8818 bd 81 09           LB035     JSR  LA390          ; GO READ IN A BASIC LINE
1431 881b 24 05                        BCC  LB03F          ; BRANCH IF ENTER KEY ENDED ENTRY
1432 881d 32 64                        LEAS 4,S            ; PURGE TWO RETURN ADDRESSES OFF THE STACK
1433 881f 7e 86 15                     JMP  LAE11          ; GO DO A 'STOP' IF BREAK KEY ENDED LINE ENTRY
1434 8822 c6 2e              LB03F     LDB  #2*23          ; 'INPUT PAST END OF FILE' ERROR
1435 8824 39                           RTS
1436                         *
1437                         * READ
1438 8825 9e 33              READ      LDX  DATPTR         ; GET 'READ' START ADDRESS
1439 8827 86                           FCB  SKP1LD         ; SKIP ONE BYTE - LDA #*$4F
1440 8828 4f                 LB049     CLRA                ; 'INPUT' ENTRY POINT: INPUT FLAG = 0
1441 8829 97 09                        STA  INPFLG         ; SET INPUT FLAG; 0 = INPUT: <> 0 = READ
1442 882b 9f 35                        STX  DATTMP         ; SAVE 'READ' START ADDRESS/'INPUT' BUFFER START
1443 882d bd 8b 2a           LB04E     JSR  LB357          ; EVALUATE A VARIABLE
1444 8830 9f 3b                        STX  VARDES         ; SAVE DESCRIPTOR ADDRESS
1445 8832 9e 82                        LDX  CHARAD         ; * GET BASIC'S INPUT POINTER
1446 8834 9f 2b                        STX  BINVAL         ; * AND SAVE IT
1447 8836 9e 35                        LDX  DATTMP         ; GET 'READ' ADDRESS START/'INPUT' BUFFER POINTER
1448 8838 a6 84                        LDA  ,X             ; GET A CHARACTER FROM THE BASIC PROGRAM
1449 883a 26 09                        BNE  LB069          ; BRANCH IF NOT END OF LINE
1450 883c 96 09                        LDA  INPFLG         ; * CHECK INPUT FLAG AND BRANCH
1451 883e 26 51                        BNE  LB0B9          ; * IF LOOKING FOR DATA (READ)
1452                         * NO DATA IN 'INPUT' LINE BUFFER AND/OR INPUT
1453                         * NOT COMING FROM SCREEN
1454 8840 bd 91 5b                     JSR  LB9AF          ; SEND A '?' TO CONSOLE OUT
1455 8843 8d cd                        BSR  LB02F          ; FILL INPUT BUFFER FROM CONSOLE IN
1456 8845 9f 82              LB069     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1457 8847 9d 7b                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
1458 8849 d6 06                        LDB  VALTYP         ; * CHECK VARIABLE TYPE AND
1459 884b 27 23                        BEQ  LB098          ; * BRANCH IF NUMERIC
1460                         * READ/INPUT A STRING VARIABLE
1461 884d 9e 82                        LDX  CHARAD         ; LOAD X WITH CURRENT BASIC INPUT POINTER
1462 884f 97 01                        STA  CHARAC         ; SAVE CURRENT INPUT CHARACTER
1463 8851 81 22                        CMPA #'"            ; CHECK FOR STRING DELIMITER
1464 8853 27 0e                        BEQ  LB08B          ; BRANCH IF STRING DELIMITER
1465 8855 30 1f                        LEAX -1,X           ; BACK UP POINTER
1466 8857 4f                           CLRA                ; * ZERO = END OF LINE CHARACTER
1467 8858 97 01                        STA  CHARAC         ; * SAVE AS TERMINATOR
1468 885a bd 80 fb                     JSR  LA35F          ; SET UP PRINT PARAMETERS
1469 885d 86 3a                        LDA  #':            ; END OF SUBLINE CHARACTER
1470 885f 97 01                        STA  CHARAC         ; SAVE AS TERMINATOR I
1471 8861 86 2c                        LDA  #',            ; COMMA
1472 8863 97 02              LB08B     STA  ENDCHR         ; SAVE AS TERMINATOR 2
1473 8865 bd 8c f1                     JSR  LB51E          ; STRIP A STRING FROM THE INPUT BUFFER
1474 8868 bd 8a 21                     JSR  LB249          ; MOVE INPUT POINTER TO END OF STRING
1475 886b bd 87 a0                     JSR  LAFA4          ; PUT A STRING INTO THE STRING SPACE IF NECESSARY
1476 886e 20 06                        BRA  LB09E          ; CHECK FOR ANOTHER DATA ITEM
1477                         * SAVE A NUMERIC VALUE IN A READ OR INPUT DATA ITEM
1478 8870 bd 94 be           LB098     JSR  LBD12          ; CONVERT AN ASCII STRING TO FP NUMBER
1479 8873 bd 93 df                     JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS IN VARDES -
1480                         *                             ; INPUT OR READ DATA ITEM
1481 8876 9d 81              LB09E     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1482 8878 27 06                        BEQ  LB0A8          ; BRANCH IF END OF LINE
1483 887a 81 2c                        CMPA #',            ; CHECK FOR A COMMA
1484 887c 10 26 ff 52                  LBNE LAFD6          ; BAD FILE DATA' ERROR OR RETRY
1485 8880 9e 82              LB0A8     LDX  CHARAD         ; * GET CURRENT INPUT
1486 8882 9f 35                        STX  DATTMP         ; * POINTER (USED AS A DATA POINTER) AND SAVE IT
1487 8884 9e 2b                        LDX  BINVAL         ; * RESET INPUT POINTER TO INPUT OR
1488 8886 9f 82                        STX  CHARAD         ; * READ STATEMENT
1489 8888 9d 81                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
1490 888a 27 21                        BEQ  LB0D5          ; BRANCH IF END OF LINE - EXIT COMMAND
1491 888c bd 8a 45                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
1492 888f 20 9c                        BRA  LB04E          ; GET ANOTHER INPUT OR READ ITEM
1493                         * SEARCH FROM ADDRESS IN X FOR
1494                         * 1ST OCCURENCE OF THE TOKEN FOR DATA
1495 8891 9f 82              LB0B9     STX  CHARAD         ; RESET BASIC'S INPUT POINTER
1496 8893 bd 86 e4                     JSR  LAEE8          ; SEARCH FOR END OF CURRENT LINE OR SUBLINE
1497 8896 30 01                        LEAX 1,X            ; MOVE X ONE PAST END OF LINE
1498 8898 4d                           TSTA                ; CHECK FOR END OF LINE
1499 8899 26 0a                        BNE  LB0CD          ; BRANCH IF END OF SUBLINE
1500 889b c6 06                        LDB  #2*3           ; 'OUT OF DATA' ERROR
1501 889d ee 81                        LDU  ,X++           ; GET NEXT 2 CHARACTERS
1502 889f 27 41                        BEQ  LB10A          ; 'OD' ERROR IF END OF PROGRAM
1503 88a1 ec 81                        LDD  ,X++           ; GET BASIC LINE NUMBER AND
1504 88a3 dd 31                        STD  DATTXT         ; SAVE IT IN DATTXT
1505 88a5 a6 84              LB0CD     LDA  ,X             ; GET AN INPUT CHARACTER
1506 88a7 81 86                        CMPA #TOK_DATA      ; DATA TOKEN?
1507 88a9 26 e6                        BNE  LB0B9          ; NO - KEEP LOOKING
1508 88ab 20 98                        BRA  LB069          ; YES
1509                         * EXIT READ AND INPUT COMMANDS
1510 88ad 9e 35              LB0D5     LDX  DATTMP         ; GET DATA POINTER
1511 88af d6 09                        LDB  INPFLG         ; * CHECK INPUT FLAG
1512 88b1 10 26 fd 3a                  LBNE LADE8          ; * SAVE NEW DATA POINTER IF READ
1513 88b5 a6 84                        LDA  ,X             ; = CHECK NEXT CHARACTER IN 'INPUT' BUFFER
1514 88b7 27 06                        BEQ  LB0E7          ; =
1515 88b9 8e 88 bf                     LDX  #LB0E8-1       ; POINT X TO '?EXTRA IGNORED'
1516 88bc 7e 91 48                     JMP  LB99C          ; PRINT THE MESSAGE
1517 88bf 39                 LB0E7     RTS
1518                         
1519 88c0 3f 45 58 54 52 41  LB0E8     FCC  "?EXTRA IGNORED" ; ?EXTRA IGNORED MESSAGE
     20 49 47 4e 4f 52
     45 44
1520                         
1521                         
1522 88ce 0d 00                        FCB  CR,$00
1523                         
1524                         * NEXT
1525 88d0 26 04              NEXT      BNE  LB0FE          ; BRANCH IF ARGUMENT GIVEN
1526 88d2 9e 73                        LDX  ZERO           ; X = 0: DEFAULT FOR NO ARGUMENT
1527 88d4 20 03                        BRA  LB101
1528 88d6 bd 8b 2a           LB0FE     JSR  LB357          ; EVALUATE AN ALPHA EXPRESSION
1529 88d9 9f 3b              LB101     STX  VARDES         ; SAVE VARIABLE DESCRIPTOR POINTER
1530 88db bd 84 01                     JSR  LABF9          ; GO SCAN FOR 'FOR/NEXT' DATA ON STACK
1531 88de 27 04                        BEQ  LB10C          ; BRANCH IF DATA FOUND
1532 88e0 c6 00                        LDB  #0             ; 'NEXT WITHOUT FOR' ERROR (SHOULD BE CLRB)
1533 88e2 20 47              LB10A     BRA  LB153          ; PROCESS ERROR
1534 88e4 1f 14              LB10C     TFR  X,S            ; POINT S TO START OF 'FOR/NEXT' DATA
1535 88e6 30 03                        LEAX 3,X            ; POINT X TO FP VALUE OF STEP
1536 88e8 bd 93 c0                     JSR  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
1537 88eb a6 68                        LDA  8,S            ; GET THE DIRECTION OF STEP
1538 88ed 97 54                        STA  FP0SGN         ; SAVE IT AS THE SIGN OF FPA0
1539 88ef 9e 3b                        LDX  VARDES         ; POINT (X) TO INDEX VARIABLE DESCRIPTOR
1540 88f1 bd 91 6e                     JSR  LB9C2          ; ADD (X) TO FPA0 (STEP TO INDEX)
1541 88f4 bd 93 df                     JSR  LBC33          ; PACK FPA0 AND STORE IT IN ADDRESS
1542                         *                             ; CONTAINED IN VARDES
1543 88f7 30 69                        LEAX 9,S            ; POINT (X) TO TERMINAL VALUE OF INDEX
1544 88f9 bd 94 42                     JSR  LBC96          ; COMPARE CURRENT INDEX VALUE TO TERMINAL VALUE OF INDEX
1545 88fc e0 68                        SUBB 8,S            ; ACCB = 0 IF TERMINAL VALUE=CURRENT VALUE AND STEP=0 OR IF
1546                         *                             ; STEP IS POSITIVE AND CURRENT VALUE>TERMINAL VALUE OR
1547                         *                             ; STEP IS NEGATIVE AND CURRENT VALUE<TERMINAL VALUE
1548 88fe 27 0c                        BEQ  LB134          ; BRANCH IF 'FOR/NEXT' LOOP DONE
1549 8900 ae 6e                        LDX  14,S           ; * GET LINE NUMBER AND
1550 8902 9f 68                        STX  CURLIN         ; * BASIC POINTER OF
1551 8904 ae e8 10                     LDX  16,S           ; * STATEMENT FOLLOWING THE
1552 8907 9f 82                        STX  CHARAD         ; * PROPER FOR STATEMENT
1553 8909 7e 85 90           LB131     JMP  LAD9E          ; JUMP BACK TO COMMAND INTEPR. LOOP
1554 890c 32 e8 12           LB134     LEAS 18,S           ; PULL THE 'FOR-NEXT' DATA OFF THE STACK
1555 890f 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1556 8911 81 2c                        CMPA #',            ; CHECK FOR ANOTHER ARGUMENT
1557 8913 26 f4                        BNE  LB131          ; RETURN IF NONE
1558 8915 9d 7b                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
1559 8917 8d bd                        BSR  LB0FE          ; BSR SIMULATES A CALL TO 'NEXT' FROM COMMAND LOOP
1560                         
1561                         
1562 8919 8d 13              LB141     BSR  LB156          ; EVALUATE EXPRESSION AND DO A TYPE CHECK FOR NUMERIC
1563 891b 1c fe              LB143     ANDCC #$FE          ; CLEAR CARRY FLAG
1564 891d 7d                 LB145     FCB  $7D            ; OP CODE OF TST $1A01 - SKIP TWO BYTES (DO
1565                         *              ; NOT CHANGE CARRY FLAG)
1566 891e 1a 01              LB146     ORCC #1             ; SET CARRY
1567                         
1568                         * STRING TYPE MODE CHECK - IF ENTERED AT LB146 THEN VALTYP PLUS IS 'TM' ERROR
1569                         * NUMERIC TYPE MODE CHECK - IF ENTERED AT LB143 THEN VALTYP MINUS IS 'TM' ERROR
1570                         * IF ENTERED AT LB148, A TYPE CHECK IS DONE ON VALTYP
1571                         * IF ENTERED WITH CARRY SET, THEN 'TM' ERROR IF NUMERIC
1572                         * IF ENTERED WITH CARRY CLEAR, THEN 'TM' ERROR IF STRING.
1573 8920 0d 06              LB148     TST  VALTYP         ; TEST TYPE FLAG; DO NOT CHANGE CARRY
1574 8922 25 03                        BCS  LB14F          ; BRANCH IF STRING
1575 8924 2a 99                        BPL  LB0E7          ; RETURN ON PLUS
1576 8926 8c                           FCB  SKP2           ; SKIP 2 BYTES - 'TM' ERROR
1577 8927 2b 96              LB14F     BMI  LB0E7          ; RETURN ON MINUS
1578 8929 c6 18                        LDB  #12*2          ; 'TYPE M1SMATCH' ERROR
1579 892b 7e 84 4e           LB153     JMP  LAC46          ; PROCESS ERROR
1580                         * EVALUATE EXPRESSION
1581 892e 8d 6e              LB156     BSR  LB1C6          ; BACK UP INPUT POINTER
1582 8930 4f                 LB158     CLRA                ; END OF OPERATION PRECEDENCE FLAG
1583 8931 8c                           FCB  SKP2           ; SKIP TWO BYTES
1584 8932 34 04              LB15A     PSHS B              ; SAVE FLAG (RELATIONAL OPERATOR FLAG)
1585 8934 34 02                        PSHS A              ; SAVE FLAG (PRECEDENCE FLAG)
1586 8936 c6 01                        LDB  #1             ; *
1587 8938 bd 84 3b                     JSR  LAC33          ; * SEE IF ROOM IN FREE RAM FOR (B) WORDS
1588 893b bd 89 fb                     JSR  LB223          ; GO EVALUATE AN EXPRESSION
1589 893e 0f 3f                        CLR  TRELFL         ; RESET RELATIONAL OPERATOR FLAG
1590 8940 9d 81              LB168     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1591                         * CHECK FOR RELATIONAL OPERATORS
1592 8942 80 b0              LB16A     SUBA #TOK_GREATER   ; TOKEN FOR >
1593 8944 25 13                        BCS  LB181          ; BRANCH IF LESS THAN RELATIONAL OPERATORS
1594 8946 81 03                        CMPA #3             ; *
1595 8948 24 0f                        BCC  LB181          ; * BRANCH IF GREATER THAN RELATIONAL OPERATORS
1596 894a 81 01                        CMPA #1             ; SET CARRY IF '>'
1597 894c 49                           ROLA                ; CARRY TO BIT 0
1598 894d 98 3f                        EORA TRELFL         ; * CARRY SET IF
1599 894f 91 3f                        CMPA TRELFL         ; * TRELFL = ACCA
1600 8951 25 64                        BCS  LB1DF          ; BRANCH IF SYNTAX ERROR : == << OR >>
1601 8953 97 3f                        STA  TRELFL         ; BIT 0: >, BIT 1 =, BIT 2: <
1602 8955 9d 7b                        JSR  GETNCH         ; GET AN INPUT CHARACTER
1603 8957 20 e9                        BRA  LB16A          ; CHECK FOR ANOTHER RELATIONAL OPERATOR
1604                         *
1605 8959 d6 3f              LB181     LDB  TRELFL         ; GET RELATIONAL OPERATOR FLAG
1606 895b 26 33                        BNE  LB1B8          ; BRANCH IF RELATIONAL COMPARISON
1607 895d 10 24 00 6b                  LBCC LB1F4          ; BRANCH IF > RELATIONAL OPERATOR
1608 8961 8b 07                        ADDA #7             ; SEVEN ARITHMETIC/LOGICAL OPERATORS
1609 8963 24 67                        BCC  LB1F4          ; BRANCH IF NOT ARITHMETIC/LOGICAL OPERATOR
1610 8965 99 06                        ADCA VALTYP         ; ADD CARRY, NUMERIC FLAG AND MODIFIED TOKEN NUMBER
1611 8967 10 27 04 77                  LBEQ LB60F          ; BRANCH IF VALTYP = FF, AND ACCA = '+' TOKEN -
1612                         *                             ; CONCATENATE TWO STRINGS
1613 896b 89 ff                        ADCA #-1            ; RESTORE ARITHMETIC/LOGICAL OPERATOR NUMBER
1614 896d 34 02                        PSHS A              ; * STORE OPERATOR NUMBER ON STACK; MULTIPLY IT BY 2
1615 896f 48                           ASLA                ; * THEN ADD THE STORED STACK DATA = MULTIPLY
1616 8970 ab e0                        ADDA ,S+            ; * X 3; 3 BYTE/TABLE ENTRY
1617 8972 8e 82 42                     LDX  #LAA51         ; JUMP TABLE FOR ARITHMETIC & LOGICAL OPERATORS
1618 8975 30 86                        LEAX A,X            ; POINT X TO PROPER TABLE
1619 8977 35 02              LB19F     PULS A              ; GET PRECEDENCE FLAG FROM STACK
1620 8979 a1 84                        CMPA ,X             ; COMPARE TO CURRENT OPERATOR
1621 897b 24 55                        BCC  LB1FA          ; BRANCH IF STACK OPERATOR > CURRENT OPERATOR
1622 897d 8d 9c                        BSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
1623                         
1624                         * OPERATION BEING PROCESSED IS OF HIGHER PRECEDENCE THAN THE PREVIOUS OPERATION.
1625 897f 34 02              LB1A7     PSHS A              ; SAVE PRECEDENCE FLAG
1626 8981 8d 29                        BSR  LB1D4          ; PUSH OPERATOR ROUTINE ADDRESS AND FPA0 ONTO STACK
1627 8983 9e 3d                        LDX  RELPTR         ; GET POINTER TO ARITHMETIC/LOGICAL TABLE ENTRY FOR
1628                         *                             ; LAST CALCULATED OPERATION
1629 8985 35 02                        PULS A              ; GET PRECEDENCE FLAG OF PREVIOUS OPERATION
1630 8987 26 1d                        BNE  LB1CE          ; BRANCH IF NOT END OF OPERATION
1631 8989 4d                           TSTA                ; CHECK TYPE OF PRECEDENCE FLAG
1632 898a 10 27 00 6a                  LBEQ LB220          ; BRANCH IF END OF EXPRESSION OR SUB-EXPRESSION
1633 898e 20 4b                        BRA  LB203          ; EVALUATE AN OPERATION
1634                         
1635 8990 08 06              LB1B8     ASL  VALTYP         ; BIT 7 OF TYPE FLAG TO CARRY
1636 8992 59                           ROLB                ; SHIFT RELATIONAL FLAG LEFT - VALTYP TO BIT 0
1637 8993 8d 09                        BSR  LB1C6          ; MOVE THE INPUT POINTER BACK ONE
1638 8995 8e 89 a3                     LDX  #LB1CB         ; POINT X TO RELATIONAL COMPARISON JUMP TABLE
1639 8998 d7 3f                        STB  TRELFL         ; SAVE RELATIONAL COMPARISON DATA
1640 899a 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
1641 899c 20 d9                        BRA  LB19F          ; PERFORM OPERATION OR SAVE ON STACK
1642                         
1643 899e 9e 82              LB1C6     LDX  CHARAD         ; * GET BASIC'S INPUT POINTER AND
1644 89a0 7e 86 b7                     JMP  LAEBB          ; * MOVE IT BACK ONE
1645                         * RELATIONAL COMPARISON JUMP TABLE
1646 89a3 64                 LB1CB     FCB  $64            ; RELATIONAL COMPARISON FLAG
1647 89a4 8a c7              LB1CC     FDB  LB2F4          ; JUMP ADDRESS
1648                         
1649 89a6 a1 84              LB1CE     CMPA ,X             ; COMPARE PRECEDENCE OF LAST DONE OPERATION TO
1650                         *         NEXT TO BE DONE OPERATION
1651 89a8 24 31                        BCC  LB203          ; EVALUATE OPERATION IF LOWER PRECEDENCE
1652 89aa 20 d3                        BRA  LB1A7          ; PUSH OPERATION DATA ON STACK IF HIGHER PRECEDENCE
1653                         
1654                         * PUSH OPERATOR EVALUATION ADDRESS AND FPA0 ONTO STACK AND EVALUATE ANOTHER EXPR
1655 89ac ec 01              LB1D4     LDD  1,X            ; GET ADDRESS OF OPERATOR ROUTINE
1656 89ae 34 06                        PSHS B,A            ; SAVE IT ON THE STACK
1657 89b0 8d 08                        BSR  LB1E2          ; PUSH FPA0 ONTO STACK
1658 89b2 d6 3f                        LDB  TRELFL         ; GET BACK RELATIONAL OPERATOR FLAG
1659 89b4 16 ff 7b                     LBRA LB15A          ; EVALUATE ANOTHER EXPRESSION
1660 89b7 7e 8a 4f           LB1DF     JMP  LB277          ; 'SYNTAX ERROR'
1661                         * PUSH FPA0 ONTO THE STACK. ,S   = EXPONENT
1662                         * 1-2,S =HIGH ORDER MANTISSA 3-4,S = LOW ORDER MANTISSA
1663                         * 5,S = SIGN RETURN WITH PRECEDENCE CODE IN ACCA
1664 89ba d6 54              LB1E2     LDB  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
1665 89bc a6 84                        LDA  ,X             ; GET PRECEDENCE CODE TO ACCA
1666 89be 35 20              LB1E6     PULS Y              ; GET RETURN ADDRESS FROM STACK & PUT IT IN Y
1667 89c0 34 04                        PSHS B              ; SAVE ACCB ON STACK
1668 89c2 d6 4f              LB1EA     LDB  FP0EXP         ; * PUSH FPA0 ONTO THE STACK
1669 89c4 9e 50                        LDX  FPA0           ; *
1670 89c6 de 52                        LDU  FPA0+2         ; *
1671 89c8 34 54                        PSHS U,X,B          ; *
1672 89ca 6e a4                        JMP  ,Y             ; JUMP TO ADDRESS IN Y
1673                         
1674                         * BRANCH HERE IF NON-OPERATOR CHARACTER FOUND - USUALLY ')' OR END OF LINE
1675 89cc 9e 73              LB1F4     LDX  ZERO           ; POINT X TO DUMMY VALUE (ZERO)
1676 89ce a6 e0                        LDA  ,S+            ; GET PRECEDENCE FLAG FROM STACK
1677 89d0 27 26                        BEQ  LB220          ; BRANCH IF END OF EXPRESSION
1678 89d2 81 64              LB1FA     CMPA #$64           ; * CHECK FOR RELATIONAL COMPARISON FLAG
1679 89d4 27 03                        BEQ  LB201          ; * AND BRANCH IF RELATIONAL COMPARISON
1680 89d6 bd 89 1b                     JSR  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
1681 89d9 9f 3d              LB201     STX  RELPTR         ; SAVE POINTER TO OPERATOR ROUTINE
1682 89db 35 04              LB203     PULS B              ; GET RELATIONAL OPERATOR FLAG FROM STACK
1683 89dd 81 5a                        CMPA #$5A           ; CHECK FOR 'NOT' OPERATOR
1684 89df 27 19                        BEQ  LB222          ; RETURN IF 'NOT' - NO RELATIONAL COMPARISON
1685 89e1 81 7d                        CMPA #$7D           ; CHECK FOR NEGATION (UNARY) FLAG
1686 89e3 27 15                        BEQ  LB222          ; RETURN IF NEGATION - NO RELATIONAL COMPARISON
1687                         
1688                         * EVALUATE AN OPERATION. EIGHT BYTES WILL BE STORED ON STACK, FIRST SIX BYTES
1689                         * ARE A TEMPORARY FLOATING POINT RESULT THEN THE ADDRESS OF ROUTINE WHICH
1690                         * WILL EVALUATE THE OPERATION. THE RTS AT END OF ROUTINE WILL VECTOR
1691                         * TO EVALUATING ROUTINE.
1692 89e5 54                           LSRB                ; = ROTATE VALTYP BIT INTO CARRY
1693 89e6 d7 0a                        STB  RELFLG         ; = FLAG AND SAVE NEW RELFLG
1694 89e8 35 52                        PULS A,X,U          ; * PULL A FP VALUE OFF OF THE STACK
1695 89ea 97 5c                        STA  FP1EXP         ; * AND SAVE IT IN FPA1
1696 89ec 9f 5d                        STX  FPA1           ; *
1697 89ee df 5f                        STU  FPA1+2         ; *
1698 89f0 35 04                        PULS B              ; = GET MANTISSA SIGN AND
1699 89f2 d7 61                        STB  FP1SGN         ; = SAVE IT IN FPA1
1700 89f4 d8 54                        EORB FP0SGN         ; EOR IT WITH FPA1 MANTISSA SIGN
1701 89f6 d7 62                        STB  RESSGN         ; SAVE IT IN RESULT SIGN BYTE
1702 89f8 d6 4f              LB220     LDB  FP0EXP         ; GET EXPONENT OF FPA0
1703 89fa 39                 LB222     RTS
1704                         
1705 89fb bd 9c 5c           LB223     JSR  XVEC15         ; CALL EXTENDED BASIC ADD-IN
1706 89fe 0f 06                        CLR  VALTYP         ; INITIALIZE TYPE FLAG TO NUMERIC
1707 8a00 9d 7b                        JSR  GETNCH         ; GET AN INPUT CHAR
1708 8a02 24 03                        BCC  LB22F          ; BRANCH IF NOT NUMERIC
1709 8a04 7e 94 be           LB22C     JMP  LBD12          ; CONVERT ASCII STRING TO FLOATING POINT -
1710                         *         RETURN RESULT IN FPA0
1711                         * PROCESS A NON NUMERIC FIRST CHARACTER
1712 8a07 bd 8b 75           LB22F     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
1713 8a0a 24 50                        BCC  LB284          ; BRANCH IF ALPHA CHARACTER
1714 8a0c 81 2e                        CMPA #'.            ; IS IT '.' (DECIMAL POINT)?
1715 8a0e 27 f4                        BEQ  LB22C          ; CONVERT ASCII STRING TO FLOATING POINT
1716 8a10 81 aa                        CMPA #TOK_MINUS     ; MINUS TOKEN
1717 8a12 27 40                        BEQ  LB27C          ; YES - GO PROCESS THE MINUS OPERATOR
1718 8a14 81 a9                        CMPA #TOK_PLUS      ; PLUS TOKEN
1719 8a16 27 e3                        BEQ  LB223          ; YES - GET ANOTHER CHARACTER
1720 8a18 81 22                        CMPA #'"            ; STRING DELIMITER?
1721 8a1a 26 0a                        BNE  LB24E          ; NO
1722 8a1c 9e 82              LB244     LDX  CHARAD         ; CURRENT BASIC POINTER TO X
1723 8a1e bd 8c eb                     JSR  LB518          ; SAVE STRING ON STRING STACK
1724 8a21 9e 64              LB249     LDX  COEFPT         ; * GET ADDRESS OF END OF STRING AND
1725 8a23 9f 82                        STX  CHARAD         ; * PUT BASIC'S INPUT POINTER THERE
1726 8a25 39                           RTS
1727 8a26 81 a6              LB24E     CMPA #TOK_NOT       ; NOT TOKEN?
1728 8a28 26 0d                        BNE  LB25F          ; NO
1729                         * PROCESS THE NOT OPERATOR
1730 8a2a 86 5a                        LDA  #$5A           ; 'NOT' PRECEDENCE FLAG
1731 8a2c bd 89 32                     JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'NOT'
1732 8a2f bd 8b c0                     JSR  INTCNV         ; CONVERT FPA0 TO INTEGER IN ACCD
1733 8a32 43                           COMA                ; * 'NOT' THE INTEGER
1734 8a33 53                           COMB                ; *
1735 8a34 7e 8c c7                     JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT (FPA0)
1736 8a37 4c                 LB25F     INCA                ; CHECK FOR TOKENS PRECEEDED BY $FF
1737 8a38 27 2e                        BEQ  LB290          ; IT WAS PRECEEDED BY $FF
1738 8a3a 8d 06              LB262     BSR  LB26A          ; SYNTAX CHECK FOR A '('
1739 8a3c bd 89 2e                     JSR  LB156          ; EVALUATE EXPRESSIONS WITHIN PARENTHESES AT
1740                         *         HIGHEST PRECEDENCE
1741 8a3f c6 29              LB267     LDB  #')            ; SYNTAX CHECK FOR ')'
1742 8a41 8c                           FCB  SKP2           ; SKIP 2 BYTES
1743 8a42 c6 28              LB26A     LDB  #'(            ; SYNTAX CHECK FOR '('
1744 8a44 8c                           FCB  SKP2           ; SKIP 2 BYTES
1745 8a45 c6 2c              LB26D     LDB  #',            ; SYNTAX CHECK FOR COMMA
1746 8a47 e1 9f 00 82        LB26F     CMPB [CHARAD]       ; * COMPARE ACCB TO CURRENT INPUT
1747 8a4b 26 02                        BNE  LB277          ; * CHARACTER - SYNTAX ERROR IF NO MATCH
1748 8a4d 0e 7b                        JMP  GETNCH         ; GET A CHARACTER FROM BASIC
1749 8a4f c6 02              LB277     LDB  #2*1           ; SYNTAX ERROR
1750 8a51 7e 84 4e                     JMP  LAC46          ; JUMP TO ERROR HANDLER
1751                         
1752                         * PROCESS THE MINUS (UNARY) OPERATOR
1753 8a54 86 7d              LB27C     LDA  #$7D           ; MINUS (UNARY) PRECEDENCE FLAG
1754 8a56 bd 89 32                     JSR  LB15A          ; PROCESS OPERATION FOLLOWING 'UNARY' NEGATION
1755 8a59 7e 96 95                     JMP  LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
1756                         
1757                         * EVALUATE ALPHA EXPRESSION
1758 8a5c bd 8b 2a           LB284     JSR  LB357          ; FIND THE DESCRIPTOR ADDRESS OF A VARIABLE
1759 8a5f 9f 52              LB287     STX  FPA0+2         ; SAVE DESCRIPTOR ADDRESS IN FPA0
1760 8a61 96 06                        LDA  VALTYP         ; TEST VARIABLE TYPE
1761 8a63 26 95                        BNE  LB222          ; RETURN IF STRING
1762 8a65 7e 93 c0                     JMP  LBC14          ; COPY A FP NUMBER FROM (X) TO FPA0
1763                         
1764                         * EVALUATING A SECONDARY TOKEN
1765 8a68 9d 7b              LB290     JSR  GETNCH         ; GET AN INPUT CHARACTER (SECONDARY TOKEN)
1766 8a6a 1f 89                        TFR  A,B            ; SAVE IT IN ACCB
1767 8a6c 58                           ASLB                ; X2 & BET RID OF BIT 7
1768 8a6d 9d 7b                        JSR  GETNCH         ; GET ANOTHER INPUT CHARACTER
1769 8a6f c1 38                        CMPB #NUM_SEC_FNS-1*2 ; 29 SECONDARY FUNCTIONS - 1
1770 8a71 23 03                        BLS  LB29F          ; BRANCH IF COLOR BASIC TOKEN
1771 8a73 7e 8a 4f                     JMP  LB277          ; SYNTAX ERROR
1772 8a76 34 04              LB29F     PSHS B              ; SAVE TOKEN OFFSET ON STACK
1773 8a78 c1 2a                        CMPB #TOK_LEFT-$80*2 ; CHECK FOR TOKEN WITH AN ARGUMENT
1774 8a7a 25 1e                        BCS  LB2C7          ; DO SECONDARIES STRING$ OR LESS
1775 8a7c c1 30                        CMPB #TOK_INKEY-$80*2 ; *
1776 8a7e 24 1c                        BCC  LB2C9          ; * DO SECONDARIES $92 (INKEY$) OR >
1777 8a80 8d c0                        BSR  LB26A          ; SYNTAX CHECK FOR A '('
1778 8a82 a6 e4                        LDA  ,S             ; GET TOKEN NUMBER
1779                         * DO SECONDARIES (LEFT$, RIGHT$, MID$)
1780 8a84 bd 89 2e                     JSR  LB156          ; EVALUATE FIRST STRING IN ARGUMENT
1781 8a87 8d bc                        BSR  LB26D          ; SYNTAX CHECK FOR A COMMA
1782 8a89 bd 89 1e                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARiABLE
1783 8a8c 35 02                        PULS A              ; GET TOKEN OFFSET FROM STACK
1784 8a8e de 52                        LDU  FPA0+2         ; POINT U TO STRING DESCRIPTOR
1785 8a90 34 42                        PSHS U,A            ; SAVE TOKEN OFFSET AND DESCRIPTOR ADDRESS
1786 8a92 bd 8e de                     JSR  LB70B          ; EVALUATE FIRST NUMERIC ARGUMENT
1787 8a95 35 02                        PULS A              ; GET TOKEN OFFSET FROM STACK
1788 8a97 34 06                        PSHS B,A            ; SAVE TOKEN OFFSET AND NUMERIC ARGUMENT
1789 8a99 8e                           FCB  $8E            ; OP CODE OF LDX# - SKlP 2 BYTES
1790 8a9a 8d 9e              LB2C7     BSR  LB262          ; SYNTAX CHECK FOR A '('
1791 8a9c 35 04              LB2C9     PULS B              ; GET TOKEN OFFSET
1792 8a9e be 80 c1                     LDX  COMVEC+8       ; GET SECONDARY FUNCTION JUMP TABLE ADDRESS
1793 8aa1 3a                 LB2CE     ABX                 ; ADD IN COMMAND OFFSET
1794                         *
1795                         * HERE IS WHERE WE BRANCH TO A SECONDARY FUNCTION
1796 8aa2 ad 94                        JSR  [,X]           ; GO DO AN SECONDARY FUNCTION
1797 8aa4 7e 89 1b                     JMP  LB143          ; 'TM' ERROR IF VARIABLE TYPE = STRING
1798                         
1799                         * LOGICAL OPERATOR 'OR' JUMPS HERE
1800 8aa7 86                 LB2D4     FCB  SKP1LD         ; SKIP ONE BYTE - 'OR' FLAG = $4F
1801                         
1802                         * LOGICAL OPERATOR 'AND' JUMPS HERE
1803 8aa8 4f                 LB2D5     CLRA                ; AND FLAG = 0
1804 8aa9 97 03                        STA  TMPLOC         ; AND/OR FLAG
1805 8aab bd 8b c0                     JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
1806 8aae dd 01                        STD  CHARAC         ; TEMP SAVE ACCD
1807 8ab0 bd 93 f6                     JSR  LBC4A          ; MOVE FPA1 TO FPA0
1808 8ab3 bd 8b c0                     JSR  INTCNV         ; CONVERT FPA0 INTO AN INTEGER IN ACCD
1809 8ab6 0d 03                        TST  TMPLOC         ; CHECK AND/OR FLAG
1810 8ab8 26 06                        BNE  LB2ED          ; BRANCH IF OR
1811 8aba 94 01                        ANDA CHARAC         ; * 'AND' ACCD WITH FPA0 INTEGER
1812 8abc d4 02                        ANDB ENDCHR         ; * STORED IN ENDCHR
1813 8abe 20 04                        BRA  LB2F1          ; CONVERT TO FP
1814 8ac0 9a 01              LB2ED     ORA  CHARAC         ; * 'OR' ACCD WITH FPA0 INTEGER
1815 8ac2 da 02                        ORB  ENDCHR         ; * STORED IN CHARAC
1816 8ac4 7e 8c c7           LB2F1     JMP  GIVABF         ; CONVERT THE VALUE IN ACCD INTO A FP NUMBER
1817                         
1818                         * RELATIONAL COMPARISON PROCESS HANDLER
1819 8ac7 bd 89 20           LB2F4     JSR  LB148          ; 'TM' ERROR IF TYPE MISMATCH
1820 8aca 26 10                        BNE  LB309          ; BRANCH IF STRING VARIABLE
1821 8acc 96 61                        LDA  FP1SGN         ; * 'PACK' THE MANTISSA
1822 8ace 8a 7f                        ORA  #$7F           ; * SIGN OF FPA1 INTO
1823 8ad0 94 5d                        ANDA FPA1           ; * BIT 7 OF THE
1824 8ad2 97 5d                        STA  FPA1           ; * MANTISSA MS BYTE
1825 8ad4 8e 00 5c                     LDX  #FP1EXP        ; POINT X TO FPA1
1826 8ad7 bd 94 42                     JSR  LBC96          ; COMPARE FPA0 TO FPA1
1827 8ada 20 36                        BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
1828                         
1829                         * RELATIONAL COMPARISON OF STRINGS
1830 8adc 0f 06              LB309     CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
1831 8ade 0a 3f                        DEC  TRELFL         ; REMOVE STRING TYPE FLAG (BIT0=1 FOR STRINGS) FROM THE
1832                         *                             ; DESIRED RELATIONAL COMPARISON DATA
1833 8ae0 bd 8e 2a                     JSR  LB657          ; GET LENGTH AND ADDRESS OF STRING WHOSE
1834                         *                             ; DESCRIPTOR ADDRESS IS IN THE BOTTOM OF FPA0
1835 8ae3 d7 56                        STB  STRDES         ; * SAVE LENGTH AND ADDRESS IN TEMPORARY
1836 8ae5 9f 58                        STX  STRDES+2       ; * DESCRIPTOR (STRING B)
1837 8ae7 9e 5f                        LDX  FPA1+2         ; = RETURN LENGTH AND ADDRESS OF STRING
1838 8ae9 bd 8e 2c                     JSR  LB659          ; = WHOSE DESCRIPTOR ADDRESS IS STORED IN FPA1+2
1839 8aec 96 56                        LDA  STRDES         ; LOAD ACCA WITH LENGTH OF STRING B
1840 8aee 34 04                        PSHS B              ; SAVE LENGTH A ON STACK
1841 8af0 a0 e0                        SUBA ,S+            ; SUBTRACT LENGTH A FROM LENGTH B
1842 8af2 27 07                        BEQ  LB328          ; BRANCH IF STRINGS OF EQUAL LENGTH
1843 8af4 86 01                        LDA  #1             ; ; TRUE FLAG
1844 8af6 24 03                        BCC  LB328          ; TRUE IF LENGTH B > LENGTH A
1845 8af8 d6 56                        LDB  STRDES         ; LOAD ACCB WITH LENGTH B
1846 8afa 40                           NEGA                ; SET FLAG = FALSE (1FF)
1847 8afb 97 54              LB328     STA  FP0SGN         ; SAVE TRUE/FALSE FLAG
1848 8afd de 58                        LDU  STRDES+2       ; POINT U TO START OF STRING
1849 8aff 5c                           INCB                ; COMPENSATE FOR THE DECB BELOW
1850                         * ENTER WITH ACCB CONTAINING LENGTH OF SHORTER STRING
1851 8b00 5a                 LB32D     DECB                ; DECREMENT SHORTER STRING LENGTH
1852 8b01 26 04                        BNE  LB334          ; BRANCH IF ALL OF STRING NOT COMPARED
1853 8b03 d6 54                        LDB  FP0SGN         ; GET TRUE/FALSE FLAB
1854 8b05 20 0b                        BRA  LB33F          ; CHECK TRUTH OF RELATIONAL COMPARISON
1855 8b07 a6 80              LB334     LDA  ,X+            ; GET A BYTE FROM STRING A
1856 8b09 a1 c0                        CMPA ,U+            ; COMPARE TO STRING B
1857 8b0b 27 f3                        BEQ  LB32D          ; CHECK ANOTHER CHARACTER IF =
1858 8b0d c6 ff                        LDB  #$FF           ; FALSE FLAG IF STRING A > B
1859 8b0f 24 01                        BCC  LB33F          ; BRANCH IF STRING A > STRING B
1860 8b11 50                           NEGB                ; SET FLAG = TRUE
1861                         
1862                         * DETERMINE TRUTH OF COMPARISON - RETURN RESULT IN FPA0
1863 8b12 cb 01              LB33F     ADDB #1             ; CONVERT $FF,0,1 TO 0,1,2
1864 8b14 59                           ROLB                ; NOW IT'S 1,2,4 FOR > = <
1865 8b15 d4 0a                        ANDB RELFLG         ; 'AND' THE ACTUAL COMPARISON WITH THE DESIRED -
1866                         COMPARISON
1867 8b17 27 02                        BEQ  LB348          ; BRANCH IF FALSE (NO MATCHING BITS)
1868 8b19 c6 ff                        LDB  #$FF           ; TRUE FLAG
1869 8b1b 7e 94 28           LB348     JMP  LBC7C          ; CONVERT ACCB INTO FP NUMBER IN FPA0
1870                         
1871                         * DIM
1872 8b1e bd 8a 45           LB34B     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
1873 8b21 c6 01              DIM       LDB  #1             ; DIMENSION FLAG
1874 8b23 8d 08                        BSR  LB35A          ; SAVE ARRAY SPACE FOR THIS VARIABLE
1875 8b25 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1876 8b27 26 f5                        BNE  LB34B          ; KEEP DIMENSIONING IF NOT END OF LINE
1877 8b29 39                           RTS
1878                         * EVALUATE A VARIABLE - RETURN X AND
1879                         * VARPTR POINTING TO VARIABLE DESCRIPTOR
1880                         * EACH VARIABLE REQUIRES 7 BYTES - THE FIRST TWO
1881                         * BYTES ARE THE VARIABLE NAME AND THE NEXT 5
1882                         * BYTES ARE THE DESCRIPTOR. IF BIT 7 OF THE
1883                         * FIRST BYTE OF VARlABLE NAME IS SET, THE
1884                         * VARIABLE IS A DEF FN VARIABLE. IF BIT 7 OF
1885                         * THE SECOND BYTE OF VARIABLE NAME IS SET, THE
1886                         * VARIABLE IS A STRING, OTHERWISE THE VARIABLE
1887                         * IS NUMERIC.
1888                         * IF THE VARIABLE IS NOT FOUND, A ZERO VARIABLE IS
1889                         * INSERTED INTO THE VARIABLE SPACE
1890 8b2a 5f                 LB357     CLRB                ; DIMENSION FLAG = 0; DO NOT SET UP AN ARRAY
1891 8b2b 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1892 8b2d d7 05              LB35A     STB  DIMFLG         ; SAVE ARRAY FLAG
1893                         * ENTRY POINT FOR DEF FN VARIABLE SEARCH
1894 8b2f 97 37              LB35C     STA  VARNAM         ; SAVE INPUT CHARACTER
1895 8b31 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
1896 8b33 8d 40                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
1897 8b35 10 25 ff 16                  LBCS LB277          ; SYNTAX ERROR IF NOT ALPHA
1898 8b39 5f                           CLRB                ; DEFAULT 2ND VARIABLE CHARACTER TO ZERO
1899 8b3a d7 06                        STB  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
1900 8b3c 9d 7b                        JSR  GETNCH         ; GET ANOTHER CHARACTER FROM BASIC
1901 8b3e 25 04                        BCS  LB371          ; BRANCH IF NUMERIC (2ND CHARACTER IN
1902                         *                             ; VARIABLE MAY BE NUMERIC)
1903 8b40 8d 33                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
1904 8b42 25 0a                        BCS  LB37B          ; BRANCH IF NOT ALPHA
1905 8b44 1f 89              LB371     TFR  A,B            ; SAVE 2ND CHARACTER IN ACCB
1906                         * READ INPUT CHARACTERS UNTIL A NON ALPHA OR
1907                         * NON NUMERIC IS FOUND - IGNORE ALL CHARACTERS
1908                         * IN VARIABLE NAME AFTER THE 1ST TWO
1909 8b46 9d 7b              LB373     JSR  GETNCH         ; GET AN INPUT CHARACTER
1910 8b48 25 fc                        BCS  LB373          ; BRANCH IF NUMERIC
1911 8b4a 8d 29                        BSR  LB3A2          ; SET CARRY IF NOT ALPHA
1912 8b4c 24 f8                        BCC  LB373          ; BRANCH IF ALPHA
1913 8b4e 81 24              LB37B     CMPA #'$            ; CHECK FOR A STRING VARIABLE
1914 8b50 26 06                        BNE  LB385          ; BRANCH IF IT IS NOT A STRING
1915 8b52 03 06                        COM  VALTYP         ; SET VARIABLE TYPE TO STRING
1916 8b54 cb 80                        ADDB #$80           ; SET BIT 7 OF 2ND CHARACTER (STRING)
1917 8b56 9d 7b                        JSR  GETNCH         ; GET AN INPUT CHARACTER
1918 8b58 d7 38              LB385     STB  VARNAM+1       ; SAVE 2ND CHARACTER IN VARNAM+1
1919 8b5a 9a 08                        ORA  ARYDIS         ; OR IN THE ARRAY DISABLE FLAG - IF = $80,
1920                         *              ; DON'T SEARCH FOR VARIABLES IN THE ARRAYS
1921 8b5c 80 28                        SUBA #'(            ; IS THIS AN ARRAY VARIABLE?
1922 8b5e 10 27 00 75                  LBEQ LB404          ; BRANCH IF IT IS
1923 8b62 0f 08                        CLR  ARYDIS         ; RESET THE ARRAY DISABLE FLAG
1924 8b64 9e 1b                        LDX  VARTAB         ; POINT X TO THE START OF VARIABLES
1925 8b66 dc 37                        LDD  VARNAM         ; GET VARIABLE IN QUESTION
1926 8b68 9c 1d              LB395     CMPX ARYTAB         ; COMPARE X TO THE END OF VARIABLES
1927 8b6a 27 12                        BEQ  LB3AB          ; BRANCH IF END OF VARIABLES
1928 8b6c 10 a3 81                     CMPD ,X++           ; * COMPARE VARIABLE IN QUESTION TO CURRENT
1929 8b6f 27 3e                        BEQ  LB3DC          ; * VARIABLE AND BRANCH IF MATCH
1930 8b71 30 05                        LEAX 5,X            ; = MOVE POINTER TO NEXT VARIABLE AND
1931 8b73 20 f3                        BRA  LB395          ; = KEEP LOOKING
1932                         
1933                         * SET CARRY IF NOT UPPER CASE ALPHA
1934 8b75 81 41              LB3A2     CMPA #'A            ; * CARRY SET IF < 'A'
1935 8b77 25 04                        BCS  LB3AA          ; *
1936 8b79 80 5b                        SUBA #'Z+1          ; =
1937                         *         SUBA #-('Z+1)       ; = CARRY CLEAR IF <= 'Z'
1938 8b7b 80 a5                        FCB  $80,$A5
1939 8b7d 39                 LB3AA     RTS
1940                         * PUT A NEW VARIABLE IN TABLE OF VARIABLES
1941 8b7e 8e 00 73           LB3AB     LDX  #ZERO          ; POINT X TO ZERO LOCATION
1942 8b81 ee e4                        LDU  ,S             ; GET CURRENT RETURN ADDRESS
1943 8b83 11 83 8a 5f                  CMPU #LB287         ; DID WE COME FROM 'EVALUATE ALPHA EXPR'?
1944 8b87 27 28                        BEQ  LB3DE          ; YES - RETURN A ZERO VALUE
1945 8b89 dc 1f                        LDD  ARYEND         ; * GET END OF ARRAYS ADDRESS AND
1946 8b8b dd 43                        STD  V43            ; * SAVE IT AT V43
1947 8b8d c3 00 07                     ADDD #7             ; = ADD 7 TO END OF ARRAYS (EACH
1948 8b90 dd 41                        STD  V41            ; = VARIABLE = 7 BYTES) AND SAVE AT V41
1949 8b92 9e 1d                        LDX  ARYTAB         ; * GET END OF VARIABLES AND SAVE AT V47
1950 8b94 9f 47                        STX  V47            ; *
1951 8b96 bd 84 26                     JSR  LAC1E          ; MAKE A SEVEN BYTE SLOT FOR NEW VARIABLE AT
1952                         *         TOP  OF VARIABLES
1953 8b99 9e 41                        LDX  V41            ; = GET NEW END OF ARRAYS AND SAVE IT
1954 8b9b 9f 1f                        STX  ARYEND         ; =
1955 8b9d 9e 45                        LDX  V45            ; * GET NEW END OF VARIABLES AND SAVE IT
1956 8b9f 9f 1d                        STX  ARYTAB         ; *
1957 8ba1 9e 47                        LDX  V47            ; GET OLD END OF VARIABLES
1958 8ba3 dc 37                        LDD  VARNAM         ; GET NEW VARIABLE NAME
1959 8ba5 ed 81                        STD  ,X++           ; SAVE VARIABLE NAME
1960 8ba7 4f                           CLRA                ; * ZERO OUT THE FP VALUE OF THE NUMERIC
1961 8ba8 5f                           CLRB                ; * VARIABLE OR THE LENGTH AND ADDRESS
1962 8ba9 ed 84                        STD  ,X             ; * OF A STRING VARIABLE
1963 8bab ed 02                        STD  2,X            ; *
1964 8bad a7 04                        STA  4,X            ; *
1965 8baf 9f 39              LB3DC     STX  VARPTR         ; STORE ADDRESS OF VARIABLE VALUE
1966 8bb1 39                 LB3DE     RTS
1967                         *
1968 8bb2 90 80 00 00 00     LB3DF     FCB  $90,$80,$00,$00,$00 ; * FLOATING POINT -32768
1969                         *                             ; SMALLEST SIGNED TWO BYTE INTEGER
1970                         *
1971 8bb7 9d 7b              LB3E4     JSR  GETNCH         ; GET AN INPUT CHARACTER FROM BASIC
1972 8bb9 bd 89 19           LB3E6     JSR  LB141          ; GO EVALUATE NUMERIC EXPRESSION
1973 8bbc 96 54              LB3E9     LDA  FP0SGN         ; GET FPA0 MANTISSA SIGN
1974 8bbe 2b 5d                        BMI  LB44A          ; 'FC' ERROR IF NEGATIVE NUMBER
1975                         
1976                         
1977 8bc0 bd 89 1b           INTCNV    JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
1978 8bc3 96 4f                        LDA  FP0EXP         ; GET FPA0 EXPONENT
1979 8bc5 81 90                        CMPA #$90           ; * COMPARE TO 32768 - LARGEST INTEGER EXPONENT AND
1980 8bc7 25 08                        BCS  LB3FE          ; * BRANCH IF FPA0 < 32768
1981 8bc9 8e 8b b2                     LDX  #LB3DF         ; POINT X TO FP VALUE OF -32768
1982 8bcc bd 94 42                     JSR  LBC96          ; COMPARE -32768 TO FPA0
1983 8bcf 26 4c                        BNE  LB44A          ; 'FC' ERROR IF NOT =
1984 8bd1 bd 94 74           LB3FE     JSR  LBCC8          ; CONVERT FPA0 TO A TWO BYTE INTEGER
1985 8bd4 dc 52                        LDD  FPA0+2         ; GET THE INTEGER
1986 8bd6 39                           RTS
1987                         * EVALUATE AN ARRAY VARIABLE
1988 8bd7 dc 05              LB404     LDD  DIMFLG         ; GET ARRAY FLAG AND VARIABLE TYPE
1989 8bd9 34 06                        PSHS B,A            ; SAVE THEM ON STACK
1990 8bdb 12                           NOP                 ; DEAD SPACE CAUSED BY 1.2 REVISION
1991 8bdc 5f                           CLRB                ; RESET DIMENSION COUNTER
1992 8bdd 9e 37              LB40A     LDX  VARNAM         ; GET VARIABLE NAME
1993 8bdf 34 14                        PSHS X,B            ; SAVE VARIABLE NAME AND DIMENSION COUNTER
1994 8be1 8d d4                        BSR  LB3E4          ; EVALUATE EXPRESSION (DIMENSlON LENGTH)
1995 8be3 35 34                        PULS B,X,Y          ; PULL OFF VARIABLE NAME, DIMENSlON COUNTER,
1996                         *                             ; ARRAY FLAG
1997 8be5 9f 37                        STX  VARNAM         ; SAVE VARIABLE NAME AND VARIABLE TYPE
1998 8be7 de 52                        LDU  FPA0+2         ; GET DIMENSION LENGTH
1999 8be9 34 60                        PSHS U,Y            ; SAVE DIMENSION LENGTH, ARRAY FLAG, VARIABLE TYPE
2000 8beb 5c                           INCB                ; INCREASE DIMENSION COUNTER
2001 8bec 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
2002 8bee 81 2c                        CMPA #',            ; CHECK FOR ANOTHER DIMENSION
2003 8bf0 27 eb                        BEQ  LB40A          ; BRANCH IF MORE
2004 8bf2 d7 03                        STB  TMPLOC         ; SAVE DIMENSION COUNTER
2005 8bf4 bd 8a 3f                     JSR  LB267          ; SYNTAX CHECK FOR A ')'
2006 8bf7 35 06                        PULS A,B            ; * RESTORE VARIABLE TYPE AND ARRAY
2007 8bf9 dd 05                        STD  DIMFLG         ; * FLAG - LEAVE DIMENSION LENGTH ON STACK
2008 8bfb 9e 1d                        LDX  ARYTAB         ; GET START OF ARRAYS
2009 8bfd 9c 1f              LB42A     CMPX ARYEND         ; COMPARE TO END OF ARRAYS
2010 8bff 27 21                        BEQ  LB44F          ; BRANCH IF NO MATCH FOUND
2011 8c01 dc 37                        LDD  VARNAM         ; GET VARIABLE IN QUESTION
2012 8c03 10 a3 84                     CMPD ,X             ; COMPARE TO CURRENT VARIABLE
2013 8c06 27 06                        BEQ  LB43B          ; BRANCH IF =
2014 8c08 ec 02                        LDD  2,X            ; GET OFFSET TO NEXT ARRAY VARIABLE
2015 8c0a 30 8b                        LEAX D,X            ; ADD TO CURRENT POINTER
2016 8c0c 20 ef                        BRA  LB42A          ; KEEP SEARCHING
2017 8c0e c6 12              LB43B     LDB  #2*9           ; 'REDIMENSIONED ARRAY' ERROR
2018 8c10 96 05                        LDA  DIMFLG         ; * TEST ARRAY FLAG - IF <>0 YOU ARE TRYING
2019 8c12 26 0b                        BNE  LB44C          ; * TO REDIMENSION AN ARRAY
2020 8c14 d6 03                        LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS IN ARRAY
2021 8c16 e1 04                        CMPB 4,X            ; COMPARE TO THIS ARRAYS DIMENSIONS
2022 8c18 27 59                        BEQ  LB4A0          ; BRANCH IF =
2023 8c1a c6 10              LB447     LDB  #8*2           ; 'BAD SUBSCRIPT'
2024 8c1c 8c                           FCB  SKP2           ; SKIP TWO BYTES
2025 8c1d c6 08              LB44A     LDB  #4*2           ; 'ILLEGAL FUNCTION CALL'
2026 8c1f 7e 84 4e           LB44C     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
2027                         
2028                         * INSERT A NEW ARRAY INTO ARRAY VARIABLES
2029                         * EACH SET OF ARRAY VARIABLES IS PRECEEDED BY A DE-
2030                         * SCRIPTOR BLOCK COMPOSED OF 5+2*N BYTES WHERE N IS THE
2031                         * NUMBER OF DIMENSIONS IN THE ARRAY. THE BLOCK IS DEFINED
2032                         * AS FOLLOWS: BYTES 0,1:VARIABLE'S NAME; 2,3:TOTAL LENGTH
2033                         * OF ARRAY ITEMS AND DESCRIPTOR BLOCK; 4:NUMBER OF DIMEN-
2034                         * ISIONS; 5,6:LENGTH OF DIMENSION 1; 7,8:LENGTH OF DIMEN-
2035                         * SION 2;... 4+N,5+N:LENGTH OF DIMENSION N.
2036                         
2037 8c22 cc 00 05           LB44F     LDD  #5             ; * 5 BYTES/ARRAY ENTRY SAVE AT COEFPT
2038 8c25 dd 64                        STD  COEFPT         ; *
2039 8c27 dc 37                        LDD  VARNAM         ; = GET NAME OF ARRAY AND SAVE IN
2040 8c29 ed 84                        STD  ,X             ; = FIRST 2 BYTES OF DESCRIPTOR
2041 8c2b d6 03                        LDB  TMPLOC         ; GET NUMBER OF DIMENSIONS AND SAVE IN
2042 8c2d e7 04                        STB  4,X            ; * 5TH BYTE OF DESCRIPTOR
2043 8c2f bd 84 3b                     JSR  LAC33          ; CHECK FOR ROOM FOR DESCRIPTOR IN FREE RAM
2044 8c32 9f 41                        STX  V41            ; TEMPORARILY SAVE DESCRIPTOR ADDRESS
2045 8c34 c6 0b              LB461     LDB  #11            ; * DEFAULT DIMENSION VALUE:X(10)
2046 8c36 4f                           CLRA                ; *
2047 8c37 0d 05                        TST  DIMFLG         ; = CHECK ARRAY FLAG AND BRANCH IF
2048 8c39 27 05                        BEQ  LB46D          ; = NOT DIMENSIONING AN ARRAY
2049 8c3b 35 06                        PULS A,B            ; GET DIMENSION LENGTH
2050 8c3d c3 00 01                     ADDD #1             ; ADD ONE (X(0) HAS A LENGTH OF ONE)
2051 8c40 ed 05              LB46D     STD  5,X            ; SAVE LENGTH OF ARRAY DIMENSION
2052 8c42 8d 5d                        BSR  LB4CE          ; MULTIPLY ACCUM ARRAY SIZE NUMBER LENGTH
2053                         *                             ; OF NEW DIMENSION
2054 8c44 dd 64                        STD  COEFPT         ; TEMP STORE NEW CURRENT ACCUMULATED ARRAY SIZE
2055 8c46 30 02                        LEAX 2,X            ; BUMP POINTER UP TWO
2056 8c48 0a 03                        DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND BRANCH IF
2057 8c4a 26 e8                        BNE  LB461          ; * NOT DONE WITH ALL DIMENSIONS
2058 8c4c 9f 0f                        STX  TEMPTR         ; SAVE ADDRESS OF (END OF ARRAY DESCRIPTOR - 5)
2059 8c4e d3 0f                        ADDD TEMPTR         ; ADD TOTAL SIZE OF NEW ARRAY
2060 8c50 10 25 f7 f8                  LBCS LAC44          ; 'OM' ERROR IF > $FFFF
2061 8c54 1f 01                        TFR  D,X            ; SAVE END OF ARRAY IN X
2062 8c56 bd 84 3f                     JSR  LAC37          ; MAKE SURE THERE IS ENOUGH FREE RAM FOR ARRAY
2063 8c59 83 00 35                     SUBD #STKBUF-5      ; SUBTRACT OUT THE (STACK BUFFER - 5)
2064 8c5c dd 1f                        STD  ARYEND         ; SAVE NEW END OF ARRAYS
2065 8c5e 4f                           CLRA                ; ZERO = TERMINATOR BYTE
2066 8c5f 30 1f              LB48C     LEAX -1,X           ; * STORE TWO TERMINATOR BYTES AT
2067 8c61 a7 05                        STA  5,X            ; * THE END OF THE ARRAY DESCRIPTOR
2068 8c63 9c 0f                        CMPX TEMPTR         ; *
2069 8c65 26 f8                        BNE  LB48C          ; *
2070 8c67 9e 41                        LDX  V41            ; GET ADDRESS OF START OF DESCRIPTOR
2071 8c69 96 1f                        LDA  ARYEND         ; GET MSB OF END OF ARRAYS; LSB ALREADY THERE
2072 8c6b 93 41                        SUBD V41            ; SUBTRACT OUT ADDRESS OF START OF DESCRIPTOR
2073 8c6d ed 02                        STD  2,X            ; SAVE LENGTH OF (ARRAY AND DESCRIPTOR)
2074 8c6f 96 05                        LDA  DIMFLG         ; * GET ARRAY FLAG AND BRANCH
2075 8c71 26 2d                        BNE  LB4CD          ; * BACK IF DIMENSIONING
2076                         * CALCULATE POINTER TO CORRECT ELEMENT
2077 8c73 e6 04              LB4A0     LDB  4,X            ; GET THE NUMBER OF DIMENSIONS
2078 8c75 d7 03                        STB  TMPLOC         ; TEMPORARILY SAVE
2079 8c77 4f                           CLRA                ; * INITIALIZE POINTER
2080 8c78 5f                           CLRB                ; * TO ZERO
2081 8c79 dd 64              LB4A6     STD  COEFPT         ; SAVE ACCUMULATED POINTER
2082 8c7b 35 06                        PULS A,B            ; * PULL DIMENSION ARGUMENT OFF THE
2083 8c7d dd 52                        STD  FPA0+2         ; * STACK AND SAVE IT
2084 8c7f 10 a3 05                     CMPD 5,X            ; COMPARE TO STORED 'DIM' ARGUMENT
2085 8c82 24 3a                        BCC  LB4EB          ; 'BS' ERROR IF > = "DIM" ARGUMENT
2086 8c84 de 64                        LDU  COEFPT         ; * GET ACCUMULATED POINTER AND
2087 8c86 27 04                        BEQ  LB4B9          ; * BRANCH IF 1ST DIMENSION
2088 8c88 8d 17                        BSR  LB4CE          ; = MULTIPLY ACCUMULATED POINTER AND DIMENSION
2089 8c8a d3 52                        ADDD FPA0+2         ; = LENGTH AND ADD TO CURRENT ARGUMENT
2090 8c8c 30 02              LB4B9     LEAX 2,X            ; MOVE POINTER TO NEXT DIMENSION
2091 8c8e 0a 03                        DEC  TMPLOC         ; * DECREMENT DIMENSION COUNTER AND
2092 8c90 26 e7                        BNE  LB4A6          ; * BRANCH IF ANY DIMENSIONS LEFT
2093                         * MULTIPLY ACCD BY 5 - 5 BYTES/ARRAY VALUE
2094 8c92 ed e3                        STD  ,--S
2095 8c94 58                           ASLB
2096 8c95 49                           ROLA                ; TIMES 2
2097 8c96 58                           ASLB
2098 8c97 49                           ROLA                ; TIMES 4
2099 8c98 e3 e1                        ADDD ,S++           ; TIMES 5
2100 8c9a 30 8b                        LEAX D,X            ; ADD OFFSET TO START OF ARRAY
2101 8c9c 30 05                        LEAX 5,X            ; ADJUST POINTER FOR SIZE OF DESCRIPTOR
2102 8c9e 9f 39                        STX  VARPTR         ; SAVE POINTER TO ARRAY VALUE
2103 8ca0 39                 LB4CD     RTS
2104                         * MULTIPLY 2 BYTE NUMBER IN 5,X BY THE 2 BYTE NUMBER
2105                         * IN COEFPT. RETURN RESULT IN ACCD, BS ERROR IF > $FFFF
2106 8ca1 86 10              LB4CE     LDA  #16            ; 16 SHIFTS TO DO A MULTIPLY
2107 8ca3 97 45                        STA  V45            ; SHIFT COUNTER
2108 8ca5 ec 05                        LDD  5,X            ; * GET SIZE OF DIMENSION
2109 8ca7 dd 17                        STD  BOTSTK         ; * AND SAVE IT
2110 8ca9 4f                           CLRA                ; * ZERO
2111 8caa 5f                           CLRB                ; * ACCD
2112 8cab 58                 LB4D8     ASLB                ; = SHIFT ACCB LEFT
2113 8cac 49                           ROLA                ; = ONE BIT
2114 8cad 25 0f                        BCS  LB4EB          ; 'BS' ERROR IF CARRY
2115 8caf 08 65                        ASL  COEFPT+1       ; * SHIFT MULTIPLICAND LEFT ONE
2116 8cb1 09 64                        ROL  COEFPT         ; * BIT - ADD MULTIPLIER TO ACCUMULATOR
2117 8cb3 24 04                        BCC  LB4E6          ; * IF CARRY <> 0
2118 8cb5 d3 17                        ADDD BOTSTK         ; ADD MULTIPLIER TO ACCD
2119 8cb7 25 05                        BCS  LB4EB          ; 'BS' ERROR IF CARRY (>$FFFF)
2120 8cb9 0a 45              LB4E6     DEC  V45            ; * DECREMENT SHIFT COUNTER
2121 8cbb 26 ee                        BNE  LB4D8          ; * IF NOT DONE
2122 8cbd 39                           RTS
2123 8cbe 7e 8c 1a           LB4EB     JMP  LB447          ; 'BS' ERROR
2124                         *
2125                         * MEM
2126                         * THIS IS NOT A TRUE INDICATOR OF FREE MEMORY BECAUSE
2127                         * BASIC REQUIRES A STKBUF SIZE BUFFER FOR THE STACK
2128                         * FOR WHICH MEM DOES NOT ALLOW.
2129                         *
2130 8cc1 1f 40              MEM       TFR  S,D            ; PUT STACK POINTER INTO ACCD
2131 8cc3 93 1f                        SUBD ARYEND         ; SUBTRACT END OF ARRAYS
2132 8cc5 21                           FCB  SKP1           ; SKIP ONE BYTE
2133                         *CONVERT THE VALUE IN ACCB INTO A FP NUMBER IN FPA0
2134 8cc6 4f                 LB4F3     CLRA                ; CLEAR MS BYTE OF ACCD
2135                         * CONVERT THE VALUE IN ACCD INTO A FLOATING POINT NUMBER IN FPA0
2136 8cc7 0f 06              GIVABF    CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
2137 8cc9 dd 50                        STD  FPA0           ; SAVE ACCD IN TOP OF FACA
2138 8ccb c6 90                        LDB  #$90           ; EXPONENT REQUIRED IF THE TOP TWO BYTES
2139                         *         OF   FPA0 ARE TO BE TREATED AS AN INTEGER IN FPA0
2140 8ccd 7e 94 2e                     JMP  LBC82          ; CONVERT THE REST OF FPA0 TO AN INTEGER
2141                         
2142                         * STR$
2143 8cd0 bd 89 1b           STR       JSR  LB143          ; 'TM' ERROR IF STRING VARIABLE
2144 8cd3 ce 01 dd                     LDU  #STRBUF+2      ; *CONVERT FP NUMBER TO ASCII STRING IN
2145 8cd6 bd 95 88                     JSR  LBDDC          ; *THE STRING BUFFER
2146 8cd9 32 62                        LEAS 2,S            ; PURGE THE RETURN ADDRESS FROM THE STACK
2147 8cdb 8e 01 dc                     LDX  #STRBUF+1      ; *POINT X TO STRING BUFFER AND SAVE
2148 8cde 20 0b                        BRA  LB518          ; *THE STRING IN THE STRING SPACE
2149                         * RESERVE ACCB BYTES OF STRING SPACE. RETURN START
2150                         * ADDRESS IN (X) AND FRESPC
2151 8ce0 9f 4d              LB50D     STX  V4D            ; SAVE X IN V4D
2152 8ce2 8d 5c              LB50F     BSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
2153 8ce4 9f 58              LB511     STX  STRDES+2       ; SAVE NEW STRING ADDRESS
2154 8ce6 d7 56                        STB  STRDES         ; SAVE LENGTH OF RESERVED BLOCK
2155 8ce8 39                           RTS
2156 8ce9 30 1f              LB516     LEAX -1,X           ; MOVE POINTER BACK ONE
2157                         * SCAN A LINE FROM (X) UNTIL AN END OF LINE FLAG (ZERO) OR
2158                         * EITHER OF THE TWO TERMINATORS STORED IN CHARAC OR ENDCHR IS MATCHED.
2159                         * THE RESULTING STRING IS STORED IN THE STRING SPACE
2160                         * ONLY IF THE START OF THE STRING IS <= STRBUF+2
2161 8ceb 86 22              LB518     LDA  #'"            ; * INITIALIZE
2162 8ced 97 01                        STA  CHARAC         ; * TERMINATORS
2163 8cef 97 02              LB51A     STA  ENDCHR         ; * TO "
2164 8cf1 30 01              LB51E     LEAX 1,X            ; MOVE POINTER UP ONE
2165 8cf3 9f 62                        STX  RESSGN         ; TEMPORARILY SAVE START OF STRING
2166 8cf5 9f 58                        STX  STRDES+2       ; SAVE START OF STRING IN TEMP DESCRIPTOR
2167 8cf7 c6 ff                        LDB  #-1            ; INITIALIZE CHARACTER COUNTER TO - 1
2168 8cf9 5c                 LB526     INCB                ; INCREMENT CHARACTER COUNTER
2169 8cfa a6 80                        LDA  ,X+            ; GET CHARACTER
2170 8cfc 27 0c                        BEQ  LB537          ; BRANCH IF END OF LINE
2171 8cfe 91 01                        CMPA CHARAC         ; * CHECK FOR TERMINATORS
2172 8d00 27 04                        BEQ  LB533          ; * IN CHARAC AND ENDCHR
2173 8d02 91 02                        CMPA ENDCHR         ; * DON'T MOVE POINTER BACK
2174 8d04 26 f3                        BNE  LB526          ; * ONE IF TERMINATOR IS "MATCHED"
2175 8d06 81 22              LB533     CMPA #'"            ; = COMPARE CHARACTER TO STRING DELIMITER
2176 8d08 27 02                        BEQ  LB539          ; = & DON'T MOVE POINTER BACK IF SO
2177 8d0a 30 1f              LB537     LEAX -1,X           ; MOVE POINTER BACK ONE
2178 8d0c 9f 64              LB539     STX  COEFPT         ; SAVE END OF STRING ADDRESS
2179 8d0e d7 56                        STB  STRDES         ; SAVE STRING LENGTH IN TEMP DESCRIPTOR
2180 8d10 de 62                        LDU  RESSGN         ; GET INITlAL STRING START
2181 8d12 11 83 01 dd                  CMPU #STRBUF+2      ; COMPARE TO START OF STRING BUFFER
2182 8d16 22 07              LB543     BHI  LB54C          ; BRANCH IF > START OF STRING BUFFER
2183 8d18 8d c6                        BSR  LB50D          ; GO RESERVE SPACE FOR THE STRING
2184 8d1a 9e 62                        LDX  RESSGN         ; POINT X TO THE BEGINNING OF THE STRING
2185 8d1c bd 8e 18                     JSR  LB645          ; MOVE (B) BYTES FROM (X) TO
2186                         *                             [FRESPC] - MOVE STRING DATA
2187                         * PUT DIRECT PAGE STRING DESCRIPTOR BUFFER DATA
2188                         * ON THE STRING STACK. SET VARIABLE TYPE TO STRING
2189 8d1f 9e 0b              LB54C     LDX  TEMPPT         ; GET NEXT AVAILABLE STRING STACK DESCRIPTOR
2190 8d21 8c 00 de                     CMPX #LINHDR        ; COMPARE TO TOP OF STRING DESCRIPTOR STACK - WAS #CFNBUF
2191 8d24 26 05                        BNE  LB558          ; FORMULA O.K.
2192 8d26 c6 1e                        LDB  #15*2          ; STRING FORMULA TOO COMPLEX' ERROR
2193 8d28 7e 84 4e           LB555     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
2194 8d2b 96 56              LB558     LDA  STRDES         ; * GET LENGTH OF STRING AND SAVE IT
2195                         *         STA  ,X             ; * IN BYTE 0 OF DESCRIPTOR
2196 8d2d a7 00                        FCB  $A7,$00
2197 8d2f dc 58                        LDD  STRDES+2       ; = GET START ADDRESS OF ACTUAL STRING
2198 8d31 ed 02                        STD  2,X            ; = AND SAVE IN BYTES 2,3 OF DESCRIPTOR
2199 8d33 86 ff                        LDA  #$FF           ; * VARIABLE TYPE = STRING
2200 8d35 97 06                        STA  VALTYP         ; * SAVE IN VARIABLE TYPE FLAG
2201 8d37 9f 0d                        STX  LASTPT         ; = SAVE START OF DESCRIPTOR
2202 8d39 9f 52                        STX  FPA0+2         ; = ADDRESS IN LASTPT AND FPA0
2203 8d3b 30 05                        LEAX 5,X            ; 5 BYTES/STRING DESCRIPTOR
2204 8d3d 9f 0b                        STX  TEMPPT         ; NEXT AVAILABLE STRING VARIABLE DESCRIPTOR
2205 8d3f 39                           RTS
2206                         * RESERVE ACCB BYTES IN STRING STORAGE SPACE
2207                         * RETURN WITH THE STARTING ADDRESS OF THE
2208                         * RESERVED STRING SPACE IN (X) AND FRESPC
2209 8d40 0f 07              LB56D     CLR  GARBFL         ; CLEAR STRING REORGANIZATION FLAG
2210 8d42 4f                 LB56F     CLRA                ; * PUSH THE LENGTH OF THE
2211 8d43 34 06                        PSHS B,A            ; * STRING ONTO THE STACK
2212 8d45 dc 23                        LDD  STRTAB         ; GET START OF STRING VARIABLES
2213 8d47 a3 e0                        SUBD ,S+            ; SUBTRACT STRING LENGTH
2214 8d49 10 93 21                     CMPD FRETOP         ; COMPARE TO START OF STRING STORAGE
2215 8d4c 25 0a                        BCS  LB585          ; IF BELOW START, THEN REORGANIZE
2216 8d4e dd 23                        STD  STRTAB         ; SAVE NEW START OF STRING VARIABLES
2217 8d50 9e 23                        LDX  STRTAB         ; GET START OF STRING VARIABLES
2218 8d52 30 01                        LEAX 1,X            ; ADD ONE
2219 8d54 9f 25                        STX  FRESPC         ; SAVE START ADDRESS OF NEWLY RESERVED SPACE
2220 8d56 35 84                        PULS B,PC           ; RESTORE NUMBER OF BYTES RESERVED AND RETURN
2221 8d58 c6 1a              LB585     LDB  #2*13          ; OUT OF STRING SPACE' ERROR
2222 8d5a 03 07                        COM  GARBFL         ; TOGGLE REORGANIZATiON FLAG
2223 8d5c 27 ca                        BEQ  LB555          ; ERROR IF FRESHLY REORGANIZED
2224 8d5e 8d 04                        BSR  LB591          ; GO REORGANIZE STRING SPACE
2225 8d60 35 04                        PULS B              ; GET BACK THE NUMBER OF BYTES TO RESERVE
2226 8d62 20 de                        BRA  LB56F          ; TRY TO RESERVE ACCB BYTES AGAIN
2227                         * REORGANIZE THE STRING SPACE
2228 8d64 9e 27              LB591     LDX  MEMSIZ         ; GET THE TOP OF STRING SPACE
2229 8d66 9f 23              LB593     STX  STRTAB         ; SAVE TOP OF UNORGANIZED STRING SPACE
2230 8d68 4f                           CLRA                ; * ZERO OUT ACCD
2231 8d69 5f                           CLRB                ; * AND RESET VARIABLE
2232 8d6a dd 4b                        STD  V4B            ; * POINTER TO 0
2233 8d6c 9e 21                        LDX  FRETOP         ; POINT X TO START OF STRING SPACE
2234 8d6e 9f 47                        STX  V47            ; SAVE POINTER IN V47
2235 8d70 8e 00 b6                     LDX  #STRSTK        ; POINT X TO START OF STRING DESCRIPTOR STACK
2236 8d73 9c 0b              LB5A0     CMPX TEMPPT         ; COMPARE TO ADDRESS OF NEXT AVAILABLE DESCRIPTOR
2237 8d75 27 04                        BEQ  LB5A8          ; BRANCH IF TOP OF STRING STACK
2238 8d77 8d 32                        BSR  LB5D8          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
2239 8d79 20 f8                        BRA  LB5A0          ; KEEP CHECKING
2240 8d7b 9e 1b              LB5A8     LDX  VARTAB         ; GET THE END OF BASIC PROGRAM
2241 8d7d 9c 1d              LB5AA     CMPX ARYTAB         ; COMPARE TO END OF VARIABLES
2242 8d7f 27 04                        BEQ  LB5B2          ; BRANCH IF AT TOP OF VARIABLES
2243 8d81 8d 22                        BSR  LB5D2          ; CHECK FOR STRING IN UNORGANIZED STRING SPACE
2244 8d83 20 f8                        BRA  LB5AA          ; KEEP CHECKING VARIABLES
2245 8d85 9f 41              LB5B2     STX  V41            ; SAVE ADDRESS OF THE END OF VARIABLES
2246 8d87 9e 41              LB5B4     LDX  V41            ; GET CURRENT ARRAY POINTER
2247 8d89 9c 1f              LB5B6     CMPX ARYEND         ; COMPARE TO THE END OF ARRAYS
2248 8d8b 27 35                        BEQ  LB5EF          ; BRANCH IF AT END OF ARRAYS
2249 8d8d ec 02                        LDD  2,X            ; GET LENGTH OF ARRAY AND DESCRIPTOR
2250 8d8f d3 41                        ADDD V41            ; * ADD TO CURRENT ARRAY POINTER
2251 8d91 dd 41                        STD  V41            ; * AND SAVE IT
2252 8d93 a6 01                        LDA  1,X            ; GET 1ST CHARACTER OF VARIABLE NAME
2253 8d95 2a f0                        BPL  LB5B4          ; BRANCH IF NUMERIC ARRAY
2254 8d97 e6 04                        LDB  4,X            ; GET THE NUMBER OF DIMENSIONS IN THIS ARRAY
2255 8d99 58                           ASLB                ; MULTIPLY BY 2
2256 8d9a cb 05                        ADDB #5             ; ADD FIVE BYTES (VARIABLE NAME, ARRAY
2257                         *                             ; LENGTH, NUMBER DIMENSIONS)
2258 8d9c 3a                           ABX                 ; X NOW POINTS TO START OF ARRAY ELEMENTS
2259 8d9d 9c 41              LB5CA     CMPX V41            ; AT END OF THIS ARRAY?
2260 8d9f 27 e8                        BEQ  LB5B6          ; YES - CHECK FOR ANOTHER
2261 8da1 8d 08                        BSR  LB5D8          ; CHECK FOR STRING LOCATED IN
2262                         *                             ; UNORGANIZED STRING SPACE
2263 8da3 20 f8                        BRA  LB5CA          ; KEEP CHECKING ELEMENTS IN THIS ARRAY
2264 8da5 a6 01              LB5D2     LDA  1,X            ; GET F1RST BYTE OF VARIABLE NAME
2265 8da7 30 02                        LEAX 2,X            ; MOVE POINTER TO DESCRIPTOR
2266 8da9 2a 14                        BPL  LB5EC          ; BRANCH IF VARIABLE IS NUMERIC
2267                         * SEARCH FOR STRING - ENTER WITH X POINTING TO
2268                         * THE STRING DESCRIPTOR. IF STRING IS STORED
2269                         * BETWEEN V47 AND STRTAB, SAVE DESCRIPTOR POINTER
2270                         * IN V4B AND RESET V47 TO STRING ADDRESS
2271 8dab e6 84              LB5D8     LDB  ,X             ; GET THE LENGTH OF THE STRING
2272 8dad 27 10                        BEQ  LB5EC          ; BRANCH IF NULL - NO STRING
2273 8daf ec 02                        LDD  2,X            ; GET STARTING ADDRESS OF THE STRING
2274 8db1 10 93 23                     CMPD STRTAB         ; COMPARE TO THE START OF STRING VARIABLES
2275 8db4 22 09                        BHI  LB5EC          ; BRANCH IF THIS STRING IS STORED IN
2276                         *              ; THE STRING VARIABLES
2277 8db6 10 93 47                     CMPD V47            ; COMPARE TO START OF STRING SPACE
2278 8db9 23 04                        BLS  LB5EC          ; BRANCH IF NOT STORED IN THE STRING SPACE
2279 8dbb 9f 4b                        STX  V4B            ; SAVE VARIABLE POINTER IF STORED IN STRING SPACE
2280 8dbd dd 47                        STD  V47            ; SAVE STRING STARTING ADDRESS
2281 8dbf 30 05              LB5EC     LEAX 5,X            ; MOVE TO NEXT VARIABLE DESCRIPTOR
2282 8dc1 39                 LB5EE     RTS
2283 8dc2 9e 4b              LB5EF     LDX  V4B            ; GET ADDRESS OF THE DESCRIPTOR FOR THE
2284                         *              ; STRING WHICH IS STORED IN THE HIGHEST RAM ADDRESS IN
2285                         *              ; THE UNORGANIZED STRING SPACE
2286 8dc4 27 fb                        BEQ  LB5EE          ; BRANCH IF NONE FOUND AND REORGANIZATION DONE
2287 8dc6 4f                           CLRA                ; CLEAR MS BYTE OF LENGTH
2288 8dc7 e6 84                        LDB  ,X             ; GET LENGTH OF STRING
2289 8dc9 5a                           DECB                ; SUBTRACT ONE
2290 8dca d3 47                        ADDD V47            ; ADD LENGTH OF STRING TO ITS STARTING ADDRESS
2291 8dcc dd 43                        STD  V43            ; SAVE AS MOVE STARTING ADDRESS
2292 8dce 9e 23                        LDX  STRTAB         ; POINT X TO THE START OF ORGANIZED STRING VARIABLES
2293 8dd0 9f 41                        STX  V41            ; SAVE AS MOVE ENDING ADDRESS
2294 8dd2 bd 84 28                     JSR  LAC20          ; MOVE STRING FROM CURRENT POSITION TO THE
2295                         *              ; TOP OF UNORGANIZED STRING SPACE
2296 8dd5 9e 4b                        LDX  V4B            ; POINT X TO STRING DESCRIPTOR
2297 8dd7 dc 45                        LDD  V45            ; * GET NEW STARTING ADDRESS OF STRING AND
2298 8dd9 ed 02                        STD  2,X            ; * SAVE IT IN DESCRIPTOR
2299 8ddb 9e 45                        LDX  V45            ; GET NEW TOP OF UNORGANIZED STRING SPACE
2300 8ddd 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
2301 8ddf 7e 8d 66                     JMP  LB593          ; JUMP BACK AND REORGANIZE SOME MORE
2302                         
2303                         
2304 8de2 dc 52              LB60F     LDD  FPA0+2         ; * GET DESCRIPTOR ADDRESS OF STRING A
2305 8de4 34 06                        PSHS B,A            ; * AND SAVE IT ON THE STACK
2306 8de6 bd 89 fb                     JSR  LB223          ; GET DESCRIPTOR ADDRESS OF STRING B
2307 8de9 bd 89 1e                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
2308 8dec 35 10                        PULS X              ; * POINT X TO STRING A DESCRIPTOR
2309 8dee 9f 62                        STX  RESSGN         ; * ADDRESS AND SAVE IT IN RESSGN
2310 8df0 e6 84                        LDB  ,X             ; GET LENGTH OF STRING A
2311 8df2 9e 52                        LDX  FPA0+2         ; POINT X TO DESCRIPTOR OF STRING B
2312 8df4 eb 84                        ADDB ,X             ; ADD LENGTH OF STRING B TO STR1NG A
2313 8df6 24 05                        BCC  LB62A          ; BRANCH IF LENGTH < 256
2314 8df8 c6 1c                        LDB  #2*14          ; 'STRING TOO LONG' ERROR IF LENGTH > 255
2315 8dfa 7e 84 4e                     JMP  LAC46          ; JUMP TO ERROR SERVICING ROUTINE
2316 8dfd bd 8c e0           LB62A     JSR  LB50D          ; RESERVE ROOM IN STRING SPACE FOR NEW STRING
2317 8e00 9e 62                        LDX  RESSGN         ; GET DESCRIPTOR ADDRESS OF STRING A
2318 8e02 e6 84                        LDB  ,X             ; GET LENGTH OF STRING A
2319 8e04 8d 10                        BSR  LB643          ; MOVE STRING A INTO RESERVED BUFFER IN STRING SPACE
2320 8e06 9e 4d                        LDX  V4D            ; GET DESCRIPTOR ADDRESS OF STRING B
2321 8e08 8d 22                        BSR  LB659          ; GET LENGTH AND ADDRESS OF STRING B
2322 8e0a 8d 0c                        BSR  LB645          ; MOVE STRING B INTO REST OF RESERVED BUFFER
2323 8e0c 9e 62                        LDX  RESSGN         ; POINT X TO DESCRIPTOR OF STRING A
2324 8e0e 8d 1c                        BSR  LB659          ; DELETE STRING A IF LAST STRING ON STRING STACK
2325 8e10 bd 8d 1f                     JSR  LB54C          ; PUT STRING DESCRIPTOR ON THE STRING STACK
2326 8e13 7e 89 40                     JMP  LB168          ; BRANCH BACK TO EXPRESSION EVALUATION
2327                         
2328                         * MOVE (B) BYTES FROM 2,X TO FRESPC
2329 8e16 ae 02              LB643     LDX  2,X            ; POINT X TO SOURCE ADDRESS
2330 8e18 de 25              LB645     LDU  FRESPC         ; POINT U TO DESTINATION ADDRESS
2331 8e1a 5c                           INCB                ; COMPENSATION FOR THE DECB BELOW
2332 8e1b 20 04                        BRA  LB64E          ; GO MOVE THE BYTES
2333                         * MOVE B BYTES FROM (X) TO (U)
2334 8e1d a6 80              LB64A     LDA  ,X+            ; * GET A SOURCE BYTE AND MOVE IT
2335 8e1f a7 c0                        STA  ,U+            ; * TO THE DESTINATION
2336 8e21 5a                 LB64E     DECB                ; DECREMENT BYTE COUNTER
2337 8e22 26 f9                        BNE  LB64A          ; BRANCH IF ALL BYTES NOT MOVED
2338 8e24 df 25                        STU  FRESPC         ; SAVE ENDING ADDRESS IN FRESPC
2339 8e26 39                           RTS
2340                         * RETURN LENGTH (ACCB) AND ADDRESS (X) OF
2341                         * STRING WHOSE DESCRIPTOR IS IN FPA0+2
2342                         * DELETE THE STRING IF IT IS THE LAST ONE
2343                         * PUT ON THE STRING STACK. REMOVE STRING FROM STRING
2344                         * SPACE IF IT IS AT THE BOTTOM OF STRING VARIABLES.
2345 8e27 bd 89 1e           LB654     JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
2346 8e2a 9e 52              LB657     LDX  FPA0+2         ; GET ADDRESS OF SELECTED STRING DESCRIPTOR
2347 8e2c e6 84              LB659     LDB  ,X             ; GET LENGTH OF STRING
2348 8e2e 8d 18                        BSR  LB675          ; * CHECK TO SEE IF THIS STRING DESCRIPTOR WAS
2349 8e30 26 13                        BNE  LB672          ; * THE LAST ONE PUT ON THE STRING STACK AND
2350                         *                             ; * BRANCH IF NOT
2351 8e32 ae 07                        LDX  5+2,X          ; GET START ADDRESS OF STRING JUST REMOVED
2352 8e34 30 1f                        LEAX -1,X           ; MOVE POINTER DOWN ONE
2353 8e36 9c 23                        CMPX STRTAB         ; COMPARE TO START OF STRING VARIABLES
2354 8e38 26 08                        BNE  LB66F          ; BRANCH IF THIS STRING IS NOT AT THE BOTTOM
2355                         *                             ; OF STRING VARIABLES
2356 8e3a 34 04                        PSHS B              ; SAVE LENGTH; ACCA WAS CLEARED
2357 8e3c d3 23                        ADDD STRTAB         ; * ADD THE LENGTH OF THE JUST REMOVED STRING
2358 8e3e dd 23                        STD  STRTAB         ; * TO THE START OF STRING VARIABLES - THIS WILL
2359                         *                             ; * REMOVE THE STRING FROM THE STRING SPACE
2360 8e40 35 04                        PULS B              ; RESTORE LENGTH
2361 8e42 30 01              LB66F     LEAX 1,X            ; ADD ONE TO POINTER
2362 8e44 39                           RTS
2363 8e45 ae 02              LB672     LDX  2,X            ; *POINT X TO ADDRESS OF STRING NOT
2364 8e47 39                           RTS                 ; *ON THE STRING STACK
2365                         * REMOVE STRING FROM STRING STACK. ENTER WITH X
2366                         * POINTING TO A STRING DESCRIPTOR - DELETE THE
2367                         * STRING FROM STACK IF IT IS ON TOP OF THE
2368                         * STACK. IF THE STRING IS DELETED, SET THE ZERO FLAG
2369 8e48 9c 0d              LB675     CMPX LASTPT         ; *COMPARE TO LAST USED DESCRIPTOR ADDRESS
2370 8e4a 26 07                        BNE  LB680          ; *ON THE STRING STACK, RETURN IF DESCRIPTOR
2371                         *                             ; *ADDRESS NOT ON THE STRING STACK
2372 8e4c 9f 0b                        STX  TEMPPT         ; SAVE LAST USED DESCRIPTOR AS NEXT AVAILABLE
2373 8e4e 30 1b                        LEAX -5,X           ; * MOVE LAST USED DESCRIPTOR BACK 5 BYTES
2374 8e50 9f 0d                        STX  LASTPT         ; * AND SAVE AS THE LAST USED DESCRIPTOR ADDR
2375 8e52 4f                           CLRA                ; SET ZERO FLAG
2376 8e53 39                 LB680     RTS
2377                         
2378                         * LEN
2379 8e54 8d 03              LEN       BSR  LB686          ; POINT X TO PROPER STRING AND GET LENGTH
2380 8e56 7e 8c c6           LB683     JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER IN FPA0
2381                         * POINT X TO STRING ADDRESS LOAD LENGTH INTO
2382                         * ACCB. ENTER WITH THE STRING DESCRIPTOR IN
2383                         * BOTTOM TWO BYTES OF FPA0
2384 8e59 8d cc              LB686     BSR  LB654          ; GET LENGTH AND ADDRESS OF STRING
2385 8e5b 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
2386 8e5d 5d                           TSTB                ; SET FLAGS ACCORDING TO LENGTH
2387 8e5e 39                           RTS
2388                         
2389                         * CHR$
2390 8e5f bd 8e e1           CHR       JSR  LB70E          ; CONVERT FPA0 TO AN INTEGER IN ACCD
2391 8e62 c6 01              LB68F     LDB  #1             ; * RESERVE ONE BYTE IN
2392 8e64 bd 8d 40                     JSR  LB56D          ; * THE STRING SPACE
2393 8e67 96 53                        LDA  FPA0+3         ; GET ASCII STRING VALUE
2394 8e69 bd 8c e4                     JSR  LB511          ; SAVE RESERVED STRING DESCRIPTOR IN TEMP DESCRIPTOR
2395 8e6c a7 84                        STA  ,X             ; SAVE THE STRING (IT'S ONLY ONE BYTE)
2396 8e6e 32 62              LB69B     LEAS 2,S            ; PURGE THE RETURN ADDRESS OFF OF THE STACK
2397 8e70 7e 8d 1f           LB69D     JMP  LB54C          ; PUT TEMP DESCRIPTOR DATA ONTO STRING STACK
2398                         
2399                         
2400 8e73 8d 02              ASC       BSR  LB6A4          ; PUT 1ST CHARACTER OF STRING INTO ACCB
2401 8e75 20 df                        BRA  LB683          ; CONVERT ACCB INTO FP NUMBER IN FPA0
2402 8e77 8d e0              LB6A4     BSR  LB686          ; POINT X TO STRING DESCRIPTOR
2403 8e79 27 5e                        BEQ  LB706          ; 'FC' ERROR IF NULL STRING
2404 8e7b e6 84                        LDB  ,X             ; GET FIRST BYTE OF STRING
2405 8e7d 39                           RTS
2406                         
2407                         
2408 8e7e 8d 48              LEFT      BSR  LB6F5          ; GET ARGUMENTS FROM STACK
2409 8e80 4f                 LB6AD     CLRA                ; CLEAR STRING POINTER OFFSET - OFFSET = 0 FOR LEFT$
2410 8e81 e1 84              LB6AE     CMPB ,X             ; * COMPARE LENGTH PARAMETER TO LENGTH OF
2411 8e83 23 03                        BLS  LB6B5          ; * STRING AND BRANCH IF LENGTH OF STRING
2412                         *                             ; >= LENGTH PARAMETER
2413 8e85 e6 84                        LDB  ,X             ; USE LENGTH OF STRING OTHERWISE
2414 8e87 4f                           CLRA                ; CLEAR STRING POINTER OFFSET (0 FOR LEFT$)
2415 8e88 34 06              LB6B5     PSHS B,A            ; PUSH PARAMETERS ONTO STACK
2416 8e8a bd 8c e2                     JSR  LB50F          ; RESERVE ACCB BYTES IN THE STRING SPACE
2417 8e8d 9e 4d                        LDX  V4D            ; POINT X TO STRING DESCRIPTOR
2418 8e8f 8d 9b                        BSR  LB659          ; GET ADDRESS OF OLD STRING (X=ADDRESS)
2419 8e91 35 04                        PULS B              ; * PULL STRING POINTER OFFSET OFF OF THE STACK
2420 8e93 3a                           ABX                 ; * AND ADD IT TO STRING ADDRESS
2421 8e94 35 04                        PULS B              ; PULL LENGTH PARAMETER OFF OF THE STACK
2422 8e96 bd 8e 18                     JSR  LB645          ; MOVE ACCB BYTES FROM (X) TO [FRESPC]
2423 8e99 20 d5                        BRA  LB69D          ; PUT TEMP STRING DESCRIPTOR ONTO THE STRING STACK
2424                         
2425                         * RIGHT$
2426 8e9b 8d 2b              RIGHT     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
2427 8e9d a0 84                        SUBA ,X             ; ACCA=LENGTH PARAMETER - LENGTH OF OLD STRING
2428 8e9f 40                           NEGA                ; NOW ACCA = LENGTH OF OLD STRING
2429 8ea0 20 df                        BRA  LB6AE          ; PUT NEW STRING IN THE STRING SPACE
2430                         
2431                         * MID$
2432 8ea2 c6 ff              MID       LDB  #$FF           ; * GET DEFAULT VALUE OF LENGTH AND
2433 8ea4 d7 53                        STB  FPA0+3         ; * SAVE IT IN FPA0
2434 8ea6 9d 81                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
2435 8ea8 81 29                        CMPA #')            ; ARGUMENT DELIMITER?
2436 8eaa 27 05                        BEQ  LB6DE          ; YES - NO LENGTH PARAMETER GIVEN
2437 8eac bd 8a 45                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
2438 8eaf 8d 2d                        BSR  LB70B          ; EVALUATE NUMERIC EXPRESSION (LENGTH)
2439 8eb1 8d 15              LB6DE     BSR  LB6F5          ; GET ARGUMENTS FROM STACK
2440 8eb3 27 24                        BEQ  LB706          ; 'FC' ERROR IF NULL STRING
2441 8eb5 5f                           CLRB                ; CLEAR LENGTH COUNTER (DEFAULT VALUE)
2442 8eb6 4a                           DECA                ; *SUOTRACT ONE FROM POSITION PARAMETER (THESE
2443 8eb7 a1 84                        CMPA ,X             ; *ROUTINES EXPECT 1ST POSITION TO BE ZERO, NOT ONE)
2444                         *                             ; *AND COMPARE IT TO LENGTH OF OLD STRING
2445 8eb9 24 cd                        BCC  LB6B5          ; IF POSITION > LENGTH OF OLD STRING, THEN NEW
2446                         *                             ; STRING WILL BE A NULL STRING
2447 8ebb 1f 89                        TFR  A,B            ; SAVE ABSOLUTE POSITION PARAMETER IN ACCB
2448 8ebd e0 84                        SUBB ,X             ; ACCB=POSITION-LENGTH OF OLD STRING
2449 8ebf 50                           NEGB                ; NOW ACCB=LENGTH OF OLDSTRING-POSITION
2450 8ec0 d1 53                        CMPB FPA0+3         ; *IF THE AMOUNT OF OLD STRING TO THE RIGHT OF
2451 8ec2 23 c4                        BLS  LB6B5          ; *POSITION IS <= THE LENGTH PARAMETER, BRANCH AND
2452                         * USE ALL OF THE STRING TO THE RIGHT OF THE POSITION
2453                         * INSTEAD OF THE LENGTH PARAMETER
2454 8ec4 d6 53                        LDB  FPA0+3         ; GET LENGTH OF NEW STRING
2455 8ec6 20 c0                        BRA  LB6B5          ; PUT NEW STRING IN STRING SPACE
2456                         * DO A SYNTAX CHECK FOR ")", THEN PULL THE PREVIOUSLY CALCULATED NUMERIC
2457                         * ARGUMENT (ACCD) AND STRING ARGUMENT DESCRIPTOR ADDR OFF OF THE STACK
2458 8ec8 bd 8a 3f           LB6F5     JSR  LB267          ; SYNTAX CHECK FOR A ")"
2459 8ecb ee e4                        LDU  ,S             ; LOAD THE RETURN ADDRESS INTO U REGISTER
2460 8ecd ae 65                        LDX  5,S            ; * GET ADDRESS OF STRING AND
2461 8ecf 9f 4d                        STX  V4D            ; * SAVE IT IN V4D
2462 8ed1 a6 64                        LDA  4,S            ; = PUT LENGTH OF STRING IN
2463 8ed3 e6 64                        LDB  4,S            ; = BOTH ACCA AND ACCB
2464 8ed5 32 67                        LEAS 7,S            ; REMOVE DESCRIPTOR AND RETURN ADDRESS FROM STACK
2465 8ed7 1f 35                        TFR  U,PC           ; JUMP TO ADDRESS IN U REGISTER
2466 8ed9 7e 8c 1d           LB706     JMP  LB44A          ; 'ILLEGAL FUNCTION CALL'
2467                         * EVALUATE AN EXPRESSION - RETURN AN INTEGER IN
2468                         * ACCB - 'FC' ERROR IF EXPRESSION > 255
2469 8edc 9d 7b              LB709     JSR  GETNCH         ; GET NEXT BASIC INPUT CHARACTER
2470 8ede bd 89 19           LB70B     JSR  LB141          ; EVALUATE A NUMERIC EXPRESSION
2471 8ee1 bd 8b bc           LB70E     JSR  LB3E9          ; CONVERT FPA0 TO INTEGER IN ACCD
2472 8ee4 4d                           TSTA                ; TEST MS BYTE OF INTEGER
2473 8ee5 26 f2                        BNE  LB706          ; 'FC' ERROR IF EXPRESSION > 255
2474 8ee7 0e 81                        JMP  GETCCH         ; GET CURRENT INPUT CHARACTER FROM BASIC
2475                         
2476                         * VAL
2477 8ee9 bd 8e 59           VAL       JSR  LB686          ; POINT X TO STRING ADDRESS
2478 8eec 10 27 02 f5                  LBEQ LBA39          ; IF NULL STRING SET FPA0
2479 8ef0 de 82                        LDU  CHARAD         ; SAVE INPUT POINTER IN REGISTER U
2480 8ef2 9f 82                        STX  CHARAD         ; POINT INPUT POINTER TO ADDRESS OF STRING
2481 8ef4 3a                           ABX                 ; MOVE POINTER TO END OF STRING TERMINATOR
2482 8ef5 a6 84                        LDA  ,X             ; GET LAST BYTE OF STRING
2483 8ef7 34 52                        PSHS U,X,A          ; SAVE INPUT POINTER, STRING TERMINATOR
2484                         *         ADDRESS AND CHARACTER
2485 8ef9 6f 84                        CLR  ,X             ; CLEAR STRING TERMINATOR : FOR ASCII - FP CONVERSION
2486 8efb 9d 81                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
2487 8efd bd 94 be                     JSR  LBD12          ; CONVERT AN ASCII STRING TO FLOATING POINT
2488 8f00 35 52                        PULS A,X,U          ; RESTORE CHARACTERS AND POINTERS
2489 8f02 a7 84                        STA  ,X             ; REPLACE STRING TERMINATOR
2490 8f04 df 82                        STU  CHARAD         ; RESTORE INPUT CHARACTER
2491 8f06 39                           RTS
2492                         
2493 8f07 8d 07              LB734     BSR  LB73D          ; * EVALUATE AN EXPRESSION, RETURN
2494 8f09 9f 2b                        STX  BINVAL         ; * THE VALUE IN X; STORE IT IN BINVAL
2495 8f0b bd 8a 45           LB738     JSR  LB26D          ; SYNTAX CHECK FOR A COMMA
2496 8f0e 20 ce                        BRA  LB70B          ; EVALUATE EXPRESSION IN RANGE 0 <= X < 256
2497                         * EVALUATE EXPRESSION : RETURN INTEGER PORTION IN X - 'FC' ERROR IF
2498                         
2499 8f10 bd 89 19           LB73D     JSR  LB141          ; EVALUATE NUMERIC EXPRESSION
2500 8f13 96 54              LB740     LDA  FP0SGN         ; GET SIGN OF FPA0 MANTISSA
2501 8f15 2b c2                        BMI  LB706          ; ILLEGAL FUNCTION CALL' IF NEGATIVE
2502 8f17 96 4f                        LDA  FP0EXP         ; GET EXPONENT OF FPA0
2503 8f19 81 90                        CMPA #$90           ; COMPARE TO LARGEST POSITIVE INTEGER
2504 8f1b 22 bc                        BHI  LB706          ; ILLEGAL FUNCTION CALL' IF TOO LARGE
2505 8f1d bd 94 74                     JSR  LBCC8          ; SHIFT BINARY POINT TO EXTREME RIGHT OF FPA0
2506 8f20 9e 52                        LDX  FPA0+2         ; LOAD X WITH LOWER TWO BYTES OF FPA0
2507 8f22 39                           RTS
2508                         
2509                         * PEEK
2510 8f23 8d ee              PEEK      BSR  LB740          ; CONVERT FPA0 TO INTEGER IN REGISTER X
2511 8f25 e6 84                        LDB  ,X             ; GET THE VALUE BEING 'PEEK'ED
2512 8f27 7e 8c c6                     JMP  LB4F3          ; CONVERT ACCB INTO A FP NUMBER
2513                         
2514                         * POKE
2515 8f2a 8d db              POKE      BSR  LB734          ; EVALUATE 2 EXPRESSIONS
2516 8f2c 9e 2b                        LDX  BINVAL         ; GET THE ADDRESS TO BE 'POKE'ED
2517 8f2e e7 84                        STB  ,X             ; STORE THE DATA IN THAT ADDRESS
2518 8f30 39                           RTS
2519                         
2520                         * LIST
2521 8f31 34 01              LIST      PSHS CC             ; SAVE ZERO FLAG ON STACK
2522 8f33 bd 87 63                     JSR  LAF67          ; CONVERT DECIMAL LINE NUMBER TO BINARY
2523 8f36 bd 84 f3                     JSR  LAD01          ; * FIND RAM ADDRESS OF THAT LINE NUMBER AND
2524 8f39 9f 66                        STX  LSTTXT         ; * SAVE IT IN LSTTXT
2525 8f3b 35 01                        PULS CC             ; GET ZERO FLAG FROM STACK
2526 8f3d 27 12                        BEQ  LB784          ; BRANCH IF END OF LINE
2527 8f3f 9d 81                        JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
2528 8f41 27 13                        BEQ  LB789          ; BRANCH IF END OF LINE
2529 8f43 81 aa                        CMPA #TOK_MINUS     ; MINUS TOKEN (IS IT A RANGE OF LINE NUMBERS?)
2530 8f45 26 09                        BNE  LB783          ; NO - RETURN
2531 8f47 9d 7b                        JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
2532 8f49 27 06                        BEQ  LB784          ; BRANCH IF END OF LINE
2533 8f4b bd 87 63                     JSR  LAF67          ; GET ENDING LINE NUMBER
2534 8f4e 27 06                        BEQ  LB789          ; BRANCH IF LEGAL LINE NUMBER
2535 8f50 39                 LB783     RTS
2536                         * LIST THE ENTIRE PROGRAM
2537 8f51 ce ff ff           LB784     LDU  #$FFFF         ; * SET THE DEFAULT ENDING LINE NUMBER
2538 8f54 df 2b                        STU  BINVAL         ; * TO $FFFF
2539 8f56 32 62              LB789     LEAS 2,S            ; PURGE RETURN ADDRESS FROM THE STACK
2540 8f58 9e 66                        LDX  LSTTXT         ; POINT X TO STARTING LINE ADDRESS
2541 8f5a bd 91 0c           LB78D     JSR  LB95C          ; MOVE CURSOR TO START OF A NEW LINE
2542 8f5d bd 81 62                     JSR  LA549          ; CHECK FOR A BREAK OR PAUSE
2543 8f60 ec 84                        LDD  ,X             ; GET ADDRESS OF NEXT BASIC LINE
2544 8f62 26 03                        BNE  LB79F          ; BRANCH IF NOT END OF PROGRAM
2545                         LB797
2546 8f64 7e 84 6d                     JMP  LAC73          ; RETURN TO BASIC'S MAIN INPUT LOOP
2547 8f67 9f 66              LB79F     STX  LSTTXT         ; SAVE NEW STARTING LINE ADDRESS
2548 8f69 ec 02                        LDD  2,X            ; * GET THE LINE NUMBER OF THIS LINE AND
2549 8f6b 10 93 2b                     CMPD BINVAL         ; * COMPARE IT TO ENDING LINE NUMBER
2550 8f6e 22 f4                        BHI  LB797          ; EXIT IF LINE NUMBER > ENDING LINE NUMBER
2551 8f70 bd 95 78                     JSR  LBDCC          ; PRINT THE NUMBER IN ACCD ON SCREEN IN DECIMAL
2552 8f73 bd 91 58                     JSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
2553 8f76 9e 66                        LDX  LSTTXT         ; GET RAM ADDRESS OF THIS LINE
2554 8f78 8d 10                        BSR  LB7C2          ; UNCRUNCH A LINE
2555 8f7a ae 9f 00 66                  LDX  [LSTTXT]       ; POINT X TO START OF NEXT LINE
2556 8f7e ce 00 e1                     LDU  #LINBUF+1      ; POINT U TO BUFFER FULL OF UNCRUNCHED LINE
2557 8f81 a6 c0              LB7B9     LDA  ,U+            ; GET A BYTE FROM THE BUFFER
2558 8f83 27 d5                        BEQ  LB78D          ; BRANCH IF END OF BUFFER
2559 8f85 bd 91 5d                     JSR  LB9B1          ; SEND CHARACTER TO CONSOLE OUT
2560 8f88 20 f7                        BRA  LB7B9          ; GET ANOTHER CHARACTER
2561                         
2562                         * UNCRUNCH A LINE INTO BASIC'S LINE INPUT BUFFER
2563 8f8a 30 04              LB7C2     LEAX 4,X            ; MOVE POINTER PAST ADDRESS OF NEXT LINE AND LINE NUMBER
2564 8f8c 10 8e 00 e1                  LDY  #LINBUF+1      ; UNCRUNCH LINE INTO LINE INPUT BUFFER
2565 8f90 a6 80              LB7CB     LDA  ,X+            ; GET A CHARACTER
2566 8f92 27 51                        BEQ  LB820          ; BRANCH IF END OF LINE
2567 8f94 2b 15                        BMI  LB7E6          ; BRANCH IF IT'S A TOKEN
2568 8f96 81 3a                        CMPA #':            ; CHECK FOR END OF SUB LINE
2569 8f98 26 0d                        BNE  LB7E2          ; BRNCH IF NOT END OF SUB LINE
2570 8f9a e6 84                        LDB  ,X             ; GET CHARACTER FOLLOWING COLON
2571 8f9c c1 84                        CMPB #TOK_ELSE      ; TOKEN FOR ELSE?
2572 8f9e 27 f0                        BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
2573 8fa0 c1 83                        CMPB #TOK_SNGL_Q    ; TOKEN FOR REMARK?
2574 8fa2 27 ec                        BEQ  LB7CB          ; YES - DON'T PUT IT IN BUFFER
2575 8fa4 8c                           FCB  SKP2           ; SKIP TWO BYTES
2576 8fa5 86 21              LB7E0     LDA  #'!            ; EXCLAMATION POINT
2577 8fa7 8d 30              LB7E2     BSR  LB814          ; PUT CHARACTER IN BUFFER
2578 8fa9 20 e5                        BRA  LB7CB          ; GET ANOTHER CHARACTER
2579                         
2580 8fab ce 80 af           LB7E6     LDU  #COMVEC-10     ; FIRST DO COMMANDS
2581 8fae 81 ff                        CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
2582 8fb0 26 04                        BNE  LB7F1          ; BRANCH IF NON SECONDARY TOKEN
2583 8fb2 a6 80                        LDA  ,X+            ; GET SECONDARY TOKEN
2584 8fb4 33 45                        LEAU 5,U            ; BUMP IT UP TO SECONDARY FUNCTIONS
2585 8fb6 84 7f              LB7F1     ANDA #$7F           ; MASK OFF BIT 7 OF TOKEN
2586 8fb8 33 4a              LB7F3     LEAU 10,U           ; MOVE TO NEXT COMMAND TABLE
2587 8fba 6d c4                        TST  ,U             ; IS THIS TABLE ENABLED?
2588 8fbc 27 e7                        BEQ  LB7E0          ; NO - ILLEGAL TOKEN
2589 8fbe a0 c4                        SUBA ,U             ; SUBTRACT THE NUMBER OF TOKENS FROM THE CURRENT TOKEN NUMBER
2590 8fc0 2a f6                        BPL  LB7F3          ; BRANCH IF TOKEN NOT IN THIS TABLE
2591 8fc2 ab c4                        ADDA ,U             ; RESTORE TOKEN NUMBER RELATIVE TO THIS TABLE
2592 8fc4 ee 41                        LDU  1,U            ; POINT U TO COMMAND DICTIONARY TABLE
2593 8fc6 4a                 LB801     DECA                ; DECREMENT TOKEN NUMBER
2594 8fc7 2b 06                        BMI  LB80A          ; BRANCH IF THIS IS THE CORRECT TOKEN
2595                         * SKIP THROUGH DICTIONARY TABLE TO START OF NEXT TOKEN
2596 8fc9 6d c0              LB804     TST  ,U+            ; GRAB A BYTE
2597 8fcb 2a fc                        BPL  LB804          ; BRANCH IF BIT 7 NOT SET
2598 8fcd 20 f7                        BRA  LB801          ; GO SEE IF THIS IS THE CORRECT TOKEN
2599 8fcf a6 c4              LB80A     LDA  ,U             ; GET A CHARACTER FROM DICTIONARY TABLE
2600 8fd1 8d 06                        BSR  LB814          ; PUT CHARACTER IN BUFFER
2601 8fd3 6d c0                        TST  ,U+            ; CHECK FOR START OF NEXT TOKEN
2602 8fd5 2a f8                        BPL  LB80A          ; BRANCH IF NOT DONE WITH THIS TOKEN
2603 8fd7 20 b7                        BRA  LB7CB          ; GO GET ANOTHER CHARACTER
2604 8fd9 10 8c 01 da        LB814     CMPY #LINBUF+LBUFMX ; TEST FOR END OF LINE INPUT BUFFER
2605 8fdd 24 06                        BCC  LB820          ; BRANCH IF AT END OF BUFFER
2606 8fdf 84 7f                        ANDA #$7F           ; MASK OFF BIT 7
2607 8fe1 a7 a0                        STA  ,Y+            ; * SAVE CHARACTER IN BUFFER AND
2608 8fe3 6f a4                        CLR  ,Y             ; * CLEAR NEXT CHARACTER SLOT IN BUFFER
2609 8fe5 39                 LB820     RTS
2610                         *
2611                         * CRUNCH THE LINE THAT THE INPUT POINTER IS
2612                         * POINTING TO INTO THE LINE INPUT BUFFER
2613                         * RETURN LENGTH OF CRUNCHED LINE IN ACCD
2614                         *
2615 8fe6 9e 82              LB821     LDX  CHARAD         ; GET BASIC'S INPUT POINTER ADDRESS
2616 8fe8 ce 00 e0                     LDU  #LINBUF        ; POINT X TO LINE INPUT BUFFER
2617 8feb 0f 43              LB829     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
2618 8fed 0f 44                        CLR  V44            ; CLEAR DATA FLAG
2619 8fef a6 80              LB82D     LDA  ,X+            ; GET INPUT CHAR
2620 8ff1 27 21                        BEQ  LB852          ; BRANCH IF END OF LINE
2621 8ff3 0d 43                        TST  V43            ; * CHECK ILLEGAL TOKEN FLAG & BRANCH IF NOT
2622 8ff5 27 0f                        BEQ  LB844          ; * PROCESSING AN ILLEGAL TOKEN
2623 8ff7 bd 8b 75                     JSR  LB3A2          ; SET CARRY IF NOT UPPER CASE ALPHA
2624 8ffa 24 18                        BCC  LB852          ; BRANCH IF UPPER CASE ALPHA
2625 8ffc 81 30                        CMPA #'0            ; * DON'T CRUNCH ASCII NUMERIC CHARACTERS
2626 8ffe 25 04                        BLO  LB842          ; * BRANCH IF NOT NUMERIC
2627 9000 81 39                        CMPA #'9            ; *
2628 9002 23 10                        BLS  LB852          ; * BRANCH IF NUMERIC
2629                         * END UP HERE IF NOT UPPER CASE ALPHA OR NUMERIC
2630 9004 0f 43              LB842     CLR  V43            ; CLEAR ILLEGAL TOKEN FLAG
2631 9006 81 20              LB844     CMPA #SPACE         ; SPACE?
2632 9008 27 0a                        BEQ  LB852          ; DO NOT REMOVE SPACES
2633 900a 97 42                        STA  V42            ; SAVE INPUT CHARACTER AS SCAN DELIMITER
2634 900c 81 22                        CMPA #'"            ; CHECK FOR STRING DELIMITER
2635 900e 27 38                        BEQ  LB886          ; BRANCH IF STRING
2636 9010 0d 44                        TST  V44            ; * CHECK DATA FLAG AND BRANCH IF CLEAR
2637 9012 27 19                        BEQ  LB86B          ; * DO NOT CRUNCH DATA
2638 9014 a7 c0              LB852     STA  ,U+            ; SAVE CHARACTER IN BUFFER
2639 9016 27 06                        BEQ  LB85C          ; BRANCH IF END OF LINE
2640 9018 81 3a                        CMPA #':            ; * CHECK FOR END OF SUBLINE
2641 901a 27 cf                        BEQ  LB829          ; * AND RESET FLAGS IF END OF SUBLINE
2642 901c 20 d1              LB85A     BRA  LB82D          ; GO GET ANOTHER CHARACTER
2643 901e 6f c0              LB85C     CLR  ,U+            ; * DOUBLE ZERO AT END OF LINE
2644 9020 6f c0                        CLR  ,U+            ; *
2645 9022 1f 30                        TFR  U,D            ; SAVE ADDRESS OF END OF LINE IN ACCD
2646 9024 83 00 de                     SUBD #LINHDR        ; LENGTH OF LINE IN ACCD
2647 9027 8e 00 df                     LDX  #LINBUF-1      ; * SET THE INPUT POINTER TO ONE BEFORE
2648 902a 9f 82                        STX  CHARAD         ; * THE START OF THE CRUNCHED LINE
2649 902c 39                           RTS                 ; EXIT 'CRUNCH'
2650 902d 81 3f              LB86B     CMPA #'?            ; CHECK FOR "?" - PRINT ABBREVIATION
2651 902f 26 04                        BNE  LB873          ; BRANCH IF NOT PRINT ABBREVIATION
2652 9031 86 87                        LDA  #TOK_PRINT     ; * GET THE PRINT TOKEN AND SAVE IT
2653 9033 20 df                        BRA  LB852          ; * IN BUFFER
2654 9035 81 27              LB873     CMPA #''            ; APOSTROPHE IS SAME AS REM
2655 9037 26 13                        BNE  LB88A          ; BRANCH IF NOT REMARK
2656 9039 cc 3a 83                     LDD  #$3A00+TOK_SNGL_Q ; COLON, REM TOKEN
2657 903c ed c1                        STD  ,U++           ; SAVE IN BUFFER
2658 903e 0f 42              LB87C     CLR  V42            ; SET DELIMITER = 0 (END OF LINE)
2659 9040 a6 80              LB87E     LDA  ,X+            ; SCAN TILL WE MATCH [V42]
2660 9042 27 d0                        BEQ  LB852          ; BRANCH IF END OF LINE
2661 9044 91 42                        CMPA V42            ; DELIMITER?
2662 9046 27 cc                        BEQ  LB852          ; BRANCH OUT IF SO
2663 9048 a7 c0              LB886     STA  ,U+            ; DON'T CRUNCH REMARKS OR STRINGS
2664 904a 20 f4                        BRA  LB87E          ; GO GET MORE STRING OR REMARK
2665 904c 81 30              LB88A     CMPA #'0            ; * LESS THAN ASCII ZERO?
2666 904e 25 04                        BCS  LB892          ; * BRANCH IF SO
2667 9050 81 3c                        CMPA #';+1          ; = CHECK FOR NUMERIC VALUE, COLON OR SEMICOLON
2668 9052 25 c0                        BCS  LB852          ; = AND INSERT IN BUFFER IF SO
2669 9054 30 1f              LB892     LEAX -1,X           ; MOVE INPUT POINTER BACK ONE
2670 9056 34 50                        PSHS U,X            ; SAVE POINTERS TO INPUT STRING, OUTPUT STRING
2671 9058 0f 41                        CLR  V41            ; TOKEN FLAG 0 = COMMAND, FF = SECONDARY
2672 905a ce 80 af                     LDU  #COMVEC-10     ; POINT U TO COMMAND INTERPRETATION
2673                         *                             ; TABLE FOR BASIC - 10
2674 905d 0f 42              LB89B     CLR  V42            ; INITIALIZE V42 AS TOKEN COUNTER
2675 905f 33 4a              LB89D     LEAU 10,U           ; MOVE TO NEXT COMMAND INTERPRETATION TABLE
2676 9061 a6 c4                        LDA  ,U             ; GET NUMBER OF COMMANDS
2677 9063 27 31                        BEQ  LB8D4          ; GO DO SECONDARY FUNCTIONS IF NO COMMAND TABLE
2678 9065 10 ae 41                     LDY  1,U            ; POINT Y TO COMMAND DICTIONARY TABLE
2679 9068 ae e4              LB8A6     LDX  ,S             ; GET POINTER TO INPUT STRING
2680 906a e6 a0              LB8A8     LDB  ,Y+            ; GET A BYTE FROM DICTIONARY TABLE
2681 906c e0 80                        SUBB ,X+            ; SUBTRACT INPUT CHARACTER
2682 906e 27 fa                        BEQ  LB8A8          ; LOOP IF SAME
2683 9070 c1 80                        CMPB #$80           ; LAST CHAR IN RESERVED WORD TABLE HAD
2684                         *                             ; BIT 7 SET, SO IF WE HAVE $80 HERE
2685                         *                             ; THEN IT IS A GOOD COMPARE
2686 9072 26 38                        BNE  LB8EA          ; BRANCH IF NO MATCH - CHECK ANOTHER COMMAND
2687 9074 32 62                        LEAS 2,S            ; DELETE OLD INPUT POINTER FROM STACK
2688 9076 35 40                        PULS U              ; GET POINTER TO OUTPUT STRING
2689 9078 da 42                        ORB  V42            ; OR IN THE TABLE POSITION TO MAKE THE TOKEN
2690                         *                             ; - NOTE THAT B ALREADY HAD $80 IN IT -
2691 907a 96 41                        LDA  V41            ; * CHECK TOKEN FLAG AND BRANCH
2692 907c 26 06                        BNE  LB8C2          ; * IF SECONDARY
2693 907e c1 84                        CMPB #TOK_ELSE      ; IS IT ELSE TOKEN?
2694 9080 26 06                        BNE  LB8C6          ; NO
2695 9082 86 3a                        LDA  #':            ; PUT A COLON (SUBLINE) BEFORE ELSE TOKEN
2696 9084 ed c1              LB8C2     STD  ,U++           ; SECONDARY TOKENS PRECEEDED BY $FF
2697 9086 20 94                        BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
2698 9088 e7 c0              LB8C6     STB  ,U+            ; SAVE THIS TOKEN
2699 908a c1 86                        CMPB #TOK_DATA      ; DATA TOKEN?
2700 908c 26 02                        BNE  LB8CE          ; NO
2701 908e 0c 44                        INC  V44            ; SET DATA FLAG
2702 9090 c1 82              LB8CE     CMPB #TOK_REM       ; REM TOKEN?
2703 9092 27 aa                        BEQ  LB87C          ; YES
2704 9094 20 86              LB8D2     BRA  LB85A          ; GO PROCESS MORE INPUT CHARACTERS
2705                         * CHECK FOR A SECONDARY TOKEN
2706 9096 ce 80 b4           LB8D4     LDU  #COMVEC-5      ; NOW DO SECONDARY FUNCTIONS
2707 9099 03 41                        COM  V41            ; TOGGLE THE TOKEN FLAG
2708 909b 26 c0                        BNE  LB89B          ; BRANCH IF NOW CHECKING SECONDARY COMMANDS
2709                         
2710                         * THIS CODE WILL PROCESS INPUT DATA WHICH CANNOT BE CRUNCHED AND SO
2711                         * IS ASSUMED TO BE ILLEGAL DATA OR AN ILLEGAL TOKEN
2712 909d 35 50                        PULS X,U            ; RESTORE INPUT AND OUTPUT POINTERS
2713 909f a6 80                        LDA  ,X+            ; * MOVE THE FIRST CHARACTER OF AN
2714 90a1 a7 c0                        STA  ,U+            ; * ILLEGAL TOKEN
2715 90a3 bd 8b 75                     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
2716 90a6 25 ec                        BCS  LB8D2          ; BRANCH IF NOT ALPHA
2717 90a8 03 43                        COM  V43            ; SET ILLEGAL TOKEN FLAG IF UPPER CASE ALPHA
2718 90aa 20 e8                        BRA  LB8D2          ; PROCESS MORE INPUT CHARACTERS
2719 90ac 0c 42              LB8EA     INC  V42            ; INCREMENT TOKEN COUNTER
2720 90ae 4a                           DECA                ; DECR COMMAND COUNTER
2721 90af 27 ae                        BEQ  LB89D          ; GET ANOTHER COMMAND TABLE IF DONE W/THIS ONE
2722 90b1 31 3f                        LEAY -1,Y           ; MOVE POINTER BACK ONE
2723 90b3 e6 a0              LB8F1     LDB  ,Y+            ; * GET TO NEXT
2724 90b5 2a fc                        BPL  LB8F1          ; * RESERVED WORD
2725 90b7 20 af                        BRA  LB8A6          ; GO SEE IF THIS WORD IS A MATCH
2726                         
2727                         * PRINT
2728 90b9 27 4d              PRINT     BEQ  LB958          ; BRANCH IF NO ARGUMENT
2729 90bb 8d 01                        BSR  LB8FE          ; CHECK FOR ALL PRINT OPTIONS
2730 90bd 39                           RTS
2731                         
2732 90be 81 40              LB8FE	CMPA #'@'	; CHECK FOR PRINT @
2733 90c0 26 05              		BNE	LB907	; NOT PRINT @
2734 90c2 bd 81 65           LB902	JSR	LA554	; MOVE CURSOR TO PROPER PRINT LOCATION
2735 90c5 20 04              LB905	BRA	LB911	; GO PRINT THE DATA
2736 90c7 81 23              LB907	CMPA #'#'	; CHECK FOR PRINT NUMBER
2737 90c9 26 07              		BNE	LB918	; NOT PRINT#
2738                         		;JSR	LA5A5	; CHECK FOR A VALID DEVICE NUMBER
2739                         		;JSR	LA406	; CHECK FOR A VALID OUTPUT FILE
2740 90cb 9d 81              LB911	JSR	GETCCH	; GET CURRENT INPUT CHARACTER
2741 90cd 27 39              		BEQ	LB958	; BRANCH IF END OF LINE
2742 90cf bd 8a 45           		JSR	LB26D	; SYNTAX CHECK FOR COMMA
2743                         
2744 90d2 bd e2 72           LB918     JSR  XVEC9          ; CALL EXTENDED BASIC ADD-IN
2745 90d5 27 3e              LB91B     BEQ  LB965          ; RETURN IF END OF LINE
2746 90d7 81 a2              LB91D     CMPA #TOK_TAB       ; TOKEN FOR TAB( ?
2747 90d9 27 53                        BEQ  LB97E          ; YES
2748 90db 81 2c                        CMPA #',            ; COMMA?
2749 90dd 27 37                        BEQ  LB966          ; YES - ADVANCE TO NEXT TAB FIELD
2750 90df 81 3b                        CMPA #';            ; SEMICOLON?
2751 90e1 27 60                        BEQ  LB997          ; YES - DO NOT ADVANCE CURSOR
2752 90e3 bd 89 2e                     JSR  LB156          ; EVALUATE EXPRESSION
2753 90e6 96 06                        LDA  VALTYP         ; * GET VARIABLE TYPE AND
2754 90e8 34 02                        PSHS A              ; * SAVE IT ON THE STACK
2755 90ea 26 06                        BNE  LB938          ; BRANCH IF STRING VARIABLE
2756 90ec bd 95 85                     JSR  LBDD9          ; CONVERT FP NUMBER TO AN ASCII STRING
2757 90ef bd 8c e9                     JSR  LB516          ; PARSE A STRING FROM (X-1) AND PUT
2758                         *                             ; DESCRIPTOR ON STRING STACK
2759 90f2 8d 57              LB938     BSR  LB99F          ; PRINT STRING POINTED TO BY X
2760 90f4 35 04                        PULS B              ; GET VARIABLE TYPE BACK
2761 90f6 bd 80 fb                     JSR  LA35F          ; SET UP TAB WIDTH ZONE, ETC
2762 90f9 5d                 LB949     TSTB                ; CHECK CURRENT PRINT POSITION
2763 90fa 26 08                        BNE  LB954          ; BRANCH IF NOT AT START OF LINE
2764 90fc 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
2765 90fe 81 2c                        CMPA #',            ; COMMA?
2766 9100 27 14                        BEQ  LB966          ; SKIP TO NEXT TAB FIELD
2767 9102 8d 54                        BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
2768 9104 9d 81              LB954     JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
2769 9106 26 cf                        BNE  LB91D          ; BRANCH IF NOT END OF LINE
2770 9108 86 0d              LB958     LDA  #CR            ; * SEND A CR TO
2771 910a 20 51                        BRA  LB9B1          ; * CONSOLE OUT
2772 910c bd 80 fb           LB95C     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
2773 910f 27 f7                        BEQ  LB958          ; BRANCH IF WIDTH = ZERO
2774 9111 96 6c                        LDA  DEVPOS         ; GET PRINT POSITION
2775 9113 26 f3                        BNE  LB958          ; BRANCH IF NOT AT START OF LINE
2776 9115 39                 LB965     RTS
2777                         * SKIP TO NEXT TAB FIELD
2778 9116 bd 80 fb           LB966     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
2779 9119 27 0a                        BEQ  LB975          ; BRANCH IF LINE WIDTH = 0 (CASSETTE)
2780 911b d6 6c                        LDB  DEVPOS         ; GET CURRENT POSITION
2781 911d d1 6b                        CMPB DEVLCF         ; COMPARE TO LAST TAB ZONE
2782 911f 25 06                        BCS  LB977          ; BRANCH IF < LAST TAB ZONE
2783 9121 8d e5                        BSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
2784 9123 20 1e                        BRA  LB997          ; GET MORE DATA
2785 9125 d6 6c              LB975     LDB  DEVPOS         ; *
2786 9127 d0 6a              LB977     SUBB DEVCFW         ; * SUBTRACT TAB FIELD WIDTH FROM CURRENT
2787 9129 24 fc                        BCC  LB977          ; * POSITION UNTIL CARRY SET - NEGATING THE
2788 912b 50                           NEGB                ; * REMAINDER LEAVES THE NUMBER OF SPACES TO NEXT
2789                         *              ; * TAB ZONE IN ACCB
2790 912c 20 10                        BRA  LB98E          ; GO ADVANCE TO NEXT TAB ZONE
2791                         
2792                         * PRINT TAB(
2793 912e bd 8e dc           LB97E     JSR  LB709          ; EVALUATE EXPRESSION - RETURN VALUE IN B
2794 9131 81 29                        CMPA #')            ; * 'SYNTAX' ERROR IF NOT ')'
2795 9133 10 26 f9 18                  LBNE LB277          ; *
2796 9137 bd 80 fb                     JSR  LA35F          ; SET UP TAB WIDTH, ZONE ETC
2797 913a d0 6c                        SUBB DEVPOS         ; GET DIFFERENCE OF PRINT POSITION & TAB POSITION
2798 913c 23 05                        BLS  LB997          ; BRANCH IF TAB POSITION < CURRENT POSITION
2799                         LB98E
2800 913e 8d 18              LB992     BSR  LB9AC          ; SEND A SPACE TO CONSOLE OUT
2801 9140 5a                           DECB                ; DECREMENT DIFFERENCE COUNT
2802 9141 26 fb                        BNE  LB992          ; BRANCH UNTIL CURRENT POSITION = TAB POSITION
2803 9143 9d 7b              LB997     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
2804 9145 7e 90 d5                     JMP  LB91B          ; LOOK FOR MORE PRINT DATA
2805                         * COPY A STRING FROM (X) TO CONSOLE OUT
2806 9148 bd 8c eb           LB99C     JSR  LB518          ; PARSE A STRING FROM X AND PUT
2807                         *         DESCRIPTOR ON STRING STACK
2808 914b bd 8e 2a           LB99F     JSR  LB657          ; GET LENGTH OF STRING AND REMOVE
2809                         *         DESCRIPTOR FROM STRING STACK
2810 914e 5c                           INCB                ; COMPENSATE FOR DECB BELOW
2811 914f 5a                 LB9A3     DECB                ; DECREMENT COUNTER
2812 9150 27 c3                        BEQ  LB965          ; EXIT ROUTINE
2813 9152 a6 80                        LDA  ,X+            ; GET A CHARACTER FROM X
2814 9154 8d 07                        BSR  LB9B1          ; SEND TO CONSOLE OUT
2815 9156 20 f7                        BRA  LB9A3          ; KEEP LOOPING
2816 9158 86 20              LB9AC     LDA  #SPACE         ; SPACE TO CONSOLE OUT
2817 915a 8c                           FCB  SKP2           ; SKIP NEXT TWO BYTES
2818 915b 86 3f              LB9AF     LDA  #'?            ; QUESTION MARK TO CONSOLE OUT
2819 915d 7e 80 31           LB9B1     JMP  PUTCHR         ; JUMP TO CONSOLE OUT
2820                         
2821                         * FLOATING POINT MATH PACKAGE
2822                         
2823                         * ADD .5 TO FPA0
2824 9160 8e 96 6c           LB9B4     LDX  #LBEC0         ; FLOATING POINT CONSTANT (.5)
2825 9163 20 09                        BRA  LB9C2          ; ADD .5 TO FPA0
2826                         * SUBTRACT FPA0 FROM FP NUMBER POINTED
2827                         * TO BY (X), LEAVE RESULT IN FPA0
2828 9165 bd 92 db           LB9B9     JSR  LBB2F          ; COPY PACKED FP DATA FROM (X) TO FPA1
2829                         
2830                         * ARITHMETIC OPERATION (-) JUMPS HERE - SUBTRACT FPA0 FROM FPA1 (ENTER
2831                         * WITH EXPONENT OF FPA0 IN ACCB AND EXPONENT OF FPA1 IN ACCA)
2832 9168 03 54              LB9BC     COM  FP0SGN         ; CHANGE MANTISSA SIGN OF FPA0
2833 916a 03 62                        COM  RESSGN         ; REVERSE RESULT SIGN FLAG
2834 916c 20 03                        BRA  LB9C5          ; GO ADD FPA1 AND FPA0
2835                         * ADD FP NUMBER POINTED TO BY
2836                         * (X) TO FPA0 - LEAVE RESULT IN FPA0
2837 916e bd 92 db           LB9C2     JSR  LBB2F          ; UNPACK PACKED FP DATA FROM (X) TO
2838                         *         FPA1; RETURN EXPONENT OF FPA1 IN ACCA
2839                         
2840                         * ARITHMETIC OPERATION (+) JUMPS HERE - ADD FPA0 TO
2841                         
2842 9171 5d                 LB9C5     TSTB                ; CHECK EXPONENT OF FPA0
2843 9172 10 27 02 80                  LBEQ LBC4A          ; COPY FPA1 TO FPA0 IF FPA0 =
2844 9176 8e 00 5c                     LDX  #FP1EXP        ; POINT X TO FPA1
2845 9179 1f 89              LB9CD     TFR  A,B            ; PUT EXPONENT OF FPA1 INTO ACCB
2846 917b 5d                           TSTB                ; CHECK EXPONENT
2847 917c 27 6c                        BEQ  LBA3E          ; RETURN IF EXPONENT = 0 (ADDING 0 TO FPA0)
2848 917e d0 4f                        SUBB FP0EXP         ; SUBTRACT EXPONENT OF FPA0 FROM EXPONENT OF FPA1
2849 9180 27 69                        BEQ  LBA3F          ; BRANCH IF EXPONENTS ARE EQUAL
2850 9182 25 0a                        BCS  LB9E2          ; BRANCH IF EXPONENT FPA0 > FPA1
2851 9184 97 4f                        STA  FP0EXP         ; REPLACE FPA0 EXPONENT WITH FPA1 EXPONENT
2852 9186 96 61                        LDA  FP1SGN         ; * REPLACE FPA0 MANTISSA SIGN
2853 9188 97 54                        STA  FP0SGN         ; * WITH FPA1 MANTISSA SIGN
2854 918a 8e 00 4f                     LDX  #FP0EXP        ; POINT X TO FPA0
2855 918d 50                           NEGB                ; NEGATE DIFFERENCE OF EXPONENTS
2856 918e c1 f8              LB9E2     CMPB #-8            ; TEST DIFFERENCE OF EXPONENTS
2857 9190 2f 59                        BLE  LBA3F          ; BRANCH IF DIFFERENCE OF EXPONENTS <= 8
2858 9192 4f                           CLRA                ; CLEAR OVERFLOW BYTE
2859 9193 64 01                        LSR  1,X            ; SHIFT MS BYTE OF MANTISSA; BIT 7 = 0
2860 9195 bd 92 66                     JSR  LBABA          ; GO SHIFT MANTISSA OF (X) TO THE RIGHT (B) TIMES
2861 9198 d6 62              LB9EC     LDB  RESSGN         ; GET SIGN FLAG
2862 919a 2a 0b                        BPL  LB9FB          ; BRANCH IF FPA0 AND FPA1 SIGNS ARE THE SAME
2863 919c 63 01                        COM  1,X            ; * COMPLEMENT MANTISSA POINTED
2864 919e 63 02                        COM  2,X            ; * TO BY (X) THE
2865 91a0 63 03                        COM  3,X            ; * ADCA BELOW WILL
2866 91a2 63 04                        COM  4,X            ; * CONVERT THIS OPERATION
2867 91a4 43                           COMA                ; * INTO A NEG (MANTISSA)
2868 91a5 89 00                        ADCA #0             ; ADD ONE TO ACCA - COMA ALWAYS SETS THE CARRY FLAG
2869                         * THE PREVIOUS TWO BYTES MAY BE REPLACED BY A NEGA
2870                         *
2871                         * ADD MANTISSAS OF FPA0 AND FPA1, PUT RESULT IN FPA0
2872 91a7 97 63              LB9FB     STA  FPSBYT         ; SAVE FPA SUB BYTE
2873 91a9 96 53                        LDA  FPA0+3         ; * ADD LS BYTE
2874 91ab 99 60                        ADCA FPA1+3         ; * OF MANTISSA
2875 91ad 97 53                        STA  FPA0+3         ; SAVE IN FPA0 LSB
2876 91af 96 52                        LDA  FPA0+2         ; * ADD NEXT BYTE
2877 91b1 99 5f                        ADCA FPA1+2         ; * OF MANTISSA
2878 91b3 97 52                        STA  FPA0+2         ; SAVE IN FPA0
2879 91b5 96 51                        LDA  FPA0+1         ; * ADD NEXT BYTE
2880 91b7 99 5e                        ADCA FPA1+1         ; * OF MANTISSA
2881 91b9 97 51                        STA  FPA0+1         ; SAVE IN FPA0
2882 91bb 96 50                        LDA  FPA0           ; * ADD MS BYTE
2883 91bd 99 5d                        ADCA FPA1           ; * OF MANTISSA
2884 91bf 97 50                        STA  FPA0           ; SAVE IN FPA0
2885 91c1 5d                           TSTB                ; TEST SIGN FLAG
2886 91c2 2a 44                        BPL  LBA5C          ; BRANCH IF FPA0 & FPA1 SIGNS WERE ALIKE
2887 91c4 25 02              LBA18     BCS  LBA1C          ; BRANCH IF POSITIVE MANTISSA
2888 91c6 8d 5d                        BSR  LBA79          ; NEGATE FPA0 MANTISSA
2889                         
2890                         * NORMALIZE FPA0
2891 91c8 5f                 LBA1C     CLRB                ; CLEAR TEMPORARY EXPONENT ACCUMULATOR
2892 91c9 96 50              LBA1D     LDA  FPA0           ; TEST MSB OF MANTISSA
2893 91cb 26 2e                        BNE  LBA4F          ; BRANCH IF <> 0
2894 91cd 96 51                        LDA  FPA0+1         ; * IF THE MSB IS
2895 91cf 97 50                        STA  FPA0           ; * 0, THEN SHIFT THE
2896 91d1 96 52                        LDA  FPA0+2         ; * MANTISSA A WHOLE BYTE
2897 91d3 97 51                        STA  FPA0+1         ; * AT A TIME. THIS
2898 91d5 96 53                        LDA  FPA0+3         ; * IS FASTER THAN ONE
2899 91d7 97 52                        STA  FPA0+2         ; * BIT AT A TIME
2900 91d9 96 63                        LDA  FPSBYT         ; * BUT USES MORE MEMORY.
2901 91db 97 53                        STA  FPA0+3         ; * FPSBYT, THE CARRY IN
2902 91dd 0f 63                        CLR  FPSBYT         ; * BYTE, REPLACES THE MATISSA LSB.
2903 91df cb 08                        ADDB #8             ; SHIFTING ONE BYTE = 8 BIT SHIFTS; ADD 8 TO EXPONENT
2904 91e1 c1 28                        CMPB #5*8           ; CHECK FOR 5 SHIFTS
2905 91e3 2d e4                        BLT  LBA1D          ; BRANCH IF < 5 SHIFTS, IF > 5, THEN MANTISSA = 0
2906 91e5 4f                 LBA39     CLRA                ; A ZERO EXPONENT = 0 FLOATING POINT
2907 91e6 97 4f              LBA3A     STA  FP0EXP         ; ZERO OUT THE EXPONENT
2908 91e8 97 54                        STA  FP0SGN         ; ZERO OUT THE MANTISSA SIGN
2909 91ea 39                 LBA3E     RTS
2910 91eb 8d 6d              LBA3F     BSR  LBAAE          ; SHIFT FPA0 MANTISSA TO RIGHT
2911 91ed 5f                           CLRB                ; CLEAR CARRY FLAG
2912 91ee 20 a8                        BRA  LB9EC
2913                         * SHIFT FPA0 LEFT ONE BIT UNTIL BIT 7
2914                         * OF MATISSA MS BYTE = 1
2915 91f0 5c                 LBA44     INCB                ; ADD ONE TO EXPONENT ACCUMULATOR
2916 91f1 08 63                        ASL  FPSBYT         ; SHIFT SUB BYTE ONE LEFT
2917 91f3 09 53                        ROL  FPA0+3         ; SHIFT LS BYTE
2918 91f5 09 52                        ROL  FPA0+2         ; SHIFT NS BYTE
2919 91f7 09 51                        ROL  FPA0+1         ; SHIFT NS BYTE
2920 91f9 09 50                        ROL  FPA0           ; SHIFT MS BYTE
2921 91fb 2a f3              LBA4F     BPL  LBA44          ; BRANCH IF NOT YET NORMALIZED
2922 91fd 96 4f                        LDA  FP0EXP         ; GET CURRENT EXPONENT
2923 91ff 34 04                        PSHS B              ; SAVE EXPONENT MODIFIER CAUSED BY NORMALIZATION
2924 9201 a0 e0                        SUBA ,S+            ; SUBTRACT ACCUMULATED EXPONENT MODIFIER
2925 9203 97 4f                        STA  FP0EXP         ; SAVE AS NEW EXPONENT
2926 9205 23 de                        BLS  LBA39          ; SET FPA0 = 0 IF THE NORMALIZATION CAUSED
2927                         *         MORE OR EQUAL NUMBER OF LEFT SHIFTS THAN THE
2928                         *         SIZE OF THE EXPONENT
2929 9207 8c                           FCB  SKP2           ; SKIP 2 BYTES
2930 9208 25 08              LBA5C     BCS  LBA66          ; BRANCH IF MANTISSA OVERFLOW
2931 920a 08 63                        ASL  FPSBYT         ; SUB BYTE BIT 7 TO CARRY - USE AS ROUND-OFF
2932                         *                             ; FLAG (TRUNCATE THE REST OF SUB BYTE)
2933 920c 86 00                        LDA  #0             ; CLRA, BUT DO NOT CHANGE CARRY FLAG
2934 920e 97 63                        STA  FPSBYT         ; CLEAR THE SUB BYTE
2935 9210 20 0c                        BRA  LBA72          ; GO ROUND-OFF RESULT
2936 9212 0c 4f              LBA66     INC  FP0EXP         ; INCREMENT EXPONENT - MULTIPLY BY 2
2937 9214 27 28                        BEQ  LBA92          ; OVERFLOW ERROR IF CARRY PAST $FF
2938 9216 06 50                        ROR  FPA0           ; * SHIFT MANTISSA
2939 9218 06 51                        ROR  FPA0+1         ; * ONE TO
2940 921a 06 52                        ROR  FPA0+2         ; * THE RIGHT -
2941 921c 06 53                        ROR  FPA0+3         ; * DIVIDE BY TWO
2942 921e 24 04              LBA72     BCC  LBA78          ; BRANCH IF NO ROUND-OFF NEEDED
2943 9220 8d 0d                        BSR  LBA83          ; ADD ONE TO MANTISSA - ROUND OFF
2944 9222 27 ee                        BEQ  LBA66          ; BRANCH iF OVERFLOW - MANTISSA = 0
2945 9224 39                 LBA78     RTS
2946                         * NEGATE FPA0 MANTISSA
2947 9225 03 54              LBA79     COM  FP0SGN         ; TOGGLE SIGN OF MANTISSA
2948 9227 03 50              LBA7B     COM  FPA0           ; * COMPLEMENT ALL 4 MANTISSA BYTES
2949 9229 03 51                        COM  FPA0+1         ; *
2950 922b 03 52                        COM  FPA0+2         ; *
2951 922d 03 53                        COM  FPA0+3         ; *
2952                         * ADD ONE TO FPA0 MANTISSA
2953 922f 9e 52              LBA83     LDX  FPA0+2         ; * GET BOTTOM 2 MANTISSA
2954 9231 30 01                        LEAX 1,X            ; * BYTES, ADD ONE TO
2955 9233 9f 52                        STX  FPA0+2         ; * THEM AND SAVE THEM
2956 9235 26 06                        BNE  LBA91          ; BRANCH IF NO OVERFLOW
2957 9237 9e 50                        LDX  FPA0           ; * IF OVERFLOW ADD ONE
2958 9239 30 01                        LEAX 1,X            ; * TO TOP 2 MANTISSA
2959 923b 9f 50                        STX  FPA0           ; * BYTES AND SAVE THEM
2960 923d 39                 LBA91     RTS
2961 923e c6 0a              LBA92     LDB  #2*5           ; OV' OVERFLOW ERROR
2962 9240 7e 84 4e                     JMP  LAC46          ; PROCESS AN ERROR
2963 9243 8e 00 12           LBA97     LDX  #FPA2-1        ; POINT X TO FPA2
2964                         * SHIFT FPA POINTED TO BY (X) TO
2965                         * THE RIGHT -(B) TIMES. EXIT WITH
2966                         * ACCA CONTAINING DATA SHIFTED OUT
2967                         * TO THE RIGHT (SUB BYTE) AND THE DATA
2968                         * SHIFTED IN FROM THE LEFT WILL COME FROM FPCARY
2969 9246 a6 04              LBA9A     LDA  4,X            ; GET LS BYTE OF MANTISSA (X)
2970 9248 97 63                        STA  FPSBYT         ; SAVE IN FPA SUB BYTE
2971 924a a6 03                        LDA  3,X            ; * SHIFT THE NEXT THREE BYTES OF THE
2972 924c a7 04                        STA  4,X            ; * MANTISSA RIGHT ONE COMPLETE BYTE.
2973 924e a6 02                        LDA  2,X            ; *
2974 9250 a7 03                        STA  3,X            ; *
2975 9252 a6 01                        LDA  1,X            ; *
2976 9254 a7 02                        STA  2,X            ; *
2977 9256 96 5b                        LDA  FPCARY         ; GET THE CARRY IN BYTE
2978 9258 a7 01                        STA  1,X            ; STORE AS THE MS MANTISSA BYTE OF (X)
2979 925a cb 08              LBAAE     ADDB #8             ; ADD 8 TO DIFFERENCE OF EXPONENTS
2980 925c 2f e8                        BLE  LBA9A          ; BRANCH IF EXPONENT DIFFERENCE < -8
2981 925e 96 63                        LDA  FPSBYT         ; GET FPA SUB BYTE
2982 9260 c0 08                        SUBB #8             ; CAST OUT THE 8 ADDED IN ABOVE
2983 9262 27 0c                        BEQ  LBAC4          ; BRANCH IF EXPONENT DIFFERENCE = 0
2984                         
2985                         
2986 9264 67 01              LBAB8     ASR  1,X            ; * SHIFT MANTISSA AND SUB BYTE ONE BIT TO THE RIGHT
2987 9266 66 02              LBABA     ROR  2,X            ; *
2988 9268 66 03                        ROR  3,X            ; *
2989 926a 66 04                        ROR  4,X            ; *
2990 926c 46                           RORA                ; *
2991 926d 5c                           INCB                ; ADD ONE TO EXPONENT DIFFERENCE
2992 926e 26 f4                        BNE  LBAB8          ; BRANCH IF EXPONENTS NOT =
2993 9270 39                 LBAC4     RTS
2994 9271 81 00 00 00 00     LBAC5     FCB  $81,$00,$00,$00,$00 ; FLOATING POINT CONSTANT 1.0
2995                         
2996                         * ARITHMETIC OPERATION (*) JUMPS HERE - MULTIPLY
2997                         * FPA0 BY (X) - RETURN PRODUCT IN FPA0
2998 9276 8d 63              LBACA     BSR  LBB2F          ; MOVE PACKED FPA FROM (X) TO FPA1
2999 9278 27 60              LBACC     BEQ  LBB2E          ; BRANCH IF EXPONENT OF FPA0 = 0
3000 927a 8d 78                        BSR  LBB48          ; CALCULATE EXPONENT OF PRODUCT
3001                         * MULTIPLY FPA0 MANTISSA BY FPA1. NORMALIZE
3002                         * HIGH ORDER BYTES OF PRODUCT IN FPA0. THE
3003                         * LOW ORDER FOUR BYTES OF THE PRODUCT WILL
3004                         * BE STORED IN VAB-VAE.
3005 927c 86 00              LBAD0     LDA  #0             ; * ZERO OUT MANTISSA OF FPA2
3006 927e 97 13                        STA  FPA2           ; *
3007 9280 97 14                        STA  FPA2+1         ; *
3008 9282 97 15                        STA  FPA2+2         ; *
3009 9284 97 16                        STA  FPA2+3         ; *
3010 9286 d6 53                        LDB  FPA0+3         ; GET LS BYTE OF FPA0
3011 9288 8d 22                        BSR  LBB00          ; MULTIPLY BY FPA1
3012 928a d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 4
3013 928c d7 8a                        STB  VAE            ; *
3014 928e d6 52                        LDB  FPA0+2         ; GET NUMBER 3 MANTISSA BYTE OF FPA0
3015 9290 8d 1a                        BSR  LBB00          ; MULTIPLY BY FPA1
3016 9292 d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 3
3017 9294 d7 89                        STB  VAD            ; *
3018 9296 d6 51                        LDB  FPA0+1         ; GET NUMBER 2 MANTISSA BYTE OF FPA0
3019 9298 8d 12                        BSR  LBB00          ; MULTIPLY BY FPA1
3020 929a d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 2
3021 929c d7 88                        STB  VAC            ; *
3022 929e d6 50                        LDB  FPA0           ; GET MS BYTE OF FPA0 MANTISSA
3023 92a0 8d 0c                        BSR  LBB02          ; MULTIPLY BY FPA1
3024 92a2 d6 63                        LDB  FPSBYT         ; * TEMPORARILY SAVE SUB BYTE 1
3025 92a4 d7 87                        STB  VAB            ; *
3026 92a6 bd 93 b7                     JSR  LBC0B          ; COPY MANTISSA FROM FPA2 TO FPA0
3027 92a9 7e 91 c8                     JMP  LBA1C          ; NORMALIZE FPA0
3028 92ac 27 95              LBB00     BEQ  LBA97          ; SHIFT FPA2 ONE BYTE TO RIGHT
3029 92ae 43                 LBB02     COMA                ; SET CARRY FLAG
3030                         * MULTIPLY FPA1 MANTISSA BY ACCB AND
3031                         * ADD PRODUCT TO FPA2 MANTISSA
3032 92af 96 13              LBB03     LDA  FPA2           ; GET FPA2 MS BYTE
3033 92b1 56                           RORB                ; ROTATE CARRY FLAG INTO SHIFT COUNTER;
3034                         *         DATA BIT INTO CARRY
3035 92b2 27 26                        BEQ  LBB2E          ; BRANCH WHEN 8 SHIFTS DONE
3036 92b4 24 16                        BCC  LBB20          ; DO NOT ADD FPA1 IF DATA BIT = 0
3037 92b6 96 16                        LDA  FPA2+3         ; * ADD MANTISSA LS BYTE
3038 92b8 9b 60                        ADDA FPA1+3         ; *
3039 92ba 97 16                        STA  FPA2+3         ; *
3040 92bc 96 15                        LDA  FPA2+2         ; = ADD MANTISSA NUMBER 3 BYTE
3041 92be 99 5f                        ADCA FPA1+2         ; =
3042 92c0 97 15                        STA  FPA2+2         ; =
3043 92c2 96 14                        LDA  FPA2+1         ; * ADD MANTISSA NUMBER 2 BYTE
3044 92c4 99 5e                        ADCA FPA1+1         ; *
3045 92c6 97 14                        STA  FPA2+1         ; *
3046 92c8 96 13                        LDA  FPA2           ; = ADD MANTISSA MS BYTE
3047 92ca 99 5d                        ADCA FPA1           ; =
3048 92cc 46                 LBB20     RORA                ; * ROTATE CARRY INTO MS BYTE
3049 92cd 97 13                        STA  FPA2           ; *
3050 92cf 06 14                        ROR  FPA2+1         ; = ROTATE FPA2 ONE BIT TO THE RIGHT
3051 92d1 06 15                        ROR  FPA2+2         ; =
3052 92d3 06 16                        ROR  FPA2+3         ; =
3053 92d5 06 63                        ROR  FPSBYT         ; =
3054 92d7 4f                           CLRA                ; CLEAR CARRY FLAG
3055 92d8 20 d5                        BRA  LBB03          ; KEEP LOOPING
3056 92da 39                 LBB2E     RTS
3057                         * UNPACK A FP NUMBER FROM (X) TO FPA1
3058 92db ec 01              LBB2F     LDD  1,X            ; GET TWO MSB BYTES OF MANTISSA FROM
3059                         *         FPA  POINTED TO BY X
3060 92dd 97 61                        STA  FP1SGN         ; SAVE PACKED MANTISSA SIGN BYTE
3061 92df 8a 80                        ORA  #$80           ; FORCE BIT 7 OF MSB MANTISSA = 1
3062 92e1 dd 5d                        STD  FPA1           ; SAVE 2 MSB BYTES IN FPA1
3063 92e3 d6 61                        LDB  FP1SGN         ; * GET PACKED MANTISSA SIGN BYTE. EOR W/FPA0
3064 92e5 d8 54                        EORB FP0SGN         ; * SIGN - NEW SIGN POSITION IF BOTH OLD SIGNS ALIKE,
3065 92e7 d7 62                        STB  RESSGN         ; * NEG IF BOTH OLD SIGNS DIFF. SAVE ADJUSTED
3066                         *                             ; * MANTISSA SIGN BYTE
3067 92e9 ec 03                        LDD  3,X            ; = GET 2 LSB BYTES OF MANTISSA
3068 92eb dd 5f                        STD  FPA1+2         ; = AND PUT IN FPA1
3069 92ed a6 84                        LDA  ,X             ; * GET EXPONENT FROM (X) AND
3070 92ef 97 5c                        STA  FP1EXP         ; * PUT IN EXPONENT OF FPA1
3071 92f1 d6 4f                        LDB  FP0EXP         ; GET EXPONENT OF FPA0
3072 92f3 39                           RTS
3073                         * CALCULATE EXPONENT FOR PRODUCT OF FPA0 & FPA1
3074                         * ENTER WITH EXPONENT OF FPA1 IN ACCA
3075 92f4 4d                 LBB48     TSTA                ; TEST EXPONENT OF FPA1
3076 92f5 27 16                        BEQ  LBB61          ; PURGE RETURN ADDRESS & SET FPA0 = 0
3077 92f7 9b 4f                        ADDA FP0EXP         ; ADD FPA1 EXPONENT TO FPA0 EXPONENT
3078 92f9 46                           RORA                ; ROTATE CARRY INTO BIT 7; BIT 0 INTO CARRY
3079 92fa 49                           ROLA                ; SET OVERFLOW FLAG
3080 92fb 28 10                        BVC  LBB61          ; BRANCH IF EXPONENT TOO LARGE OR SMALL
3081 92fd 8b 80                        ADDA #$80           ; ADD $80 BIAS TO EXPONENT
3082 92ff 97 4f                        STA  FP0EXP         ; SAVE NEW EXPONENT
3083 9301 27 0c                        BEQ  LBB63          ; SET FPA0
3084 9303 96 62                        LDA  RESSGN         ; GET MANTISSA SIGN
3085 9305 97 54                        STA  FP0SGN         ; SAVE AS MANTISSA SIGN OF FPA0
3086 9307 39                           RTS
3087                         * IF FPA0 = POSITIVE THEN 'OV' ERROR IF FPA0
3088                         * = IS NEGATIVE THEN FPA0 = 0
3089 9308 96 54              LBB5C     LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
3090 930a 43                           COMA                ; CHANGE SIGN OF FPA0 MANTISSA
3091 930b 20 02                        BRA  LBB63
3092 930d 32 62              LBB61     LEAS 2,S            ; PURGE RETURN ADDRESS FROM STACK
3093 930f 10 2a fe d2        LBB63     LBPL LBA39          ; ZERO FPA0 MANTISSA SIGN & EXPONENT
3094 9313 7e 92 3e           LBB67     JMP  LBA92          ; 'OV' OVERFLOW ERROR
3095                         * FAST MULTIPLY BY 10 AND LEAVE RESULT IN FPA0
3096 9316 bd 94 0b           LBB6A     JSR  LBC5F          ; TRANSFER FPA0 TO FPA1
3097 9319 27 0d                        BEQ  LBB7C          ; BRANCH IF EXPONENT = 0
3098 931b 8b 02                        ADDA #2             ; ADD 2 TO EXPONENT (TIMES 4)
3099 931d 25 f4                        BCS  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
3100 931f 0f 62                        CLR  RESSGN         ; CLEAR RESULT SIGN BYTE
3101 9321 bd 91 79                     JSR  LB9CD          ; ADD FPA1 TO FPA0 (TIMES 5)
3102 9324 0c 4f                        INC  FP0EXP         ; ADD ONE TO EXPONENT (TIMES 10)
3103 9326 27 eb                        BEQ  LBB67          ; 'OV' ERROR IF EXPONENT > $FF
3104 9328 39                 LBB7C     RTS
3105 9329 84 20 00 00 00     LBB7D     FCB  $84,$20,$00,$00,$00 ; FLOATING POINT CONSTANT 10
3106                         * DIVIDE FPA0 BY 10
3107 932e bd 94 0b           LBB82     JSR  LBC5F          ; MOVE FPA0 TO FPA1
3108 9331 8e 93 29                     LDX  #LBB7D         ; POINT TO FLOATING POINT CONSTANT 10
3109 9334 5f                           CLRB                ; ZERO MANTISSA SIGN BYTE
3110 9335 d7 62              LBB89     STB  RESSGN         ; STORE THE QUOTIENT MANTISSA SIGN BYTE
3111 9337 bd 93 c0                     JSR  LBC14          ; UNPACK AN FP NUMBER FROM (X) INTO FPA0
3112 933a 8c                           FCB  SKP2           ; SKIP TWO BYTES
3113                         * DIVIDE (X) BY FPA0-LEAVE NORMALIZED QUOTIENT IN FPA0
3114 933b 8d 9e              LBB8F     BSR  LBB2F          ; GET FP NUMBER FROM (X) TO FPA1
3115                         
3116                         * ARITHMETIC OPERATION (/) JUMPS HERE. DIVIDE FPA1 BY FPA0 (ENTER WITH
3117                         * EXPONENT OF FPA1 IN ACCA AND FLAGS SET BY TSTA)
3118                         
3119                         * DIVIDE FPA1 BY FPA0
3120 933d 27 73              LBB91     BEQ  LBC06          ; '/0' DIVIDE BY ZERO ERROR
3121 933f 00 4f                        NEG  FP0EXP         ; GET EXPONENT OF RECIPROCAL OF DIVISOR
3122 9341 8d b1                        BSR  LBB48          ; CALCULATE EXPONENT OF QUOTIENT
3123 9343 0c 4f                        INC  FP0EXP         ; INCREMENT EXPONENT
3124 9345 27 cc                        BEQ  LBB67          ; 'OV' OVERFLOW ERROR
3125 9347 8e 00 13                     LDX  #FPA2          ; POINT X TO MANTISSA OF FPA2 - HOLD
3126                         *                             ; TEMPORARY QUOTIENT IN FPA2
3127 934a c6 04                        LDB  #4             ; 5 BYTE DIVIDE
3128 934c d7 03                        STB  TMPLOC         ; SAVE BYTE COUNTER
3129 934e c6 01                        LDB  #1             ; SHIFT COUNTER-AND TEMPORARY QUOTIENT BYTE
3130                         * COMPARE FPA0 MANTISSA TO FPA1 MANTISSA -
3131                         * SET CARRY FLAG IF FPA1 >= FPA0
3132 9350 96 50              LBBA4     LDA  FPA0           ; * COMPARE THE TWO MS BYTES
3133 9352 91 5d                        CMPA FPA1           ; * OF FPA0 AND FPA1 AND
3134 9354 26 13                        BNE  LBBBD          ; * BRANCH IF <>
3135 9356 96 51                        LDA  FPA0+1         ; = COMPARE THE NUMBER 2
3136 9358 91 5e                        CMPA FPA1+1         ; = BYTES AND
3137 935a 26 0d                        BNE  LBBBD          ; = BRANCH IF <>
3138 935c 96 52                        LDA  FPA0+2         ; * COMPARE THE NUMBER 3
3139 935e 91 5f                        CMPA FPA1+2         ; * BYTES AND
3140 9360 26 07                        BNE  LBBBD          ; * BRANCH IF <>
3141 9362 96 53                        LDA  FPA0+3         ; = COMPARE THE LS BYTES
3142 9364 91 60                        CMPA FPA1+3         ; = AND BRANCH
3143 9366 26 01                        BNE  LBBBD          ; = IF <>
3144 9368 43                           COMA                ; SET CARRY FLAG IF FPA0 = FPA1
3145 9369 1f a8              LBBBD     TFR  CC,A           ; SAVE CARRY FLAG STATUS IN ACCA; CARRY
3146                         *         CLEAR IF FPA0 > FPA1
3147 936b 59                           ROLB                ; ROTATE CARRY INTO TEMPORARY QUOTIENT BYTE
3148 936c 24 0a                        BCC  LBBCC          ; CARRY WILL BE SET AFTER 8 SHIFTS
3149 936e e7 80                        STB  ,X+            ; SAVE TEMPORARY QUOTIENT
3150 9370 0a 03                        DEC  TMPLOC         ; DECREMENT BYTE COUNTER
3151 9372 2b 34                        BMI  LBBFC          ; BRANCH IF DONE
3152 9374 27 2e                        BEQ  LBBF8          ; BRANCH IF LAST BYTE
3153 9376 c6 01                        LDB  #1             ; RESET SHIFT COUNTER AND TEMPORARY QUOTIENT BYTE
3154 9378 1f 8a              LBBCC     TFR  A,CC           ; RESTORE CARRY FLAG AND
3155 937a 25 0e                        BCS  LBBDE          ; BRANCH IF FPA0 =< FPA1
3156 937c 08 60              LBBD0     ASL  FPA1+3         ; * SHIFT FPA1 MANTISSA 1 BIT TO LEFT
3157 937e 09 5f                        ROL  FPA1+2         ; *
3158 9380 09 5e                        ROL  FPA1+1         ; *
3159 9382 09 5d                        ROL  FPA1           ; *
3160 9384 25 e3                        BCS  LBBBD          ; BRANCH IF CARRY - ADD ONE TO PARTIAL QUOTIENT
3161 9386 2b c8                        BMI  LBBA4          ; IF MSB OF HIGH ORDER MANTISSA BYTE IS
3162                         *         SET, CHECK THE MAGNITUDES OF FPA0, FPA1
3163 9388 20 df                        BRA  LBBBD          ; CARRY IS CLEAR, CHECK ANOTHER BIT
3164                         * SUBTRACT FPA0 FROM FPA1 - LEAVE RESULT IN FPA1
3165 938a 96 60              LBBDE     LDA  FPA1+3         ; * SUBTRACT THE LS BYTES OF MANTISSA
3166 938c 90 53                        SUBA FPA0+3         ; *
3167 938e 97 60                        STA  FPA1+3         ; *
3168 9390 96 5f                        LDA  FPA1+2         ; = THEN THE NEXT BYTE
3169 9392 92 52                        SBCA FPA0+2         ; =
3170 9394 97 5f                        STA  FPA1+2         ; =
3171 9396 96 5e                        LDA  FPA1+1         ; * AND THE NEXT
3172 9398 92 51                        SBCA FPA0+1         ; *
3173 939a 97 5e                        STA  FPA1+1         ; *
3174 939c 96 5d                        LDA  FPA1           ; = AND FINALLY, THE MS BYTE OF MANTISSA
3175 939e 92 50                        SBCA FPA0           ; =
3176 93a0 97 5d                        STA  FPA1           ; =
3177 93a2 20 d8                        BRA  LBBD0          ; GO SHIFT FPA1
3178 93a4 c6 40              LBBF8     LDB  #$40           ; USE ONLY TWO BITS OF THE LAST BYTE (FIFTH)
3179 93a6 20 d0                        BRA  LBBCC          ; GO SHIFT THE LAST BYTE
3180 93a8 56                 LBBFC     RORB                ; * SHIFT CARRY (ALWAYS SET HERE) INTO
3181 93a9 56                           RORB                ; * BIT 5 AND MOVE
3182 93aa 56                           RORB                ; * BITS 1,0 TO BITS 7,6
3183 93ab d7 63                        STB  FPSBYT         ; SAVE SUB BYTE
3184 93ad 8d 08                        BSR  LBC0B          ; MOVE MANTISSA OF FPA2 TO FPA0
3185 93af 7e 91 c8                     JMP  LBA1C          ; NORMALIZE FPA0
3186 93b2 c6 14              LBC06     LDB  #2*10          ; /0' ERROR
3187 93b4 7e 84 4e                     JMP  LAC46          ; PROCESS THE ERROR
3188                         * COPY MANTISSA FROM FPA2 TO FPA0
3189 93b7 9e 13              LBC0B     LDX  FPA2           ; * MOVE TOP 2 BYTES
3190 93b9 9f 50                        STX  FPA0           ; *
3191 93bb 9e 15                        LDX  FPA2+2         ; = MOVE BOTTOM 2 BYTES
3192 93bd 9f 52                        STX  FPA0+2         ; =
3193 93bf 39                           RTS
3194                         * COPY A PACKED FP NUMBER FROM (X) TO FPA0
3195 93c0 34 02              LBC14     PSHS A              ; SAVE ACCA
3196 93c2 ec 01                        LDD  1,X            ; GET TOP TWO MANTISSA BYTES
3197 93c4 97 54                        STA  FP0SGN         ; SAVE MS BYTE OF MANTISSA AS MANTISSA SIGN
3198 93c6 8a 80                        ORA  #$80           ; UNPACK MS BYTE
3199 93c8 dd 50                        STD  FPA0           ; SAVE UNPACKED TOP 2 MANTISSA BYTES
3200 93ca 0f 63                        CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
3201 93cc e6 84                        LDB  ,X             ; GET EXPONENT TO ACCB
3202 93ce ae 03                        LDX  3,X            ; * MOVE LAST 2
3203 93d0 9f 52                        STX  FPA0+2         ; * MANTISSA BYTES
3204 93d2 d7 4f                        STB  FP0EXP         ; SAVE EXPONENT
3205 93d4 35 82                        PULS A,PC           ; RESTORE ACCA AND RETURN
3206                         
3207 93d6 8e 00 45           LBC2A     LDX  #V45           ; POINT X TO MANTISSA OF FPA4
3208 93d9 20 06                        BRA  LBC35          ; MOVE FPA0 TO FPA4
3209 93db 8e 00 40           LBC2F     LDX  #V40           ; POINT X TO MANTISSA OF FPA3
3210 93de 8c                           FCB  SKP2           ; SKIP TWO BYTES
3211 93df 9e 3b              LBC33     LDX  VARDES         ; POINT X TO VARIABLE DESCRIPTOR IN VARDES
3212                         * PACK FPA0 AND MOVE IT TO ADDRESS IN X
3213 93e1 96 4f              LBC35     LDA  FP0EXP         ; * COPY EXPONENT
3214 93e3 a7 84                        STA  ,X             ; *
3215 93e5 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN BIT
3216 93e7 8a 7f                        ORA  #$7F           ; MASK THE BOTTOM 7 BITS
3217 93e9 94 50                        ANDA FPA0           ; AND BIT 7 OF MANTISSA SIGN INTO BIT 7 OF MS BYTE
3218 93eb a7 01                        STA  1,X            ; SAVE MS BYTE
3219 93ed 96 51                        LDA  FPA0+1         ; * MOVE 2ND MANTISSA BYTE
3220 93ef a7 02                        STA  2,X            ; *
3221 93f1 de 52                        LDU  FPA0+2         ; = MOVE BOTTOM 2 MANTISSA BYTES
3222 93f3 ef 03                        STU  3,X            ; =
3223 93f5 39                           RTS
3224                         * MOVE FPA1 TO FPA0 RETURN W/MANTISSA SIGN IN ACCA
3225 93f6 96 61              LBC4A     LDA  FP1SGN         ; * COPY MANTISSA SIGN FROM
3226 93f8 97 54              LBC4C     STA  FP0SGN         ; * FPA1 TO FPA0
3227 93fa 9e 5c                        LDX  FP1EXP         ; = COPY EXPONENT + MS BYTE FROM
3228 93fc 9f 4f                        STX  FP0EXP         ; = FPA1 TO FPA0
3229 93fe 0f 63                        CLR  FPSBYT         ; CLEAR MANTISSA SUB BYTE
3230 9400 96 5e                        LDA  FPA1+1         ; * COPY 2ND MANTISSA BYTE
3231 9402 97 51                        STA  FPA0+1         ; * FROM FPA1 TO FPA0
3232 9404 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN
3233 9406 9e 5f                        LDX  FPA1+2         ; * COPY 3RD AND 4TH MANTISSA BYTE
3234 9408 9f 52                        STX  FPA0+2         ; * FROM FPA1 TO FPA0
3235 940a 39                           RTS
3236                         * TRANSFER FPA0 TO FPA1
3237 940b dc 4f              LBC5F     LDD  FP0EXP         ; * TRANSFER EXPONENT & MS BYTE
3238 940d dd 5c                        STD  FP1EXP         ; *
3239 940f 9e 51                        LDX  FPA0+1         ; = TRANSFER MIDDLE TWO BYTES
3240 9411 9f 5e                        STX  FPA1+1         ; =
3241 9413 9e 53                        LDX  FPA0+3         ; * TRANSFER BOTTOM TWO BYTES
3242 9415 9f 60                        STX  FPA1+3         ; *
3243 9417 4d                           TSTA                ; SET FLAGS ACCORDING TO EXPONENT
3244 9418 39                           RTS
3245                         * CHECK FPA0; RETURN ACCB = 0 IF FPA0 = 0,
3246                         * ACCB = $FF IF FPA0 = NEGATIVE, ACCB = 1 IF FPA0 = POSITIVE
3247 9419 d6 4f              LBC6D     LDB  FP0EXP         ; GET EXPONENT
3248 941b 27 08                        BEQ  LBC79          ; BRANCH IF FPA0 = 0
3249 941d d6 54              LBC71     LDB  FP0SGN         ; GET SIGN OF MANTISSA
3250 941f 59                 LBC73     ROLB                ; BIT 7 TO CARRY
3251 9420 c6 ff                        LDB  #$FF           ; NEGATIVE FLAG
3252 9422 25 01                        BCS  LBC79          ; BRANCH IF NEGATIVE MANTISSA
3253 9424 50                           NEGB                ; ACCB = 1 IF POSITIVE MANTISSA
3254 9425 39                 LBC79     RTS
3255                         
3256                         * SGN
3257 9426 8d f1              SGN       BSR  LBC6D          ; SET ACCB ACCORDING TO SIGN OF FPA0
3258                         * CONVERT A SIGNED NUMBER IN ACCB INTO A FLOATING POINT NUMBER
3259 9428 d7 50              LBC7C     STB  FPA0           ; SAVE ACCB IN FPA0
3260 942a 0f 51                        CLR  FPA0+1         ; CLEAR NUMBER 2 MANTISSA BYTE OF FPA0
3261 942c c6 88                        LDB  #$88           ; EXPONENT REQUIRED IF FPA0 IS TO BE AN INTEGER
3262 942e 96 50              LBC82     LDA  FPA0           ; GET MS BYTE OF MANTISSA
3263 9430 80 80                        SUBA #$80           ; SET CARRY IF POSITIVE MANTISSA
3264 9432 d7 4f              LBC86     STB  FP0EXP         ; SAVE EXPONENT
3265 9434 dc 73                        LDD  ZERO           ; * ZERO OUT ACCD AND
3266 9436 dd 52                        STD  FPA0+2         ; * BOTTOM HALF OF FPA0
3267 9438 97 63                        STA  FPSBYT         ; CLEAR SUB BYTE
3268 943a 97 54                        STA  FP0SGN         ; CLEAR SIGN OF FPA0 MANTISSA
3269 943c 7e 91 c4                     JMP  LBA18          ; GO NORMALIZE FPA0
3270                         
3271                         * ABS
3272 943f 0f 54              ABS       CLR  FP0SGN         ; FORCE MANTISSA SIGN OF FPA0 POSITIVE
3273 9441 39                           RTS
3274                         * COMPARE A PACKED FLOATING POINT NUMBER POINTED TO
3275                         * BY (X) TO AN UNPACKED FP NUMBER IN FPA0. RETURN
3276                         * ZERO FLAG SET AND ACCB = 0, IF EQUAL; ACCB = 1 IF
3277                         * FPA0 > (X); ACCB = $FF IF FPA0 < (X)
3278 9442 e6 84              LBC96     LDB  ,X             ; CHECK EXPONENT OF (X)
3279 9444 27 d3                        BEQ  LBC6D          ; BRANCH IF FPA = 0
3280 9446 e6 01                        LDB  1,X            ; GET MS BYTE OF MANTISSA OF (X)
3281 9448 d8 54                        EORB FP0SGN         ; EOR WITH SIGN OF FPA0
3282 944a 2b d1                        BMI  LBC71          ; BRANCH IF SIGNS NOT =
3283                         * COMPARE FPA0 WITH FP NUMBER POINTED TO BY (X).
3284                         * FPA0 IS NORMALIZED, (X) IS PACKED.
3285 944c d6 4f              LBCA0     LDB  FP0EXP         ; * GET EXPONENT OF
3286 944e e1 84                        CMPB ,X             ; * FPA0, COMPARE TO EXPONENT OF
3287 9450 26 1d                        BNE  LBCC3          ; * (X) AND BRANCH IF <>.
3288 9452 e6 01                        LDB  1,X            ; * GET MS BYTE OF (X), KEEP ONLY
3289 9454 ca 7f                        ORB  #$7F           ; * THE SIGN BIT - 'AND' THE BOTTOM 7
3290 9456 d4 50                        ANDB FPA0           ; * BITS OF FPA0 INTO ACCB
3291 9458 e1 01                        CMPB 1,X            ; = COMPARE THE BOTTOM 7 BITS OF THE MANTISSA
3292 945a 26 13                        BNE  LBCC3          ; = MS BYTE AND BRANCH IF <>
3293 945c d6 51                        LDB  FPA0+1         ; * COMPARE 2ND BYTE
3294 945e e1 02                        CMPB 2,X            ; * OF MANTISSA,
3295 9460 26 0d                        BNE  LBCC3          ; * BRANCH IF <>
3296 9462 d6 52                        LDB  FPA0+2         ; = COMPARE 3RD BYTE
3297 9464 e1 03                        CMPB 3,X            ; = OF MANTISSA,
3298 9466 26 07                        BNE  LBCC3          ; = BRANCH IF <>
3299 9468 d6 53                        LDB  FPA0+3         ; * SUBTRACT LS BYTE
3300 946a e0 04                        SUBB 4,X            ; * OF (X) FROM LS BYTE OF
3301 946c 26 01                        BNE  LBCC3          ; * FPA0, BRANCH IF <>
3302 946e 39                           RTS                 ; RETURN IF FP (X) = FPA0
3303 946f 56                 LBCC3     RORB                ; SHIFT CARRY TO BIT 7; CARRY SET IF FPA0 < (X)
3304 9470 d8 54                        EORB FP0SGN         ; TOGGLE SIZE COMPARISON BIT IF FPA0 IS NEGATIVE
3305 9472 20 ab                        BRA  LBC73          ; GO SET ACCB ACCORDING TO COMPARISON
3306                         * DE-NORMALIZE FPA0 : SHIFT THE MANTISSA UNTIL THE BINARY POINT IS TO THE RIGHT
3307                         * OF THE LEAST SIGNIFICANT BYTE OF THE MANTISSA
3308 9474 d6 4f              LBCC8     LDB  FP0EXP         ; GET EXPONENT OF FPA0
3309 9476 27 3d                        BEQ  LBD09          ; ZERO MANTISSA IF FPA0 = 0
3310 9478 c0 a0                        SUBB #$A0           ; SUBTRACT $A0 FROM FPA0 EXPONENT T THIS WILL YIELD
3311                         *                             ; THE NUMBER OF SHIFTS REQUIRED TO DENORMALIZE FPA0. WHEN
3312                         *                             ; THE EXPONENT OF FPA0 IS = ZERO, THEN THE BINARY POINT
3313                         *                             ; WILL BE TO THE RIGHT OF THE MANTISSA
3314 947a 96 54                        LDA  FP0SGN         ; TEST SIGN OF FPA0 MANTISSA
3315 947c 2a 05                        BPL  LBCD7          ; BRANCH IF POSITIVE
3316 947e 03 5b                        COM  FPCARY         ; COMPLEMENT CARRY IN BYTE
3317 9480 bd 92 27                     JSR  LBA7B          ; NEGATE MANTISSA OF FPA0
3318 9483 8e 00 4f           LBCD7     LDX  #FP0EXP        ; POINT X TO FPA0
3319 9486 c1 f8                        CMPB #-8            ; EXPONENT DIFFERENCE < -8?
3320 9488 2e 06                        BGT  LBCE4          ; YES
3321 948a bd 92 5a                     JSR  LBAAE          ; SHIFT FPA0 RIGHT UNTIL FPA0 EXPONENT = $A0
3322 948d 0f 5b                        CLR  FPCARY         ; CLEAR CARRY IN BYTE
3323 948f 39                           RTS
3324 9490 0f 5b              LBCE4     CLR  FPCARY         ; CLEAR CARRY IN BYTE
3325 9492 96 54                        LDA  FP0SGN         ; * GET SIGN OF FPA0 MANTISSA
3326 9494 49                           ROLA                ; * ROTATE IT INTO THE CARRY FLAG
3327 9495 06 50                        ROR  FPA0           ; ROTATE CARRY (MANTISSA SIGN) INTO BIT 7
3328                         *                             ; OF LS BYTE OF MANTISSA
3329 9497 7e 92 66                     JMP  LBABA          ; DE-NORMALIZE FPA0
3330                         
3331                         * INT
3332                         * THE INT STATEMENT WILL "DENORMALIZE" FPA0 - THAT IS IT WILL SHIFT THE BINARY POINT
3333                         * TO THE EXTREME RIGHT OF THE MANTISSA TO FORCE ITS EXPONENT TO BE $AO. ONCE
3334                         * THIS IS DONE THE MANTISSA OF FPA0 WILL CONTAIN THE FOUR LEAST SIGNIFICANT
3335                         * BYTES OF THE INTEGER PORTION OF FPA0. AT THE CONCLUSION OF THE DE-NORMALIZATION
3336                         * ONLY THE INTEGER PORTION OF FPA0 WILL REMAIN.
3337                         *
3338 949a d6 4f              INT       LDB  FP0EXP         ; GET EXPONENT OF FPA0
3339 949c c1 a0                        CMPB #$A0           ; LARGEST POSSIBLE INTEGER EXPONENT
3340 949e 24 1d                        BCC  LBD11          ; RETURN IF FPA0 >= 32768
3341 94a0 8d d2                        BSR  LBCC8          ; SHIFT THE BINARY POINT ONE TO THE RIGHT OF THE
3342                         *                             ; LS BYTE OF THE FPA0 MANTISSA
3343 94a2 d7 63                        STB  FPSBYT         ; ACCB = 0: ZERO OUT THE SUB BYTE
3344 94a4 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN
3345 94a6 d7 54                        STB  FP0SGN         ; FORCE MANTISSA SIGN TO BE POSITIVE
3346 94a8 80 80                        SUBA #$80           ; SET CARRY IF MANTISSA
3347 94aa 86 a0                        LDA  #$A0           ; * GET DENORMALIZED EXPONENT AND
3348 94ac 97 4f                        STA  FP0EXP         ; * SAVE IT IN FPA0 EXPONENT
3349 94ae 96 53                        LDA  FPA0+3         ; = GET LS BYTE OF FPA0 AND
3350 94b0 97 01                        STA  CHARAC         ; = SAVE IT IN CHARAC
3351 94b2 7e 91 c4                     JMP  LBA18          ; NORMALIZE FPA0
3352                         
3353 94b5 d7 50              LBD09     STB  FPA0           ; * LOAD MANTISSA OF FPA0 WITH CONTENTS OF ACCB
3354 94b7 d7 51                        STB  FPA0+1         ; *
3355 94b9 d7 52                        STB  FPA0+2         ; *
3356 94bb d7 53                        STB  FPA0+3         ; *
3357 94bd 39                 LBD11     RTS                 ; *
3358                         
3359                         * CONVERT ASCII STRING TO FLOATING POINT
3360 94be 9e 73              LBD12     LDX  ZERO           ; (X) = 0
3361 94c0 9f 54                        STX  FP0SGN         ; * ZERO OUT FPA0 & THE SIGN FLAG (COEFCT)
3362 94c2 9f 4f                        STX  FP0EXP         ; *
3363 94c4 9f 51                        STX  FPA0+1         ; *
3364 94c6 9f 52                        STX  FPA0+2         ; *
3365 94c8 9f 47                        STX  V47            ; INITIALIZE EXPONENT & EXPONENT SIGN FLAG TO ZERO
3366 94ca 9f 45                        STX  V45            ; INITIALIZE RIGHT DECIMAL CTR & DECIMAL PT FLAG TO 0
3367 94cc 25 64                        BCS  LBD86          ; IF CARRY SET (NUMERIC CHARACTER), ASSUME ACCA CONTAINS FIRST
3368                         *         NUMERIC CHAR, SIGN IS POSITIVE AND SKIP THE RAM HOOK
3369 94ce bd 9b fb                     JSR  XVEC19         ; CALL EXTENDED BASIC ADD-IN
3370 94d1 81 2d              LBD25     CMPA #'-            ; * CHECK FOR A LEADING MINUS SIGN AND BRANCH
3371 94d3 26 04                        BNE  LBD2D          ; * IF NO MINUS SIGN
3372 94d5 03 55                        COM  COEFCT         ; TOGGLE SIGN; 0 = +; FF = -
3373 94d7 20 04                        BRA  LBD31          ; INTERPRET THE REST OF THE STRING
3374 94d9 81 2b              LBD2D     CMPA #'+            ; * CHECK FOR LEADING PLUS SlGN AND BRANCH
3375 94db 26 04                        BNE  LBD35          ; * IF NOT A PLUS SIGN
3376 94dd 9d 7b              LBD31     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
3377 94df 25 51                        BCS  LBD86          ; BRANCH IF NUMERIC CHARACTER
3378 94e1 81 2e              LBD35     CMPA #'.            ; DECIMAL POlNT?
3379 94e3 27 28                        BEQ  LBD61          ; YES
3380 94e5 81 45                        CMPA #'E            ; "E" SHORTHAND FORM (SCIENTIFIC NOTATION)?
3381 94e7 26 28                        BNE  LBD65          ; NO
3382                         * EVALUATE EXPONENT OF EXPONENTIAL FORMAT
3383 94e9 9d 7b                        JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
3384 94eb 25 64                        BCS  LBDA5          ; BRANCH IF NUMERIC
3385 94ed 81 aa                        CMPA #TOK_MINUS     ; MINUS TOKEN?
3386 94ef 27 0e                        BEQ  LBD53          ; YES
3387 94f1 81 2d                        CMPA #'-            ; ASCII MINUS?
3388 94f3 27 0a                        BEQ  LBD53          ; YES
3389 94f5 81 a9                        CMPA #TOK_PLUS      ; PLUS TOKEN?
3390 94f7 27 08                        BEQ  LBD55          ; YES
3391 94f9 81 2b                        CMPA #'+            ; ASCII PLUS?
3392 94fb 27 04                        BEQ  LBD55          ; YES
3393 94fd 20 06                        BRA  LBD59          ; BRANCH IF NO SIGN FOUND
3394 94ff 03 48              LBD53     COM  V48            ; SET EXPONENT SIGN FLAG TO NEGATIVE
3395                         * STRIP A DECIMAL NUMBER FROM BASIC LINE, CONVERT IT TO BINARY IN V47
3396 9501 9d 7b              LBD55     JSR  GETNCH         ; GET NEXT INPUT CHARACTER FROM BASIC
3397 9503 25 4c                        BCS  LBDA5          ; IF NUMERIC CHARACTER, CONVERT TO BINARY
3398 9505 0d 48              LBD59     TST  V48            ; * CHECK EXPONENT SIGN FLAG
3399 9507 27 08                        BEQ  LBD65          ; * AND BRANCH IF POSITIVE
3400 9509 00 47                        NEG  V47            ; NEGATE VALUE OF EXPONENT
3401 950b 20 04                        BRA  LBD65
3402 950d 03 46              LBD61     COM  V46            ; *TOGGLE DECIMAL PT FLAG AND INTERPRET ANOTHER
3403 950f 26 cc                        BNE  LBD31          ; *CHARACTER IF <> 0 - TERMINATE INTERPRETATION
3404                         *         IF   SECOND DECIMAL POINT
3405                         * ADJUST FPA0 FOR THE DECIMAL EXPONENT IN V47
3406 9511 96 47              LBD65     LDA  V47            ; * GET EXPONENT, SUBTRACT THE NUMBER OF
3407 9513 90 45                        SUBA V45            ; * PLACES TO THE RIGHT OF DECIMAL POINT
3408 9515 97 47                        STA  V47            ; * AND RESAVE IT.
3409 9517 27 12                        BEQ  LBD7F          ; EXIT ROUTINE IF ADJUSTED EXPONENT = ZERO
3410 9519 2a 09                        BPL  LBD78          ; BRANCH IF POSITIVE EXPONENT
3411 951b bd 93 2e           LBD6F     JSR  LBB82          ; DIVIDE FPA0 BY 10
3412 951e 0c 47                        INC  V47            ; INCREMENT EXPONENT COUNTER (MULTIPLY BY 10)
3413 9520 26 f9                        BNE  LBD6F          ; KEEP MULTIPLYING
3414 9522 20 07                        BRA  LBD7F          ; EXIT ROUTINE
3415 9524 bd 93 16           LBD78     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
3416 9527 0a 47                        DEC  V47            ; DECREMENT EXPONENT COUNTER (DIVIDE BY 10)
3417 9529 26 f9                        BNE  LBD78          ; KEEP MULTIPLYING
3418 952b 96 55              LBD7F     LDA  COEFCT         ; GET THE SIGN FLAG
3419 952d 2a 8e                        BPL  LBD11          ; RETURN IF POSITIVE
3420 952f 7e 96 95                     JMP  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0, IF NEGATIVE
3421                         *MULTIPLY FPA0 BY TEN AND ADD ACCA TO THE RESULT
3422 9532 d6 45              LBD86     LDB  V45            ; *GET THE RIGHT DECIMAL COUNTER AND SUBTRACT
3423 9534 d0 46                        SUBB V46            ; *THE DECIMAL POINT FLAG FROM IT. IF DECIMAL POINT
3424 9536 d7 45                        STB  V45            ; *FLAG=0, NOTHING HAPPENS. IF DECIMAL POINT FLAG IS
3425                         *                             -1, THEN RIGHT DECIMAL COUNTER IS INCREMENTED BY ONE
3426 9538 34 02                        PSHS A              ; SAVE NEW DIGIT ON STACK
3427 953a bd 93 16                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
3428 953d 35 04                        PULS B              ; GET NEW DIGIT BACK
3429 953f c0 30                        SUBB #'0            ; MASK OFF ASCII
3430 9541 8d 02                        BSR  LBD99          ; ADD ACCB TO FPA0
3431 9543 20 98                        BRA  LBD31          ; GET ANOTHER CHARACTER FROM BASIC
3432 9545 bd 93 db           LBD99     JSR  LBC2F          ; PACK FPA0 AND SAVE IT IN FPA3
3433 9548 bd 94 28                     JSR  LBC7C          ; CONVERT ACCB TO FP NUMBER IN FPA0
3434 954b 8e 00 40                     LDX  #V40           ; * ADD FPA0 TO
3435 954e 7e 91 6e                     JMP  LB9C2          ; * FPA3
3436                         
3437                         
3438 9551 d6 47              LBDA5     LDB  V47
3439 9553 58                           ASLB                ; TIMES 2
3440 9554 58                           ASLB                ; TIMES 4
3441 9555 db 47                        ADDB V47            ; ADD 1 = TIMES 5
3442 9557 58                           ASLB                ; TIMES 10
3443 9558 80 30                        SUBA #'0            ; *MASK OFF ASCII FROM ACCA, PUSH
3444 955a 34 04                        PSHS B              ; *RESULT ONTO THE STACK AND
3445 955c ab e0                        ADDA ,S+            ; ADD lT TO ACCB
3446 955e 97 47                        STA  V47            ; SAVE IN V47
3447 9560 20 9f                        BRA  LBD55          ; INTERPRET ANOTHER CHARACTER
3448                         *
3449 9562 9b 3e bc 1f fd     LBDB6     FCB  $9B,$3E,$BC,$1F,$FD ; * 99999999.9
3450 9567 9e 6e 6b 27 fd     LBDBB     FCB  $9E,$6E,$6B,$27,$FD ; * 999999999
3451 956c 9e 6e 6b 28 00     LBDC0     FCB  $9E,$6E,$6B,$28,$00 ; * 1E + 09
3452                         *
3453 9571 8e 83 ef           LBDC5     LDX  #LABE8-1       ; POINT X TO " IN " MESSAGE
3454 9574 8d 0c                        BSR  LBDD6          ; COPY A STRING FROM (X) TO CONSOLE OUT
3455 9576 dc 68                        LDD  CURLIN         ; GET CURRENT BASIC LINE NUMBER TO ACCD
3456                         * CONVERT VALUE IN ACCD INTO A DECIMAL NUMBER
3457                         * AND PRINT IT TO CONSOLE OUT
3458 9578 dd 50              LBDCC     STD  FPA0           ; SAVE ACCD IN TOP HALF OF FPA0
3459 957a c6 90                        LDB  #$90           ; REQ'D EXPONENT IF TOP HALF OF ACCD = INTEGER
3460 957c 43                           COMA                ; SET CARRY FLAG - FORCE POSITIVE MANTISSA
3461 957d bd 94 32                     JSR  LBC86          ; ZERO BOTTOM HALF AND SIGN OF FPA0, THEN
3462                         *         SAVE EXPONENT AND NORMALIZE IT
3463 9580 8d 03                        BSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
3464 9582 7e 91 48           LBDD6     JMP  LB99C          ; COPY A STRING FROM (X) TO CONSOLE OUT
3465                         
3466                         * CONVERT FP NUMBER TO ASCII STRING
3467 9585 ce 01 de           LBDD9     LDU  #STRBUF+3      ; POINT U TO BUFFER WHICH WILL NOT CAUSE
3468                         *                             ; THE STRING TO BE STORED IN STRING SPACE
3469 9588 86 20              LBDDC     LDA  #SPACE         ; SPACE = DEFAULT SIGN FOR POSITIVE #
3470 958a d6 54                        LDB  FP0SGN         ; GET SIGN OF FPA0
3471 958c 2a 02                        BPL  LBDE4          ; BRANCH IF POSITIVE
3472 958e 86 2d                        LDA  #'-            ; ASCII MINUS SIGN
3473 9590 a7 c0              LBDE4     STA  ,U+            ; STORE SIGN OF NUMBER
3474 9592 df 64                        STU  COEFPT         ; SAVE BUFFER POINTER
3475 9594 97 54                        STA  FP0SGN         ; SAVE SIGN (IN ASCII)
3476 9596 86 30                        LDA  #'0            ; ASCII ZERO IF EXPONENT = 0
3477 9598 d6 4f                        LDB  FP0EXP         ; GET FPA0 EXPONENT
3478 959a 10 27 00 c6                  LBEQ LBEB8          ; BRANCH IF FPA0 = 0
3479 959e 4f                           CLRA                ; BASE 10 EXPONENT=0 FOR FP NUMBER > 1
3480 959f c1 80                        CMPB #$80           ; CHECK EXPONENT
3481 95a1 22 08                        BHI  LBDFF          ; BRANCH IF FP NUMBER > 1
3482                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 TO SPEED UP THE CONVERSION PROCESS
3483 95a3 8e 95 6c                     LDX  #LBDC0         ; POINT X TO FP 1E+09
3484 95a6 bd 92 76                     JSR  LBACA          ; MULTIPLY FPA0 BY (X)
3485 95a9 86 f7                        LDA  #-9            ; BASE 10 EXPONENT = -9
3486 95ab 97 45              LBDFF     STA  V45            ; BASE 10 EXPONENT
3487                         * PSEUDO - NORMALIZE THE FP NUMBER TO A VALUE IN THE RANGE
3488                         * OF 999,999,999 RO 99,999,999.9 - THIS IS THE LARGEST
3489                         * NUMBER RANGE IN WHICH ALL OF THE DIGITS ARE
3490                         * SIGNIFICANT WHICH CAN BE DISPLAYED WITHOUT USING
3491                         * SCIENTIFIC NOTATION
3492 95ad 8e 95 67           LBE01     LDX  #LBDBB         ; POINT X TO FP 999,999,999
3493 95b0 bd 94 4c                     JSR  LBCA0          ; COMPARE FPA0 TO 999,999,999
3494 95b3 2e 0f                        BGT  LBE18          ; BRANCH IF > 999,999,999
3495 95b5 8e 95 62           LBE09     LDX  #LBDB6         ; POINT X TO FP 99,999,999.9
3496 95b8 bd 94 4c                     JSR  LBCA0          ; COMPARE FPA0 TO 99,999,999.9
3497 95bb 2e 0e                        BGT  LBE1F          ; BRANCH IF > 99,999,999.9 (IN RANGE)
3498 95bd bd 93 16                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
3499 95c0 0a 45                        DEC  V45            ; SUBTRACT ONE FROM DECIMAL OFFSET
3500 95c2 20 f1                        BRA  LBE09          ; PSEUDO - NORMALIZE SOME MORE
3501 95c4 bd 93 2e           LBE18     JSR  LBB82          ; DIVIDE FPA0 BY 10
3502 95c7 0c 45                        INC  V45            ; ADD ONE TO BASE 10 EXPONENT
3503 95c9 20 e2                        BRA  LBE01          ; PSEUDO - NORMALIZE SOME MORE
3504 95cb bd 91 60           LBE1F     JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
3505 95ce bd 94 74                     JSR  LBCC8          ; CONVERT FPA0 TO AN INTEGER
3506 95d1 c6 01                        LDB  #1             ; DEFAULT DECIMAL POINT FLAG (FORCE IMMED DECIMAL PT)
3507 95d3 96 45                        LDA  V45            ; * GET BASE 10 EXPONENT AND ADD TEN TO IT
3508 95d5 8b 0a                        ADDA #9+1           ; * (NUMBER 'NORMALIZED' TO 9 PLACES & DECIMAL PT)
3509 95d7 2b 09                        BMI  LBE36          ; BRANCH IF NUMBER < 1.0
3510 95d9 81 0b                        CMPA #9+2           ; NINE PLACES MAY BE DISPLAYED WITHOUT
3511                         *         USING SCIENTIFIC NOTATION
3512 95db 24 05                        BCC  LBE36          ; BRANCH IF SCIENTIFIC NOTATION REQUIRED
3513 95dd 4a                           DECA                ; * SUBTRACT 1 FROM MODIFIED BASE 10 EXPONENT CTR
3514 95de 1f 89                        TFR  A,B            ; * AND SAVE IT IN ACCB (DECiMAL POINT FLAG)
3515 95e0 86 02                        LDA  #2             ; FORCE EXPONENT = 0 - DON'T USE SCIENTIFIC NOTATION
3516 95e2 4a                 LBE36     DECA                ; * SUBTRACT TWO (WITHOUT AFFECTING CARRY)
3517 95e3 4a                           DECA                ; * FROM BASE 10 EXPONENT
3518 95e4 97 47                        STA  V47            ; SAVE EXPONENT - ZERO EXPONENT = DO NOT DISPLAY
3519                         *         IN   SCIENTIFIC NOTATION
3520 95e6 d7 45                        STB  V45            ; DECIMAL POINT FLAG - NUMBER OF PLACES TO
3521                         *         LEFT OF DECIMAL POINT
3522 95e8 2e 0d                        BGT  LBE4B          ; BRANCH IF >= 1
3523 95ea de 64                        LDU  COEFPT         ; POINT U TO THE STRING BUFFER
3524 95ec 86 2e                        LDA  #'.            ; * STORE A PERIOD
3525 95ee a7 c0                        STA  ,U+            ; * IN THE BUFFER
3526 95f0 5d                           TSTB                ; CHECK DECIMAL POINT FLAG
3527 95f1 27 04                        BEQ  LBE4B          ; BRANCH IF NOTHING TO LEFT OF DECIMAL POINT
3528 95f3 86 30                        LDA  #'0            ; * STORE A ZERO
3529 95f5 a7 c0                        STA  ,U+            ; * IN THE BUFFER
3530                         
3531                         * CONVERT FPA0 INTO A STRING OF ASCII DIGITS
3532 95f7 8e 96 71           LBE4B     LDX  #LBEC5         ; POINT X TO FP POWER OF 10 MANTISSA
3533 95fa c6 80                        LDB  #0+$80         ; INITIALIZE DIGIT COUNTER TO 0+$80
3534                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
3535                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
3536                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB IS HOW
3537                         * THE ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURING.
3538 95fc 96 53              LBE50     LDA  FPA0+3         ; * ADD MANTISSA LS
3539 95fe ab 03                        ADDA 3,X            ; * BYTE OF FPA0
3540 9600 97 53                        STA  FPA0+3         ; * AND (X)
3541 9602 96 52                        LDA  FPA0+2         ; = ADD MANTISSA
3542 9604 a9 02                        ADCA 2,X            ; = NUMBER 3 BYTE OF
3543 9606 97 52                        STA  FPA0+2         ; = FPA0 AND (X)
3544 9608 96 51                        LDA  FPA0+1         ; * ADD MANTISSA
3545 960a a9 01                        ADCA 1,X            ; * NUMBER 2 BYTE OF
3546 960c 97 51                        STA  FPA0+1         ; * FPA0 AND (X)
3547 960e 96 50                        LDA  FPA0           ; = ADD MANTISSA
3548 9610 a9 84                        ADCA ,X             ; = MS BYTE OF
3549 9612 97 50                        STA  FPA0           ; = FPA0 AND (X)
3550 9614 5c                           INCB                ; ADD ONE TO DIGIT COUNTER
3551 9615 56                           RORB                ; ROTATE CARRY INTO BIT 7
3552 9616 59                           ROLB                ; *SET OVERFLOW FLAG AND BRANCH IF CARRY = 1 AND
3553 9617 28 e3                        BVC  LBE50          ; *POSITIVE MANTISSA OR CARRY = 0 AND NEG MANTISSA
3554 9619 24 03                        BCC  LBE72          ; BRANCH IF NEGATIVE MANTISSA
3555 961b c0 0b                        SUBB #10+1          ; * TAKE THE 9'S COMPLEMENT IF
3556 961d 50                           NEGB                ; * ADDING MANTISSA
3557 961e cb 2f              LBE72     ADDB #'0-1          ; ADD ASCII OFFSET TO DIGIT
3558 9620 30 04                        LEAX 4,X            ; MOVE TO NEXT POWER OF 10 MANTISSA
3559 9622 1f 98                        TFR  B,A            ; SAVE DIGIT IN ACCA
3560 9624 84 7f                        ANDA #$7F           ; MASK OFF BIT 7 (ADD/SUBTRACT FLAG)
3561 9626 a7 c0                        STA  ,U+            ; STORE DIGIT IN STRING BUFFER
3562 9628 0a 45                        DEC  V45            ; DECREMENT DECIMAL POINT FLAG
3563 962a 26 04                        BNE  LBE84          ; BRANCH IF NOT TIME FOR DECIMAL POINT
3564 962c 86 2e                        LDA  #'.            ; * STORE DECIMAL POINT IN
3565 962e a7 c0                        STA  ,U+            ; * STRING BUFFER
3566 9630 53                 LBE84     COMB                ; TOGGLE BIT 7 (ADD/SUBTRACT FLAG)
3567 9631 c4 80                        ANDB #$80           ; MASK OFF ALL BUT ADD/SUBTRACT FLAG
3568 9633 8c 96 95                     CMPX #LBEC5+36      ; COMPARE X TO END OF MANTISSA TABLE
3569 9636 26 c4                        BNE  LBE50          ; BRANCH IF NOT AT END OF TABLE
3570                         * BLANK TRAILING ZEROS AND STORE EXPONENT IF ANY
3571 9638 a6 c2              LBE8C     LDA  ,-U            ; GET THE LAST CHARACTER; MOVE POINTER BACK
3572 963a 81 30                        CMPA #'0            ; WAS IT A ZERO?
3573 963c 27 fa                        BEQ  LBE8C          ; IGNORE TRAILING ZEROS IF SO
3574 963e 81 2e                        CMPA #'.            ; CHECK FOR DECIMAL POINT
3575 9640 26 02                        BNE  LBE98          ; BRANCH IF NOT DECIMAL POINT
3576 9642 33 5f                        LEAU -1,U           ; STEP OVER THE DECIMAL POINT
3577 9644 86 2b              LBE98     LDA  #'+            ; ASCII PLUS SIGN
3578 9646 d6 47                        LDB  V47            ; GET SCIENTIFIC NOTATION EXPONENT
3579 9648 27 1c                        BEQ  LBEBA          ; BRANCH IF NOT SCIENTIFIC NOTATION
3580 964a 2a 03                        BPL  LBEA3          ; BRANCH IF POSITIVE EXPONENT
3581 964c 86 2d                        LDA  #'-            ; ASCII MINUS SIGN
3582 964e 50                           NEGB                ; NEGATE EXPONENT IF NEGATIVE
3583 964f a7 42              LBEA3     STA  2,U            ; STORE EXPONENT SIGN IN STRING
3584 9651 86 45                        LDA  #'E            ; * GET ASCII 'E' (SCIENTIFIC NOTATION
3585 9653 a7 41                        STA  1,U            ; * FLAG) AND SAVE IT IN THE STRING
3586 9655 86 2f                        LDA  #'0-1          ; INITIALIZE ACCA TO ASCII ZERO
3587                         
3588                         
3589 9657 4c                 LBEAB     INCA                ; ADD ONE TO 10'S DIGIT OF EXPONENT
3590 9658 c0 0a                        SUBB #10            ; SUBTRACT 10 FROM ACCB
3591 965a 24 fb                        BCC  LBEAB          ; ADD 1 TO 10'S DIGIT IF NO CARRY
3592 965c cb 3a                        ADDB #'9+1          ; CONVERT UNITS DIGIT TO ASCII
3593 965e ed 43                        STD  3,U            ; SAVE EXPONENT IN STRING
3594 9660 6f 45                        CLR  5,U            ; CLEAR LAST BYTE (TERMINATOR)
3595 9662 20 04                        BRA  LBEBC          ; GO RESET POINTER
3596 9664 a7 c4              LBEB8     STA  ,U             ; STORE LAST CHARACTER
3597 9666 6f 41              LBEBA     CLR  1,U            ; CLEAR LAST BYTE (TERMINATOR - REQUIRED BY
3598                         *         PRINT SUBROUTINES)
3599 9668 8e 01 de           LBEBC     LDX  #STRBUF+3      ; RESET POINTER TO START OF BUFFER
3600 966b 39                           RTS
3601                         *
3602 966c 80 00 00 00 00     LBEC0     FCB  $80,$00,$00,$00,$00 ; FLOATING POINT .5
3603                         *
3604                         *** TABLE OF UNNORMALIZED POWERS OF 10
3605 9671 fa 0a 1f 00        LBEC5     FCB  $FA,$0A,$1F,$00 ; -100000000
3606 9675 00 98 96 80        LBEC9     FCB  $00,$98,$96,$80 ; 10000000
3607 9679 ff f0 bd c0        LBECD     FCB  $FF,$F0,$BD,$C0 ; -1000000
3608 967d 00 01 86 a0        LBED1     FCB  $00,$01,$86,$A0 ; 100000
3609 9681 ff ff d8 f0        LBED5     FCB  $FF,$FF,$D8,$F0 ; -10000
3610 9685 00 00 03 e8        LBED9     FCB  $00,$00,$03,$E8 ; 1000
3611 9689 ff ff ff 9c        LBEDD     FCB  $FF,$FF,$FF,$9C ; -100
3612 968d 00 00 00 0a        LBEE1     FCB  $00,$00,$00,$0A ; 10
3613 9691 ff ff ff ff        LBEE5     FCB  $FF,$FF,$FF,$FF ; -1
3614                         *
3615                         *
3616 9695 96 4f              LBEE9     LDA  FP0EXP         ; GET EXPONENT OF FPA0
3617 9697 27 02                        BEQ  LBEEF          ; BRANCH IF FPA0 = 0
3618 9699 03 54                        COM  FP0SGN         ; TOGGLE MANTISSA SIGN OF FPA0
3619 969b 39                 LBEEF     RTS
3620                         * EXPAND A POLYNOMIAL OF THE FORM
3621                         * AQ+BQ**3+CQ**5+DQ**7.... WHERE Q = FPA0
3622                         * AND THE X REGISTER POINTS TO A TABLE OF
3623                         * COEFFICIENTS A,B,C,D....
3624 969c 9f 64              LBEF0     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
3625 969e bd 93 db                     JSR  LBC2F          ; MOVE FPA0 TO FPA3
3626 96a1 8d 05                        BSR  LBEFC          ; MULTIPLY FPA3 BY FPA0
3627 96a3 8d 08                        BSR  LBF01          ; EXPAND POLYNOMIAL
3628 96a5 8e 00 40                     LDX  #V40           ; POINT X TO FPA3
3629 96a8 7e 92 76           LBEFC     JMP  LBACA          ; MULTIPLY (X) BY FPA0
3630                         
3631                         * CALCULATE THE VALUE OF AN EXPANDED POLYNOMIAL
3632                         * EXPRESSION. ENTER WITH (X) POINTING TO A TABLE
3633                         * OF COEFFICIENTS, THE FIRST BYTE OF WHICH IS THE
3634                         * NUMBER OF (COEFFICIENTS-1) FOLLOWED BY THAT NUMBER
3635                         * OF PACKED FLOATING POINT NUMBERS. THE
3636                         * POLYNOMIAL IS EVALUATED AS FOLLOWS: VALUE =
3637                         * (((FPA0*Y0+Y1)*FPA0+Y2)*FPA0...YN)
3638 96ab 9f 64              LBEFF     STX  COEFPT         ; SAVE COEFFICIENT TABLE POINTER
3639 96ad bd 93 d6           LBF01     JSR  LBC2A          ; MOVE FPA0 TO FPA4
3640 96b0 9e 64                        LDX  COEFPT         ; GET THE COEFFICIENT POINTER
3641 96b2 e6 80                        LDB  ,X+            ; GET THE TOP OF COEFFICIENT TABLE TO
3642 96b4 d7 55                        STB  COEFCT         ; * USE AND STORE IT IN TEMPORARY COUNTER
3643 96b6 9f 64                        STX  COEFPT         ; SAVE NEW COEFFICIENT POINTER
3644 96b8 8d ee              LBF0C     BSR  LBEFC          ; MULTIPLY (X) BY FPA0
3645 96ba 9e 64                        LDX  COEFPT         ; *GET COEFFICIENT POINTER
3646 96bc 30 05                        LEAX 5,X            ; *MOVE TO NEXT FP NUMBER
3647 96be 9f 64                        STX  COEFPT         ; *SAVE NEW COEFFICIENT POINTER
3648 96c0 bd 91 6e                     JSR  LB9C2          ; ADD (X) AND FPA0
3649 96c3 8e 00 45                     LDX  #V45           ; POINT (X) TO FPA4
3650 96c6 0a 55                        DEC  COEFCT         ; DECREMENT TEMP COUNTER
3651 96c8 26 ee                        BNE  LBF0C          ; BRANCH IF MORE COEFFICIENTS LEFT
3652 96ca 39                           RTS
3653                         
3654                         * RND
3655 96cb bd 94 19           RND       JSR  LBC6D          ; TEST FPA0
3656 96ce 2b 1f                        BMI  LBF45          ; BRANCH IF FPA0 = NEGATIVE
3657 96d0 27 15                        BEQ  LBF3B          ; BRANCH IF FPA0 = 0
3658 96d2 8d 10                        BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
3659 96d4 bd 93 db                     JSR  LBC2F          ; PACK FPA0 TO FPA3
3660 96d7 8d 0e                        BSR  LBF3B          ; GET A RANDOM NUMBER: FPA0 < 1.0
3661 96d9 8e 00 40                     LDX  #V40           ; POINT (X) TO FPA3
3662 96dc 8d ca                        BSR  LBEFC          ; MULTIPLY (X) BY FPA0
3663 96de 8e 92 71                     LDX  #LBAC5         ; POINT (X) TO FP VALUE OF 1.0
3664 96e1 bd 91 6e                     JSR  LB9C2          ; ADD 1.0 TO FPA0
3665 96e4 7e 94 9a           LBF38     JMP  INT            ; CONVERT FPA0 TO AN INTEGER
3666                         * CALCULATE A RANDOM NUMBER IN THE RANGE 0.0 < X <= 1.0
3667 96e7 9e 9e              LBF3B     LDX  RVSEED+1       ; * MOVE VARIABLE
3668 96e9 9f 50                        STX  FPA0           ; * RANDOM NUMBER
3669 96eb 9e a0                        LDX  RVSEED+3       ; * SEED TO
3670 96ed 9f 52                        STX  FPA0+2         ; * FPA0
3671 96ef be 97 1c           LBF45     LDX  RSEED          ; = MOVE FIXED
3672 96f2 9f 5d                        STX  FPA1           ; = RANDOM NUMBER
3673 96f4 be 97 1e                     LDX  RSEED+2        ; = SEED TO
3674 96f7 9f 5f                        STX  FPA1+2         ; = MANTISSA OF FPA0
3675 96f9 bd 92 7c                     JSR  LBAD0          ; MULTIPLY FPA0 X FPA1
3676 96fc dc 89                        LDD  VAD            ; GET THE TWO LOWEST ORDER PRODUCT BYTES
3677 96fe c3 65 8b                     ADDD #$658B         ; ADD A CONSTANT
3678 9701 dd a0                        STD  RVSEED+3       ; SAVE NEW LOW ORDER VARIABLE RANDOM # SEED
3679 9703 dd 52                        STD  FPA0+2         ; SAVE NEW LOW ORDER BYTES OF FPA0 MANTISSA
3680 9705 dc 87                        LDD  VAB            ; GET 2 MORE LOW ORDER PRODUCT BYTES
3681 9707 c9 b0                        ADCB #$B0           ; ADD A CONSTANT
3682 9709 89 05                        ADCA #5             ; ADD A CONSTANT
3683 970b dd 9e                        STD  RVSEED+1       ; SAVE NEW HIGH ORDER VARIABLE RANDOM # SEED
3684 970d dd 50                        STD  FPA0           ; SAVE NEW HIGH ORDER FPA0 MANTISSA
3685 970f 0f 54                        CLR  FP0SGN         ; FORCE FPA0 MANTISSA = POSITIVE
3686 9711 86 80                        LDA  #$80           ; * SET FPA0 BIASED EXPONENT
3687 9713 97 4f                        STA  FP0EXP         ; * TO 0 1 < FPA0 < 0
3688 9715 96 15                        LDA  FPA2+2         ; GET A BYTE FROM FPA2 (MORE RANDOMNESS)
3689 9717 97 63                        STA  FPSBYT         ; SAVE AS SUB BYTE
3690 9719 7e 91 c8                     JMP  LBA1C          ; NORMALIZE FPA0
3691                         *
3692 971c 40 e6              RSEED     FDB  $40E6          ; *CONSTANT RANDOM NUMBER GENERATOR SEED
3693 971e 4d ab                        FDB  $4DAB          ; *
3694                         
3695                         * SIN
3696                         * THE SIN FUNCTION REQUIRES AN ARGUMENT IN RADIANS AND WILL REPEAT ITSELF EVERY
3697                         * 2*PI RADIANS. THE ARGUMENT IS DIVIDED BY 2*PI AND ONLY THE FRACTIONAL PART IS
3698                         * RETAINED. SINCE THE ARGUMENT WAS DIVIDED BY 2*P1, THE COEFFICIENTS MUST BE
3699                         * MULTIPLIED BY THE APPROPRIATE POWER OF 2*PI.
3700                         
3701                         * SIN IS EVALUATED USING THE TRIGONOMETRIC IDENTITIES BELOW:
3702                         * SIN(X)=SIN(PI-X) & -SIN(PI/2-X)=SIN((3*PI)/2+X)
3703 9720 bd 94 0b           SIN       JSR  LBC5F          ; COPY FPA0 TO FPA1
3704 9723 8e 97 65                     LDX  #LBFBD         ; POINT (X) TO 2*PI
3705 9726 d6 61                        LDB  FP1SGN         ; *GET MANTISSA SIGN OF FPA1
3706 9728 bd 93 35                     JSR  LBB89          ; *AND DIVIDE FPA0 BY 2*PI
3707 972b bd 94 0b                     JSR  LBC5F          ; COPY FPA0 TO FPA1
3708 972e 8d b4                        BSR  LBF38          ; CONVERT FPA0 TO AN INTEGER
3709 9730 0f 62                        CLR  RESSGN         ; SET RESULT SIGN = POSITIVE
3710 9732 96 5c                        LDA  FP1EXP         ; *GET EXPONENT OF FPA1
3711 9734 d6 4f                        LDB  FP0EXP         ; *GET EXPONENT OF FPA0
3712 9736 bd 91 68                     JSR  LB9BC          ; *SUBTRACT FPA0 FROM FPA1
3713                         * NOW FPA0 CONTAINS ONLY THE FRACTIONAL PART OF ARGUMENT/2*PI
3714 9739 8e 97 6a                     LDX  #LBFC2         ; POINT X TO FP (.25)
3715 973c bd 91 65                     JSR  LB9B9          ; SUBTRACT FPA0 FROM .25 (PI/2)
3716 973f 96 54                        LDA  FP0SGN         ; GET MANTISSA SIGN OF FPA0
3717 9741 34 02                        PSHS A              ; SAVE IT ON STACK
3718 9743 2a 09                        BPL  LBFA6          ; BRANCH IF MANTISSA POSITIVE
3719 9745 bd 91 60                     JSR  LB9B4          ; ADD .5 (PI) TO FPA0
3720 9748 96 54                        LDA  FP0SGN         ; GET SIGN OF FPA0
3721 974a 2b 05                        BMI  LBFA9          ; BRANCH IF NEGATIVE
3722 974c 03 0a                        COM  RELFLG         ; COM IF +(3*PI)/2 >= ARGUMENT >+ PI/2 (QUADRANT FLAG)
3723 974e bd 96 95           LBFA6     JSR  LBEE9          ; TOGGLE MANTISSA SIGN OF FPA0
3724 9751 8e 97 6a           LBFA9     LDX  #LBFC2         ; POINT X TO FP (.25)
3725 9754 bd 91 6e                     JSR  LB9C2          ; ADD .25 (PI/2) TO FPA0
3726 9757 35 02                        PULS A              ; GET OLD MANTISSA SIGN
3727 9759 4d                           TSTA                ; * BRANCH IF OLD
3728 975a 2a 03                        BPL  LBFB7          ; * SIGN WAS POSITIVE
3729 975c bd 96 95                     JSR  LBEE9          ; TOGGLE MANTISSA SIGN
3730 975f 8e 97 6f           LBFB7     LDX  #LBFC7         ; POINT X TO TABLE OF COEFFICIENTS
3731 9762 7e 96 9c                     JMP  LBEF0          ; GO CALCULATE POLYNOMIAL VALUE
3732                         
3733 9765 83 49 0f da a2     LBFBD     FCB  $83,$49,$0F,$DA,$A2 ; 6.28318531 (2*PI)
3734 976a 7f 00 00 00 00     LBFC2     FCB  $7F,$00,$00,$00,$00 ; .25
3735                         
3736                         
3737 976f 05                 LBFC7     FCB  6-1            ; SIX COEFFICIENTS
3738 9770 84 e6 1a 2d 1b     LBFC8     FCB  $84,$E6,$1A,$2D,$1B ; * -((2*PI)**11)/11!
3739 9775 86 28 07 fb f8     LBFCD     FCB  $86,$28,$07,$FB,$F8 ; * ((2*PI)**9)/9!
3740 977a 87 99 68 89 01     LBFD2     FCB  $87,$99,$68,$89,$01 ; * -((2*PI)**7)/7!
3741 977f 87 23 35 df e1     LBFD7     FCB  $87,$23,$35,$DF,$E1 ; * ((2*PI)**5)/5!
3742 9784 86 a5 5d e7 28     LBFDC     FCB  $86,$A5,$5D,$E7,$28 ; * -((2*PI)**3)/3!
3743 9789 83 49 0f da a2     LBFE1     FCB  $83,$49,$0F,$DA,$A2 ; *
3744                         
3745 978e a1 54 46 8f 13               FCB  $A1,$54,$46,$8F,$13 ; UNUSED GARBAGE BYTES
3746 9793 8f 52 43 89 cd               FCB  $8F,$52,$43,$89,$CD ; UNUSED GARBAGE BYTES
3747                         * EXTENDED BASIC
3748                         
3749                         * COS
3750                         * THE VALUE OF COS(X) IS DETERMINED BY THE TRIG IDENTITY COS(X)=SIN((PI/2)+X)
3751 9798 8e 97 cb           COS       LDX  #L83AB         ; POINT X TO FP CONSTANT (P1/2)
3752 979b bd 91 6e                     JSR  LB9C2          ; ADD FPA0 TO (X)
3753 979e 7e 97 20           L837E     JMP  SIN            ; JUMP TO SIN ROUTINE
3754                         
3755                         * TAN
3756                         * THE VALUE OF TAN(X) IS DETERMINED BY THE TRIG IDENTITY TAN(X)=SIN(X)/COS(X)
3757 97a1 bd 93 db           TAN       JSR  LBC2F          ; PACK FPA0 AND MOVE IT TO FPA3
3758 97a4 0f 0a                        CLR  RELFLG         ; RESET QUADRANT FLAG
3759 97a6 8d f6                        BSR  L837E          ; CALCULATE SIN OF ARGUMENT
3760 97a8 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5
3761 97ab bd 93 e1                     JSR  LBC35          ; PACK FPA0 AND MOVE IT TO FPA5
3762 97ae 8e 00 40                     LDX  #V40           ; POINT X TO FPA3
3763 97b1 bd 93 c0                     JSR  LBC14          ; MOVE FPA3 TO FPA0
3764 97b4 0f 54                        CLR  FP0SGN         ; FORCE FPA0 MANTISSA TO BE POSITIVE
3765 97b6 96 0a                        LDA  RELFLG         ; GET THE QUADRANT FLAG - COS NEGATIVE IN QUADS 2,3
3766 97b8 8d 0c                        BSR  L83A6          ; CALCULATE VALUE OF COS(FPA0)
3767 97ba 0d 4f                        TST  FP0EXP         ; CHECK EXPONENT OF FPA0
3768 97bc 10 27 fa 7e                  LBEQ LBA92          ; ''OV' ERROR IF COS(X)=0
3769 97c0 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5
3770 97c3 7e 93 3b           L83A3     JMP  LBB8F          ; DIVIDE (X) BY FPA0 - SIN(X)/COS(X)
3771 97c6 34 02              L83A6     PSHS A              ; SAVE SIGN FLAG ON STACK
3772 97c8 7e 97 4e                     JMP  LBFA6          ; EXPAND POLYNOMIAL
3773                         
3774 97cb 81 49 0f da a2     L83AB     FCB  $81,$49,$0F,$DA,$A2 ; 1.57079633 (PI/2)
3775                         
3776                         * ATN
3777                         * A 12 TERM TAYLOR SERIES IS USED TO EVALUATE THE
3778                         * ARCTAN EXPRESSION. TWO  DIFFERENT FORMULI ARE USED
3779                         * TO EVALUATE THE EXPRESSION DEPENDING UPON
3780                         * WHETHER OR NOT THE ARGUMENT SQUARED IS > OR < 1.0
3781                         
3782                         * IF X**2<1 THEN ATN=X-(X**3)/3+(X**5)/5-(X**7)/7. . .
3783                         * IF X**2>=1 THEN ATN=PI/2-(1/X-1/((X**3)*3)+(1/((X**5)*5)-. . .)
3784                         
3785 97d0 96 54              ATN       LDA  FP0SGN         ; * GET THE SIGN OF THE MANTISSA AND
3786 97d2 34 02                        PSHS A              ; * SAVE IT ON THE STACK
3787 97d4 2a 02                        BPL  L83B8          ; BRANCH IF POSITIVE MANTISSA
3788 97d6 8d 24                        BSR  L83DC          ; CHANGE SIGN OF FPA0
3789 97d8 96 4f              L83B8     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
3790 97da 34 02                        PSHS A              ; * SAVE IT ON THE STACK
3791 97dc 81 81                        CMPA #$81           ; IS FPAO < 1.0?
3792 97de 25 05                        BLO  L83C5          ; YES
3793 97e0 8e 92 71                     LDX  #LBAC5         ; POINT X TO FP CONSTANT 1.0
3794 97e3 8d de                        BSR  L83A3          ; GET RECIPROCAL OF FPA0
3795 97e5 8e 98 00           L83C5     LDX  #L83E0         ; POINT (X) TO TAYLOR SERIES COEFFICIENTS
3796 97e8 bd 96 9c                     JSR  LBEF0          ; EXPAND POLYNOMIAL
3797 97eb 35 02                        PULS A              ; GET EXPONENT OF ARGUMENT
3798 97ed 81 81                        CMPA #$81           ; WAS ARGUMENT < 1.0?
3799 97ef 25 06                        BLO  L83D7          ; YES
3800 97f1 8e 97 cb                     LDX  #L83AB         ; POINT (X) TO FP NUMBER (PI/2)
3801 97f4 bd 91 65                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (PI/2)
3802 97f7 35 02              L83D7     PULS A              ; * GET SIGN OF INITIAL ARGUMENT MANTISSA
3803 97f9 4d                           TSTA                ; * AND SET FLAGS ACCORDING TO IT
3804 97fa 2a 03                        BPL  L83DF          ; RETURN IF ARGUMENT WAS POSITIVE
3805 97fc 7e 96 95           L83DC     JMP  LBEE9          ; CHANGE MANTISSA SIGN OF FPA0
3806 97ff 39                 L83DF     RTS
3807                         *
3808                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR ARCTANGENT
3809 9800 0b                 L83E0     FCB  $0B            ; TWELVE COEFFICIENTS
3810 9801 76 b3 83 bd d3     L83E1     FCB  $76,$B3,$83,$BD,$D3 ; -6.84793912E-04 1/23
3811 9806 79 1e f4 a6 f5     L83E6     FCB  $79,$1E,$F4,$A6,$F5 ; +4.85094216E-03 1/21
3812 980b 7b 83 fc b0 10     L83EB     FCB  $7B,$83,$FC,$B0,$10 ; -0.0161117018
3813 9810 7c 0c 1f 67 ca     L83F0     FCB  $7C,$0C,$1F,$67,$CA ; 0.0342096381
3814 9815 7c de 53 cb c1     L83F5     FCB  $7C,$DE,$53,$CB,$C1 ; -0.0542791328
3815 981a 7d 14 64 70 4c     L83FA     FCB  $7D,$14,$64,$70,$4C ; 0.0724571965
3816 981f 7d b7 ea 51 7a     L83FF     FCB  $7D,$B7,$EA,$51,$7A ; -0.0898023954
3817 9824 7d 63 30 88 7e     L8404     FCB  $7D,$63,$30,$88,$7E ; 0.110932413
3818 9829 7e 92 44 99 3a     L8409     FCB  $7E,$92,$44,$99,$3A ; -0.142839808
3819 982e 7e 4c cc 91 c7     L840E     FCB  $7E,$4C,$CC,$91,$C7 ; 0.199999121
3820 9833 7f aa aa aa 13     L8413     FCB  $7F,$AA,$AA,$AA,$13 ; -0.333333316
3821 9838 81 00 00 00 00     L8418     FCB  $81,$00,$00,$00,$00 ; 1
3822                         *
3823                         *** TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR LN(X)
3824                         *
3825 983d 03                 L841D     FCB  3              ; FOUR COEFFICIENTS
3826 983e 7f 5e 56 cb 79     L841E     FCB  $7F,$5E,$56,$CB,$79 ; 0.434255942
3827 9843 80 13 9b 0b 64     L8423     FCB  $80,$13,$9B,$0B,$64 ; 0.576584541
3828 9848 80 76 38 93 16     L8428     FCB  $80,$76,$38,$93,$16 ; 0.961800759
3829 984d 82 38 aa 3b 20     L842D     FCB  $82,$38,$AA,$3B,$20 ; 2.88539007
3830                         
3831 9852 80 35 04 f3 34     L8432     FCB  $80,$35,$04,$F3,$34 ; 1/SQR(2)
3832                         
3833 9857 81 35 04 f3 34     L8437     FCB  $81,$35,$04,$F3,$34 ; SQR(2)
3834                         
3835 985c 80 80 00 00 00     L843C     FCB  $80,$80,$00,$00,$00 ; -0.5
3836                         
3837 9861 80 31 72 17 f8     L8441     FCB  $80,$31,$72,$17,$F8 ; LN(2)
3838                         *
3839                         * LOG - NATURAL LOGARITHM (LN)
3840                         
3841                         * THE NATURAL OR NAPERIAN LOGARITHM IS CALCULATED USING
3842                         * MATHEMATICAL IDENTITIES. FPA0 IS OF THE FORM FPA0=A*(2**B) (SCIENTIFIC
3843                         * NOTATION). THEREFORE, THE LOG ROUTINE DETERMINES THE VALUE OF
3844                         * LN(A*(2**B)). A SERIES OF MATHEMATICAL IDENTITIES WILL EXPAND THIS
3845                         * TERM: LN(A*(2**B))=(-1/2+(1/LN(2))*(LN(A*SQR(2)))+B)*LN(2). ALL OF
3846                         * THE TERMS OF THE LATTER EXPRESSION ARE CONSTANTS EXCEPT FOR THE
3847                         * LN(A*SQR(2)) TERM WHICH IS EVALUATED USING THE TAYLOR SERIES EXPANSION
3848 9866 bd 94 19           LOG       JSR  LBC6D          ; CHECK STATUS OF FPA0
3849 9869 10 2f f3 b0                  LBLE LB44A          ; 'FC' ERROR IF NEGATIVE OR ZERO
3850 986d 8e 98 52                     LDX  #L8432         ; POINT (X) TO FP NUMBER (1/SQR(2))
3851 9870 96 4f                        LDA  FP0EXP         ; *GET EXPONENT OF ARGUMENT
3852 9872 80 80                        SUBA #$80           ; *SUBTRACT OFF THE BIAS AND
3853 9874 34 02                        PSHS A              ; *SAVE IT ON THE STACK
3854 9876 86 80                        LDA  #$80
3855 9878 97 4f                        STA  FP0EXP
3856 987a bd 91 6e                     JSR  LB9C2          ; ADD FPA0 TO (X)
3857 987d 8e 98 57                     LDX  #L8437         ; POINT X TO SQR(2)
3858 9880 bd 93 3b                     JSR  LBB8F          ; DIVIDE SQR(2) BY FPA0
3859 9883 8e 92 71                     LDX  #LBAC5         ; POINT X TO FP VALUE OF 1.00
3860 9886 bd 91 65                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (X)
3861                         *         NOW  FPA0 = (1-SQR(2)*X)/(1+SQR(2)*X) WHERE X IS ARGUMENT
3862 9889 8e 98 3d                     LDX  #L841D         ; POINT X TO TABLE OF COEFFICIENTS
3863 988c bd 96 9c                     JSR  LBEF0          ; EXPAND POLYNOMIAL
3864 988f 8e 98 5c                     LDX  #L843C         ; POINT X TO FP VALUE OF (-.5)
3865 9892 bd 91 6e                     JSR  LB9C2          ; ADD FPA0 TO X
3866 9895 35 04                        PULS B              ; GET EXPONENT OF ARGUMENT BACK (WITHOUT BIAS)
3867 9897 bd 95 45                     JSR  LBD99          ; ADD ACCB TO FPA0
3868 989a 8e 98 61                     LDX  #L8441         ; POINT X TO LN(2)
3869 989d 7e 92 76                     JMP  LBACA          ; MULTIPLY FPA0 * LN(2)
3870                         
3871                         * SQR
3872 98a0 bd 94 0b           SQR       JSR  LBC5F          ; MOVE FPA0 TO FPA1
3873 98a3 8e 96 6c                     LDX  #LBEC0         ; POINT (X) TO FP NUMBER (.5)
3874 98a6 bd 93 c0                     JSR  LBC14          ; COPY A PACKED NUMBER FROM (X) TO FPA0
3875                         
3876                         * ARITHMETIC OPERATOR FOR EXPONENTIATION JUMPS
3877                         * HERE. THE FORMULA USED TO EVALUATE EXPONENTIATION
3878                         * IS A**X=E**(X LN A) = E**(FPA0*LN(FPA1)), E=2.7182818
3879 98a9 27 67              L8489     BEQ  EXP            ; DO A NATURAL EXPONENTIATION IF EXPONENT = 0
3880 98ab 4d                           TSTA                ; *CHECK VALUE BEING EXPONENTIATED
3881 98ac 26 03                        BNE  L8491          ; *AND BRANCH IF IT IS <> 0
3882 98ae 7e 91 e6                     JMP  LBA3A          ; FPA0=0 IF RAISING ZERO TO A POWER
3883 98b1 8e 00 4a           L8491     LDX  #V4A           ; * PACK FPA0 AND SAVE
3884 98b4 bd 93 e1                     JSR  LBC35          ; * IT IN FPA5 (ARGUMENT'S EXPONENT)
3885 98b7 5f                           CLRB                ; ACCB=DEFAULT RESULT SIGN FLAG; 0=POSITIVE
3886 98b8 96 61                        LDA  FP1SGN         ; *CHECK THE SIGN OF ARGUMENT
3887 98ba 2a 10                        BPL  L84AC          ; *BRANCH IF POSITIVE
3888 98bc bd 94 9a                     JSR  INT            ; CONVERT EXPONENT INTO AN INTEGER
3889 98bf 8e 00 4a                     LDX  #V4A           ; POINT X TO FPA5 (ORIGINAL EXPONENT)
3890 98c2 96 61                        LDA  FP1SGN         ; GET MANTISSA SIGN OF FPA1 (ARGUMENT)
3891 98c4 bd 94 4c                     JSR  LBCA0          ; *COMPARE FPA0 TO (X) AND
3892 98c7 26 03                        BNE  L84AC          ; *BRANCH IF NOT EQUAL
3893 98c9 43                           COMA                ; TOGGLE FPA1 MANTISSA SIGN - FORCE POSITIVE
3894 98ca d6 01                        LDB  CHARAC         ; GET LS BYTE OF INTEGER VALUE OF EXPONENT (RESULT SIGN FLAG)
3895 98cc bd 93 f8           L84AC     JSR  LBC4C          ; COPY FPA1 TO FPA0; ACCA = MANTISSA SIGN
3896 98cf 34 04                        PSHS B              ; PUT RESULT SIGN FLAG ON THE STACK
3897 98d1 bd 98 66                     JSR  LOG
3898 98d4 8e 00 4a                     LDX  #V4A           ; POINT (X) TO FPA5
3899 98d7 bd 92 76                     JSR  LBACA          ; MULTIPLY FPA0 BY FPA5
3900 98da 8d 36                        BSR  EXP            ; CALCULATE E**(FPA0)
3901 98dc 35 02                        PULS A              ; * GET RESULT SIGN FLAG FROM THE STACK
3902 98de 46                           RORA                ; * AND BRANCH IF NEGATIVE
3903 98df 10 25 fd b2                  LBCS LBEE9          ; CHANGE SIGN OF FPA0 MANTISSA
3904 98e3 39                           RTS
3905                         
3906                         * CORRECTION FACTOR FOR EXPONENTIAL FUNCTION
3907 98e4 81 38 aa 3b 29     L84C4     FCB  $81,$38,$AA,$3B,$29 ; 1.44269504 ( CF )
3908                         *
3909                         * TCHEBYSHEV MODIFIED TAYLOR SERIES COEFFICIENTS FOR E**X
3910                         *
3911 98e9 07                 L84C9     FCB  7              ; EIGHT COEFFICIENTS
3912 98ea 71 34 58 3e 56     L84CA     FCB  $71,$34,$58,$3E,$56 ; 2.14987637E-05: 1/(7!*(CF**7))
3913 98ef 74 16 7e b3 1b     L84CF     FCB  $74,$16,$7E,$B3,$1B ; 1.4352314E-04 : 1/(6!*(CF**6))
3914 98f4 77 2f ee e3 85     L84D4     FCB  $77,$2F,$EE,$E3,$85 ; 1.34226348E-03: 1/(5!*(CF**5))
3915 98f9 7a 1d 84 1c 2a     L84D9     FCB  $7A,$1D,$84,$1C,$2A ; 9.61401701E-03: 1/(4!*(CF**4))
3916 98fe 7c 63 59 58 0a     L84DE     FCB  $7C,$63,$59,$58,$0A ; 0.0555051269
3917 9903 7e 75 fd e7 c6     L84E3     FCB  $7E,$75,$FD,$E7,$C6 ; 0.240226385
3918 9908 80 31 72 18 10     L84E8     FCB  $80,$31,$72,$18,$10 ; 0.693147186
3919 990d 81 00 00 00 00     L84ED     FCB  $81,$00,$00,$00,$00 ; 1
3920                         *
3921                         * EXP ( E**X)
3922                         * THE EXPONENTIAL FUNCTION IS EVALUATED BY FIRST MULTIPLYING THE
3923                         * ARGUMENT BY A CORRECTION FACTOR (CF). AFTER THIS IS DONE, AN
3924                         * ARGUMENT >= 127 WILL YIELD A ZERO RESULT (NO UNDERFLOW) FOR A
3925                         * NEGATIVE ARGUMENT OR AN 'OV' (OVERFLOW) ERROR FOR A POSITIVE
3926                         * ARGUMENT. THE POLYNOMIAL COEFFICIENTS ARE MODIFIED TO REFLECT
3927                         * THE CF MULTIPLICATION AT THE START OF THE EVALUATION PROCESS.
3928                         
3929 9912 8e 98 e4           EXP       LDX  #L84C4         ; POINT X TO THE CORRECTION FACTOR
3930 9915 bd 92 76                     JSR  LBACA          ; MULTIPLY FPA0 BY (X)
3931 9918 bd 93 db                     JSR  LBC2F          ; PACK FPA0 AND STORE IT IN FPA3
3932 991b 96 4f                        LDA  FP0EXP         ; *GET EXPONENT OF FPA0 AND
3933 991d 81 88                        CMPA #$88           ; *COMPARE TO THE MAXIMUM VALUE
3934 991f 25 03                        BLO  L8504          ; BRANCH IF FPA0 < 128
3935 9921 7e 93 08           L8501     JMP  LBB5C          ; SET FPA0 = 0 OR 'OV' ERROR
3936 9924 bd 94 9a           L8504     JSR  INT            ; CONVERT FPA0 TO INTEGER
3937 9927 96 01                        LDA  CHARAC         ; GET LS BYTE OF INTEGER
3938 9929 8b 81                        ADDA #$81           ; * WAS THE ARGUMENT =127, IF SO
3939 992b 27 f4                        BEQ  L8501          ; * THEN 'OV' ERROR; THIS WILL ALSO ADD THE $80 BIAS
3940                         *              ; * REQUIRED WHEN THE NEW EXPONENT IS CALCULATED BELOW
3941 992d 4a                           DECA                ; DECREMENT ONE FROM THE EXPONENT, BECAUSE $81, NOT $80 WAS USED ABOVE
3942 992e 34 02                        PSHS A              ; SAVE EXPONENT OF INTEGER PORTION ON STACK
3943 9930 8e 00 40                     LDX  #V40           ; POINT (X) TO FPA3
3944 9933 bd 91 65                     JSR  LB9B9          ; SUBTRACT FPA0 FROM (X) - GET FRACTIONAL PART OF ARGUMENT
3945 9936 8e 98 e9                     LDX  #L84C9         ; POINT X TO COEFFICIENTS
3946 9939 bd 96 ab                     JSR  LBEFF          ; EVALUATE POLYNOMIAL FOR FRACTIONAL PART
3947 993c 0f 62                        CLR  RESSGN         ; FORCE THE MANTISSA TO BE POSITIVE
3948 993e 35 02                        PULS A              ; GET INTEGER EXPONENT FROM STACK
3949 9940 bd 92 f4                     JSR  LBB48          ; * CALCULATE EXPONENT OF NEW FPA0 BY ADDING THE EXPONENTS OF THE
3950                         *              ; * INTEGER AND FRACTIONAL PARTS
3951 9943 39                           RTS
3952                         
3953                         * FIX
3954 9944 bd 94 19           FIX       JSR  LBC6D          ; CHECK STATUS OF FPA0
3955 9947 2b 03                        BMI  L852C          ; BRANCH IF FPA0 = NEGATIVE
3956 9949 7e 94 9a           L8529     JMP  INT            ; CONVERT FPA0 TO INTEGER
3957 994c 03 54              L852C     COM  FP0SGN         ; TOGGLE SIGN OF FPA0 MANTISSA
3958 994e 8d f9                        BSR  L8529          ; CONVERT FPA0 TO INTEGER
3959 9950 7e 96 95                     JMP  LBEE9          ; TOGGLE SIGN OF FPA0
3960                         
3961                         * EDIT
3962 9953 bd 9d 81           EDIT      JSR  L89AE          ; GET LINE NUMBER FROM BASIC
3963 9956 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
3964 9958 86 01              L8538     LDA  #$01           ; 'LIST' FLAG
3965 995a 97 97                        STA  VD8            ; SET FLAG TO LIST LINE
3966 995c bd 84 f3                     JSR  LAD01          ; GO FIND THE LINE NUMBER IN PROGRAM
3967 995f 10 25 ed 6b                  LBCS LAED2          ; ERROR #7 'UNDEFINED LINE #'
3968 9963 bd 8f 8a                     JSR  LB7C2          ; GO UNCRUNCH LINE INTO BUFFER AT LINBUF+1
3969 9966 1f 20                        TFR  Y,D            ; PUT ABSOLUTE ADDRESS OF END OF LINE TO ACCD
3970 9968 83 00 e2                     SUBD #LINBUF+2      ; SUBTRACT OUT THE START OF LINE
3971 996b d7 96                        STB  VD7            ; SAVE LENGTH OF LINE
3972 996d dc 2b              L854D     LDD  BINVAL         ; GET THE HEX VALUE OF LINE NUMBER
3973 996f bd 95 78                     JSR  LBDCC          ; LIST THE LINE NUMBER ON THE SCREEN
3974 9972 bd 91 58                     JSR  LB9AC          ; PRINT A SPACE
3975 9975 8e 00 e1                     LDX  #LINBUF+1      ; POINT X TO BUFFER
3976 9978 d6 97                        LDB  VD8            ; * CHECK TO SEE IF LINE IS TO BE
3977 997a 26 25                        BNE  L8581          ; * LISTED TO SCREEN - BRANCH IF IT IS
3978 997c 5f                 L855C     CLRB                ; RESET DIGIT ACCUMULATOR - DEFAULT VALUE
3979 997d bd 9a a7           L855D     JSR  L8687          ; GET KEY STROKE
3980 9980 bd e4 8c                     JSR  L90AA          ; SET CARRY IF NOT NUMERIC
3981 9983 25 0b                        BLO  L8570          ; BRANCH IF NOT NUMERIC
3982 9985 80 30                        SUBA #'0            ; MASK OFF ASCII
3983 9987 34 02                        PSHS A              ; SAVE IT ON STACK
3984 9989 86 0a                        LDA  #10            ; NUMBER BEING CONVERTED IS BASE 10
3985 998b 3d                           MUL                 ; MULTIPLY ACCUMULATED VALUE BY BASE (10)
3986 998c eb e0                        ADDB ,S+            ; ADD DIGIT TO ACCUMULATED VALUE
3987 998e 20 ed                        BRA  L855D          ; CHECK FOR ANOTHER DIGIT
3988 9990 c0 01              L8570     SUBB #$01           ; * REPEAT PARAMETER IN ACCB; IF IT
3989 9992 c9 01                        ADCB #$01           ; *IS 0, THEN MAKE IT '1'
3990 9994 81 41                        CMPA #'A            ; ABORT?
3991 9996 26 05                        BNE  L857D          ; NO
3992 9998 bd 91 08                     JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
3993 999b 20 bb                        BRA  L8538          ; RESTART EDIT PROCESS - CANCEL ALL CHANGES
3994 999d 81 4c              L857D     CMPA #'L            ; LIST?
3995 999f 26 0b                        BNE  L858C          ; NO
3996 99a1 8d 31              L8581     BSR  L85B4          ; LIST THE LINE
3997 99a3 0f 97                        CLR  VD8            ; RESET THE LIST FLAG TO 'NO LIST'
3998 99a5 bd 91 08                     JSR  LB958          ; PRINT CARRIAGE RETURN
3999 99a8 20 c3                        BRA  L854D          ; GO INTERPRET ANOTHER EDIT COMMAND
4000 99aa 32 62              L858A     LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF THE STACK
4001 99ac 81 0d              L858C     CMPA #CR            ; ENTER KEY?
4002 99ae 26 0d                        BNE  L859D          ; NO
4003 99b0 8d 22                        BSR  L85B4          ; ECHO THE LINE TO THE SCREEN
4004 99b2 bd 91 08           L8592     JSR  LB958          ; PRINT CARRIAGE RETURN
4005 99b5 8e 00 e1                     LDX  #LINBUF+1      ; * RESET BASIC'S INPUT POINTER
4006 99b8 9f 82                        STX  CHARAD         ; * TO THE LINE INPUT BUFFER
4007 99ba 7e 84 9c                     JMP  LACA8          ; GO PUT LINE BACK IN PROGRAM
4008 99bd 81 45              L859D     CMPA #'E            ; EXIT?
4009 99bf 27 f1                        BEQ  L8592          ; YES - SAME AS ENTER EXCEPT NO ECHO
4010 99c1 81 51                        CMPA #'Q            ; QUIT?
4011 99c3 26 06                        BNE  L85AB          ; NO
4012 99c5 bd 91 08                     JSR  LB958          ; PRINT CARRIAGE RETURN TO SCREEN
4013 99c8 7e 84 6d                     JMP  LAC73          ; GO TO COMMAND LEVEL - MAKE NO CHANGES
4014 99cb 8d 02              L85AB     BSR  L85AF          ; INTERPRET THE REMAINING COMMANDS AS SUBROUTINES
4015 99cd 20 ad                        BRA  L855C          ; GO INTERPRET ANOTHER EDIT COMMAND
4016 99cf 81 20              L85AF     CMPA #SPACE         ; SPACE BAR?
4017 99d1 26 10                        BNE  L85C3          ; NO
4018 99d3 8c                 L85B3     FCB  SKP2           ; SKIP TWO BYTES
4019                         * DISPLAY THE NEXT ACCB BYTES OF THE LINE IN THE BUFFER TO THE SCREEN
4020                         *
4021 99d4 c6 f9              L85B4     LDB  #LBUFMX-1      ; 250 BYTES MAX IN BUFFER
4022 99d6 a6 84              L85B6     LDA  ,X             ; GET A CHARACTER FROM BUFFER
4023 99d8 27 08                        BEQ  L85C2          ; EXIT IF IT'S A 0
4024 99da bd 80 31                     JSR  PUTCHR         ; SEND CHAR TO CONSOLE OUT
4025 99dd 30 01                        LEAX $01,X          ; MOVE POINTER UP ONE
4026 99df 5a                           DECB                ; DECREMENT CHARACTER COUNTER
4027 99e0 26 f4                        BNE  L85B6          ; LOOP IF NOT DONE
4028 99e2 39                 L85C2     RTS
4029 99e3 81 44              L85C3     CMPA #'D            ; DELETE?
4030 99e5 26 48                        BNE  L860F          ; NO
4031 99e7 6d 84              L85C7     TST  ,X             ; * CHECK FOR END OF LINE
4032 99e9 27 f7                        BEQ  L85C2          ; * AND BRANCH IF SO
4033 99eb 8d 04                        BSR  L85D1          ; REMOVE A CHARACTER
4034 99ed 5a                           DECB                ; DECREMENT REPEAT PARAMETER
4035 99ee 26 f7                        BNE  L85C7          ; BRANCH IF NOT DONE
4036 99f0 39                           RTS
4037                         * REMOVE ONE CHARACTER FROM BUFFER
4038 99f1 0a 96              L85D1     DEC  VD7            ; DECREMENT LENGTH OF BUFFER
4039 99f3 31 1f                        LEAY -1,X           ; POINT Y TO ONE BEFORE CURRENT BUFFER POINTER
4040 99f5 31 21              L85D5     LEAY $01,Y          ; INCREMENT TEMPORARY BUFFER POINTER
4041 99f7 a6 21                        LDA  $01,Y          ; GET NEXT CHARACTER
4042 99f9 a7 a4                        STA  ,Y             ; PUT IT IN CURRENT POSITION
4043 99fb 26 f8                        BNE  L85D5          ; BRANCH IF NOT END OF LINE
4044 99fd 39                           RTS
4045 99fe 81 49              L85DE     CMPA #'I            ;  INSERT?
4046 9a00 27 13                        BEQ  L85F5          ; YES
4047 9a02 81 58                        CMPA #'X            ; EXTEND?
4048 9a04 27 0d                        BEQ  L85F3          ; YES
4049 9a06 81 48                        CMPA #'H            ; HACK?
4050 9a08 26 5c                        BNE  L8646          ; NO
4051 9a0a 6f 84                        CLR  ,X             ; TURN CURRENT BUFFER POINTER INTO END OF LINE FLAG
4052 9a0c 1f 10                        TFR  X,D            ; PUT CURRENT BUFFER POINTER IN ACCD
4053 9a0e 83 00 e2                     SUBD #LINBUF+2      ; SUBTRACT INITIAL POINTER POSITION
4054 9a11 d7 96                        STB  VD7            ; SAVE NEW BUFFER LENGTH
4055 9a13 8d bf              L85F3     BSR  L85B4          ; DISPLAY THE LINE ON THE SCREEN
4056 9a15 bd 9a a7           L85F5     JSR  L8687          ; GET A KEYSTROKE
4057 9a18 81 0d                        CMPA #CR            ; ENTER KEY?
4058 9a1a 27 8e                        BEQ  L858A          ; YES - INTERPRET ANOTHER COMMAND - PRINT LINE
4059 9a1c 81 1b                        CMPA #ESC           ; ESCAPE?
4060 9a1e 27 25                        BEQ  L8625          ; YES - RETURN TO COMMAND LEVEL - DON'T PRINT LINE
4061 9a20 81 08                        CMPA #BS            ; BACK SPACE?
4062 9a22 26 22                        BNE  L8626          ; NO
4063 9a24 8c 00 e1                     CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
4064 9a27 27 ec                        BEQ  L85F5          ; DO NOT ALLOW BS IF AT START
4065 9a29 8d 45                        BSR  L8650          ; MOVE POINTER BACK ONE, BS TO SCREEN
4066 9a2b 8d c4                        BSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
4067 9a2d 20 e6                        BRA  L85F5          ; GET INSERT SUB COMMAND
4068 9a2f 81 43              L860F     CMPA #'C            ; CHANGE?
4069 9a31 26 cb                        BNE  L85DE          ; NO
4070 9a33 6d 84              L8613     TST  ,X             ; CHECK CURRENT BUFFER CHARACTER
4071 9a35 27 0e                        BEQ  L8625          ; BRANCH IF END OF LINE
4072 9a37 bd 9a a7                     JSR  L8687          ; GET A KEYSTROKE
4073 9a3a 25 02                        BLO  L861E          ; BRANCH IF LEGITIMATE KEY
4074 9a3c 20 f5                        BRA  L8613          ; TRY AGAIN IF ILLEGAL KEY
4075 9a3e a7 80              L861E     STA  ,X+            ; INSERT NEW CHARACTER INTO BUFFER
4076 9a40 8d 37                        BSR  L8659          ; SEND NEW CHARACTER TO SCREEN
4077 9a42 5a                           DECB                ; DECREMENT REPEAT PARAMETER
4078 9a43 26 ee                        BNE  L8613          ; BRANCH IF NOT DONE
4079 9a45 39                 L8625     RTS
4080 9a46 d6 96              L8626     LDB  VD7            ; GET LENGTH OF LINE
4081 9a48 c1 f9                        CMPB #LBUFMX-1      ; COMPARE TO MAXIMUM LENGTH
4082 9a4a 26 02                        BNE  L862E          ; BRANCH IF NOT AT MAXIMUM
4083 9a4c 20 c7                        BRA  L85F5          ; IGNORE INPUT IF LINE AT MAXIMUM LENGTH
4084 9a4e 34 10              L862E     PSHS X              ; SAVE CURRENT BUFFER POINTER
4085 9a50 6d 80              L8630     TST  ,X+            ; * SCAN THE LINE UNTIL END OF
4086 9a52 26 fc                        BNE  L8630          ; * LINE (0) IS FOUND
4087 9a54 e6 82              L8634     LDB  ,-X            ; DECR TEMP LINE POINTER AND GET A CHARACTER
4088 9a56 e7 01                        STB  $01,X          ; PUT CHARACTER BACK DOWN ONE SPOT
4089 9a58 ac e4                        CMPX ,S             ; HAVE WE REACHED STARTING POINT?
4090 9a5a 26 f8                        BNE  L8634          ; NO - KEEP GOING
4091 9a5c 32 62                        LEAS $02,S          ; PURGE BUFFER POINTER FROM STACK
4092 9a5e a7 80                        STA  ,X+            ; INSERT NEW CHARACTER INTO THE LINE
4093 9a60 8d 17                        BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
4094 9a62 0c 96                        INC  VD7            ; ADD ONE TO BUFFER LENGTH
4095 9a64 20 af                        BRA  L85F5          ; GET INSERT SUB COMMAND
4096 9a66 81 08              L8646     CMPA #BS            ; BACKSPACE?
4097 9a68 26 12                        BNE  L865C          ; NO
4098 9a6a 8d 04              L864A     BSR  L8650          ; MOVE POINTER BACK 1, SEND BS TO SCREEN
4099 9a6c 5a                           DECB                ; DECREMENT REPEAT PARAMETER
4100 9a6d 26 fb                        BNE  L864A          ; LOOP UNTIL DONE
4101 9a6f 39                           RTS
4102 9a70 8c 00 e1           L8650     CMPX #LINBUF+1      ; COMPARE POINTER TO START OF BUFFER
4103 9a73 27 d0                        BEQ  L8625          ; DO NOT ALLOW BS IF AT START
4104 9a75 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
4105 9a77 86 08                        LDA  #BS            ; BACK SPACE
4106 9a79 7e 80 31           L8659     JMP  PUTCHR         ; SEND TO CONSOLE OUT
4107 9a7c 81 4b              L865C     CMPA #'K            ; KILL?
4108 9a7e 27 05                        BEQ  L8665          ; YES
4109 9a80 80 53                        SUBA #'S            ; SEARCH?
4110 9a82 27 01                        BEQ  L8665          ; YES
4111 9a84 39                           RTS
4112 9a85 34 02              L8665     PSHS A              ; SAVE KILL/SEARCH FLAG ON STACK
4113 9a87 8d 1e                        BSR  L8687          ; * GET A KEYSTROKE (TARGET CHARACTER)
4114 9a89 34 02                        PSHS A              ; * AND SAVE IT ON STACK
4115 9a8b a6 84              L866B     LDA  ,X             ; GET CURRENT BUFFER CHARACTER
4116 9a8d 27 16                        BEQ  L8685          ; AND RETURN IF END OF LINE
4117 9a8f 6d 61                        TST  $01,S          ; CHECK KILL/SEARCH FLAG
4118 9a91 26 06                        BNE  L8679          ; BRANCH IF KILL
4119 9a93 8d e4                        BSR  L8659          ; SEND A CHARACTER TO CONSOLE OUT
4120 9a95 30 01                        LEAX $01,X          ; INCREMENT BUFFER POINTER
4121 9a97 20 03                        BRA  L867C          ; CHECK NEXT INPUT CHARACTER
4122 9a99 bd 99 f1           L8679     JSR  L85D1          ; REMOVE ONE CHARACTER FROM BUFFER
4123 9a9c a6 84              L867C     LDA  ,X             ; GET CURRENT INPUT CHARACTER
4124 9a9e a1 e4                        CMPA ,S             ; COMPARE TO TARGET CHARACTER
4125 9aa0 26 e9                        BNE  L866B          ; BRANCH IF NO MATCH
4126 9aa2 5a                           DECB                ; DECREMENT REPEAT PARAMETER
4127 9aa3 26 e6                        BNE  L866B          ; BRANCH IF NOT DONE
4128 9aa5 35 a0              L8685     PULS Y,PC           ; THE Y PULL WILL CLEAN UP THE STACK FOR THE 2 PSHS A
4129                         *
4130                         * GET A KEYSTRKE
4131 9aa7 bd 80 1f           L8687     JSR  LA171          ; CALL CONSOLE IN : DEV NBR=SCREEN
4132 9aaa 81 7f                        CMPA #$7F           ; GRAPHIC CHARACTER?
4133 9aac 24 f9                        BCC  L8687          ; YES - GET ANOTHER CHAR
4134 9aae 81 5f                        CMPA #$5F           ; SHIFT UP ARROW (QUIT INSERT)
4135 9ab0 26 02                        BNE  L8694          ; NO
4136 9ab2 86 1b                        LDA  #ESC           ; REPLACE W/ESCAPE CODE
4137 9ab4 81 0d              L8694     CMPA #CR            ; ENTER KEY
4138 9ab6 27 0e                        BEQ  L86A6          ; YES
4139 9ab8 81 1b                        CMPA #ESC           ; ESCAPE?
4140 9aba 27 0a                        BEQ  L86A6          ; YES
4141 9abc 81 08                        CMPA #BS            ; BACKSPACE?
4142 9abe 27 06                        BEQ  L86A6          ; YES
4143 9ac0 81 20                        CMPA #SPACE         ; SPACE
4144 9ac2 25 e3                        BLO  L8687          ; GET ANOTHER CHAR IF CONTROL CHAR
4145 9ac4 1a 01                        ORCC #$01           ; SET CARRY
4146 9ac6 39                 L86A6     RTS
4147                         
4148                         * TRON
4149 9ac7 86                 TRON      FCB  SKP1LD         ; SKIP ONE BYTE AND LDA #$4F
4150                         
4151                         * TROFF
4152 9ac8 4f                 TROFF     CLRA                ; TROFF FLAG
4153 9ac9 97 8b                        STA  TRCFLG         ; TRON/TROFF FLAG:0=TROFF, <> 0=TRON
4154 9acb 39                           RTS
4155                         
4156                         * POS
4157                         
4158 9acc 86 00              POS       LDA  #0             ; GET DEVICE NUMBER
4159 9ace d6 78                        LDB  LPTPOS         ; GET PRINT POSITION
4160 9ad0 1d                 LA5E8     SEX                 ; CONVERT ACCB TO 2 DIGIT SIGNED INTEGER
4161 9ad1 7e 8c c7                     JMP  GIVABF         ; CONVERT ACCD TO FLOATING POINT
4162                         
4163                         
4164                         * VARPTR
4165 9ad4 bd 8a 42           VARPT     JSR  LB26A          ; SYNTAX CHECK FOR '('
4166 9ad7 dc 1f                        LDD  ARYEND         ; GET ADDR OF END OF ARRAYS
4167 9ad9 34 06                        PSHS B,A            ; SAVE IT ON STACK
4168 9adb bd 8b 2a                     JSR  LB357          ; GET VARIABLE DESCRIPTOR
4169 9ade bd 8a 3f                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4170 9ae1 35 06                        PULS A,B            ; GET END OF ARRAYS ADDR BACK
4171 9ae3 1e 10                        EXG  X,D            ; SWAP END OF ARRAYS AND VARIABLE DESCRIPTOR
4172 9ae5 9c 1f                        CMPX ARYEND         ; COMPARE TO NEW END OF ARRAYS
4173 9ae7 26 51                        BNE  L8724          ; 'FC' ERROR IF VARIABLE WAS NOT DEFINED PRIOR TO CALLING VARPTR
4174 9ae9 7e 8c c7                     JMP  GIVABF         ; CONVERT VARIABLE DESCRIPTOR INTO A FP NUMBER
4175                         
4176                         * MID$(OLDSTRING,POSITION,LENGTH)=REPLACEMENT
4177 9aec 9d 7b              L86D6     JSR  GETNCH         ; GET INPUT CHAR FROM BASIC
4178 9aee bd 8a 42                     JSR  LB26A          ; SYNTAX CHECK FOR '('
4179 9af1 bd 8b 2a                     JSR  LB357          ; * GET VARIABLE DESCRIPTOR ADDRESS AND
4180 9af4 34 10                        PSHS X              ; * SAVE IT ON THE STACK
4181 9af6 ec 02                        LDD  $02,X          ; POINT ACCD TO START OF OLDSTRING
4182 9af8 10 93 21                     CMPD FRETOP         ; COMPARE TO START OF CLEARED SPACE
4183 9afb 23 04                        BLS  L86EB          ; BRANCH IF <=
4184 9afd 93 27                        SUBD MEMSIZ         ; SUBTRACT OUT TOP OF CLEARED SPACE
4185 9aff 23 12                        BLS  L86FD          ; BRANCH IF STRING IN STRING SPACE
4186 9b01 e6 84              L86EB     LDB  ,X             ; GET LENGTH OF OLDSTRING
4187 9b03 bd 8d 40                     JSR  LB56D          ; RESERVE ACCB BYTES IN STRING SPACE
4188 9b06 34 10                        PSHS X              ; SAVE RESERVED SPACE STRING ADDRESS ON STACK
4189 9b08 ae 62                        LDX  $02,S          ; POINT X TO OLDSTRING DESCRIPTOR
4190 9b0a bd 8e 16                     JSR  LB643          ; MOVE OLDSTRING INTO STRING SPACE
4191 9b0d 35 50                        PULS X,U            ; * GET OLDSTRING DESCRIPTOR ADDRESS AND RESERVED STRING
4192 9b0f af 42                        STX  $02,U          ; * ADDRESS AND SAVE RESERVED ADDRESS AS OLDSTRING ADDRESS
4193 9b11 34 40                        PSHS U              ; SAVE OLDSTRING DESCRIPTOR ADDRESS
4194 9b13 bd 8f 0b           L86FD     JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
4195 9b16 34 04                        PSHS B              ; SAVE POSITION PARAMETER ON STACK
4196 9b18 5d                           TSTB                ; * CHECK POSITION PARAMETER AND BRANCH
4197 9b19 27 1f                        BEQ  L8724          ; * IF START OF STRING
4198 9b1b c6 ff                        LDB  #$FF           ; DEFAULT REPLACEMENT LENGTH = $FF
4199 9b1d 81 29                        CMPA #')            ; * CHECK FOR END OF MID$ STATEMENT AND
4200 9b1f 27 03                        BEQ  L870E          ; * BRANCH IF AT END OF STATEMENT
4201 9b21 bd 8f 0b                     JSR  LB738          ; SYNTAX CHECK FOR COMMA AND EVALUATE LENGTH EXPRESSION
4202 9b24 34 04              L870E     PSHS B              ; SAVE LENGTH PARAMETER ON STACK
4203 9b26 bd 8a 3f                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4204 9b29 c6 b1                        LDB  #TOK_EQUALS    ; TOKEN FOR =
4205 9b2b bd 8a 47                     JSR  LB26F          ; SYNTAX CHECK FOR '='
4206 9b2e 8d 2e                        BSR  L8748          ; EVALUATE REPLACEMENT STRING
4207 9b30 1f 13                        TFR  X,U            ; SAVE REPLACEMENT STRING ADDRESS IN U
4208 9b32 ae 62                        LDX  $02,S          ; POINT X TO OLOSTRING DESCRIPTOR ADDRESS
4209 9b34 a6 84                        LDA  ,X             ; GET LENGTH OF OLDSTRING
4210 9b36 a0 61                        SUBA $01,S          ; SUBTRACT POSITION PARAMETER
4211 9b38 24 03                        BCC  L8727          ; INSERT REPLACEMENT STRING INTO OLDSTRING
4212 9b3a 7e 8c 1d           L8724     JMP  LB44A          ; 'FC' ERROR IF POSITION > LENGTH OF OLDSTRING
4213 9b3d 4c                 L8727     INCA                ; * NOW ACCA = NUMBER OF CHARACTERS TO THE RIGHT
4214                         *                             ; * (INCLUSIVE) OF THE POSITION PARAMETER
4215 9b3e a1 e4                        CMPA ,S
4216 9b40 24 02                        BCC  L872E          ; BRANCH IF NEW STRING WILL FIT IN OLDSTRING
4217 9b42 a7 e4                        STA  ,S             ; IF NOT, USE AS MUCH OF LENGTH PARAMETER AS WILL FIT
4218 9b44 a6 61              L872E     LDA  $01,S          ; GET POSITION PARAMETER
4219 9b46 1e 89                        EXG  A,B            ; ACCA=LENGTH OF REPL STRING, ACCB=POSITION PARAMETER
4220 9b48 ae 02                        LDX  $02,X          ; POINT X TO OLDSTRING ADDRESS
4221 9b4a 5a                           DECB                ; * BASIC'S POSITION PARAMETER STARTS AT 1; THIS ROUTINE
4222                         *                             ; * WANTS IT TO START AT ZERO
4223 9b4b 3a                           ABX                 ; POINT X TO POSITION IN OLDSTRING WHERE THE REPLACEMENT WILL GO
4224 9b4c 4d                           TSTA                ; * IF THE LENGTH OF THE REPLACEMENT STRING IS ZERO
4225 9b4d 27 0d                        BEQ  L8746          ; * THEN RETURN
4226 9b4f a1 e4                        CMPA ,S
4227 9b51 23 02                        BLS  L873F          ; ADJUSTED LENGTH PARAMETER, THEN BRANCH
4228 9b53 a6 e4                        LDA  ,S             ; OTHERWISE USE AS MUCH ROOM AS IS AVAILABLE
4229 9b55 1f 89              L873F     TFR  A,B            ; SAVE NUMBER OF BYTES TO MOVE IN ACCB
4230 9b57 1e 31                        EXG  U,X            ; SWAP SOURCE AND DESTINATION POINTERS
4231 9b59 bd 81 94                     JSR  LA59A          ; MOVE (B) BYTES FROM (X) TO (U)
4232 9b5c 35 96              L8746     PULS A,B,X,PC
4233 9b5e bd 89 2e           L8748     JSR  LB156          ; EVALUATE EXPRESSION
4234 9b61 7e 8e 27                     JMP  LB654          ; *'TM' ERROR IF NUMERIC; RETURN WITH X POINTING
4235                         *                             ; *TO STRING, ACCB = LENGTH
4236                         
4237                         * STRING
4238 9b64 bd 8a 42           STRING    JSR  LB26A          ; SYNTAX CHECK FOR '('
4239 9b67 bd 8e de                     JSR  LB70B          ; EVALUATE EXPRESSION; ERROR IF > 255
4240 9b6a 34 04                        PSHS B              ; SAVE LENGTH OF STRING
4241 9b6c bd 8a 45                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4242 9b6f bd 89 2e                     JSR  LB156          ; EVALUATE EXPRESSION
4243 9b72 bd 8a 3f                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4244 9b75 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
4245 9b77 26 05                        BNE  L8768          ; BRANCH IF STRING
4246 9b79 bd 8e e1                     JSR  LB70E          ; CONVERT FPA0 INTO AN INTEGER IN ACCB
4247 9b7c 20 03                        BRA  L876B          ; SAVE THE STRING IN STRING SPACE
4248 9b7e bd 8e 77           L8768     JSR  LB6A4          ; GET FIRST BYTE OF STRING
4249 9b81 34 04              L876B     PSHS B              ; SAVE FIRST BYTE OF EXPRESSION
4250 9b83 e6 61                        LDB  $01,S          ; GET LENGTH OF STRING
4251 9b85 bd 8c e2                     JSR  LB50F          ; RESERVE ACCB BYTES IN STRING SPACE
4252 9b88 35 06                        PULS A,B            ; GET LENGTH OF STRING AND CHARACTER
4253 9b8a 27 05                        BEQ  L877B          ; BRANCH IF NULL STRING
4254 9b8c a7 80              L8776     STA  ,X+            ; SAVE A CHARACTER IN STRING SPACE
4255 9b8e 5a                           DECB                ; DECREMENT LENGTH
4256 9b8f 26 fb                        BNE  L8776          ; BRANCH IF NOT DONE
4257 9b91 7e 8e 6e           L877B     JMP  LB69B          ; PUT STRING DESCRIPTOR ONTO STRING STACK
4258                         
4259                         * INSTR
4260 9b94 bd 8a 42           INSTR     JSR  LB26A          ; SYNTAX CHECK FOR '('
4261 9b97 bd 89 2e                     JSR  LB156          ; EVALUATE EXPRESSION
4262 9b9a c6 01                        LDB  #$01           ; DEFAULT POSITION = 1 (SEARCH START)
4263 9b9c 34 04                        PSHS B              ; SAVE START
4264 9b9e 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
4265 9ba0 26 10                        BNE  L879C          ; BRANCH IF STRING
4266 9ba2 bd 8e e1                     JSR  LB70E          ; CONVERT FPA0 TO INTEGER IN ACCB
4267 9ba5 e7 e4                        STB  ,S             ; SAVE START SEARCH VALUE
4268 9ba7 27 91                        BEQ  L8724          ; BRANCH IF START SEARCH AT ZERO
4269 9ba9 bd 8a 45                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4270 9bac bd 89 2e                     JSR  LB156          ; EVALUATE EXPRESSION - SEARCH STRING
4271 9baf bd 89 1e                     JSR  LB146          ; 'TM' ERROR IF NUMERIC
4272 9bb2 9e 52              L879C     LDX  FPA0+2         ; SEARCH STRING DESCRIPTOR ADDRESS
4273 9bb4 34 10                        PSHS X              ; SAVE ON THE STACK
4274 9bb6 bd 8a 45                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4275 9bb9 bd 9b 5e                     JSR  L8748          ; EVALUATE TARGET STRING EXPRESSION
4276 9bbc 34 14                        PSHS X,B            ; SAVE ADDRESS AND LENGTH ON STACK
4277 9bbe bd 8a 3f                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4278 9bc1 ae 63                        LDX  $03,S          ; * LOAD X WITH SEARCH STRING DESCRIPTOR ADDRESS
4279 9bc3 bd 8e 2c                     JSR  LB659          ; * AND GET THE LENGTH ANDADDRESS OF SEARCH STRING
4280 9bc6 34 04                        PSHS B              ; SAVE LENGTH ON STACK
4281                         *
4282                         * AT THIS POINT THE STACK HAS THE FOLLOWING INFORMATION
4283                         * ON IT: 0,S-SEARCH LENGTH; 1,S-TARGET LENGTH; 2 3,S-TARGET
4284                         * ADDRESS; 4 5,S-SEARCH DESCRIPTOR ADDRESS; 6,S-SEARCH POSITION
4285 9bc8 e1 66                        CMPB $06,S          ; COMPARE LENGTH OF SEARCH STRING TO START
4286 9bca 25 23                        BLO  L87D9          ; POSITION; RETURN 0 IF LENGTH < START
4287 9bcc a6 61                        LDA  $01,S          ; GET LENGTH OF TARGET STRING
4288 9bce 27 1c                        BEQ  L87D6          ; BRANCH IF TARGET STRING = NULL
4289 9bd0 e6 66                        LDB  $06,S          ; GET START POSITION
4290 9bd2 5a                           DECB                ; MOVE BACK ONE
4291 9bd3 3a                           ABX                 ; POINT X TO POSITION IN SEARCH STRING WHERE SEARCHING WILL START
4292 9bd4 31 84              L87BE     LEAY ,X             ; POINT Y TO SEARCH POSITION
4293 9bd6 ee 62                        LDU  $02,S          ; POINT U TO START OF TARGET
4294 9bd8 e6 61                        LDB  $01,S          ; LOAD ACCB WITH LENGTH OF TARGET
4295 9bda a6 e4                        LDA  ,S             ; LOAD ACCA WITH LENGTH OF SEARCH
4296 9bdc a0 66                        SUBA $06,S          ; SUBTRACT SEARCH POSITION FROM SEARCH LENGTH
4297 9bde 4c                           INCA                ; ADD ONE
4298 9bdf a1 61                        CMPA $01,S          ; COMPARE TO TARGET LENGTH
4299 9be1 25 0c                        BLO  L87D9          ; RETURN 0 IF TARGET LENGTH > WHAT'S LEFT OF SEARCH STRING
4300 9be3 a6 80              L87CD     LDA  ,X+            ; GET A CHARACTER FROM SEARCH STRING
4301 9be5 a1 c0                        CMPA ,U+            ; COMPARE IT TO TARGET STRING
4302 9be7 26 0c                        BNE  L87DF          ; BRANCH IF NO MATCH
4303 9be9 5a                           DECB                ; DECREMENT TARGET LENGTH
4304 9bea 26 f7                        BNE  L87CD          ; CHECK ANOTHER CHARACTER
4305 9bec e6 66              L87D6     LDB  $06,S          ; GET MATCH POSITION
4306 9bee 21                 L87D8     FCB  SKP1           ; SKIP NEXT BYTE
4307 9bef 5f                 L87D9     CLRB                ; MATCH ADDRESS = 0
4308 9bf0 32 67                        LEAS $07,S          ; CLEAN UP THE STACK
4309 9bf2 7e 8c c6                     JMP  LB4F3          ; CONVERT ACCB TO FP NUMBER
4310 9bf5 6c 66              L87DF     INC  $06,S          ; INCREMENT SEARCH POSITION
4311 9bf7 30 21                        LEAX $01,Y          ; MOVE X TO NEXT SEARCH POSITION
4312 9bf9 20 d9                        BRA  L87BE          ; KEEP LOOKING FOR A MATCH
4313                         
4314                         * EXTENDED BASIC RVEC19 HOOK CODE
4315 9bfb 81 26              XVEC19    CMPA #'&            ; *
4316 9bfd 26 5c                        BNE  L8845          ; * RETURN IF NOT HEX OR OCTAL VARIABLE
4317 9bff 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
4318                         * PROCESS A VARIABLE PRECEEDED BY A '&' (&H,&O)
4319 9c01 0f 52              L87EB     CLR  FPA0+2         ; * CLEAR BOTTOM TWO
4320 9c03 0f 53                        CLR  FPA0+3         ; * BYTES OF FPA0
4321 9c05 8e 00 52                     LDX  #FPA0+2        ; BYTES 2,3 OF FPA0 = (TEMPORARY ACCUMULATOR)
4322 9c08 9d 7b                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4323 9c0a 81 4f                        CMPA #'O
4324 9c0c 27 12                        BEQ  L880A          ; YES
4325 9c0e 81 48                        CMPA #'H
4326 9c10 27 23                        BEQ  L881F          ; YES
4327 9c12 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4328 9c14 20 0c                        BRA  L880C          ; DEFAULT TO OCTAL (&O)
4329 9c16 81 38              L8800     CMPA #'8
4330 9c18 10 22 ee 33                  LBHI LB277
4331 9c1c c6 03                        LDB  #$03           ; BASE 8 MULTIPLIER
4332 9c1e 8d 2a                        BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
4333                         * EVALUATE AN &O VARIABLE
4334 9c20 9d 7b              L880A     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4335 9c22 25 f2              L880C     BLO  L8800          ; BRANCH IF NUMERIC
4336 9c24 0f 50              L880E     CLR  FPA0           ; * CLEAR 2 HIGH ORDER
4337 9c26 0f 51                        CLR  FPA0+1         ; * BYTES OF FPA0
4338 9c28 0f 06                        CLR  VALTYP         ; SET VARXABLE TYPE TO NUMERIC
4339 9c2a 0f 63                        CLR  FPSBYT         ; ZERO OUT SUB BYTE OF FPA0
4340 9c2c 0f 54                        CLR  FP0SGN         ; ZERO OUT MANTISSA SIGN OF FPA0
4341 9c2e c6 a0                        LDB  #$A0           ; * SET EXPONENT OF FPA0
4342 9c30 d7 4f                        STB  FP0EXP         ; *
4343 9c32 7e 91 c8                     JMP  LBA1C          ; GO NORMALIZE FPA0
4344                         * EVALUATE AN &H VARIABLE
4345 9c35 9d 7b              L881F     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4346 9c37 25 0b                        BLO  L882E          ; BRANCH IF NUMERIC
4347 9c39 bd 8b 75                     JSR  LB3A2          ; SET CARRY IF NOT ALPHA
4348 9c3c 25 e6                        BLO  L880E          ; BRANCH IF NOT ALPHA OR NUMERIC
4349 9c3e 81 47                        CMPA #'G            ; CHECK FOR LETTERS A-F
4350 9c40 24 e2                        BCC  L880E          ; BRANCH IF >= G (ILLEGAL HEX LETTER)
4351 9c42 80 07                        SUBA #7             ; SUBTRACT ASCII DIFFERENCE BETWEEN A AND 9
4352 9c44 c6 04              L882E     LDB  #$04           ; BASE 16 DIGIT MULTIPLIER = 2**4
4353 9c46 8d 02                        BSR  L8834          ; ADD DIGIT TO TEMPORARY ACCUMULATOR
4354 9c48 20 eb                        BRA  L881F          ; KEEP EVALUATING VARIABLE
4355 9c4a 68 01              L8834     ASL  $01,X          ; * MULTIPLY TEMPORARY
4356 9c4c 69 84                        ROL  ,X             ; * ACCUMULATOR BY TWO
4357 9c4e 10 25 f5 ec                  LBCS LBA92          ; 'OV' OVERFLOW ERROR
4358 9c52 5a                           DECB                ; DECREMENT SHIFT COUNTER
4359 9c53 26 f5                        BNE  L8834          ; MULTIPLY TEMPORARY ACCUMULATOR AGAIN
4360 9c55 80 30                        SUBA #'0            ; MASK OFF ASCII
4361 9c57 ab 01                        ADDA $01,X          ; * ADD DIGIT TO TEMPORARY
4362 9c59 a7 01                        STA  $01,X          ; * ACCUMULATOR AND SAVE IT
4363 9c5b 39                 L8845     RTS
4364                         
4365 9c5c 35 40              XVEC15    PULS U              ; PULL RETURN ADDRESS AND SAVE IN U REGISTER
4366 9c5e 0f 06                        CLR  VALTYP         ; SET VARIABLE TYPE TO NUMERIC
4367 9c60 9e 82                        LDX  CHARAD         ; CURRENT INPUT POINTER TO X
4368 9c62 9d 7b                        JSR  GETNCH         ; GET CHARACTER FROM BASIC
4369 9c64 81 26                        CMPA #'&            ; HEX AND OCTAL VARIABLES ARE PRECEEDED BY &
4370 9c66 27 99                        BEQ  L87EB          ; PROCESS A '&' VARIABLE
4371 9c68 81 b3                        CMPA #TOK_FN        ; TOKEN FOR FN
4372 9c6a 27 5e                        BEQ  L88B4          ; PROCESS FN CALL
4373 9c6c 81 ff                        CMPA #$FF           ; CHECK FOR SECONDARY TOKEN
4374 9c6e 26 08                        BNE  L8862          ; NOT SECONDARY
4375 9c70 9d 7b                        JSR  GETNCH         ; GET CHARACTER FROM BASIC
4376 9c72 81 83                        CMPA #TOK_USR       ; TOKEN FOR USR
4377 9c74 10 27 00 ab                  LBEQ L892C          ; PROCESS USR CALL
4378 9c78 9f 82              L8862     STX  CHARAD         ; RESTORE BASIC'S INPUT POINTER
4379 9c7a 6e c4                        JMP  ,U             ; RETURN TO CALLING ROUTINE
4380 9c7c 9e 68              L8866     LDX  CURLIN         ; GET CURRENT LINE NUMBER
4381 9c7e 30 01                        LEAX $01,X          ; IN DIRECT MODE?
4382 9c80 26 d9                        BNE  L8845          ; RETURN IF NOT IN DIRECT MODE
4383 9c82 c6 16                        LDB  #2*11          ; 'ILLEGAL DIRECT STATEMENT' ERROR
4384 9c84 7e 84 4e           L886E     JMP  LAC46          ; PROCESS ERROR
4385                         
4386 9c87 ae 9f 00 82        DEF       LDX  [CHARAD]       ; GET TWO INPUT CHARS
4387 9c8b 8c ff 83                     CMPX #TOK_FF_USR    ; TOKEN FOR USR
4388 9c8e 10 27 00 74                  LBEQ L890F          ; BRANCH IF DEF USR
4389 9c92 8d 23                        BSR  L88A1          ; GET DESCRIPTOR ADDRESS FOR FN VARIABLE NAME
4390 9c94 8d e6                        BSR  L8866          ; DON'T ALLOW DEF FN IF IN DIRECT MODE
4391 9c96 bd 8a 42                     JSR  LB26A          ; SYNTAX CHECK FOR '('
4392 9c99 c6 80                        LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE
4393 9c9b d7 08                        STB  ARYDIS         ; * AND SAVE IT IN THE ARRAY DISABLE FLAG
4394 9c9d bd 8b 2a                     JSR  LB357          ; GET VARIABLE DESCRIPTOR
4395 9ca0 8d 25                        BSR  L88B1          ; 'TM' ERROR IF STRING
4396 9ca2 bd 8a 3f                     JSR  LB267          ; SYNTAX CHECK FOR ')'
4397 9ca5 c6 b1                        LDB  #TOK_EQUALS    ; TOKEN FOR '='
4398 9ca7 bd 8a 47                     JSR  LB26F          ; DO A SYNTAX CHECK FOR =
4399 9caa 9e 4b                        LDX  V4B            ; GET THE ADDRESS OF THE FN NAME DESCRIPTOR
4400 9cac dc 82                        LDD  CHARAD         ; * GET THE CURRENT INPUT POINTER ADDRESS AND
4401 9cae ed 84                        STD  ,X             ; * SAVE IT IN FIRST 2 BYTES OF THE DESCRIPTOR
4402 9cb0 dc 39                        LDD  VARPTR         ; = GET THE DESCRIPTOR ADDRESS OF THE ARGUMENT
4403 9cb2 ed 02                        STD  $02,X          ; = VARIABLE AND SAVE IT IN THE DESCRIPTOR OF THE FN NAME
4404 9cb4 7e 86 dc                     JMP  DATA           ; MOVE INPUT POINTER TO END OF LINE OR SUBLINE
4405 9cb7 c6 b3              L88A1     LDB  #TOK_FN        ; TOKEN FOR FN
4406 9cb9 bd 8a 47                     JSR  LB26F          ; DO A SYNTAX CHECK FOR FN
4407 9cbc c6 80                        LDB  #$80           ; * GET THE FLAG TO INDICATE ARRAY VARIABLE SEARCH DISABLE FLAG
4408 9cbe d7 08                        STB  ARYDIS         ; * AND SAVE IT IN ARRAY VARIABLE FLAG
4409 9cc0 8a 80                        ORA  #$80           ; SET BIT 7 OF CURRENT INPUT CHARACTER TO INDICATE AN FN VARIABLE
4410 9cc2 bd 8b 2f                     JSR  LB35C          ; * GET THE DESCRIPTOR ADDRESS OF THIS
4411 9cc5 9f 4b                        STX  V4B            ; * VARIABLE AND SAVE IT IN V4B
4412 9cc7 7e 89 1b           L88B1     JMP  LB143          ; 'TM' ERROR IF STRING VARIABLE
4413                         * EVALUATE AN FN CALL
4414 9cca 8d eb              L88B4     BSR  L88A1          ; * GET THE DESCRIPTOR OF THE FN NAME
4415 9ccc 34 10                        PSHS X              ; * VARIABLE AND SAVE IT ON THE STACK
4416 9cce bd 8a 3a                     JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
4417 9cd1 8d f4                        BSR  L88B1          ; 'TM' ERROR IF STRING VARIABLE
4418 9cd3 35 40                        PULS U              ; POINT U TO FN NAME DESCRIPTOR
4419 9cd5 c6 32                        LDB  #2*25          ; 'UNDEFINED FUNCTION CALL' ERROR
4420 9cd7 ae 42                        LDX  $02,U          ; POINT X TO ARGUMENT VARIABLE DESCRIPTOR
4421 9cd9 27 a9                        BEQ  L886E          ; BRANCH TO ERROR HANDLER
4422 9cdb 10 9e 82                     LDY  CHARAD         ; SAVE CURRENT INPUT POINTER IN Y
4423 9cde ee c4                        LDU  ,U             ; * POINT U TO START OF FN FORMULA AND
4424 9ce0 df 82                        STU  CHARAD         ; * SAVE IT IN INPUT POINTER
4425 9ce2 a6 04                        LDA  $04,X          ; = GET FP VALUE OF
4426 9ce4 34 02                        PSHS A              ; = ARGUMENT VARIABLE, CURRENT INPUT
4427 9ce6 ec 84                        LDD  ,X             ; = POINTER, AND ADDRESS OF START
4428 9ce8 ee 02                        LDU  $02,X          ; = OF FN FORMULA AND SAVE
4429 9cea 34 76                        PSHS U,Y,X,B,A      ; = THEM ON THE STACK
4430 9cec bd 93 e1                     JSR  LBC35          ; PACK FPA0 AND SAVE IT IN (X)
4431 9cef bd 89 19           L88D9     JSR  LB141          ; EVALUATE FN EXPRESSION
4432 9cf2 35 76                        PULS A,B,X,Y,U      ; RESTORE REGISTERS
4433 9cf4 ed 84                        STD  ,X             ; * GET THE FP
4434 9cf6 ef 02                        STU  $02,X          ; * VALUE OF THE ARGUMENT
4435 9cf8 35 02                        PULS A              ; * VARIABLE OFF OF THE
4436 9cfa a7 04                        STA  $04,X          ; * STACK AND RE-SAVE IT
4437 9cfc 9d 81                        JSR  GETCCH         ; GET FINAL CHARACTER OF THE FN FORMULA
4438 9cfe 10 26 ed 4d                  LBNE LB277          ; 'SYNTAX' ERROR IF NOT END OF LINE
4439 9d02 10 9f 82                     STY  CHARAD         ; RESTORE INPUT POINTER
4440 9d05 39                 L88EF     RTS
4441                         
4442                         
4443                         
4444                         * DEF USR
4445 9d06 9d 7b              L890F     JSR  GETNCH         ; SKIP PAST SECOND BYTE OF DEF USR TOKEN
4446 9d08 8d 09                        BSR  L891C          ; GET FN NUMBER
4447 9d0a 34 10                        PSHS X              ; SAVE FN EXEC ADDRESS STORAGE LOC
4448 9d0c 8d 2d                        BSR  L8944          ; CALCULATE EXEC ADDRESS
4449 9d0e 35 40                        PULS U              ; GET FN EXEC ADDRESS STORAGE LOC
4450 9d10 af c4                        STX  ,U             ; SAVE EXEC ADDRESS
4451 9d12 39                           RTS
4452 9d13 5f                 L891C     CLRB                ; DEFAULT TO USR0 IF NO ARGUMENT
4453 9d14 9d 7b                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4454 9d16 24 06                        BCC  L8927          ; BRANCH IF NOT NUMERIC
4455 9d18 80 30                        SUBA #'0            ; MASK OFF ASCII
4456 9d1a 1f 89                        TFR  A,B            ; SAVE USR NUMBER IN ACCB
4457 9d1c 9d 7b                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4458 9d1e 9e 8c              L8927     LDX  USRADR         ; GET ADDRESS OF STORAGE LOCs FOR USR ADDRESS
4459 9d20 58                           ASLB                ; X2 - 2 BYTES/USR ADDRESS
4460 9d21 3a                           ABX                 ; ADD OFFSET TO START ADDRESS OF STORAGE LOCs
4461 9d22 39                           RTS
4462                         * PROCESS A USR CALL
4463 9d23 8d ee              L892C     BSR  L891C          ; GET STORAGE LOC OF EXEC ADDRESS FOR USR N
4464 9d25 ae 84                        LDX  ,X             ; * GET EXEC ADDRESS AND
4465 9d27 34 10                        PSHS X              ; * PUSH IT ONTO STACK
4466 9d29 bd 8a 3a                     JSR  LB262          ; SYNTAX CHECK FOR '(' & EVALUATE EXPR
4467 9d2c 8e 00 4f                     LDX  #FP0EXP        ; POINT X TO FPA0
4468 9d2f 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
4469 9d31 27 07                        BEQ  L8943          ; BRANCH IF NUMERIC, STRING IF <> 0
4470 9d33 bd 8e 2a                     JSR  LB657          ; GET LENGTH & ADDRESS OF STRING VARIABLE
4471 9d36 9e 52                        LDX  FPA0+2         ; GET POINTER TO STRING DESCRIPTOR
4472 9d38 96 06                        LDA  VALTYP         ; GET VARIABLE TYPE
4473 9d3a 39                 L8943     RTS                 ; JUMP TO USR ROUTINE (PSHS X ABOVE)
4474 9d3b c6 b1              L8944     LDB  #TOK_EQUALS    ; TOKEN FOR '='
4475 9d3d bd 8a 47                     JSR  LB26F          ; DO A SYNTAX CHECK FOR =
4476 9d40 7e 8f 10                     JMP  LB73D          ; EVALUATE EXPRESSION, RETURN VALUE IN X
4477                         
4478                         
4479                         
4480                         * DEL
4481 9d43 10 27 ee d6        DEL       LBEQ LB44A          ; 'FC' ERROR IF NO ARGUMENT
4482 9d47 bd 87 63                     JSR  LAF67          ; CONVERT A DECIMAL BASiC NUMBER TO BINARY
4483 9d4a bd 84 f3                     JSR  LAD01          ; FIND RAM ADDRESS OF START OF A BASIC LINE
4484 9d4d 9f 92                        STX  VD3            ; SAVE RAM ADDRESS OF STARTING LINE NUMBER
4485 9d4f 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4486 9d51 27 10                        BEQ  L8990          ; BRANCH IF END OF LINE
4487 9d53 81 aa                        CMPA #TOK_MINUS     ; TOKEN FOR '-'
4488 9d55 26 3b                        BNE  L89BF          ; TERMINATE COMMAND IF LINE NUMBER NOT FOLLOWED BY '-'
4489 9d57 9d 7b                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4490 9d59 27 04                        BEQ  L898C          ; IF END OF LINE, USE DEFAULT ENDING LINE NUMBER
4491 9d5b 8d 24                        BSR  L89AE          ; * CONVERT ENDING LINE NUMBER TO BINARY
4492 9d5d 20 04                        BRA  L8990          ; * AND SAVE IT IN BINVAL
4493 9d5f 86 ff              L898C     LDA  #$FF           ; = USE $FFXX AS DEFAULT ENDING
4494 9d61 97 2b                        STA  BINVAL         ; = LINE NUMBER - SAVE IT IN BINVAL
4495 9d63 de 92              L8990     LDU  VD3            ; POINT U TO STARTING LINE NUMBER ADDRESS
4496 9d65 8c                 L8992     FCB  SKP2           ; SKIP TWO BYTES
4497 9d66 ee c4              L8993     LDU  ,U             ; POINT U TO START OF NEXT LINE
4498 9d68 ec c4                        LDD  ,U             ; CHECK FOR END OF PROGRAM
4499 9d6a 27 06                        BEQ  L899F          ; BRANCH IF END OF PROGRAM
4500 9d6c ec 42                        LDD  $02,U          ; LOAD ACCD WITH THIS LINE'S NUMBER
4501 9d6e 93 2b                        SUBD BINVAL         ; SUBTRACT ENDING LINE NUMBER ADDRESS
4502 9d70 23 f4                        BLS  L8993          ; BRANCH IF = < ENDING LINE NUMBER
4503 9d72 9e 92              L899F     LDX  VD3            ; GET STARTING LINE NUMBER
4504 9d74 8d 15                        BSR  L89B8          ; MOVE (U) TO (X) UNTIL END OF PROGRAM
4505 9d76 bd 85 13                     JSR  LAD21          ; RESET BASIC'S INPUT POINTER AND ERASE VARIABLES
4506 9d79 9e 92                        LDX  VD3            ; GET STARTING LINE NUMBER ADDRESS
4507 9d7b bd 84 e3                     JSR  LACF1          ; RECOMPUTE START OF NEXT LINE ADDRESSES
4508 9d7e 7e 84 6d                     JMP  LAC73          ; JUMP TO BASIC'S MAIN COMMAND LOOP
4509 9d81 bd 87 63           L89AE     JSR  LAF67          ; GO GET LINE NUMBER CONVERTED TO BINARY
4510 9d84 7e 81 9c                     JMP  LA5C7          ; MAKE SURE THERE'S NO MORE ON THIS LINE
4511 9d87 a6 c0              L89B4     LDA  ,U+            ; GET A BYTE FROM (U)
4512 9d89 a7 80                        STA  ,X+            ; MOVE THE BYTE TO (X)
4513 9d8b 11 93 1b           L89B8     CMPU VARTAB         ; COMPARE TO END OF BASIC
4514 9d8e 26 f7                        BNE  L89B4          ; BRANCH IF NOT AT END
4515 9d90 9f 1b                        STX  VARTAB         ; SAVE (X) AS NEW END OF BASIC
4516 9d92 39                 L89BF     RTS
4517                         
4518                         
4519 9d93 bd 9c 7c           L89C0     JSR  L8866          ; 'BS' ERROR IF IN DIRECT MODE
4520 9d96 9d 7b                        JSR  GETNCH         ; GET A CHAR FROM BASIC
4521 9d98 81 22              L89D2     CMPA #'"            ; CHECK FOR PROMPT STRING
4522 9d9a 26 0b                        BNE  L89E1          ; BRANCH IF NO PROMPT STRING
4523 9d9c bd 8a 1c                     JSR  LB244          ; STRIP OFF PROMPT STRING & PUT IT ON STRING STACK
4524 9d9f c6 3b                        LDB  #';            ; *
4525 9da1 bd 8a 47                     JSR  LB26F          ; * DO A SYNTAX CHECK FOR;
4526 9da4 bd 91 4b                     JSR  LB99F          ; REMOVE PROMPT STRING FROM STRING STACK & SEND TO CONSOLE OUT
4527 9da7 32 7e              L89E1     LEAS -2,S           ; RESERVE TWO STORAGE SLOTS ON STACK
4528 9da9 bd 88 18                     JSR  LB035          ; INPUT A LINE FROM CURRENT INPUT DEVICE
4529 9dac 32 62                        LEAS $02,S          ; CLEAN UP THE STACK
4530 9dae bd 8b 2a                     JSR  LB357          ; SEARCH FOR A VARIABLE
4531 9db1 9f 3b                        STX  VARDES         ; SAVE POINTER TO VARIABLE DESCRIPTOR
4532 9db3 bd 89 1e                     JSR  LB146          ; ''TM' ERROR IF VARIABLE TYPE = NUMERIC
4533 9db6 8e 00 e0                     LDX  #LINBUF        ; POINT X TO THE STRING BUFFER WHERE THE INPUT STRING WAS STORED
4534 9db9 4f                           CLRA                ; TERMINATOR CHARACTER 0 (END OF LINE)
4535 9dba bd 8c ef                     JSR  LB51A          ; PARSE THE INPUT STRING AND STORE IT IN THE STRING SPACE
4536 9dbd 7e 87 a0                     JMP  LAFA4          ; REMOVE DESCRIPTOR FROM STRING STACK
4537                         
4538 e000                    		  ORG $e000			  ; BEGIN OTHER ROM SECTION
4539                         		  
4540 e000 bd 87 63           L89FC     JSR  LAF67          ; STRIP A DECIMAL NUMBER FROM BASIC INPUT LINE
4541 e003 9e 2b                        LDX  BINVAL         ; GET BINARY VALUE
4542 e005 39                           RTS
4543 e006 9e 90              L8A02     LDX  VD1            ; GET CURRENT OLD NUMBER BEING RENUMBERED
4544 e008 9f 2b              L8A04     STX  BINVAL         ; SAVE THE LINE NUMBER BEING SEARCHED FOR
4545 e00a 7e 84 f3                     JMP  LAD01          ; GO FIND THE LINE NUMBER IN BASIC PROGRAM
4546                         
4547                         * RENUM
4548 e00d bd 85 18           RENUM     JSR  LAD26          ; ERASE VARIABLES
4549 e010 cc 00 0a                     LDD  #10            ; DEFAULT LINE NUMBER INTERVAL
4550 e013 dd 94                        STD  VD5            ; SAVE DEFAULT RENUMBER START LINE NUMBER
4551 e015 dd 8e                        STD  VCF            ; SAVE DEFAULT INTERVAL
4552 e017 5f                           CLRB                ; NOW ACCD = 0
4553 e018 dd 90                        STD  VD1            ; DEFAULT LINE NUMBER OF WHERE TO START RENUMBERING
4554 e01a 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4555 e01c 24 06                        BCC  L8A20          ; BRANCH IF NOT NUMERIC
4556 e01e 8d e0                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4557 e020 9f 94                        STX  VD5            ; SAVE LINE NUMBER WHERE RENUMBERING STARTS
4558 e022 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4559 e024 27 1b              L8A20     BEQ  L8A3D          ; BRANCH IF END OF LINE
4560 e026 bd 8a 45                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4561 e029 24 06                        BCC  L8A2D          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
4562 e02b 8d d3                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4563 e02d 9f 90                        STX  VD1            ; SAVE NEW RENUMBER LINE
4564 e02f 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4565 e031 27 0e              L8A2D     BEQ  L8A3D          ; BRANCH IF END OF LINE
4566 e033 bd 8a 45                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
4567 e036 24 06                        BCC  L8A3A          ; BRANCH IF NEXT CHARACTER NOT NUMERIC
4568 e038 8d c6                        BSR  L89FC          ; CONVERT DECIMAL NUMBER IN BASIC PROGRAM TO BINARY
4569 e03a 9f 8e                        STX  VCF            ; SAVE NEW INTERVAL
4570 e03c 27 49                        BEQ  L8A83          ; 'FC' ERROR
4571 e03e bd 81 9c           L8A3A     JSR  LA5C7          ; CHECK FOR MORE CHARACTERS ON LINE - 'SYNTAX' ERROR IF ANY
4572 e041 8d c3              L8A3D     BSR  L8A02          ; GO GET ADDRESS OF OLD NUMBER BEING RENUMBERED
4573 e043 9f 92                        STX  VD3            ; SAVE ADDRESS
4574 e045 9e 94                        LDX  VD5            ; GET NEXT RENUMBERED LINE NUMBER TO USE
4575 e047 8d bf                        BSR  L8A04          ; FIND THE LINE NUMBER IN THE BASIC PROGRAM
4576 e049 9c 92                        CMPX VD3            ; COMPARE TO ADDRESS OF OLD LINE NUMBER
4577 e04b 25 3a                        BLO  L8A83          ; 'FC' ERROR IF NEW ADDRESS < OLD ADDRESS
4578 e04d 8d 1c                        BSR  L8A67          ; MAKE SURE RENUMBERED LINE NUMBERS WILL BE IN RANGE
4579 e04f bd e0 e1                     JSR  L8ADD          ; CONVERT ASCII LINE NUMBERS TO 'EXPANDED' BINARY
4580 e052 bd 84 e1                     JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESSES
4581 e055 8d af                        BSR  L8A02          ; GET RAM ADDRESS OF FIRST LINE TO BE RENUMBERED
4582 e057 9f 92                        STX  VD3            ; SAVE IT
4583 e059 8d 3a                        BSR  L8A91          ; MAKE SURE LINE NUMBERS EXIST
4584 e05b 8d 0f                        BSR  L8A68          ; INSERT NEW LINE NUMBERS IN LINE HEADERS
4585 e05d 8d 36                        BSR  L8A91          ; INSERT NEW LINE NUMBERS IN PROGRAM STATEMENTS
4586 e05f bd e1 7c                     JSR  L8B7B          ; CONVERT PACKED BINARY LINE NUMBERS TO ASCII
4587 e062 bd 85 18                     JSR  LAD26          ; ERASE VARIABLES
4588 e065 bd 84 e1                     JSR  LACEF          ; RECALCULATE NEXT LINE RAM ADDRESS
4589 e068 7e 84 6d                     JMP  LAC73          ; GO BACK TO BASIC'S MAIN LOOP
4590 e06b 86                 L8A67     FCB  SKP1LD         ; SKIP ONE BYTE - LDA #$4F
4591 e06c 4f                 L8A68     CLRA                ; NEW LINE NUMBER FLAG - 0; INSERT NEW LINE NUMBERS
4592 e06d 97 97                        STA  VD8            ; SAVE NEW LINE NUMBER FLAG; 0 = INSERT NEW NUMBERS
4593 e06f 9e 92                        LDX  VD3            ; GET ADDRESS OF OLD LINE NUMBER BEING RENUMBERED
4594 e071 dc 94                        LDD  VD5            ; GET THE CURRENT RENUMBERED LINE NUMBER
4595 e073 8d 15                        BSR  L8A86          ; RETURN IF END OF PROGRAM
4596 e075 0d 97              L8A71     TST  VD8            ; CHECK NEW LINE NUMBER FLAG
4597 e077 26 02                        BNE  L8A77          ; BRANCH IF NOT INSERTING NEW LINE NUMBERS
4598 e079 ed 02                        STD  $02,X          ; STORE THE NEW LINE NUMBER IN THE BASIC PROGRAM
4599 e07b ae 84              L8A77     LDX  ,X             ; POINT X TO THE NEXT LINE IN BASIC
4600 e07d 8d 0b                        BSR  L8A86          ; RETURN IF END OF PROGRAM
4601 e07f d3 8e                        ADDD VCF            ; ADD INTERVAL TO CURRENT RENUMBERED LINE NUMBER
4602 e081 25 04                        BLO  L8A83          ; 'FC' ERROR IF LINE NUMBER > $FFFF
4603 e083 81 fa                        CMPA #MAXLIN        ; LARGEST LINE NUMBER = $F9FF
4604 e085 25 ee                        BLO  L8A71          ; BRANCH IF LEGAL LINE NUMBER
4605 e087 7e 8c 1d           L8A83     JMP  LB44A          ; 'FC' ERROR IF LINE NUMBER MS BYTE > $F9
4606                         * TEST THE TWO BYTES POINTED TO BY (X).
4607                         * NORMAL RETURN IF <> 0. IF = 0 (END OF
4608                         * PROGRAM) RETURN IS PULLED OFF STACK AND
4609                         * YOU RETURN TO PREVIOUS SUBROUTINE CALL.
4610 e08a 34 06              L8A86     PSHS B,A            ; SAVE ACCD
4611 e08c ec 84                        LDD  ,X             ; TEST THE 2 BYTES POINTED TO BY X
4612 e08e 35 06                        PULS A,B            ; RESTORE ACCD
4613 e090 26 02                        BNE  L8A90          ; BRANCH IF NOT END OF PROGRAM
4614 e092 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS FROM STACK
4615 e094 39                 L8A90     RTS
4616 e095 9e 19              L8A91     LDX  TXTTAB         ; GET START OF BASIC PROGRAM
4617 e097 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
4618 e099 30 01              L8A95     LEAX $01,X          ; MOVE POINTER UP ONE
4619 e09b 8d ed                        BSR  L8A86          ; RETURN IF END OF PROGRAM
4620 e09d 30 03              L8A99     LEAX $03,X          ; SKIP OVER NEXT LINE ADDRESS AND LINE NUMBER
4621 e09f 30 01              L8A9B     LEAX $01,X          ; MOVE POINTER TO NEXT CHARACTER
4622 e0a1 a6 84                        LDA  ,X             ; CHECK CURRENT CHARACTER
4623 e0a3 27 f4                        BEQ  L8A95          ; BRANCH IF END OF LINE
4624 e0a5 9f 0f                        STX  TEMPTR         ; SAVE CURRENT POINTER
4625 e0a7 4a                           DECA                ; =
4626 e0a8 27 0c                        BEQ  L8AB2          ; =BRANCH IF START OF PACKED NUMERIC LINE
4627 e0aa 4a                           DECA                ; *
4628 e0ab 27 2a                        BEQ  L8AD3          ; *BRANCH IF LINE NUMBER EXISTS
4629 e0ad 4a                           DECA                ; =
4630 e0ae 26 ef                        BNE  L8A9B          ; =MOVE TO NEXT CHARACTER IF > 3
4631 e0b0 86 03              L8AAC     LDA  #$03           ; * SET 1ST BYTE = 3 TO INDICATE LINE
4632 e0b2 a7 80                        STA  ,X+            ; * NUMBER DOESN'T CURRENTLY EXIST
4633 e0b4 20 e7                        BRA  L8A99          ; GO GET ANOTHER CHARACTER
4634 e0b6 ec 01              L8AB2     LDD  $01,X          ; GET MS BYTE OF LINE NUMBER
4635 e0b8 6a 02                        DEC  $02,X          ; DECREMENT ZERO CHECK BYTE
4636 e0ba 27 01                        BEQ  L8AB9          ; BRANCH IF MS BYTE <> 0
4637 e0bc 4f                           CLRA                ; CLEAR MS BYTE
4638 e0bd e6 03              L8AB9     LDB  $03,X          ; GET LS BYTE OF LINE NUMBER
4639 e0bf 6a 04                        DEC  $04,X          ; DECREMENT ZERO CHECK FLAG
4640 e0c1 27 01                        BEQ  L8AC0          ; BRANCH IF IS BYTE <> 0
4641 e0c3 5f                           CLRB                ; CLEAR LS BYTE
4642 e0c4 ed 01              L8AC0     STD  $01,X          ; SAVE BINARY LINE NUMBER
4643 e0c6 dd 2b                        STD  BINVAL         ; SAVE TRIAL LINE NUMBER
4644 e0c8 bd 84 f3                     JSR  LAD01          ; FIND RAM ADDRESS OF A BASIC LINE NUMBER
4645 e0cb 9e 0f              L8AC7     LDX  TEMPTR         ; GET BACK POINTER TO START OF PACKED LINE NUMBER
4646 e0cd 25 e1                        BLO  L8AAC          ; BRANCH IF NO LINE NUMBER MATCH FOUND
4647 e0cf dc 47                        LDD  V47            ; GET START ADDRESS OF LINE NUMBER
4648 e0d1 6c 80                        INC  ,X+            ; * SET 1ST BYTE = 2, TO INDICATE LINE NUMBER EXISTS IF CHECKING FOR
4649                         *              ; * EXISTENCE OF LINE NUMBER, SET IT = 1 IF INSERTING LINE NUMBERS
4650                         
4651 e0d3 ed 84                        STD  ,X             ; SAVE RAM ADDRESS OF CORRECT LINE NUMBER
4652 e0d5 20 c6                        BRA  L8A99          ; GO GET ANOTHER CHARACTER
4653 e0d7 6f 84              L8AD3     CLR  ,X             ; CLEAR CARRY FLAG AND 1ST BYTE
4654 e0d9 ae 01                        LDX  $01,X          ; POINT X TO RAM ADDRESS OF CORRECT LINE NUMBER
4655 e0db ae 02                        LDX  $02,X          ; PUT CORRECT LINE NUMBER INTO (X)
4656 e0dd 9f 47                        STX  V47            ; SAVE IT TEMPORARILY
4657 e0df 20 ea                        BRA  L8AC7          ; GO INSERT IT INTO BASIC LINE
4658 e0e1 9e 19              L8ADD     LDX  TXTTAB         ; GET BEGINNING OF BASIC PROGRAM
4659 e0e3 20 04                        BRA  L8AE5
4660 e0e5 9e 82              L8AE1     LDX  CHARAD         ; *GET CURRENT INPUT POINTER
4661 e0e7 30 01                        LEAX $01,X          ; *AND BUMP IT ONE
4662 e0e9 8d 9f              L8AE5     BSR  L8A86          ; RETURN IF END OF PROGRAM
4663 e0eb 30 02                        LEAX $02,X          ; SKIP PAST NEXT LINE ADDRESS
4664 e0ed 30 01              L8AE9     LEAX $01,X          ; ADVANCE POINTER BY ONE
4665 e0ef 9f 82              L8AEB     STX  CHARAD         ; SAVE NEW BASIC INPUT POINTER
4666 e0f1 9d 7b              L8AED     JSR  GETNCH         ; GET NEXT CHARACTER FROM BASIC
4667 e0f3 4d                 L8AEF     TSTA                ; CHECK THE CHARACTER
4668 e0f4 27 ef                        BEQ  L8AE1          ; BRANCH IF END OF LINE
4669 e0f6 2a f9                        BPL  L8AED          ; BRANCH IF NOT A TOKEN
4670 e0f8 9e 82                        LDX  CHARAD         ; GET CURRENT INPUT POINTER
4671 e0fa 81 ff                        CMPA #$FF           ; IS THIS A SECONDARY TOKEN?
4672 e0fc 27 ef                        BEQ  L8AE9          ; YES - IGNORE IT
4673 e0fe 81 a5                        CMPA #TOK_THEN      ; TOKEN FOR THEN?
4674 e100 27 12                        BEQ  L8B13          ; YES
4675 e102 81 84                        CMPA #TOK_ELSE      ; TOKEN FOR ELSE?
4676 e104 27 0e                        BEQ  L8B13          ; YES
4677 e106 81 81                        CMPA #TOK_GO        ; TOKEN FOR GO?
4678 e108 26 e7                        BNE  L8AED          ; NO
4679 e10a 9d 7b                        JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4680 e10c 81 a3                        CMPA #TOK_TO        ; TOKEN FOR TO?
4681 e10e 27 04                        BEQ  L8B13          ; YES
4682 e110 81 a4                        CMPA #TOK_SUB       ; TOKEN FOR SUB?
4683 e112 26 db                        BNE  L8AEB          ; NO
4684 e114 9d 7b              L8B13     JSR  GETNCH         ; GET A CHARACTER FROM BASIC
4685 e116 25 04                        BLO  L8B1B          ; BRANCH IF NUMERIC
4686 e118 9d 81              L8B17     JSR  GETCCH         ; GET CURRENT BASIC INPUT CHARRACTER
4687 e11a 20 d7                        BRA  L8AEF          ; KEEP CHECKING THE LINE
4688 e11c 9e 82              L8B1B     LDX  CHARAD         ; GET CURRENT INPUT ADDRESS
4689 e11e 34 10                        PSHS X              ; SAVE IT ON THE STACK
4690 e120 bd 87 63                     JSR  LAF67          ; CONVERT DECIMAL BASIC NUMBER TO BINARY
4691 e123 9e 82                        LDX  CHARAD         ; GET CURRENT INPUT POINTER
4692 e125 a6 82              L8B24     LDA  ,-X            ; GET PREVIOUS INPUT CHARACTER
4693 e127 bd e4 8c                     JSR  L90AA          ; CLEAR CARRY IF NUMERIC INPUT VALUE
4694 e12a 25 f9                        BLO  L8B24          ; BRANCH IF NON-NUMERIC
4695 e12c 30 01                        LEAX $01,X          ; MOVE POINTER UP ONE
4696 e12e 1f 10                        TFR  X,D            ; NOW ACCD POINTS TO ONE PAST END OF LINE NUMBER
4697 e130 e0 61                        SUBB $01,S          ; SUBTRACT PRE-NUMERIC POINTER LS BYTE
4698 e132 c0 05                        SUBB #$05           ; MAKE SURE THERE ARE AT LEAST 5 CHARACTERS IN THE NUMERIC LINE
4699                         *
4700 e134 27 20                        BEQ  L8B55          ; BRANCH IF EXACTLY 5
4701 e136 25 0a                        BLO  L8B41          ; BRANCH IF < 5
4702 e138 33 84                        LEAU ,X             ; TRANSFER X TO U
4703 e13a 50                           NEGB                ; NEGATE B
4704 e13b 30 85                        LEAX B,X            ; MOVE X BACK B BYTES
4705 e13d bd 9d 8b                     JSR  L89B8          ; *MOVE BYTES FROM (U) TO (X) UNTIL
4706                         *         *U   = END OF BASIC; (I) = NEW END OF BASIC
4707 e140 20 14                        BRA  L8B55
4708                         * FORCE FIVE BYTES OF SPACE FOR THE LINE NUMBER
4709 e142 9f 47              L8B41     STX  V47            ; SAVE END OF NUMERIC VALUE
4710 e144 9e 1b                        LDX  VARTAB         ; GET END OF BASIC PROGRAM
4711 e146 9f 43                        STX  V43            ; SAVE IT
4712 e148 50                           NEGB                ; NEGATE B
4713 e149 30 85                        LEAX B,X            ; ADD IT TO END OF NUMERIC POiNTER
4714 e14b 9f 41                        STX  V41            ; SAVE POINTER
4715 e14d 9f 1b                        STX  VARTAB         ; STORE END OF BASIC PROGRAM
4716 e14f bd 84 26                     JSR  LAC1E          ; ACCD = TOP OF ARRAYS - CHECK FOR ENOUGH ROOM
4717 e152 9e 45                        LDX  V45            ; * GET AND SAVE THE
4718 e154 9f 82                        STX  CHARAD         ; * NEW CURRENT INPUT POINTER
4719 e156 35 10              L8B55     PULS X              ; RESTORE POINTER TO START OF NUMERIC VALUE
4720 e158 86 01                        LDA  #$01           ; NEW LINE NUMBER FLAG
4721 e15a a7 84                        STA  ,X             ; * SAVE NEW LINE FLAG
4722 e15c a7 02                        STA  $02,X          ; *
4723 e15e a7 04                        STA  $04,X          ; *
4724 e160 d6 2b                        LDB  BINVAL         ; GET MS BYTE OF BINARY LINE NUMBER
4725 e162 26 04                        BNE  L8B67          ; BRANCH IF IT IS NOT ZERO
4726 e164 c6 01                        LDB  #$01           ; ; SAVE A 1 IF BYTE IS 0; OTHERWISE, BASIC WILL
4727                         *              ; THINK IT IS THE END OF A LINE
4728 e166 6c 02                        INC  $02,X          ; IF 2,X = 2, THEN PREVIOUS BYTE WAS A ZERO
4729 e168 e7 01              L8B67     STB  $01,X          ; SAVE MS BYTE OF BINARY LINE NUMBER
4730 e16a d6 2c                        LDB  BINVAL+1       ; GET IS BYTE OF BINARY LINE NUMBER
4731 e16c 26 04                        BNE  L8B71          ; BRANCH IF NOT A ZERO BYTE
4732 e16e c6 01                        LDB  #$01           ; SAVE A 1 IF BYTE IS A 0
4733 e170 6c 04                        INC  $04,X          ; IF 4,X = 2, THEN PREVIOUS BYTE WAS A 0
4734 e172 e7 03              L8B71     STB  $03,X          ; SAVE LS BYTE OF BINARY LINE NUMBER
4735 e174 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4736 e176 81 2c                        CMPA #',            ; IS IT A COMMA?
4737 e178 27 9a                        BEQ  L8B13          ; YES - PROCESS ANOTHER NUMERIC VALUE
4738 e17a 20 9c                        BRA  L8B17          ; NO - GO GET AND PROCESS AN INPUT CHARACTER
4739 e17c 9e 19              L8B7B     LDX  TXTTAB         ; POINT X TO START OF BASIC PROGRAM
4740 e17e 30 1f                        LEAX -1,X           ; MOVE POINTER BACK ONE
4741 e180 30 01              L8B7F     LEAX $01,X          ; MOVE POINTER UP ONE
4742 e182 ec 02                        LDD  $02,X          ; GET ADDRESS OF NEXT LINE
4743 e184 dd 68                        STD  CURLIN         ; SAVE IT IN CURLIN
4744 e186 bd e0 8a                     JSR  L8A86          ; RETURN IF END OF PROGRAM
4745 e189 30 03                        LEAX $03,X          ; SKIP OVER ADDRESS OF NEXT LINE AND 1ST BYTE OF LINE NUMBER
4746 e18b 30 01              L8B8A     LEAX $01,X          ; MOVE POINTER UP ONE
4747 e18d a6 84              L8B8C     LDA  ,X             ; GET CURRENT CHARACTER
4748 e18f 27 ef                        BEQ  L8B7F          ; BRANCH IF END OF LINE
4749 e191 4a                           DECA                ; INPUT CHARACTER = 1? - VALID LINE NUMBER
4750 e192 27 1b                        BEQ  L8BAE          ; YES
4751 e194 80 02                        SUBA #$02           ; INPUT CHARACTER 3? - UL LINE NUMBER
4752 e196 26 f3                        BNE  L8B8A          ; NO
4753 e198 34 10                        PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
4754 e19a 8e e1 d9                     LDX  #L8BD9-1       ; POINT X TO 'UL' MESSAGE
4755 e19d bd 91 48                     JSR  LB99C          ; PRINT STRING TO THE SCREEN
4756 e1a0 ae e4                        LDX  ,S             ; GET INPUT POINTER
4757 e1a2 ec 01                        LDD  $01,X          ; GET THE UNDEFINED LINE NUMBER
4758 e1a4 bd 95 78                     JSR  LBDCC          ; CONVERT NUMBER IN ACCD TO DECIMAL AND DISPLAY IT
4759 e1a7 bd 95 71                     JSR  LBDC5          ; PRINT 'IN XXXX' XXXX = CURRENT LINE NUMBER
4760 e1aa bd 91 08                     JSR  LB958          ; SEND A CR TO CONSOLE OUT
4761 e1ad 35 10                        PULS X              ; GET INPUT POINTER BACK
4762 e1af 34 10              L8BAE     PSHS X              ; SAVE CURRENT POSITION OF INPUT POINTER
4763 e1b1 ec 01                        LDD  $01,X          ; LOAD ACCD WITH BINARY VALUE OF LINE NUMBER
4764 e1b3 dd 52                        STD  FPA0+2         ; SAVE IN BOTTOM 2 BYTES OF FPA0
4765 e1b5 bd 9c 24                     JSR  L880E          ; ADJUST REST OF FPA0 AS AN INTEGER
4766 e1b8 bd 95 85                     JSR  LBDD9          ; CONVERT FPA0 TO ASCII, STORE IN LINE NUMBER
4767 e1bb 35 40                        PULS U              ; LOAD U WITH PREVIOUS ADDRESS OF INPUT POINTER
4768 e1bd c6 05                        LDB  #$05           ; EACH EXPANDED LINE NUMBER USES 5 BYTES
4769 e1bf 30 01              L8BBE     LEAX $01,X          ; MOVE POINTER FORWARD ONE
4770 e1c1 a6 84                        LDA  ,X             ; GET AN ASCII BYTE
4771 e1c3 27 05                        BEQ  L8BC9          ; BRANCH IF END OF NUMBER
4772 e1c5 5a                           DECB                ; DECREMENT BYTE COUNTER
4773 e1c6 a7 c0                        STA  ,U+            ; STORE ASCII NUMBER IN BASIC LINE
4774 e1c8 20 f5                        BRA  L8BBE          ; CHECK FOR ANOTHER DIGIT
4775 e1ca 30 c4              L8BC9     LEAX ,U             ; TRANSFER NEW LINE POINTER TO (X)
4776 e1cc 5d                           TSTB                ; DOES THE NEW LINE NUMBER REQUIRE 5 BYTES?
4777 e1cd 27 be                        BEQ  L8B8C          ; YES - GO GET ANOTHER INPUT CHARACTER
4778 e1cf 31 c4                        LEAY ,U             ; SAVE NEW LINE POINTER IN Y
4779 e1d1 33 c5                        LEAU B,U            ; POINT U TO END OF 5 BYTE PACKED LINE NUMBER BLOCK
4780 e1d3 bd 9d 8b                     JSR  L89B8          ; MOVE BYTES FROM (U) TO (X) UNTIL END OF PROGRAM
4781 e1d6 30 a4                        LEAX ,Y             ; LOAD (X) WITH NEW LINE POINTER
4782 e1d8 20 b3                        BRA  L8B8C          ; GO GET ANOTHER INPUT CHARACTER
4783                         
4784 e1da 55 4c 20           L8BD9     FCC  "UL "          ; UNKNOWN LINE NUMBER MESSAGE
4785 e1dd 00                           FCB  0
4786                         
4787                         
4788 e1de bd 8f 13           HEXDOL    JSR  LB740          ; CONVERT FPA0 INTO A POSITIVE 2 BYTE INTEGER
4789 e1e1 8e 01 dd                     LDX  #STRBUF+2      ; POINT TO TEMPORARY BUFFER
4790 e1e4 c6 04                        LDB  #$04           ; CONVERT 4 NIBBLES
4791 e1e6 34 04              L8BE5     PSHS B              ; SAVE NIBBLE COUNTER
4792 e1e8 5f                           CLRB                ; CLEAR CARRY FLAG
4793 e1e9 86 04                        LDA  #$04           ; 4 SHIFTS
4794 e1eb 08 53              L8BEA     ASL  FPA0+3         ; * SHIFT BOTTOM TWO BYTES OF
4795 e1ed 09 52                        ROL  FPA0+2         ; * FPA0 LEFT ONE BIT (X2)
4796 e1ef 59                           ROLB                ; IF OVERFLOW, ACCB <> 0
4797 e1f0 4a                           DECA                ; * DECREMENT SHIFT COUNTER AND
4798 e1f1 26 f8                        BNE  L8BEA          ; * BRANCH IF NOT DONE
4799 e1f3 5d                           TSTB                ; CHECK FOR OVERFLOW
4800 e1f4 26 0a                        BNE  L8BFF          ; BRANCH IF OVERFLOW
4801 e1f6 a6 e4                        LDA  ,S             ; * GET NIBBLE COUNTER,
4802 e1f8 4a                           DECA                ; * DECREMENT IT AND
4803 e1f9 27 05                        BEQ  L8BFF          ; * BRANCH IF DONE
4804 e1fb 8c 01 dd                     CMPX #STRBUF+2      ; DO NOT DO A CONVERSION UNTIL A NON-ZERO
4805 e1fe 27 0c                        BEQ  L8C0B          ; BYTE IS FOUND - LEADING ZERO SUPPRESSION
4806 e200 cb 30              L8BFF     ADDB #'0            ; ADD IN ASCII ZERO
4807 e202 c1 39                        CMPB #'9            ; COMPARE TO ASCII 9
4808 e204 23 02                        BLS  L8C07          ; BRANCH IF < 9
4809 e206 cb 07                        ADDB #7             ; ADD ASCII OFFSET IF HEX LETTER
4810 e208 e7 80              L8C07     STB  ,X+            ; STORE HEX VALUE AND ADVANCE POINTER
4811 e20a 6f 84                        CLR  ,X             ; CLEAR NEXT BYTE - END OF STRING FLAG
4812 e20c 35 04              L8C0B     PULS B              ; * GET NIBBLE COUNTER,
4813 e20e 5a                           DECB                ; * DECREMENT IT AND
4814 e20f 26 d5                        BNE  L8BE5          ; * BRANCH IF NOT DONE
4815 e211 32 62                        LEAS $02,S          ; PURGE RETURN ADDRESS OFF OF STACK
4816 e213 8e 01 dc                     LDX  #STRBUF+1      ; RESET POINTER
4817 e216 7e 8c eb                     JMP  LB518          ; SAVE STRING ON STRING STACK
4818                         * PROCESS EXCLAMATION POINT
4819 e219 86 01              L8E37     LDA  #$01           ; * SET SPACES
4820 e21b 97 98                        STA  VD9            ; * COUNTER = 1
4821                         * PROCESS STRING ITEM - LIST
4822 e21d 5a                 L8E3B     DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
4823 e21e bd e3 ba                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <>0
4824 e221 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
4825 e223 10 27 00 93                  LBEQ L8ED8          ; EXIT PRINT USING IF END OF LINE
4826 e227 d7 92                        STB  VD3            ; SAVE REMAINDER FORMAT STRING LENGTH
4827 e229 bd 89 2e                     JSR  LB156          ; EVALUATE EXPRESSION
4828 e22c bd 89 1e                     JSR  LB146          ; 'TM' ERROR IF NUMERIC VARIABLE
4829 e22f 9e 52                        LDX  FPA0+2         ; * GET ITEM - LIST DESCRIPTOR ADDRESS
4830 e231 9f 4d                        STX  V4D            ; * AND SAVE IT IN V4D
4831 e233 d6 98                        LDB  VD9            ; GET SPACES COUNTER
4832 e235 bd 8e 80                     JSR  LB6AD          ; PUT ACCB BYTES INTO STRING SPACE & PUT DESCRIPTOR ON STRING STACK
4833 e238 bd 91 4b                     JSR  LB99F          ; PRINT THE FORMATTED STRING TO CONSOLE OUT
4834                         * PAD FORMAT STRING WITH SPACES IF ITEM - LIST STRING < FORMAT STRING LENGTH
4835 e23b 9e 52                        LDX  FPA0+2         ; POINT X TO FORMATTED STRING DESCRIPTOR ADDRESS
4836 e23d d6 98                        LDB  VD9            ; GET SPACES COUNTER
4837 e23f e0 84                        SUBB ,X             ; SUBTRACT LENGTH OF FORMATTED STRING
4838 e241 5a                 L8E5F     DECB                ; DECREMENT DIFFERENCE
4839 e242 10 2b 01 4f                  LBMI L8FB3          ; GO INTERPRET ANOTHER ITEM - LIST
4840 e246 bd 91 58                     JSR  LB9AC          ; PAD FORMAT STRING WITH A SPACE
4841 e249 20 f6                        BRA  L8E5F          ; KEEP PADDING
4842                         * PERCENT SIGN - PROCESS A %SPACES% COMMAND
4843 e24b d7 92              L8E69     STB  VD3            ; * SAVE THE CURRENT FORMAT STRING
4844 e24d 9f 0f                        STX  TEMPTR         ; * COUNTER AND POINTER
4845 e24f 86 02                        LDA  #$02           ; INITIAL SPACES COUNTER = 2
4846 e251 97 98                        STA  VD9            ; SAVE IN SPACES COUNTER
4847 e253 a6 84              L8E71     LDA  ,X             ; GET A CHARACTER FROM FORMAT STRING
4848 e255 81 25                        CMPA #'%            ; COMPARE TO TERMINATOR CHARACTER
4849 e257 27 c4                        BEQ  L8E3B          ; BRANCH IF END OF SPACES COMMAND
4850 e259 81 20                        CMPA #'             ; BLANK
4851 e25b 26 07                        BNE  L8E82          ; BRANCH IF ILLEGAL CHARACTER
4852 e25d 0c 98                        INC  VD9            ; ADD ONE TO SPACES COUNTER
4853 e25f 30 01                        LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
4854 e261 5a                           DECB                ; DECREMENT LENGTH COUNTER
4855 e262 26 ef                        BNE  L8E71          ; BRANCH IF NOT END OF FORMAT STRING
4856 e264 9e 0f              L8E82     LDX  TEMPTR         ; * RESTORE CURRENT FORMAT STRING COUNTER
4857 e266 d6 92                        LDB  VD3            ; * AND POINTER TO POSITION BEFORE SPACES COMMAND
4858 e268 86 25                        LDA  #'%            ; SEND A '%' TO CONSOLE OUT AS A DEBUGGING AID
4859                         * ERROR PROCESSOR - ILLEGAL CHARACTER OR BAD SYNTAX IN FORMAT STRING
4860 e26a bd e3 ba           L8E88     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
4861 e26d bd 80 31                     JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
4862 e270 20 29                        BRA  L8EB9          ; GET NEXT CHARACTER IN FORMAT STRING
4863                         
4864                         * PRINT RAM HOOK
4865 e272 81 b4              XVEC9     CMPA #TOK_USING     ; USING TOKEN
4866 e274 27 01                        BEQ  L8E95          ; BRANCH IF PRINT USING
4867 e276 39                           RTS
4868                         
4869                         * PRINT USING
4870                         * VDA IS USED AS A STATUS BYTE: BIT 6 = COMMA FORCE
4871                         * BIT 5=LEADING ASTERISK FORCE; BIT 4 = FLOATING $ FORCE
4872                         * BIT 3 = PRE SIGN FORCE; BIT 2 = POST SIGN FORCE; BIT 0 = EXPONENTIAL FORCE
4873 e277 32 62              L8E95     LEAS $02,S          ; PURGE RETURN ADDRESS OFF THE STACK
4874 e279 bd 89 30                     JSR  LB158          ; EVALUATE FORMAT STRING
4875 e27c bd 89 1e                     JSR  LB146          ; 'TM' ERROR IF VARIABLE TYPE = NUMERIC
4876 e27f c6 3b                        LDB  #';            ; CHECK FOR ITEM LIST SEPARATOR
4877 e281 bd 8a 47                     JSR  LB26F          ; SYNTAX CHECK FOR ;
4878 e284 9e 52                        LDX  FPA0+2         ; * GET FORMAT STRING DESCRIPTOR ADDRESS
4879 e286 9f 94                        STX  VD5            ; * AND SAVE IT IN VD5
4880 e288 20 06                        BRA  L8EAE          ; GO PROCESS FORMAT STRING
4881 e28a 96 96              L8EA8     LDA  VD7            ; *CHECK NEXT PRINT ITEM FLAG AND
4882 e28c 27 08                        BEQ  L8EB4          ; *'FC' ERROR IF NO FURTHER PRINT ITEMS
4883 e28e 9e 94                        LDX  VD5            ; RESET FORMAT STRING POINTER TO START OF STRING
4884 e290 0f 96              L8EAE     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
4885 e292 e6 84                        LDB  ,X             ; GET LENGTH OF FORMAT STRING
4886 e294 26 03                        BNE  L8EB7          ; INTERPRET FORMAT STRING IF LENGTH > 0
4887 e296 7e 8c 1d           L8EB4     JMP  LB44A          ; 'FC' ERROR IF FORMAT STRING = NULL
4888 e299 ae 02              L8EB7     LDX  $02,X          ; POINT X TO START OF FORMAT STRING
4889                         * INTERPRET THE FORMAT STRING
4890 e29b 0f 99              L8EB9     CLR  VDA            ; CLEAR THE STATUS BYTE
4891 e29d 0f 98              L8EBB     CLR  VD9            ; CLEAR LEFT DIGIT COUNTER
4892 e29f a6 80                        LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
4893 e2a1 81 21                        CMPA #'!            ; EXCLAMATION POINT?
4894 e2a3 10 27 ff 72                  LBEQ L8E37          ; YES - STRING TYPE FORMAT
4895 e2a7 81 23                        CMPA #'#            ; NUMBER SIGN? (DIGIT LOCATOR)
4896 e2a9 27 5b                        BEQ  L8F24          ; YES - NUMERIC TYPE FORMAT
4897 e2ab 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH
4898 e2ac 26 16                        BNE  L8EE2          ; BRANCH IF NOT DONE
4899 e2ae bd e3 ba                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
4900 e2b1 bd 80 31                     JSR  PUTCHR         ; SEND CHARACTER TO CONSOLE OUT
4901 e2b4 9d 81              L8ED2     JSR  GETCCH         ; GET CURRENT CHARACTER FROM BASIC
4902 e2b6 26 d2                        BNE  L8EA8          ; BRANCH IF NOT END OF LINE
4903 e2b8 96 96                        LDA  VD7            ; GET NEXT PRINT ITEM FLAG
4904 e2ba 26 03              L8ED8     BNE  L8EDD          ; BRANCH IF MORE PRINT ITEMS
4905 e2bc bd 91 08                     JSR  LB958          ; SEND A CARRIAGE RETURN TO CONSOLE OUT
4906 e2bf 9e 94              L8EDD     LDX  VD5            ; POINT X TO FORMAT STRING DESCRIPTOR
4907 e2c1 7e 8e 2c                     JMP  LB659          ; RETURN ADDRESS AND LENGTH OF FORMAT STRING - EXIT PRINT USING
4908 e2c4 81 2b              L8EE2     CMPA #'+            ; CHECK FOR '+' (PRE-SIGN FORCE)
4909 e2c6 26 09                        BNE  L8EEF          ; NO PLUS
4910 e2c8 bd e3 ba                     JSR  L8FD8          ; SEND A '+' TO CONSOLE OUT IF VDA <> 0
4911 e2cb 86 08                        LDA  #$08           ; * LOAD THE STATUS BYTE WITH 8;
4912 e2cd 97 99                        STA  VDA            ; * PRE-SIGN FORCE FLAG
4913 e2cf 20 cc                        BRA  L8EBB          ; INTERPRET THE REST OF THE FORMAT STRING
4914 e2d1 81 2e              L8EEF     CMPA #'.            ; DECIMAL POINT?
4915 e2d3 27 4e                        BEQ  L8F41          ; YES
4916 e2d5 81 25                        CMPA #'%            ; PERCENT SIGN?
4917 e2d7 10 27 ff 70                  LBEQ L8E69          ; YES
4918 e2db a1 84                        CMPA ,X             ; COMPARE THE PRESENT FORMAT STRING INPUT
4919                         *              ; CHARACTER TO THE NEXT ONE IN THE STRING
4920 e2dd 26 8b              L8EFB     BNE  L8E88          ; NO MATCH - ILLEGAL CHARACTER
4921                         * TWO CONSECUTIVE EQUAL CHARACTERS IN FORMAT STRING
4922 e2df 81 24                        CMPA #'$            ; DOLLAR SIGN?
4923 e2e1 27 19                        BEQ  L8F1A          ; YES - MAKE THE DOLLAR SIGN FLOAT
4924 e2e3 81 2a                        CMPA #'*            ; ASTERISK?
4925 e2e5 26 f6                        BNE  L8EFB          ; NO - ILLEGAL CHARACTER
4926 e2e7 96 99                        LDA  VDA            ; * GRAB THE STATUS BYTE AND BET BIT 5
4927 e2e9 8a 20                        ORA  #$20           ; * TO INDICATE THAT THE OUTPUT WILL
4928 e2eb 97 99                        STA  VDA            ; * BE LEFT PADDED WITH ASTERISKS
4929 e2ed c1 02                        CMPB #2             ; * CHECK TO SEE IF THE $$ ARE THE LAST TWO
4930 e2ef 25 11                        BLO  L8F20          ; * CHARACTERS IN THE FORMAT STRING AND BRANCH IF SO
4931 e2f1 a6 01                        LDA  $01,X          ; GET THE NEXT CHARACTER AFTER **
4932 e2f3 81 24                        CMPA #'$            ; CHECK FOR **$
4933 e2f5 26 0b                        BNE  L8F20          ; CHECK FOR MORE CHARACTERS
4934 e2f7 5a                           DECB                ; DECREMENT STRING LENGTH COUNTER
4935 e2f8 30 01                        LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
4936 e2fa 0c 98                        INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER - FOR ASTERISK PAD AND
4937                         *              ; FLOATING DOLLAR SIGN COMBINATION
4938 e2fc 96 99              L8F1A     LDA  VDA            ; * GET THE STATUS BYTE AND SET
4939 e2fe 8a 10                        ORA  #$10           ; * BIT 4 TO INDICATE A
4940 e300 97 99                        STA  VDA            ; * FLOATING DOLLAR SIGN
4941 e302 30 01              L8F20     LEAX $01,X          ; MOVE FORMAT STRING POINTER UP ONE
4942 e304 0c 98                        INC  VD9            ; ADD ONE TO LEFT DIGIT (FLOATING $ OR ASTERISK PAD)
4943                         * PROCESS CHARACTERS TO THE LEFT OF THE DECIMAL POINT IN THE FORMAT STRING
4944 e306 0f 97              L8F24     CLR  VD8            ; CLEAR THE RIGHT DIGIT COUNTER
4945 e308 0c 98              L8F26     INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER
4946 e30a 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH COUNTER
4947 e30b 27 49                        BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
4948 e30d a6 80                        LDA  ,X+            ; GET THE NEXT FORMAT CHARACTER
4949 e30f 81 2e                        CMPA #'.            ; DECIMAL POINT?
4950 e311 27 1e                        BEQ  L8F4F          ; YES
4951 e313 81 23                        CMPA #'#            ; NUMBER SIGN?
4952 e315 27 f1                        BEQ  L8F26          ; YES
4953 e317 81 2c                        CMPA #',            ; COMMA?
4954 e319 26 21                        BNE  L8F5A          ; NO
4955 e31b 96 99                        LDA  VDA            ; * GET THE STATUS BYTE
4956 e31d 8a 40                        ORA  #$40           ; * AND SET BIT 6 WHICH IS THE
4957 e31f 97 99                        STA  VDA            ; * COMMA SEPARATOR FLAG
4958 e321 20 e5                        BRA  L8F26          ; PROCESS MORE CHARACTERS TO LEFT OF DECIMAL POINT
4959                         * PROCESS DECIMAL POINT IF NO DIGITS TO LEFT OF IT
4960 e323 a6 84              L8F41     LDA  ,X             ; GET NEXT FORMAT CHARACTER
4961 e325 81 23                        CMPA #'#            ; IS IT A NUMBER SIGN?
4962 e327 10 26 ff 3f                  LBNE L8E88          ; NO
4963 e32b 86 01                        LDA  #1             ; * SET THE RIGHT DIGIT COUNTER TO 1 -
4964 e32d 97 97                        STA  VD8            ; * ALLOW ONE SPOT FOR DECIMAL POINT
4965 e32f 30 01                        LEAX $01,X          ; MOVE FORMAT POINTER UP ONE
4966                         * PROCESS DIGITS TO RIGHT OF DECIMAL POINT
4967 e331 0c 97              L8F4F     INC  VD8            ; ADD ONE TO RIGHT DIGIT COUNTER
4968 e333 5a                           DECB                ; DECREMENT FORMAT LENGTH COUNTER
4969 e334 27 20                        BEQ  L8F74          ; BRANCH IF END OF FORMAT STRING
4970 e336 a6 80                        LDA  ,X+            ; GET A CHARACTER FROM FORMAT STRING
4971 e338 81 23                        CMPA #'#            ; IS IT NUMBER SIGN?
4972 e33a 27 f5                        BEQ  L8F4F          ; YES - KEEP CHECKING
4973                         * CHECK FOR EXPONENTIAL FORCE
4974 e33c 81 5e              L8F5A     CMPA #$5E           ; CHECK FOR UP ARROW
4975 e33e 26 16                        BNE  L8F74          ; NO UP ARROW
4976 e340 a1 84                        CMPA ,X             ; IS THE NEXT CHARACTER AN UP ARROW?
4977 e342 26 12                        BNE  L8F74          ; NO
4978 e344 a1 01                        CMPA $01,X          ; AND THE NEXT CHARACTER?
4979 e346 26 0e                        BNE  L8F74          ; NO
4980 e348 a1 02                        CMPA $02,X          ; HOW ABOUT THE 4TH CHARACTER?
4981 e34a 26 0a                        BNE  L8F74          ; NO, ALSO
4982 e34c c1 04                        CMPB #4             ; * CHECK TO SEE IF THE 4 UP ARROWS ARE IN THE
4983 e34e 25 06                        BLO  L8F74          ; * FORMAT STRING AND BRANCH IF NOT
4984 e350 c0 04                        SUBB #4             ; * MOVE POINTER UP 4 AND SUBTRACT
4985 e352 30 04                        LEAX $04,X          ; * FOUR FROM LENGTH
4986 e354 0c 99                        INC  VDA            ; INCREMENT STATUS BYTE - EXPONENTIAL FORM
4987                         
4988                         * CHECK FOR A PRE OR POST - SIGN FORCE AT END OF FORMAT STRING
4989 e356 30 1f              L8F74     LEAX -1,X           ; MOVE POINTER BACK ONE
4990 e358 0c 98                        INC  VD9            ; ADD ONE TO LEFT DIGIT COUNTER FOR PRE-SIGN FORCE
4991 e35a 96 99                        LDA  VDA            ; * PRE-SIGN
4992 e35c 85 08                        BITA #$08           ; * FORCE AND
4993 e35e 26 18                        BNE  L8F96          ; * BRANCH IF SET
4994 e360 0a 98                        DEC  VD9            ; DECREMENT LEFT DIGIT - NO PRE-SIGN FORCE
4995 e362 5d                           TSTB                ; * CHECK LENGTH COUNTER AND BRANCH
4996 e363 27 13                        BEQ  L8F96          ; * IF END OF FORMAT STRING
4997 e365 a6 84                        LDA  ,X             ; GET NEXT FORMAT STRING CHARACTER
4998 e367 80 2d                        SUBA #'-            ; CHECK FOR MINUS SIGN
4999 e369 27 06                        BEQ  L8F8F          ; BRANCH IF MINUS SIGN
5000 e36b 81 fe                        CMPA #$FE           ; * WAS CMPA #('+')-('-')
5001 e36d 26 09                        BNE  L8F96          ; BRANCH IF NO PLUS SIGN
5002 e36f 86 08                        LDA  #$08           ; GET THE PRE-SIGN FORCE FLAG
5003 e371 8a 04              L8F8F     ORA  #$04           ; 'OR' IN POST-SIGN FORCE FLAG
5004 e373 9a 99                        ORA  VDA            ; 'OR' IN THE STATUS BYTE
5005 e375 97 99                        STA  VDA            ; SAVE THE STATUS BYTE
5006 e377 5a                           DECB                ; DECREMENT FORMAT STRING LENGTH
5007                         
5008                         * EVALUATE NUMERIC ITEM-LIST
5009 e378 9d 81              L8F96     JSR  GETCCH         ; GET CURRENT CHARACTER
5010 e37a 10 27 ff 3c                  LBEQ L8ED8          ; BRANCH IF END OF LINE
5011 e37e d7 92                        STB  VD3            ; SAVE FORMAT STRING LENGTH WHEN FORMAT EVALUATION ENDED
5012 e380 bd 89 19                     JSR  LB141          ; EVALUATE EXPRESSION
5013 e383 96 98                        LDA  VD9            ; GET THE LEFT DIGIT COUNTER
5014 e385 9b 97                        ADDA VD8            ; ADD IT TO THE RIGHT DIGIT COUNTER
5015 e387 81 11                        CMPA #17            ; *
5016 e389 10 22 a8 90                  LBHI LB44A          ; *'FC' ERROR IF MORE THAN 16 DIGITS AND DECIMAL POiNT
5017 e38d bd e3 c7                     JSR  L8FE5          ; CONVERT ITEM-LIST TO FORMATTED ASCII STRING
5018 e390 30 1f                        LEAX -1,X           ; MOVE BUFFER POINTER BACK ONE
5019 e392 bd 91 48                     JSR  LB99C          ; DISPLAY THE FORMATTED STRING TO CONSOLE OUT
5020 e395 0f 96              L8FB3     CLR  VD7            ; RESET NEXT PRINT ITEM FLAG
5021 e397 9d 81                        JSR  GETCCH         ; GET CURRENT INPUT CHARACTER
5022 e399 27 0d                        BEQ  L8FC6          ; BRANCH IF END OF LINE
5023 e39b 97 96                        STA  VD7            ; SAVE CURRENT CHARACTER (<>0) IN NEXT PRINT ITEM FLAG
5024 e39d 81 3b                        CMPA #';            ; * CHECK FOR ; - ITEM-LIST SEPARATOR AND
5025 e39f 27 05                        BEQ  L8FC4          ; * BRANCH IF SEMICOLON
5026 e3a1 bd 8a 45                     JSR  LB26D          ; SYNTAX CHECK FOR COMMA
5027 e3a4 20 02                        BRA  L8FC6          ; PROCESS NEXT PRINT ITEM
5028 e3a6 9d 7b              L8FC4     JSR  GETNCH         ; GET NEXT INPUT CHARACTER
5029 e3a8 9e 94              L8FC6     LDX  VD5            ; GET FORMAT STRING DESCRIPTOR ADDRESS
5030 e3aa e6 84                        LDB  ,X             ; GET LENGTH OF FORMAT STRING
5031 e3ac d0 92                        SUBB VD3            ; SUBTRACT AMOUNT OF FORMAT STRING LEFT AFTER LAST PRINT ITEM
5032 e3ae ae 02                        LDX  $02,X          ; *GET FORMAT STRING START ADDRESS AND ADVANCE
5033 e3b0 3a                           ABX                 ; *POINTER TO START OF UNUSED FORMAT STRING
5034 e3b1 d6 92                        LDB  VD3            ; * GET AMOUNT OF UNUSED FORMAT STRING
5035 e3b3 10 26 fe e4                  LBNE L8EB9          ; * REINTERPRET FORMAT STRING FROM THAT POINT
5036 e3b7 7e e2 b4                     JMP  L8ED2          ; REINTERPRET FORMAT STRING FROM THE START IF ENTIRELY
5037                         *         USED ON LAST PRINT ITEM
5038                         
5039                         * PRINT A '+' TO CONSOLE OUT IF THE STATUS BYTE <> 0
5040 e3ba 34 02              L8FD8     PSHS A              ; RESTORE ACCA AND RETURN
5041 e3bc 86 2b                        LDA  #'+            ; GET ASCII PLUS SIGN
5042 e3be 0d 99                        TST  VDA            ; * CHECK THE STATUS BYTE AND
5043 e3c0 27 03                        BEQ  L8FE3          ; * RETURN IF = 0
5044 e3c2 bd 80 31                     JSR  PUTCHR         ; SEND A CHARACTER TO CONSOLE OUT
5045 e3c5 35 82              L8FE3     PULS A,PC           ; RETURN ACCA AND RETURN
5046                         
5047                         * CONVERT ITEM-LIST TO DECIMAL ASCII STRING
5048 e3c7 ce 01 df           L8FE5     LDU  #STRBUF+4      ; POINT U TO STRING BUFFER
5049 e3ca c6 20                        LDB  #SPACE         ; BLANK
5050 e3cc 96 99                        LDA  VDA            ; * GET THE STATUS FLAG AND
5051 e3ce 85 08                        BITA #$08           ; * CHECK FOR A PRE-SIGN FORCE
5052 e3d0 27 02                        BEQ  L8FF2          ; * BRANCH IF NO PRE-SIGN FORCE
5053 e3d2 c6 2b                        LDB  #'+            ; PLUS SIGN
5054 e3d4 0d 54              L8FF2     TST  FP0SGN         ; CHECK THE SIGN OF FPA0
5055 e3d6 2a 04                        BPL  L8FFA          ; BRANCH IF POSITIVE
5056 e3d8 0f 54                        CLR  FP0SGN         ; FORCE FPA0 SIGN TO BE POSITIVE
5057 e3da c6 2d                        LDB  #'-            ; MINUS SIGN
5058 e3dc e7 c0              L8FFA     STB  ,U+            ; SAVE THE SIGN IN BUFFER
5059 e3de c6 30                        LDB  #'0            ; * PUT A ZERO INTO THE BUFFER
5060 e3e0 e7 c0                        STB  ,U+            ; *
5061 e3e2 84 01                        ANDA #$01           ; * CHECK THE EXPONENTIAL FORCE FLAG IN
5062 e3e4 10 26 01 07                  LBNE L910D          ; * THE STATUS BYTE - BRANCH IF ACTIVE
5063 e3e8 8e 95 6c                     LDX  #LBDC0         ; POINT X TO FLOATING POINT 1E + 09
5064 e3eb bd 94 4c                     JSR  LBCA0          ; COMPARE FPA0 TO (X)
5065 e3ee 2b 15                        BMI  L9023          ; BRANCH IF FPA0 < 1E+09
5066 e3f0 bd 95 85                     JSR  LBDD9          ; CONVERT FP NUMBER TO ASCII STRING
5067 e3f3 a6 80              L9011     LDA  ,X+            ; * ADVANCE POINTER TO END OF
5068 e3f5 26 fc                        BNE  L9011          ; * ASCII STRING (ZERO BYTE)
5069 e3f7 a6 82              L9015     LDA  ,-X            ; MOVE THE
5070 e3f9 a7 01                        STA  $01,X          ; ENTIRE STRING
5071 e3fb 8c 01 de                     CMPX #STRBUF+3      ; UP ONE
5072 e3fe 26 f7                        BNE  L9015          ; BYTE
5073 e400 86 25                        LDA  #'%            ; * INSERT A % SIGN AT START OF
5074 e402 a7 84                        STA  ,X             ; * STRING - OVERFLOW ERROR
5075 e404 39                           RTS
5076                         
5077 e405 96 4f              L9023     LDA  FP0EXP         ; GET EXPONENT OF FPA0
5078 e407 97 47                        STA  V47            ; AND SAVE IT IN V74
5079 e409 27 03                        BEQ  L902C          ; BRANCH IF FPA0 = 0
5080 e40b bd e5 af                     JSR  L91CD          ; CONVERT FPA0 TO NUMBER WITH 9 SIGNIFICANT
5081                         *              ; PLACES TO LEFT OF DECIMAL POINT
5082 e40e 96 47              L902C     LDA  V47            ; GET BASE 10 EXPONENT OFFSET
5083 e410 10 2b 00 81                  LBMI L90B3          ; BRANCH IF FPA0 < 100,000,000
5084 e414 40                           NEGA                ; * CALCULATE THE NUMBER OF LEADING ZEROES TO INSERT -
5085 e415 9b 98                        ADDA VD9            ; * SUBTRACT BASE 10 EXPONENT OFFSET AND 9 (FPA0 HAS
5086 e417 80 09                        SUBA #$09           ; * 9 PLACES TO LEFT OF EXPONENT) FROM LEFT DIGIT COUNTER
5087 e419 bd e4 cc                     JSR  L90EA          ; PUT ACCA ZEROES IN STRING BUFFER
5088 e41c bd e6 45                     JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
5089 e41f bd e5 e4                     JSR  L9202          ; CONVERT FPA0 TO DECIMAL ASCII IN THE STRING BUFFER
5090 e422 96 47                        LDA  V47            ; * GET BASE 10 EXPONENT AND PUT THAT MANY
5091 e424 bd e6 63                     JSR  L9281          ; * ZEROES IN STRING BUFFER - STOP AT DECIMAL POINT
5092 e427 96 47                        LDA  V47            ; WASTED INSTRUCTION - SERVES NO PURPOSE
5093 e429 bd e6 2b                     JSR  L9249          ; CHECK FOR DECIMAL POINT
5094 e42c 96 97                        LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
5095 e42e 26 02                        BNE  L9050          ; BRANCH IF RIGHT DIGlT COUNTER <> 0
5096 e430 33 5f                        LEAU -1,U           ; * MOVE BUFFER POINTER BACK ONE - DELETE
5097                         *                             ; * DECIMAL POINT IF NO RIGHT DIGITS SPECiFIED
5098 e432 4a                 L9050     DECA                ; SUBTRACT ONE (DECIMAL POINT)
5099 e433 bd e4 cc                     JSR  L90EA          ; PUT ACCA ZEROES INTO BUFFER (TRAILING ZEROES)
5100 e436 bd e5 67           L9054     JSR  L9185          ; INSERT ASTERISK PADDING, FLOATING $, AND POST-SIGN
5101 e439 4d                           TSTA                ; WAS THERE A POST-SIGN?
5102 e43a 27 06                        BEQ  L9060          ; NO
5103 e43c c1 2a                        CMPB #'*            ; IS THE FIRST CHARACTER AN $?
5104 e43e 27 02                        BEQ  L9060          ; YES
5105 e440 e7 c0                        STB  ,U+            ; STORE THE POST-SIGN
5106 e442 6f c4              L9060     CLR  ,U             ; CLEAR THE LAST CHARACTER IN THE BUFFER
5107                         *
5108                         * REMOVE ANY EXTRA BLANKS OR ASTERISKS FROM THE
5109                         * STRING BUFFER TO THE LEFT OF THE DECIMAL POINT
5110 e444 8e 01 de                     LDX  #STRBUF+3      ; POINT X TO THE START OF THE BUFFER
5111 e447 30 01              L9065     LEAX $01,X          ; MOVE BUFFER POINTER UP ONE
5112 e449 9f 0f                        STX  TEMPTR         ; SAVE BUFFER POINTER IN TEMPTR
5113 e44b 96 3a                        LDA  VARPTR+1       ; * GET ADDRESS OF DECIMAL POINT IN BUFFER, SUBTRACT
5114 e44d 90 10                        SUBA TEMPTR+1       ; * CURRENT POSITION AND SUBTRACT LEFT DIGIT COUNTER -
5115 e44f 90 98                        SUBA VD9            ; * THE RESULT WILL BE ZERO WHEN TEMPTR+1 IS POINTING
5116                         *              ; * TO THE FIRST DIGIT OF THE FORMAT STRING
5117 e451 27 38                        BEQ  L90A9          ; RETURN IF NO DIGITS TO LEFT OF THE DECiMAL POINT
5118 e453 a6 84                        LDA  ,X             ; GET THE CURRENT BUFFER CHARACTER
5119 e455 81 20                        CMPA #SPACE         ; SPACE?
5120 e457 27 ee                        BEQ  L9065          ; YES - ADVANCE POINTER
5121 e459 81 2a                        CMPA #'*            ; ASTERISK?
5122 e45b 27 ea                        BEQ  L9065          ; YES - ADVANCE POINTER
5123 e45d 4f                           CLRA                ; A ZERO ON THE STACK IS END OF DATA POINTER
5124 e45e 34 02              L907C     PSHS A              ; PUSH A CHARACTER ONTO THE STACK
5125 e460 a6 80                        LDA  ,X+            ; GET NEXT CHARACTER FROM BUFFER
5126 e462 81 2d                        CMPA #'-            ; MINUS SIGN?
5127 e464 27 f8                        BEQ  L907C          ; YES
5128 e466 81 2b                        CMPA #'+            ; PLUS SIGN?
5129 e468 27 f4                        BEQ  L907C          ; YES
5130 e46a 81 24                        CMPA #'$            ; DOLLAR SIGN?
5131 e46c 27 f0                        BEQ  L907C          ; YES
5132 e46e 81 30                        CMPA #'0            ; ZERO?
5133 e470 26 0e                        BNE  L909E          ; NO - ERROR
5134 e472 a6 01                        LDA  $01,X          ; GET CHARACTER FOLLOWING ZERO
5135 e474 8d 16                        BSR  L90AA          ; CLEAR CARRY IF NUMERIC
5136 e476 25 08                        BLO  L909E          ; BRANCH IF NOT A NUMERIC CHARACTER - ERROR
5137 e478 35 02              L9096     PULS A              ; * PULL A CHARACTER OFF OF THE STACK
5138 e47a a7 82                        STA  ,-X            ; * AND PUT IT BACK IN THE STRING BUFFER
5139 e47c 26 fa                        BNE  L9096          ; * KEEP GOING UNTIL ZERO FLAG
5140 e47e 20 c7                        BRA  L9065          ; KEEP CLEANING UP THE INPUT BUFFER
5141 e480 35 02              L909E     PULS A              ;
5142 e482 4d                           TSTA                ; * THE STACK AND EXIT WHEN
5143 e483 26 fb                        BNE  L909E          ; * ZERO FLAG FOUND
5144 e485 9e 0f                        LDX  TEMPTR         ; GET THE STRING BUFFER START POINTER
5145 e487 86 25                        LDA  #'%            ; * PUT A % SIGN BEFORE THE ERROR POSITION TO
5146 e489 a7 82                        STA  ,-X            ; * INDICATE AN ERROR
5147 e48b 39                 L90A9     RTS
5148                         *
5149                         * CLEAR CARRY IF NUMERIC
5150 e48c 81 30              L90AA     CMPA #'0            ; ASCII ZERO
5151 e48e 25 04                        BLO  L90B2          ; RETURN IF ACCA < ASCII 0
5152 e490 80 3a                        SUBA #$3A           ; *  #'9'+1
5153 e492 80 c6                        SUBA #$C6           ; * #-('9'+1)  CARRY CLEAR IF NUMERIC
5154 e494 39                 L90B2     RTS
5155                         *
5156                         * PROCESS AN ITEM-LIST WHICH IS < 100,000,000
5157 e495 96 97              L90B3     LDA  VD8            ; GET RIGHT DIGIT COUNTER
5158 e497 27 01                        BEQ  L90B8          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT OF DECIMAL PT
5159 e499 4a                           DECA                ; SUBTRACT ONE FOR DECIMAL POINT
5160 e49a 9b 47              L90B8     ADDA V47            ; *ADD THE BASE 10 EXPONENT OFFSET - ACCA CONTAINS THE
5161                         *         *NUMBER OF SHIFTS REQUIRED TO ADJUST FPA0 TO THE SPECIFIED
5162                         *         *NUMBER OF DlGITS TO THE RIGHT OF THE DECIMAL POINT
5163 e49c 2b 01                        BMI  L90BD          ; IF ACCA >= 0 THEN NO SHIFTS ARE REQUIRED
5164 e49e 4f                           CLRA                ; FORCE SHIFT COUNTER = 0
5165 e49f 34 02              L90BD     PSHS A              ; SAVE INITIAL SHIFT COUNTER ON THE STACK
5166 e4a1 2a 0a              L90BF     BPL  L90CB          ; EXIT ROUTINE IF POSITIVE
5167 e4a3 34 02                        PSHS A              ; SAVE SHIFT COUNTER ON STACK
5168 e4a5 bd 93 2e                     JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT ONE DIGIT TO RIGHT
5169 e4a8 35 02                        PULS A              ; GET SHIFT COUNTER FROM THE STACK
5170 e4aa 4c                           INCA                ; BUMP SHIFT COUNTER UP BY ONE
5171 e4ab 20 f4                        BRA  L90BF          ; CHECK FOR FURTHER DIVISION
5172 e4ad 96 47              L90CB     LDA  V47            ; * GET BASE 10 EXPONENT OFFSET, ADD INITIAL SHIFT COUNTER
5173 e4af a0 e0                        SUBA ,S+            ; * AND SAVE NEW BASE 10 EXPONENT OFFSET - BECAUSE
5174 e4b1 97 47                        STA  V47            ; * FPA0 WAS SHIFTED ABOVE
5175 e4b3 8b 09                        ADDA #$09           ; * ADD NINE (SIGNIFICANT PLACES) AND BRANCH IF THERE ARE NO
5176 e4b5 2b 19                        BMI  L90EE          ; * ZEROES TO THE LEFT OF THE DECIMAL POINT IN THIS PRINT ITEM
5177 e4b7 96 98                        LDA  VD9            ; *DETERMINE HOW MANY FILLER ZEROES TO THE LEFT OF THE DECIMAL
5178 e4b9 80 09                        SUBA #$09           ; *POINT. GET THE NUMBER OF FORMAT PLACES TO LEFT OF DECIMAL
5179 e4bb 90 47                        SUBA V47            ; *POINT, SUBTRACT THE BASE 10 EXPONENT OFFSET AND THE CONSTANT 9
5180 e4bd 8d 0d                        BSR  L90EA          ; *(UNNORMALIZATION)-THEN OUTPUT THAT MANY ZEROES TO THE BUFFER
5181 e4bf bd e6 45                     JSR  L9263          ; INITIALIZE DECIMAL POINT AND COMMA COUNTERS
5182 e4c2 20 1d                        BRA  L90FF          ; PROCESS THE REMAINDER OF THE PRINT ITEM
5183                         *
5184                         * PUT (ACCA+1) ASCII ZEROES IN BUFFER
5185 e4c4 34 02              L90E2     PSHS A              ; SAVE ZERO COUNTER
5186 e4c6 86 30                        LDA  #'0            ; * INSERT A ZERO INTO
5187 e4c8 a7 c0                        STA  ,U+            ; * THE BUFFER
5188 e4ca 35 02                        PULS A              ; RESTORE ZERO COUNTER
5189                         
5190                         * PUT ACCA ASCII ZEROES INTO THE BUFFER
5191 e4cc 4a                 L90EA     DECA                ; DECREMENT ZERO COUNTER
5192 e4cd 2a f5                        BPL  L90E2          ; BRANCH IF NOT DONE
5193 e4cf 39                           RTS
5194                         
5195 e4d0 96 98              L90EE     LDA  VD9            ; * GET THE LEFT DIGIT COUNTER AND PUT
5196 e4d2 8d f8                        BSR  L90EA          ; * THAT MANY ZEROES IN THE STRiNG BUFFER
5197 e4d4 bd e6 2f                     JSR  L924D          ; PUT THE DECIMAL POINT IN THE STRING BUFFER
5198 e4d7 86 f7                        LDA  #-9            ; *DETERMINE HOW MANY FILLER ZEROES BETWEEN THE DECIMAL POINT
5199 e4d9 90 47                        SUBA V47            ; *AND SIGNIFICANT DATA. SUBTRACT BASE 10 EXPONENT FROM -9
5200 e4db 8d ef                        BSR  L90EA          ; *(UNNORMALIZATION) AND OUTPUT THAT MANY ZEROES TO BUFFER
5201 e4dd 0f 45                        CLR  V45            ; CLEAR THE DECIMAL POINT COUNTER - SUPPRESS THE DECIMAL POINT
5202 e4df 0f 96                        CLR  VD7            ; CLEAR THE COMMA COUNTER - SUPPRESS COMMAS
5203 e4e1 bd e5 e4           L90FF     JSR  L9202          ; DECODE FPA0 INTO A DECIMAL ASCII STRING
5204 e4e4 96 97                        LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
5205 e4e6 26 02                        BNE  L9108          ; BRANCH IF RIGHT DIGIT COUNTER <> 0
5206 e4e8 de 39                        LDU  VARPTR         ; RESET BUFFER PTR TO THE DECIMAL POINT IF NO DIGITS TO RIGHT
5207 e4ea 9b 47              L9108     ADDA V47            ; *ADD BASE 10 EXPONENT - A POSITIVE ACCA WILL CAUSE THAT MANY
5208                         * *FILLER ZEROES TO BE OUTPUT ; TO THE RIGHT OF LAST SIGNIFICANT DATA
5209                         *         *SIGNIFICANT DATA
5210 e4ec 16 ff 43                     LBRA L9050          ; INSERT LEADING ASTERISKS, FLOATING DOLLAR SIGN, ETC
5211                         *
5212                         * FORCE THE NUMERIC OUTPUT FORMAT TO BE EXPONENTIAL FORMAT
5213 e4ef 96 4f              L910D     LDA  FP0EXP         ; * GET EXPONENT OF FPA0 AND
5214 e4f1 34 02                        PSHS A              ; * SAVE IT ON THE STACK
5215 e4f3 27 03                        BEQ  L9116          ; BRANCH IF FPA0 = 0
5216 e4f5 bd e5 af                     JSR  L91CD          ; *CONVERT FPA0 INTO A NUMBER WITH 9 SIGNIFICANT
5217                         *         *DIGITS TO THE LEFT OF THE DECIMAL POINT
5218 e4f8 96 97              L9116     LDA  VD8            ; GET THE RIGHT DIGIT COUNTER
5219 e4fa 27 01                        BEQ  L911B          ; BRANCH IF NO FORMATTED DIGITS TO THE RIGHT
5220 e4fc 4a                           DECA                ; SUBTRACT ONE FOR THE DECIMAL POINT
5221 e4fd 9b 98              L911B     ADDA VD9            ; ADD TO THE LEFT DIGIT COUNTER
5222 e4ff 7f 01 de                     CLR  STRBUF+3       ; CLEAR BUFFER BYTE AS TEMPORARY STORAGE LOCATION
5223 e502 d6 99                        LDB  VDA            ; * GET THE STATUS BYTE FOR A
5224 e504 c4 04                        ANDB #$04           ; * POST-BYTE FORCE; BRANCH IF
5225 e506 26 03                        BNE  L9129          ; * A POST-BYTE FORCE
5226 e508 73 01 de                     COM  STRBUF+3       ; TOGGLE BUFFER BYTE TO -1 IF NO POST-BYTE FORCE
5227 e50b bb 01 de           L9129     ADDA STRBUF+3       ; SUBTRACT 1 IF NO POST BYTE FORCE
5228 e50e 80 09                        SUBA #$09           ; *SUBTRACT 9 (DUE TO THE CONVERSION TO 9
5229                         *         *SIGNIFICANT DIGITS TO LEFT OF DECIMAL POINT)
5230 e510 34 02                        PSHS A              ; * SAVE SHIFT COUNTER ON THE STACK - ACCA CONTAINS THE NUMBER
5231                         *         OF   SHIFTS REQUIRED TO ADJUST FPA0 FOR THE NUMBER OF
5232                         *         FORMATTED PLACES TO THE RIGHT OF THE DECIMAL POINT.
5233 e512 2a 0a              L9130     BPL  L913C          ; NO MORE SHIFTS WHEN ACCA >= 0
5234 e514 34 02                        PSHS A              ; SAVE SHIFT COUNTER
5235 e516 bd 93 2e                     JSR  LBB82          ; DIVIDE FPA0 BY 10 - SHIFT TO RIGHT ONE
5236 e519 35 02                        PULS A              ; RESTORE THE SHIFT COUNTER
5237 e51b 4c                           INCA                ; ADD 1 TO SHIFT COUNTER
5238 e51c 20 f4                        BRA  L9130          ; CHECK FOR FURTHER SHIFTING (DIVISION)
5239 e51e a6 e4              L913C     LDA  ,S             ; *GET THE INITIAL VALUE OF THE SHIFT COUNTER
5240 e520 2b 01                        BMI  L9141          ; *AND BRANCH IF SHIFTING HAS TAKEN PLACE
5241 e522 4f                           CLRA                ; RESET ACCA IF NO SHIFTING HAS TAKEN PLACE
5242 e523 40                 L9141     NEGA                ; *CALCULATE THE POSITION OF THE DECIMAL POINT BY
5243 e524 9b 98                        ADDA VD9            ; *NEGATING SHIFT COUNTER, ADDING THE LEFT DIGIT COUNTER
5244 e526 4c                           INCA                ; *PLUS ONE AND THE POST-BYTE POSlTION, IF USED
5245 e527 bb 01 de                     ADDA STRBUF+3       ; *
5246 e52a 97 45                        STA  V45            ; SAVE DECIMAL POINT COUNTER
5247 e52c 0f 96                        CLR  VD7            ; CLEAR COMMA COUNTER - NO COMMAS INSERTED
5248 e52e bd e5 e4                     JSR  L9202          ; CONVERT FPA0 INTO ASCII DECIMAL STRING
5249 e531 35 02                        PULS A              ; * GET THE INITIAL VALUE OF SHIFT COUNTER AND
5250 e533 bd e6 63                     JSR  L9281          ; * INSERT THAT MANY ZEROES INTO THE BUFFER
5251 e536 96 97                        LDA  VD8            ; *GET THE RIGHT DIGIT COUNTER AND BRANCH
5252 e538 26 02                        BNE  L915A          ; *IF NOT ZERO
5253 e53a 33 5f                        LEAU -1,U           ; MOVE BUFFER POINTER BACK ONE
5254                         
5255                         * CALCULATE VALUE OF EXPONENT AND PUT IN STRING BUFFER
5256 e53c e6 e0              L915A     LDB  ,S+            ; GET ORIGINAL EXPONENT OF FPA0
5257 e53e 27 09                        BEQ  L9167          ; BRANCH IF EXPONENT = 0
5258 e540 d6 47                        LDB  V47            ; GET BASE 10 EXPONENT
5259 e542 cb 09                        ADDB #$09           ; ADD 9 FOR 9 SIGNIFICANT DIGIT CONVERSION
5260 e544 d0 98                        SUBB VD9            ; SUBTRACT LEFT DIGIT COUNTER
5261 e546 f0 01 de                     SUBB STRBUF+3       ; ADD ONE TO EXPONENT IF POST-SIGN FORCE
5262 e549 86 2b              L9167     LDA  #'+            ; PLUS SIGN
5263 e54b 5d                           TSTB                ; TEST EXPONENT
5264 e54c 2a 03                        BPL  L916F          ; BRANCH IF POSITIVE EXPONENT
5265 e54e 86 2d                        LDA  #'-            ; MINUS SIGN
5266 e550 50                           NEGB                ; CONVERT EXPONENT TO POSITIVE NUMBER
5267 e551 a7 41              L916F     STA  $01,U          ; PUT SIGN OF EXPONENT IN STRING BUFFER
5268 e553 86 45                        LDA  #'E            ; * PUT AN 'E' (EXPONENTIATION FLAG) IN
5269 e555 a7 c1                        STA  ,U++           ; * BUFFER AND SKIP OVER THE SIGN
5270 e557 86 2f                        LDA  #$2F           ; * WAS LDA #'0'-1
5271                         *CONVERT BINARY EXPONENT IN ACCB TO ASCII VALUE IN ACCA
5272 e559 4c                 L9177     INCA                ; ADD ONE TO TENS DIGIT COUNTER
5273 e55a c0 0a                        SUBB #10            ; *SUBTRACT 10 FROM EXPONENT AND ADD ONE TO TENS
5274 e55c 24 fb                        BCC  L9177          ; * DIGIT IF NO CARRY. TENS DIGIT DONE IF THERE IS A CARRY
5275 e55e cb 3a                        ADDB #$3A           ; WAS ADDB #'9'+1
5276 e560 ed c1                        STD  ,U++           ; SAVE EXPONENT IN BUFFER
5277 e562 6f c4                        CLR  ,U             ; CLEAR FINAL BYTE IN BUFFER - PRINT TERMINATOR
5278 e564 7e e4 36                     JMP  L9054          ; INSERT ASTERISK PADDING, FLOATING DOLLAR SIGN, ETC.
5279                         
5280                         * INSERT ASTERISK PADDING, FLOATING $ AND PRE-SIGN
5281 e567 8e 01 df           L9185     LDX  #STRBUF+4      ; POINT X TO START OF PRINT ITEM BUFFER
5282 e56a e6 84                        LDB  ,X             ; * GET SIGN BYTE OF ITEM-LIST BUFFER
5283 e56c 34 04                        PSHS B              ; * AND SAVE IT ON THE STACK
5284 e56e 86 20                        LDA  #SPACE         ; DEFAULT PAD WITH BLANKS
5285 e570 d6 99                        LDB  VDA            ; * GET STATUS BYTE AND CHECK FOR
5286 e572 c5 20                        BITB #$20           ; * ASTERISK LEFT PADDING
5287 e574 35 04                        PULS B              ; GET SIGN BYTE AGAIN
5288 e576 27 08                        BEQ  L919E          ; BRANCH IF NO PADDING
5289 e578 86 2a                        LDA  #'*            ; PAD WITH ASTERISK
5290 e57a c1 20                        CMPB #SPACE         ; WAS THE FIRST BYTE A BLANK (POSITIVE)?
5291 e57c 26 02                        BNE  L919E          ; NO
5292 e57e 1f 89                        TFR  A,B            ; TRANSFER PAD CHARACTER TO ACCB
5293 e580 34 04              L919E     PSHS B              ; SAVE FIRST CHARACTER ON STACK
5294 e582 a7 80              L91A0     STA  ,X+            ; STORE PAD CHARACTER IN BUFFER
5295 e584 e6 84                        LDB  ,X             ; GET NEXT CHARACTER IN BUFFER
5296 e586 27 10                        BEQ  L91B6          ; INSERT A ZERO IF END OF BUFFER
5297 e588 c1 45                        CMPB #'E            ; * CHECK FOR AN 'E' AND
5298 e58a 27 0c                        BEQ  L91B6          ; * PUT A ZERO BEFORE IT
5299 e58c c1 30                        CMPB #'0            ; * REPLACE LEADING ZEROES WITH
5300 e58e 27 f2                        BEQ  L91A0          ; * PAD CHARACTERS
5301 e590 c1 2c                        CMPB #',            ; * REPLACE LEADING COMMAS
5302 e592 27 ee                        BEQ  L91A0          ; * WITH PAD CHARACTERS
5303 e594 c1 2e                        CMPB #'.            ; * CHECK FOR DECIMAL POINT
5304 e596 26 04                        BNE  L91BA          ; * AND DON'T PUT A ZERO BEFORE IT
5305 e598 86 30              L91B6     LDA  #'0            ; * REPLACE PREVIOUS CHARACTER
5306 e59a a7 82                        STA  ,-X            ; * WITH A ZERO
5307 e59c 96 99              L91BA     LDA  VDA            ; * GET STATUS BYTE, CHECK
5308 e59e 85 10                        BITA #$10           ; * FOR FLOATING $
5309 e5a0 27 04                        BEQ  L91C4          ; * BRANCH IF NO FLOATING $
5310 e5a2 c6 24                        LDB  #'$            ; * STORE A $ IN
5311 e5a4 e7 82                        STB  ,-X            ; * BUFFER
5312 e5a6 84 04              L91C4     ANDA #$04           ; CHECK PRE-SIGN FLAG
5313 e5a8 35 04                        PULS B              ; GET SIGN CHARACTER
5314 e5aa 26 02                        BNE  L91CC          ; RETURN IF POST-SIGN REQUIRED
5315 e5ac e7 82                        STB  ,-X            ; STORE FIRST CHARACTER
5316 e5ae 39                 L91CC     RTS
5317                         *
5318                         * CONVERT FPA0 INTO A NUMBER OF THE FORM - NNN,NNN,NNN X 10**M.
5319                         * THE EXPONENT M WILL BE RETURNED IN V47 (BASE 10 EXPONENT).
5320 e5af 34 40              L91CD     PSHS U              ; SAVE BUFFER POINTER
5321 e5b1 4f                           CLRA                ; INITIAL EXPONENT OFFSET = 0
5322 e5b2 97 47              L91D0     STA  V47            ; SAVE EXPONENT OFFSET
5323 e5b4 d6 4f                        LDB  FP0EXP         ; GET EXPONENT OF FPA0
5324 e5b6 c1 80                        CMPB #$80           ; * COMPARE TO EXPONENT OF .5
5325 e5b8 22 11                        BHI  L91E9          ; * AND BRANCH IF FPA0 > = 1.0
5326                         
5327                         * IF FPA0 < 1.0, MULTIPLY IT BY 1E+09 UNTIL IT IS >= 1
5328 e5ba 8e 95 6c                     LDX  #LBDC0         ; POINT X TO FP NUMBER (1E+09)
5329 e5bd bd 92 76                     JSR  LBACA          ; MULTIPLY FPA0 BY 1E+09
5330 e5c0 96 47                        LDA  V47            ; GET EXPONENT OFFSET
5331 e5c2 80 09                        SUBA #$09           ; SUBTRACT 9 (BECAUSE WE MULTIPLIED BY 1E+09 ABOVE)
5332 e5c4 20 ec                        BRA  L91D0          ; CHECK TO SEE IF > 1.0
5333 e5c6 bd 93 2e           L91E4     JSR  LBB82          ; DIVIDE FPA0 BY 10
5334 e5c9 0c 47                        INC  V47            ; INCREMENT EXPONENT OFFSET
5335 e5cb 8e 95 67           L91E9     LDX  #LBDBB         ; POINT X TO FP NUMBER (999,999,999)
5336 e5ce bd 94 4c                     JSR  LBCA0          ; COMPARE FPA0 TO X
5337 e5d1 2e f3                        BGT  L91E4          ; BRANCH IF FPA0 > 999,999,999
5338 e5d3 8e 95 62           L91F1     LDX  #LBDB6         ; POINT X TO FP NUMBER (99,999,999.9)
5339 e5d6 bd 94 4c                     JSR  LBCA0          ; COMPARE FPA0 TO X
5340 e5d9 2e 07                        BGT  L9200          ; RETURN IF 999,999,999 > FPA0 > 99,999,999.9
5341 e5db bd 93 16                     JSR  LBB6A          ; MULTIPLY FPA0 BY 10
5342 e5de 0a 47                        DEC  V47            ; DECREMENT EXPONENT OFFSET
5343 e5e0 20 f1                        BRA  L91F1          ; KEEP UNNORMALIZING
5344 e5e2 35 c0              L9200     PULS U,PC           ; RESTORE BUFFER POINTER AND RETURN
5345                         *
5346                         * CONVERT FPA0 INTO AN INTEGER, THEN DECODE IT
5347                         * INTO A DECIMAL ASCII STRING IN THE BUFFER
5348 e5e4 34 40              L9202     PSHS U              ; SAVE BUFFER POINTER
5349 e5e6 bd 91 60                     JSR  LB9B4          ; ADD .5 TO FPA0 (ROUND OFF)
5350 e5e9 bd 94 74                     JSR  LBCC8          ; CONVERT FPA0 TO INTEGER FORMAT
5351 e5ec 35 40                        PULS U              ; RESTORE BUFFER POINTER
5352                         *
5353                         * CONVERT FPA0 INTO A DECIMAL ASCII STRING
5354 e5ee 8e 96 71                     LDX  #LBEC5         ; POINT X TO UNNORMALIZED POWERS OF 10
5355 e5f1 c6 80                        LDB  #$80           ; INITIALIZE DIGIT COUNTER TO 0 + $80.
5356                         * BIT 7 SET IS USED TO INDICATE THAT THE POWER OF 10 MANTISSA
5357                         * IS NEGATIVE. WHEN YOU 'ADD' A NEGATIVE MANTISSA, IT IS
5358                         * THE SAME AS SUBTRACTING A POSITIVE ONE AND BIT 7 OF ACCB
5359                         * IS HOW THIS ROUTINE KNOWS THAT A 'SUBTRACTION' IS OCCURRING.
5360 e5f3 8d 36              L9211     BSR  L9249          ; CHECK FOR COMMA INSERTION
5361 e5f5 96 53              L9213     LDA  FPA0+3         ; * 'ADD' A POWER OF 10 MANTISSA TO FPA0.
5362 e5f7 ab 03                        ADDA $03,X          ; * IF THE MANTISSA IS NEGATIVE, A SUBTRACTION
5363 e5f9 97 53                        STA  FPA0+3         ; * WILL BE WHAT REALLY TAKES PLACE.
5364 e5fb 96 52                        LDA  FPA0+2         ; *
5365 e5fd a9 02                        ADCA $02,X          ; *
5366 e5ff 97 52                        STA  FPA0+2         ; *
5367 e601 96 51                        LDA  FPA0+1         ; *
5368 e603 a9 01                        ADCA $01,X          ; *
5369 e605 97 51                        STA  FPA0+1         ; *
5370 e607 96 50                        LDA  FPA0           ; *
5371 e609 a9 84                        ADCA ,X             ; *
5372 e60b 97 50                        STA  FPA0           ; *
5373 e60d 5c                           INCB                ; ADD ONE TO DIGIT COUNTER
5374 e60e 56                           RORB                ; ROTATE CARRY INTO BIT 7
5375 e60f 59                           ROLB                ; * SET OVERFLOW FLAG - BRANCH IF CARRY SET AND
5376 e610 28 e3                        BVC  L9213          ; * ADDING MANTISSA OR CARRY CLEAR AND SUBTRACTING MANTISSA
5377 e612 24 03                        BCC  L9235          ; BRANCH IF SUBTRACTING MANTISSA
5378 e614 c0 0b                        SUBB #10+1          ; WAS SUBB #10+1
5379 e616 50                           NEGB                ; * IF ADDING MANTISSA
5380 e617 cb 2f              L9235     ADDB #$2F           ; WAS ADDB #'0'-1
5381 e619 30 04                        LEAX $04,X          ; MOVE TO NEXT POWER OF 10 MANTISSA
5382 e61b 1f 98                        TFR  B,A            ; SAVE DIGIT IN ACCA
5383 e61d 84 7f                        ANDA #$7F           ; MASK OFF ADD/SUBTRACT FLAG (BIT 7)
5384 e61f a7 c0                        STA  ,U+            ; STORE DIGIT IN BUFFER
5385 e621 53                           COMB                ; TOGGLE ADD/SUBTRACT FLAG
5386 e622 c4 80                        ANDB #$80           ; MASK OFF EVERYTHING BUT ADD/SUB FLAG
5387 e624 8c 96 95                     CMPX #LBEE9         ; COMPARE TO END OF UNNORMALIZED POWERS OF 10
5388 e627 26 ca                        BNE  L9211          ; BRANCH IF NOT DONE
5389 e629 6f c4                        CLR  ,U             ; PUT A ZERO AT END OF INTEGER
5390                         
5391                         * DECREMENT DECIMAL POINT COUNTER AND CHECK FOR COMMA INSERTION
5392 e62b 0a 45              L9249     DEC  V45            ; DECREMENT DECIMAL POINT COUNTER
5393 e62d 26 09                        BNE  L9256          ; NOT TIME FOR DECIMAL POINT
5394 e62f df 39              L924D     STU  VARPTR         ; SAVE BUFFER POINTER-POSITION OF THE DECIMAL POINT
5395 e631 86 2e                        LDA  #'.            ; * STORE A DECIMAL
5396 e633 a7 c0                        STA  ,U+            ; * POINT IN THE OUTPUT BUFFER
5397 e635 0f 96                        CLR  VD7            ; * CLEAR COMMA COUNTER - NOW IT WILL TAKE 255
5398                         *                             ; * DECREMENTS BEFORE ANOTHER COMMA WILL BE INSERTED
5399 e637 39                           RTS
5400 e638 0a 96              L9256     DEC  VD7            ; DECREMENT COMMA COUNTER
5401 e63a 26 08                        BNE  L9262          ; RETURN IF NOT TIME FOR COMMA
5402 e63c 86 03                        LDA  #$03           ; * RESET COMMA COUNTER TO 3; THREE
5403 e63e 97 96                        STA  VD7            ; * DIGITS BETWEEN COMMAS
5404 e640 86 2c                        LDA  #',            ; * PUT A COMMA INTO
5405 e642 a7 c0                        STA  ,U+            ; * THE BUFFER
5406 e644 39                 L9262     RTS
5407                         
5408                         * INITIALIZE DECIMAL POINT AND COMMA COUNTERS
5409 e645 96 47              L9263     LDA  V47            ; GET THE BASE 10 EXPONENT OFFSET
5410 e647 8b 0a                        ADDA #10            ; * ADD 10 (FPA0 WAS 'NORMALIZED' TO 9 PLACES LEFT
5411 e649 97 45                        STA  V45            ; * OF DECIMAL POINT) - SAVE IN DECIMAL POINT COUNTER
5412 e64b 4c                           INCA                ; ADD ONE FOR THE DECIMAL POINT
5413 e64c 80 03              L926A     SUBA #$03           ; * DIVIDE DECIMAL POINT COUNTER BY 3; LEAVE
5414 e64e 24 fc                        BCC  L926A          ; * THE REMAINDER IN ACCA
5415 e650 8b 05                        ADDA #$05           ; CONVERT REMAINDER INTO A NUMBER FROM 1-3
5416 e652 97 96                        STA  VD7            ; SAVE COMMA COUNTER
5417 e654 96 99                        LDA  VDA            ; GET STATUS BYTE
5418 e656 84 40                        ANDA #$40           ; CHECK FOR COMMA FLAG
5419 e658 26 02                        BNE  L927A          ; BRANCH IF COMMA FLAG ACTIVE
5420 e65a 97 96                        STA  VD7            ; CLEAR COMMA COUNTER - 255 DIGITS OUTPUT BEFORE A COMMA
5421 e65c 39                 L927A     RTS
5422                         *
5423                         * INSERT ACCA ZEROES INTO THE BUFFER
5424 e65d 34 02              L927B     PSHS A              ; SAVE ZEROES COUNTER
5425 e65f 8d ca                        BSR  L9249          ; CHECK FOR DECIMAL POINT
5426 e661 35 02                        PULS A              ; RESTORE ZEROES COUNTER
5427 e663 4a                 L9281     DECA                ; * DECREMENT ZEROES COUNTER AND
5428 e664 2b 0a                        BMI  L928E          ; * RETURN IF < 0
5429 e666 34 02                        PSHS A              ; SAVE ZEROES COUNTER
5430 e668 86 30                        LDA  #'0            ; * PUT A ZERO INTO
5431 e66a a7 c0                        STA  ,U+            ; * THE BUFFER
5432 e66c a6 e0                        LDA  ,S+            ; RESTORE THE ZEROES COUNTER
5433 e66e 26 ed                        BNE  L927B          ; BRANCH IF NOT DONE
5434 e670 39                 L928E     RTS
5435                         
5436                         
5437                         * LINE
5438 e671 81 89              LINE      CMPA #TOK_INPUT     ; 'INPUT' TOKEN
5439 e673 10 27 b7 1c                  LBEQ L89C0          ; GO DO 'LINE INPUT' COMMAND
5440 e677 7e 8a 4f                     JMP  LB277          ; 'SYNTAX ERROR' IF NOT "LINE INPUT"
5441                         
5442                         * END OF EXTENDED BASIC
5443                         


Number of errors 0
